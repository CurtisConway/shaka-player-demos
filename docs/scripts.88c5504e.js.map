{"version":3,"sources":["node_modules/mux.js/lib/utils/stream.js","node_modules/mux.js/lib/codecs/adts.js","node_modules/mux.js/lib/utils/exp-golomb.js","node_modules/mux.js/lib/codecs/h264.js","node_modules/mux.js/lib/codecs/index.js","node_modules/mux.js/lib/mp4/mp4-generator.js","node_modules/mux.js/lib/utils/bin.js","node_modules/mux.js/lib/mp4/probe.js","node_modules/mux.js/lib/mp4/frame-utils.js","node_modules/mux.js/lib/data/silence.js","node_modules/mux.js/lib/utils/clock.js","node_modules/mux.js/lib/mp4/audio-frame-utils.js","node_modules/mux.js/lib/mp4/track-decode-info.js","node_modules/mux.js/lib/tools/caption-packet-parser.js","node_modules/mux.js/lib/m2ts/caption-stream.js","node_modules/mux.js/lib/m2ts/stream-types.js","node_modules/mux.js/lib/m2ts/timestamp-rollover-stream.js","node_modules/mux.js/lib/m2ts/metadata-stream.js","node_modules/mux.js/lib/m2ts/m2ts.js","node_modules/mux.js/lib/aac/utils.js","node_modules/mux.js/lib/aac/index.js","node_modules/mux.js/lib/mp4/transmuxer.js","node_modules/mux.js/lib/tools/mp4-inspector.js","node_modules/mux.js/lib/mp4/caption-parser.js","node_modules/mux.js/lib/mp4/index.js","node_modules/mux.js/lib/flv/flv-tag.js","node_modules/mux.js/lib/flv/coalesce-stream.js","node_modules/mux.js/lib/flv/tag-list.js","node_modules/mux.js/lib/flv/transmuxer.js","node_modules/mux.js/lib/flv/flv-header.js","node_modules/mux.js/lib/flv/index.js","node_modules/mux.js/lib/m2ts/index.js","node_modules/mux.js/lib/tools/flv-inspector.js","node_modules/mux.js/lib/m2ts/probe.js","node_modules/mux.js/lib/tools/ts-inspector.js","node_modules/mux.js/lib/index.js","../lib/util/dom_utils.js","../third_party/closure/goog/base.js"," [synthetic:util/defineproperty] "," [synthetic:util/global] "," [synthetic:es6/symbol] "," [synthetic:es6/util/makeiterator] "," [synthetic:util/polyfill] "," [synthetic:es6/execute_async_generator] "," [synthetic:es6/promise/promise] "," [synthetic:es6/promise/finally] "," [synthetic:util/objectcreate] "," [synthetic:es6/util/setprototypeof] "," [synthetic:es6/generator_engine] "," [synthetic:es6/util/arrayfromiterable] "," [synthetic:es6/util/arrayfromiterator] "," [synthetic:util/owns] "," [synthetic:util/findinternal] "," [synthetic:util/checkstringargs] "," [synthetic:es6/weakmap] "," [synthetic:es6/map] "," [synthetic:es6/set] "," [synthetic:es6/array/findindex] "," [synthetic:es6/array/keys] "," [synthetic:es6/util/iteratorfromarray] "," [synthetic:es6/object/is] "," [synthetic:es6/array/includes] "," [synthetic:es6/string/includes] "," [synthetic:es6/array/from] "," [synthetic:es6/string/startswith] "," [synthetic:es6/array/find] ","../lib/abr/ewma.js","../lib/abr/ewma_bandwidth_estimator.js","../lib/debug/log.js","../third_party/closure/goog/uri/utils.js","../third_party/closure/goog/uri/uri.js","../lib/util/delayed_tick.js","../lib/util/timer.js","../lib/net/backoff.js","../lib/util/error.js","../lib/util/public_promise.js","../lib/util/abortable_operation.js","../lib/util/fake_event.js","../lib/util/multi_map.js","../lib/util/fake_event_target.js","../lib/util/object_utils.js","../lib/util/array_utils.js","../lib/util/operation_manager.js","../lib/net/networking_engine.js"," [synthetic:es6/util/inherits] ","../lib/util/i_releasable.js","../lib/util/event_manager.js","../lib/util/iterables.js","../lib/util/map_utils.js","../lib/util/mime_utils.js","../lib/util/platform.js","../lib/util/string_utils.js","../lib/util/uint8array_utils.js","../lib/media/drm_engine.js","../lib/media/closed_caption_parser.js","../lib/media/time_ranges_utils.js","../lib/util/functional.js","../lib/util/manifest_parser_utils.js","../lib/media/transmuxer.js","../lib/text/cue.js","../lib/text/text_engine.js","../lib/media/media_source_engine.js","../lib/util/language_utils.js","../lib/util/stream_utils.js","../lib/abr/simple_abr_manager.js","../lib/deprecate/version.js","../lib/deprecate/deprecate.js","../lib/cast/cast_proxy.js","../lib/deprecate/enforcer.js","../lib/cast/cast_utils.js","../lib/cast/cast_sender.js","../lib/cast/cast_receiver.js","../lib/util/xml_utils.js","../lib/dash/content_protection.js","../lib/dash/mpd_utils.js","../lib/media/segment_reference.js","../lib/util/data_view_reader.js","../lib/util/ebml_parser.js","../lib/util/mp4_parser.js","../lib/media/mp4_segment_index_parser.js","../lib/media/segment_index.js","../lib/media/webm_segment_index_parser.js","../lib/dash/segment_base.js","../lib/dash/segment_list.js","../lib/dash/segment_template.js","../lib/media/manifest_parser.js","../lib/media/presentation_timeline.js","../lib/util/networking.js","../lib/dash/dash_parser.js","../lib/hls/hls_classes.js","../lib/hls/hls_utils.js","../lib/util/text_parser.js","../lib/hls/manifest_text_parser.js","../lib/net/data_uri_plugin.js","../lib/hls/hls_parser.js","../lib/media/active_stream_map.js","../lib/media/adaptation_set.js","../lib/media/adaptation_set_criteria.js","../lib/media/buffering_observer.js","../lib/media/stall_detector.js","../lib/media/gap_jumping_controller.js","../lib/media/playhead_observer.js","../lib/util/periods.js","../lib/media/period_observer.js","../lib/media/play_rate_controller.js","../lib/media/video_wrapper.js","../lib/media/playhead.js","../lib/media/region_timeline.js","../lib/media/region_observer.js","../lib/media/streaming_engine.js","../lib/net/http_plugin_utils.js","../lib/net/http_fetch_plugin.js","../lib/net/http_xhr_plugin.js","../lib/offline/download_progress_estimator.js","../lib/offline/download_manager.js","../lib/offline/indexeddb/db_operation.js","../lib/offline/indexeddb/db_connection.js","../lib/offline/indexeddb/eme_session_storage_cell.js","../lib/offline/storage_muxer.js","../lib/offline/indexeddb/storage_mechanism.js","../lib/offline/indexeddb/v1_storage_cell.js","../lib/offline/indexeddb/v2_storage_cell.js","../lib/offline/offline_uri.js","../lib/offline/manifest_converter.js","../lib/offline/offline_manifest_parser.js","../lib/offline/offline_scheme.js","../lib/offline/session_deleter.js","../lib/routing/walker.js","../lib/player.js","../lib/text/simple_text_displayer.js","../lib/util/config_utils.js","../lib/util/player_configuration.js","../lib/util/state_history.js","../lib/util/switch_history.js","../lib/util/stats.js","../lib/offline/stored_content_utils.js","../lib/offline/stream_bandwidth_estimator.js","../lib/util/destroyer.js","../lib/util/manifest_filter.js","../lib/offline/storage.js","../lib/polyfill/all.js","../lib/polyfill/patchedmediakeys_apple.js","../lib/polyfill/patchedmediakeys_ms.js","../lib/polyfill/fullscreen.js","../lib/polyfill/input_event.js","../lib/polyfill/mediasource.js","../lib/util/pssh.js","../lib/polyfill/patchedmediakeys_nop.js","../lib/polyfill/indexed_db.js","../lib/polyfill/languages.js","../lib/polyfill/mathround.js","../lib/polyfill/patchedmediakeys_webkit.js","../lib/polyfill/pip_webkit.js","../lib/polyfill/videoplaybackquality.js","../lib/polyfill/vttcue.js","../lib/text/ttml_text_parser.js","../lib/polyfill/video_play_promise.js","../lib/text/mp4_ttml_parser.js","../lib/text/vtt_text_parser.js","../lib/text/mp4_vtt_parser.js","scripts.js"],"names":["$jscomp.defineProperty","$jscomp.global","$jscomp.initSymbol","$jscomp.Symbol","$jscomp.SYMBOL_PREFIX","$jscomp.iteratorPrototype","$jscomp.initSymbolIterator","$jscomp.arrayIterator","$jscomp.polyfill","$jscomp.makeIterator","$jscomp.objectCreate","$jscomp.setPrototypeOf","$jscomp.generator.Context","$jscomp.generator.Generator_","$jscomp.generator.Engine_","$jscomp.owns","$jscomp.checkStringArgs","goog.global","publicPath","object","part","parts","cur","goog.inherits","childCtor","parentCtor","tempCtor","superClass_","prototype","constructor","base","childCtor.base","me","methodName","var_args","Array","slice","call","args","arguments","shaka.abr.Ewma","halfLife","Math","totalWeight_","shaka.abr.Ewma.prototype.sample","weight","value","adjAlpha","newEstimate","isNaN","shaka.abr.Ewma.prototype.getEstimate","estimate_","shaka.abr.EwmaBandwidthEstimator","slow_","bytesSampled_","shaka.log.alwaysError","shaka.log.alwaysWarn","shaka.log.error","CLOSURE_NO_DEPS","getBandwidthEstimate","shaka.abr.EwmaBandwidthEstimator.prototype.getBandwidthEstimate","defaultEstimate","getEstimate","window","log","bind","console","goog.uri.utils.splitRe_","goog.Uri","uri","m","setScheme","setUserInfo","setDomain","setPort","setPath","setQueryData","clone","setFragment","String","SCHEME","goog.Uri.decodeOrEmpty_","USER_INFO","DOMAIN","PORT","PATH","QUERY_DATA","FRAGMENT","goog.Uri.QueryData","goog.Uri.prototype.setScheme","newScheme","decode","scheme_","replace","goog.Uri.prototype.setPort","newPort","Number","port_","goog.Uri.prototype.setQueryData","queryData","goog.Uri.encodeSpecialChars_","goog.Uri.reDisallowedInQuery_","val","preserveReserved","decodeURI","decodeURIComponent","unescapedPart","extra","removeDoubleEncoding","encoded","encodeURI","goog.Uri.encodeChar_","ch","n","goog.Uri.prototype","userInfo_","domain_","path_","fragment_","toString","goog.Uri.prototype.toString","out","scheme","getScheme","domain","goog.Uri.reDisallowedInSchemeOrUserInfo_","getDomain","userInfo","getUserInfo","push","encodeURIComponent","port","getPort","path","getPath","hasDomain","goog.Uri.reDisallowedInAbsolutePath_","goog.Uri.reDisallowedInRelativePath_","query","getEncodedQuery","fragment","getFragment","goog.Uri.reDisallowedInFragment_","join","resolve","goog.Uri.prototype.resolve","relativeUri","absoluteUri","overridden","hasPath","lastSlashIndex","lastIndexOf","substr","leadingSlash","segments","pos","segment","goog.Uri.prototype.clone","onTick","cancelPending_","ticker_","shaka.net.Backoff","parameters","autoReset","defaults","maxAttempts","baseDelay","backoffFactor","fuzzFactor","timeout","maxAttempts_","baseDelay_","fuzzFactor_","backoffFactor_","numAttempts_","nextUnfuzzedDelay_","shaka.net.Backoff.prototype.attempt","currentAttempt","fuzzedDelayMs","$jscomp.generator.createGenerator","Promise","reset_","tickAfter","shaka.util.Timer","shaka.util.Error","severity","category","code","data","varArgs","handled","shaka.util.PublicPromise","resolvePromise","rejectPromise","publicPromise","promise","reject","onAbort","onAbort_","aborted_","error","shaka.util.AbortableOperation","p","shaka.util.Error.Severity.CRITICAL","shaka.util.Error.Category.PLAYER","shaka.util.Error.Code.OPERATION_ABORTED","catch","operations","op","all","abort","callback","newPromise","ret","exception","shaka.util.FakeEvent","type","dict","key","defaultPrevented","timeStamp","now","Date","isTrusted","target","stopped","shaka.util.MultiMap","shaka.util.FakeEventTarget","dispatchTarget","cloneObject","arg","seenObjects","Set","ArrayBuffer","isArray","Object","add","name","shaka.util.ArrayUtils.defaultEquals","a","b","shaka.util.ArrayUtils.remove","array","element","index","shaka.util.ArrayUtils.hasSameElements","compareFn","copy","item","idx","other","pop","manage","operation","finally","shaka.net.NetworkingEngine","onProgressUpdated","shaka.util.FakeEventTarget.call","destroyed_","operationManager_","shaka.util.OperationManager","requestFilters_","responseFilters_","onProgressUpdated_","goog.Uri.QueryData.prototype","count_","goog.Uri.QueryData.prototype.add","ensureKeyMapInitialized_","encodedQuery_","pairs","split","i","indexOfEquals","values","hasOwnProperty","goog.Uri.QueryData.prototype.toString","sb","keyMap_","encodedKey","j","param","goog.Uri.QueryData.prototype.clone","rv","cloneMap","shaka.util.DelayedTick","delayInSeconds","stop","alive","timeoutId","this.cancelPending_","goog.exportSymbol","Timer","tickNow","onTick_","goog.exportProperty","seconds","tickEvery","Error","shaka.util.Error.prototype.toString","JSON","shaka.util.Error.Severity","shaka.util.Error.Category","shaka.util.Error.Code","shaka.util.PublicPromise.prototype.resolve","shaka.util.PublicPromise.prototype.reject","AbortableOperation","shaka.util.AbortableOperation.failed","shaka.util.AbortableOperation.aborted","shaka.util.AbortableOperation.completed","shaka.util.AbortableOperation.notAbortable","shaka.util.AbortableOperation.all","onFinal","then","chain","onSuccess","onError","shaka.util.AbortableOperation.wrapChainCallback_","e","wrapChainCallback_","preventDefault","shaka.util.FakeEvent.prototype.preventDefault","stopImmediatePropagation","shaka.util.FakeEvent.prototype.stopImmediatePropagation","stopPropagation","shaka.util.FakeEvent.prototype.stopPropagation","shaka.util.MultiMap.prototype","shaka.util.MultiMap.prototype.push","get","shaka.util.MultiMap.prototype.get","list","getAll","shaka.util.MultiMap.prototype.getAll","map_","apply","remove","shaka.util.MultiMap.prototype.remove","forEach","shaka.util.MultiMap.prototype.forEach","addEventListener","shaka.util.FakeEventTarget.prototype.addEventListener","listener","removeEventListener","shaka.util.FakeEventTarget.prototype.removeEventListener","dispatchEvent","shaka.util.FakeEventTarget.prototype.dispatchEvent","event","listeners","currentTarget","destroy","cleanup","operations_","NetworkingEngine","shaka.net.NetworkingEngine.RequestType","shaka.net.NetworkingEngine.PluginPriority","shaka.net.NetworkingEngine.schemes_","plugin","priority","shaka.net.NetworkingEngine.PluginPriority.APPLICATION","existing","uris","retryParams","method","body","headers","allowCrossSiteCredentials","retryParameters","licenseRequestType","numBytesRemainingObj","shaka.util.AbortableOperation.call","bytesRemaining_","shaka.net.NetworkingEngine.registerScheme","shaka.net.NetworkingEngine.unregisterScheme","registerRequestFilter","shaka.net.NetworkingEngine.prototype.registerRequestFilter","filter","unregisterRequestFilter","shaka.net.NetworkingEngine.prototype.unregisterRequestFilter","delete","clearAllRequestFilters","shaka.net.NetworkingEngine.prototype.clearAllRequestFilters","clear","registerResponseFilter","shaka.net.NetworkingEngine.prototype.registerResponseFilter","unregisterResponseFilter","shaka.net.NetworkingEngine.prototype.unregisterResponseFilter","clearAllResponseFilters","shaka.net.NetworkingEngine.prototype.clearAllResponseFilters","shaka.net.NetworkingEngine.makeRequest","shaka.net.NetworkingEngine.prototype.destroy","request","shaka.net.NetworkingEngine.prototype.request","shaka.net.NetworkingEngine.NumBytesRemainingClass","shaka.net.NetworkingEngine.PendingRequest","shaka.util.ObjectUtils.cloneObject","requestOperation","requestFilterOperation","shaka.net.NetworkingEngine.prototype.filterRequest_","filterOperation","undefined","requestFilter","shaka.util.Error.Category.NETWORK","shaka.util.Error.Code.REQUEST_FILTER_ERROR","filterRequest_","shaka.net.NetworkingEngine.prototype.send_","backoff","lastError","gotProgress","location","shaka.util.Error.Code.UNSUPPORTED_SCHEME","startTimeMs","backoffOperation","attempt","time","bytes","numBytesRemaining","shaka.net.NetworkingEngine.RequestType.SEGMENT","sendOperation","response","responseAndGotProgress","shaka.util.Error.Severity.RECOVERABLE","errorOrNull","length","send_","makeRequestWithRetry_","responseFilterOperation","shaka.net.NetworkingEngine.prototype.filterResponse_","shaka.util.Error.Code.RESPONSE_FILTER_ERROR","filterResponse_","requestFilterStartTime","requestFilterMs","responseFilterStartTime","pendingRequest","responseFilterMs","timeMs","byteLength","options","ignored","shaka.util.EventManager.Binding_.doesSupportObject_","keys","k","doesSupportObject_","supports","shaka.util.EventManager.Binding_.supportsObject_","prop","defineProperty","shaka.util.EventManager.Binding_.convertOptions_","IReleasable","shaka.util.IReleasable","release","EventManager","shaka.util.EventManager","bindingMap_","listen","binding","shaka.util.EventManager.Binding_","listenOnce","shim","unlisten","removeAll","convertOptions_","every","iterable","test","shaka.util.MapUtils.asMap","map","Map","shaka.util.MapUtils.asObject","obj","getFullType","mimeType","codecs","fullMimeType","getCodecParts_","codecString","profile","shaka.util.MimeUtils.EXTENDED_MIME_PARAMETERS_","set","supportsMediaSource","MediaSource","supportsMediaType","shaka.util.Platform.cachedMediaElement_","shaka.util.Platform.cacheExpirationTimer_","document","userAgentContains_","navigator","includes","shaka.util.StringUtils.fromUTF8","uint8","Uint8Array","utf8","shaka.util.StringUtils.fromCharCode","escaped","escape","shaka.util.Error.Category.TEXT","shaka.util.Error.Code.BAD_ENCODING","littleEndian","noThrow","buffer","temp","arr","Uint16Array","dataView","DataView","isAscii","shaka.util.Error.Code.UNABLE_TO_DETECT_ENCODING","str","unescape","result","view","shaka.util.StringUtils.fromCharCodeImpl_","supportsChunkSize","size","$jscomp.arrayFromIterable","subArray","fromUTF8","fromUTF16","shaka.util.StringUtils.fromUTF16","fromBytesAutoDetect","shaka.util.StringUtils.fromBytesAutoDetect","toUTF8","shaka.util.StringUtils.toUTF8","toUTF16","shaka.util.StringUtils.toUTF16","shaka.util.Uint8ArrayUtils.toBase64","padding","base64","hex","arr1","arr2","totalLength","offset","shaka.media.DrmEngine","playerInterface","playerInterface_","supportedTypes_","video_","initialized_","currentDrmInfo_","eventManager_","activeSessions_","offlineSessionIds_","allSessionsLoaded_","config_","onError_","this.onError_","err","keyStatusByKeyId_","announcedKeyStatusByKeyId_","keyStatusTimer_","shaka.media.DrmEngine.prototype.processKeyStatusChanges_","privateMap","publicMap","status","keyId","statuses","shaka.util.Error.Category.DRM","shaka.util.Error.Code.EXPIRED","onKeyStatus","processKeyStatusChanges_","isDestroying_","finishedDestroyingPromise_","usePersistentLicenses_","mediaKeyMessageEvents_","initialRequestsSent_","expirationTimer_","shaka.media.DrmEngine.prototype.pollExpiration_","pollExpiration_","metadata","session","oldTime","newTime","Infinity","onExpirationUpdated","noop","shaka.media.DrmEngine.prototype.initForPlayback","variants","offlineSessionIds","init_","shaka.media.DrmEngine.prototype.init_","hadDrmInfo","v","servers","shaka.media.DrmEngine.replaceDrmInfo_","keySystems","drmInfos","keySystem","licenseServerUri","distinctiveIdentifierRequired","persistentStateRequired","audioRobustness","videoRobustness","serverCertificate","initData","keyIds","clearKeyDrmInfo","shaka.media.DrmEngine.prototype.configureClearKey_","clearKeys","keyHex","keyIdHex","shaka.util.Uint8ArrayUtils.fromHex","keyObj","kty","kid","license","jwkSet","initDataStr","initDatas","initDataType","configureClearKey_","shaka.media.DrmEngine.fillInDrmInfoDefaults_","advanced","configsByKeySystem","shaka.media.DrmEngine.prototype.prepareMediaKeyConfigsForVariants_","allDrmInfo","persistentState","sessionTypes","configs","info","config","audioCapabilities","videoCapabilities","distinctiveIdentifier","label","variant","audio","video","audioMimeType","shaka.util.MimeUtils.getFullType","videoMimeType","capability","robustness","contentType","prepareMediaKeyConfigsForVariants_","queryMediaKeys_","shaka.media.DrmEngine.prototype.setServerCertificate","setServerCertificate","shaka.util.Error.Code.INVALID_SERVER_CERTIFICATE","shaka.media.DrmEngine.prototype.createOrLoad","initDataOverride","createTemporarySession_","sessionId","loadOfflineSession_","shaka.media.DrmEngine.prototype.newInitData","metadatas","shaka.util.Uint8ArrayUtils.equal","shaka.media.DrmEngine.prototype.willSupport","has","shaka.media.DrmEngine.prototype.getSessionIds","ids","mapping","shaka.util.Iterables.map","sessions","s","from","shaka.media.DrmEngine.prototype.queryMediaKeys_","shaka.util.Error.Code.NO_RECOGNIZED_KEY_SYSTEMS","instigator","shouldHaveLicenseServer","some","hasLicenseServer","requestMediaKeySystemAccess","shaka.util.Error.Code.REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE","mediaKeySystemAccess","realConfig","videoCaps","licenseServers","serverCerts","shaka.media.DrmEngine.processDrmInfos_","drmInfo","found","cert","shaka.util.Error.Code.NO_LICENSE_SERVER_GIVEN","mediaKeys","mediaKeys_","shaka.util.Error.Code.FAILED_TO_CREATE_CDM","shaka.media.DrmEngine.prototype.loadOfflineSession_","createSession","shaka.util.Error.Code.FAILED_TO_CREATE_SESSION","loaded","oldExpiration","updatePromise","load","present","areAllSessionsLoaded_","shaka.util.Error.Code.OFFLINE_SESSION_REMOVED","shaka.media.DrmEngine.prototype.createTemporarySession_","generateRequest","systemCode","extended","shaka.util.Error.Code.FAILED_TO_GENERATE_LICENSE_REQUEST","shaka.media.DrmEngine.prototype.sendLicenseRequest_","url","advancedConfig","shaka.media.DrmEngine.prototype.unpackPlayReadyRequest_","xml","dom","parseFromString","DOMParser","shaka.util.Uint8ArrayUtils.fromBase64","challenge","unpackPlayReadyRequest_","startsWith","shaka.media.DrmEngine.prototype.formatFairPlayRequest_","originalPayload","params","formatFairPlayRequest_","netEngine","shaka.net.NetworkingEngine.RequestType.LICENSE","shaka.media.DrmEngine.prototype.parseFairPlayResponse_","responseText","responseObject","parseFairPlayResponse_","update","onEvent","shaka.media.DrmEngine.SESSION_LOAD_TIMEOUT_","shakaErr","shaka.util.Error.Code.LICENSE_REQUEST_FAILED","shaka.util.Error.Code.LICENSE_RESPONSE_REJECTED","shaka.media.DrmEngine.probeSupport","basicVideoCapabilities","offlineConfig","basicConfig","support","tests","testKeySystems","testSystem","access","shaka.util.Platform.userAgentContains_","shaka.media.DrmEngine.prototype.supportsVariant","willSupport","audioContentType","videoContentType","shaka.media.DrmEngine.getCommonDrmInfos","drms1","drms2","commonDrms","drm1","drm2","mergedDrm","shaka.media.DrmEngine.prototype.areAllSessionsLoaded_","shaka.util.Iterables.every","advancedConfigs","server","cast","__platform__","toBase64","fromBase64","fromHex","toHex","shaka.util.Uint8ArrayUtils.toHex","equal","concat","shaka.util.Uint8ArrayUtils.concat","shaka.media.DrmEngine.prototype","shaka.media.DrmEngine.prototype.destroy","$jscomp.asyncExecutePromiseGeneratorFunction","shaka.media.DrmEngine.prototype.destroyNow_","openSessions","shaka.media.DrmEngine.closeSession_","shaka.media.DrmEngine.CLOSE_TIMEOUT_","setMediaKeys","destroyNow_","shaka.media.DrmEngine.prototype.configure","shaka.media.DrmEngine.prototype.attach","shaka.util.Error.Code.ENCRYPTED_CONTENT_WITHOUT_DRM_INFO","onPlay_","sendLicenseRequest_","shaka.util.Error.Code.FAILED_TO_ATTACH_TO_VIDEO","createOrLoad","cb","newInitData","shaka.media.DrmEngine.prototype.keySystem","shaka.media.DrmEngine.prototype.getExpiration","min","shaka.media.DrmEngine.prototype.onSessionMessage_","delayLicenseRequest_","delayLicenseRequestUntilPlayed","paused","shaka.media.DrmEngine.prototype.onKeyStatusesChange_","hasExpiredKeys","keyStatuses","tmp","part0","part1","part2","setUint32","setUint16","msUntilExpiration","shaka.media.DrmEngine.KEY_STATUS_BATCH_TIME_","muxjs","CaptionParser","videoTrackIds_","timescales_","shaka.media.TimeRangesUtils.bufferEnd","shaka.media.TimeRangesUtils.isBuffered","smallGapLimit","shaka.media.TimeRangesUtils.bufferedAheadOf","shaka.media.TimeRangesUtils.getBufferedInfo","start","end","shaka.media.MuxJSClosedCaptionParser","init","probe","initBytes","muxCaptionParser_","parseFrom","onCaptions","segmentBytes","dashParsed","parse","clearParsedCaptions","reset","resetCaptionStream","shaka.media.NoopCaptionParser","shaka.util.Functional","shaka.util.Functional.createFallbackPromiseChain","reduce","elem","shaka.util.Functional.collapseArrays","shaka.util.Functional.noop","shaka.util.Functional.isNotNull","shaka.util.ManifestParserUtils.resolveUris","baseUris","relativeUris","relativeAsGoog","shaka.util.ManifestParserUtils.createDrmInfo","shaka.util.ManifestParserUtils.ContentType","VIDEO","AUDIO","TEXT","APPLICATION","shaka.util.ManifestParserUtils.GAP_OVERLAP_TOLERANCE_SECONDS","shaka.media.Transmuxer","Transmuxer","transmuxPromise_","transmuxedData_","captions_","isTransmuxing_","muxTransmuxer_","on","shaka.media.Transmuxer.convertTsCodecs","tsMimeType","mp4MimeType","match","newCodecString","level","shaka.text.Cue","startTime","endTime","payload","direction","shaka.text.Cue.direction.HORIZONTAL_LEFT_TO_RIGHT","region","shaka.text.CueRegion","position","positionAlign","shaka.text.Cue.positionAlign.AUTO","textAlign","shaka.text.Cue.textAlign.CENTER","writingMode","shaka.text.Cue.writingMode.HORIZONTAL_TOP_TO_BOTTOM","lineInterpretation","shaka.text.Cue.lineInterpretation.LINE_NUMBER","line","lineHeight","lineAlign","shaka.text.Cue.lineAlign.START","displayAlign","shaka.text.Cue.displayAlign.AFTER","fontSize","fontWeight","shaka.text.Cue.fontWeight.NORMAL","fontStyle","shaka.text.Cue.fontStyle.NORMAL","fontFamily","textDecoration","wrapLine","id","shaka.media.Transmuxer.prototype.destroy","dispose","onTransmuxed_","shaka.media.Transmuxer.prototype.onTransmuxed_","segmentWithInit","onTransmuxDone_","shaka.media.Transmuxer.prototype.onTransmuxDone_","output","shaka.util.Uint8ArrayUtils.concat.apply","captions","Cue","shaka.text.Cue.positionAlign","shaka.text.Cue.textAlign","shaka.text.Cue.displayAlign","shaka.text.Cue.direction","shaka.text.Cue.writingMode","shaka.text.Cue.lineInterpretation","shaka.text.Cue.lineAlign","shaka.text.Cue.fontWeight","shaka.text.Cue.fontStyle","regionAnchorY","height","viewportAnchorUnits","shaka.text.CueRegion.units.PERCENTAGE","scroll","shaka.text.CueRegion.scrollMode.NONE","shaka.text.Cue.textDecoration","CueRegion","shaka.text.CueRegion.units","shaka.text.TextEngine","displayer","displayer_","appendWindowStart_","appendWindowEnd_","bufferEnd_","selectedClosedCaptionId_","closedCaptionsMap_","shaka.text.CueRegion.scrollMode","shaka.text.TextEngine.parserMap_","shaka.util.MimeUtils.CLOSED_CAPTION_MIMETYPE","shaka.text.TextEngine.prototype.initParser","shaka.text.TextEngine.prototype.storeAndAppendClosedCaptions","closedCaptions","videoTimestampOffset","startAndEndTime","captionsMap","caption","cue","append","cues","bufferStart_","shaka.media.MediaSourceEngine","closedCaptionParser","textDisplayer","textDisplayer_","sourceBuffers_","textEngine_","queues_","transmuxers_","captionParser_","mediaSourceOpen_","mediaSource","src","shaka.media.MediaSourceEngine.createObjectURL","mediaSource_","registerParser","shaka.text.TextEngine.registerParser","unregisterParser","shaka.text.TextEngine.unregisterParser","shaka.text.TextEngine.prototype.destroy","getStartTime","shaka.text.TextEngine.prototype.getStartTime","parser_","parseMedia","allCues","periodStart","segmentStart","segmentEnd","shaka.util.Error.Code.UNABLE_TO_EXTRACT_CUE_START_TIME","shaka.text.TextEngine.prototype.remove","appendCues","shaka.text.TextEngine.prototype.appendCues","setSelectedClosedCaptionId","shaka.text.TextEngine.prototype.setSelectedClosedCaptionId","bufferEndTime","c","createObjectURL","shaka.media.MediaSourceEngine.isStreamSupported","stream","extendedMimeType","getExtendedType","components","mimeKey","streamKey","shaka.util.MimeUtils.getExtendedType","shaka.text.TextEngine.isTypeSupported","shaka.media.Transmuxer.isSupported","shaka.media.MediaSourceEngine.prototype.reinitText","shaka.media.MediaSourceEngine.prototype.bufferStart","shaka.media.MediaSourceEngine.prototype.bufferEnd","getBuffered_","shaka.media.MediaSourceEngine.prototype.getBuffered_","shaka.media.MediaSourceEngine.prototype.appendBuffer","hasClosedCaptions","shaka.text.TextEngine.prototype.appendBuffer","parseInit","cuesToAppend","shaka.media.Transmuxer.prototype.transmux","dataArray","flush","shaka.util.Error.Category.MEDIA","shaka.util.Error.Code.TRANSMUXING_FAILED","transmux","transmuxedData","enqueueOperation_","reinitText","storeAndAppendClosedCaptions","timestampOffset","shaka.media.MediaSourceEngine.prototype.clear","duration","shaka.media.MediaSourceEngine.prototype.enqueueOperation_","shaka.util.Error.Code.QUOTA_EXCEEDED_ERROR","shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_THREW","popFromQueue_","shaka.media.MediaSourceEngine.prototype.enqueueBlockingOperation_","run","allWaiters","ready","shaka.media.MediaSourceEngine.prototype.popFromQueue_","next","areLanguageCompatible","locale1","locale2","shaka.util.LanguageUtils.normalize","isParentOf","possibleParent","possibleChild","possibleParentComponents","possibleChildComponents","normalize","locale","language","shaka.util.LanguageUtils.isoMap_.get","getLocaleForVariant","findClosestLocale","searchSpace","safeTarget","safeSearchSpace","option","shaka.util.LanguageUtils.isParentOf","localeA","localeB","localeAComponents","localeBComponents","shaka.media.MediaSourceEngine.prototype","shaka.media.MediaSourceEngine.prototype.destroy","q","inProgress","removeAttribute","shaka.media.MediaSourceEngine.prototype.init","streamsByType","forceTransmuxTS","ContentType","sourceBuffer","addSourceBuffer","shaka.media.MediaSourceEngine.prototype.getBufferedInfo","buffered","text","shaka.media.MediaSourceEngine.prototype.setSelectedClosedCaptionId","videoBufferEndTime","bufferEnd","shaka.media.MediaSourceEngine.prototype.remove","shaka.media.MediaSourceEngine.prototype.flush","shaka.media.MediaSourceEngine.prototype.endOfStream","reason","enqueueBlockingOperation_","endOfStream","setDuration","shaka.media.MediaSourceEngine.prototype.setDuration","getDuration","shaka.media.MediaSourceEngine.prototype.getDuration","shaka_media_MediaSourceEngine_prototype$append_","shaka.media.MediaSourceEngine.prototype.append_","shaka_media_MediaSourceEngine_prototype$remove_","shaka.media.MediaSourceEngine.prototype.remove_","abort_","shaka.media.MediaSourceEngine.prototype.abort_","appendWindowStart","appendWindowEnd","onUpdateEnd_","flush_","shaka.media.MediaSourceEngine.prototype.flush_","currentTime","setTimestampOffset_","shaka.media.MediaSourceEngine.prototype.setTimestampOffset_","setAppendWindow_","shaka.media.MediaSourceEngine.prototype.setAppendWindow_","shaka_media_MediaSourceEngine_prototype$onError_","shaka.media.MediaSourceEngine.prototype.onError_","shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_FAILED","shaka.media.MediaSourceEngine.prototype.onUpdateEnd_","shaka.util.LanguageUtils.isoMap_","shaka.util.StreamUtils.meetsRestrictions","restrictions","maxHwRes","inRange","x","max","shaka.util.StreamUtils.applyRestrictions","tracksChanged","originalAllowed","allowedByApplication","shaka.util.StreamUtils.filterNewPeriod","drmEngine","activeAudio","activeVideo","period","supportsVariant","shaka.util.StreamUtils.areStreamsCompatible_","textStreams","keep","s0","s1","shaka.util.StreamUtils.variantToTrack","audioCodec","videoCodec","mimeTypes","kinds","kind","roles","track","role","active","bandwidth","width","frameRate","primary","audioRoles","videoId","audioId","channelsCount","audioBandwidth","videoBandwidth","originalVideoId","originalAudioId","originalTextId","shaka.util.StreamUtils.textStreamToTrack","shaka.util.StreamUtils.html5TrackId","html5Track","shaka.util.StreamUtils.nextTrackId_","shaka.util.StreamUtils.isPlayable","shaka.util.StreamUtils.filterVariantsByAudioChannelCount","preferredAudioChannelCount","variantsWithChannelCounts","variantsByChannelCount","count","channelCounts","countLessThanOrEqualtoConfig","shaka.util.StreamUtils.filterStreamsByLanguageAndRole","streams","preferredLanguage","preferredRole","chosen","firstLanguage","closestLocale","shaka.util.LanguageUtils.findClosestLocale","roleMatches","shaka.util.StreamUtils.filterTextStreamsByRole_","noRoleMatches","allRoles","shaka.util.StreamUtils.getVariantByStreams","shaka.abr.SimpleAbrManager","enabled_","bandwidthEstimator_","variants_","startupComplete_","sort","v1","v2","major","minor","minor_","deprecateFeature","description","expiresAt","shaka.deprecate.Version","enforce","shaka.Deprecate.enforcer_","libraryVersion_","minorCheck","expiresOn","onPending_","libraryVersion","featureVersion","onExpired_","errorMessage","SimpleAbrManager","shaka.abr.SimpleAbrManager.prototype.stop","lastTimeChosenMs_","shaka.abr.SimpleAbrManager.prototype.init","switchCallback","chooseVariant","shaka.abr.SimpleAbrManager.prototype.chooseVariant","sortedVariants","shaka.abr.SimpleAbrManager.filterAndSortVariants_","currentBandwidth","defaultBandwidthEstimate","maxBandwidth","bandwidthUpgradeTarget","bandwidthDowngradeTarget","enable","shaka.abr.SimpleAbrManager.prototype.enable","disable","shaka.abr.SimpleAbrManager.prototype.disable","segmentDownloaded","shaka.abr.SimpleAbrManager.prototype.segmentDownloaded","deltaTimeMs","numBytes","minBytes_","suggestStreams_","switchInterval","minTotalBytes_","chosenVariant","switch_","shaka.abr.SimpleAbrManager.prototype.getBandwidthEstimate","setVariants","shaka.abr.SimpleAbrManager.prototype.setVariants","configure","shaka.abr.SimpleAbrManager.prototype.configure","shaka.cast.CastUtils.VideoEvents","shaka.cast.CastUtils.VideoAttributes","shaka.cast.CastUtils.VideoInitStateAttributes","shaka.cast.CastUtils.VideoVoidMethods","shaka.cast.CastUtils.PlayerEvents","shaka.cast.CastUtils.PlayerGetterMethods","shaka.cast.CastUtils.PlayerGetterMethodsThatRequireLive","shaka.cast.CastUtils.PlayerInitState","shaka.cast.CastUtils.PlayerInitAfterLoadState","shaka.cast.CastUtils.PlayerVoidMethods","shaka.cast.CastUtils.PlayerPromiseMethods","thing","stringify","eventKey","simpleEvent","eventValue","ranges","shaka.cast.CastUtils.deserialize","NaN","shaka.cast.CastUtils.simulateTimeRanges_","shaka.cast.CastSender","receiverAppId","onStatusChanged","onFirstCastStateUpdate","onRemoteEvent","onResumeLocal","onInitStateRequired","statusChangeTimer_","onFirstCastStateUpdate_","hasJoinedExistingSession_","onRemoteEvent_","onResumeLocal_","onInitStateRequired_","isCasting_","receiverName_","appData_","onConnectionStatusChangedBound_","onMessageReceivedBound_","cachedProperties_","nextAsyncCallId_","asyncCallPromises_","castPromise_","shaka.cast.CastSender.hasReceivers_","shaka.cast.CastSender.session_","shaka.cast.CastSender.prototype.removeListeners_","removeUpdateListener","removeMessageListener","shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE","shaka.cast.CastSender.prototype.rejectAllPromises_","shaka.util.Error.Code.LOAD_INTERRUPTED","message","serialized","shaka.cast.CastUtils.serialize","sendMessage","shaka.cast.CastProxy","player","localVideo_","localPlayer_","onCastStatusChanged_","targetName","getInitState_","shaka.cast.CastProxy.prototype.init_","videoProxy_","configurable","enumerable","playerProxy_","videoEventTarget_","playerEventTarget_","shaka.cast.CastProxy.prototype.getInitState_","initState","getAssetUri","pause","ended","pair","setter","shaka.cast.CastProxy.prototype.onCastStatusChanged_","shaka.cast.CastProxy.prototype.onFirstCastStateUpdate_","fakeEvent","shaka.cast.CastProxy.prototype.onResumeLocal_","shaka.cast.CastUtils.PlayerInitState.forEach","assetUri","manifestReady","autoplay","videoState","shaka.cast.CastUtils.VideoInitStateAttributes.forEach","shaka.cast.CastUtils.PlayerInitAfterLoadState.forEach","play","shaka.cast.CastProxy.prototype.onRemoteEvent_","isCasting","shaka.cast.CastReceiver","appDataCallback","contentIdCallback","player_","targets_","appDataCallback_","contentIdCallback_","contentId","isConnected_","isIdle_","updateNumber_","startUpdatingUpdateNumber_","initialStatusUpdatePending_","genericBus_","pollTimer_","pollAttributes_","shaka.cast.CastReceiver.prototype.init_","manager","CastReceiverManager","getInstance","onSenderConnected","onSenderDisconnected","onSystemVolumeChanged","shaka.cast.CastUtils.GENERIC_MESSAGE_NAMESPACE","onMessage","shakaBus_","canDisplayType","setMaxHardwareResolution","timer","shaka.cast.CastReceiver.prototype.onCastStatusChanged_","maybeSendMediaInfoMessage_","sendMediaStatus_","shaka.cast.CastReceiver.prototype.pollAttributes_","isLive","systemVolume","sendMessage_","shaka.cast.CastReceiver.prototype.maybeSendMediaInfoMessage_","sendMediaInfoMessage_","shaka.cast.CastReceiver.prototype.sendMediaInfoMessage_","media","shaka.cast.CastReceiver.prototype.sendMessage_","bus","senderId","shaka.cast.CastReceiver.prototype.sendMediaStatus_","requestId","playbackRate","playState","shaka.cast.CastReceiver.PLAY_STATE","mediaStatus","getPlayState_","isBuffering","volume","muted","shaka.cast.CastSender.prototype","shaka.cast.CastSender.prototype.destroy","rejectAllPromises_","removeListeners_","shaka.cast.CastSender.prototype.isCasting","receiverName","shaka.cast.CastSender.prototype.receiverName","shaka.cast.CastSender.prototype.init","chrome","isAvailable","apiReady_","sessionRequest","SessionRequest","apiConfig","ApiConfig","initialize","oldSession","SessionStatus","STOPPED","__onGCastApiAvailable","setAppData","shaka.cast.CastSender.prototype.setAppData","appData","shaka.cast.CastSender.prototype.cast","shaka.util.Error.Category.CAST","shaka.util.Error.Code.ALREADY_CASTING","requestSession","shaka.util.Error.Code.NO_CAST_RECEIVERS","shaka.util.Error.Code.CAST_API_UNAVAILABLE","forceDisconnect","shaka.cast.CastSender.prototype.forceDisconnect","shaka.cast.CastSender.session_.stop","shaka.cast.CastSender.prototype.get","property","shaka.cast.CastUtils.VideoVoidMethods.includes","remoteCall_","shaka.cast.CastUtils.PlayerVoidMethods.includes","shaka.cast.CastUtils.PlayerPromiseMethods.includes","remoteAsyncCall_","propertyGetter_","shaka.cast.CastSender.prototype.set","onSessionInitiated_","shaka.cast.CastSender.prototype.onSessionInitiated_","addUpdateListener","onSessionCreated_","addMessageListener","onConnectionStatusChanged_","onConnectionError_","shaka.cast.CastSender.prototype.onConnectionError_","shaka.util.Error.Code.UNEXPECTED_CAST_ERROR","shaka.util.Error.Code.CAST_CANCELED_BY_USER","shaka.util.Error.Code.CAST_CONNECTION_TIMED_OUT","shaka.util.Error.Code.CAST_RECEIVER_APP_UNAVAILABLE","shaka.cast.CastSender.prototype.propertyGetter_","shaka.cast.CastSender.prototype.remoteCall_","shaka.cast.CastSender.prototype.remoteAsyncCall_","onExistingSessionJoined_","shaka.cast.CastSender.prototype.onExistingSessionJoined_","onReceiverStatusChanged_","shaka.cast.CastSender.prototype.onReceiverStatusChanged_","availability","shaka.cast.CastSender.prototype.onConnectionStatusChanged_","connected","shaka.cast.CastSender.session_.status","shaka.cast.CastSender.session_.receiver.friendlyName","friendlyName","shaka.cast.CastSender.prototype.onMessageReceived_","namespace","reconstructedError","CastProxy","shaka.cast.CastProxy.prototype.destroy","waitFor","sender_","getVideo","shaka.cast.CastProxy.prototype.getVideo","getPlayer","shaka.cast.CastProxy.prototype.getPlayer","canCast","shaka.cast.CastProxy.prototype.canCast","shaka.cast.CastProxy.prototype.isCasting","shaka.cast.CastProxy.prototype.receiverName","shaka.cast.CastProxy.prototype.cast","shaka.util.Error.Code.CAST_RECEIVER_APP_ID_MISSING","unload","shaka.cast.CastProxy.prototype.setAppData","suggestDisconnect","shaka.cast.CastProxy.prototype.suggestDisconnect","changeReceiverId","shaka.cast.CastProxy.prototype.changeReceiverId","newAppId","receiverAppId_","shaka.cast.CastProxy.prototype.forceDisconnect","shaka.cast.CastProxy.prototype","shaka.cast.CastProxy.prototype.videoProxyGet_","videoProxySet_","shaka.cast.CastProxy.prototype.videoProxySet_","videoProxyLocalEvent_","shaka.cast.CastProxy.prototype.videoProxyLocalEvent_","playerProxyGet_","shaka.cast.CastProxy.prototype.playerProxyGet_","getConfiguration","getNetworkingEngine","playerProxyLocalEvent_","shaka.cast.CastProxy.prototype.playerProxyLocalEvent_","CastReceiver","isConnected","shaka.cast.CastReceiver.prototype.isConnected","isIdle","shaka.cast.CastReceiver.prototype.isIdle","shaka.cast.CastReceiver.prototype.destroy","shaka.cast.CastReceiver.prototype","shaka.cast.CastReceiver.prototype.onSendersChanged_","shaka.cast.CastReceiver.prototype.proxyEvent_","shaka.cast.CastReceiver.prototype.fakeVolumeChangeEvent_","onShakaMessage_","shaka.cast.CastReceiver.prototype.onShakaMessage_","shaka.cast.CastReceiver.prototype.initState_","initState_","onGenericMessage_","shaka.cast.CastReceiver.prototype.onGenericMessage_","resumeState","volumeObject","oldVolumeLevel","oldVolumeMuted","mediaInfo","sendAsyncComplete_","shaka.cast.CastReceiver.prototype.sendAsyncComplete_","IDLE","PLAYING","BUFFERING","PAUSED","shaka.util.XmlUtils","shaka.util.XmlUtils.findChild","children","shaka.util.XmlUtils.findChildren","shaka.util.XmlUtils.findChildNS","ns","shaka.util.XmlUtils.findChildrenNS","child","shaka.util.XmlUtils.getAttributeNS","hasAttributeNS","shaka.util.XmlUtils.getContents","isText","nodeType","Node","trim","shaka.util.XmlUtils.parseAttr","parseFunction","defaultValue","parsedValue","shaka.util.XmlUtils.parseDate","dateString","shaka.util.XmlUtils.parseDuration","durationString","matches","d","shaka.util.XmlUtils.parseRange","rangeString","isFinite","shaka.util.XmlUtils.parseInt","intString","shaka.util.XmlUtils.parsePositiveInt","shaka.util.XmlUtils.parseNonNegativeInt","shaka.util.XmlUtils.parseFloat","floatString","shaka.util.XmlUtils.evalDivision","exprString","res","shaka.util.XmlUtils.parseXmlString","xmlString","expectedRootElemName","parser","tagName","rootElem","shaka.util.XmlUtils.parseXml","string","parseXmlString","shaka.dash.ContentProtection.defaultKeySystems_","elems","ignoreDrmInfo","parsed","shaka.dash.ContentProtection.parseElement_","shaka.dash.ContentProtection.parseElements_","defaultInit","parsedNonCenc","shaka.util.Error.Category.MANIFEST","shaka.util.Error.Code.DASH_CONFLICTING_KEY_IDS","shaka.dash.ContentProtection.MP4Protection_","shaka.dash.ContentProtection.convertElements_","elements","shaka.dash.ContentProtection.defaultKeySystems_.get","licenseParser","shaka.dash.ContentProtection.licenseUrlParsers_.get","infos","shaka.dash.ContentProtection.defaultKeySystems_.values","defaultKeyId","firstRepresentation","shaka.dash.ContentProtection.licenseUrlParsers_","shaka.dash.ContentProtection.getWidevineLicenseUrl","mslaurlNode","shaka.dash.ContentProtection.getPlayReadyLicenseUrl","proNode","record","shaka.dash.ContentProtection.parseMsPro_","byteOffset","getUint32","records","recordValue","rootElement","shaka.dash.ContentProtection.getLaurl_","laurlNode","schemeUri","shaka.dash.ContentProtection.CencNamespaceUri_","psshs","shaka.util.Error.Code.DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED","pssh","shaka.util.Error.Code.DASH_PSSH_BAD_ENCODING","node","shaka.dash.MpdUtils.fillUriTemplate","uriTemplate","representationId","number","valueTable","re","widthString","format","valueString","paddingSize","shaka.dash.MpdUtils.parseSegmentInfo","context","timescaleStr","shaka.dash.MpdUtils.inheritAttribute","timescale","durationStr","segmentDuration","startNumberStr","unscaledPresentationTimeOffset","startNumber","timelineNode","shaka.dash.MpdUtils.inheritChild","timeline","timePoints","lastEndTime","timePoint","t","r","repeat","nextStartTime","periodDuration","unscaledStart","scaledPresentationTimeOffset","attribute","nodes","getAttribute","findChild","shaka.dash.MpdUtils.processXlinks","failGracefully","baseUri","networkingEngine","linkDepth","shaka.dash.MpdUtils.XlinkNamespaceUri_","shaka.dash.MpdUtils.handleXlinkInElement_","xlinkHref","xlinkActuate","shaka.util.Error.Code.DASH_XLINK_DEPTH_LIMIT","shaka.util.Error.Code.DASH_UNSUPPORTED_XLINK_ACTUATE","shaka.net.NetworkingEngine.RequestType.MANIFEST","shaka.util.Error.Code.DASH_INVALID_XML","removeChild","appendChild","attributeValue","setAttribute","childOperations","resolveToZeroString","shaka.media.InitSegmentReference","startByte","endByte","getUris","shaka.util.DataViewReader","endianness","littleEndian_","shaka.util.DataViewReader.Endianness.LITTLE_ENDIAN","position_","InitSegmentReference","createUris","shaka.media.InitSegmentReference.prototype.createUris","getStartByte","shaka.media.InitSegmentReference.prototype.getStartByte","getEndByte","shaka.media.InitSegmentReference.prototype.getEndByte","shaka.media.SegmentReference","SegmentReference","getPosition","shaka.media.SegmentReference.prototype.getPosition","shaka.media.SegmentReference.prototype.getStartTime","getEndTime","shaka.media.SegmentReference.prototype.getEndTime","shaka.media.SegmentReference.prototype.createUris","shaka.media.SegmentReference.prototype.getStartByte","shaka.media.SegmentReference.prototype.getEndByte","DataViewReader","LITTLE_ENDIAN","shaka.util.Error.Code.BUFFER_READ_OUT_OF_BOUNDS","shaka.util.Mp4Parser","boxDefinitions_","done_","box","hasMoreData","parseNext","readUint32","readBytes","dataView_","shaka.util.Mp4Parser.typeToString","fromCharCode","shaka.media.Mp4SegmentIndexParser","sidxData","sidxOffset","references","fullBox","shaka.media.Mp4SegmentIndexParser.parseSIDX_","reader","skip","shaka.util.Error.Code.MP4_SIDX_INVALID_TIMESCALE","earliestPresentationTime","firstOffset","readUint64","referenceCount","readUint16","chunk","referenceType","referenceSize","subsegmentDuration","shaka.util.Error.Code.MP4_SIDX_TYPE_NOT_SUPPORTED","unscaledStartTime","shaka.util.Error.Code.MP4_SIDX_WRONG_BOX_TYPE","shaka.media.SegmentIndex","shaka.media.SegmentIndex.prototype.fit","lastReference","firstReference","shift","references_","shaka.util.EbmlParser","reader_","BIG_ENDIAN","shaka.util.EbmlParser.DYNAMIC_SIZES","shaka.util.EbmlParser.prototype.parseElement","vint","parseVint_","parseId_","shaka.util.Error.Code.EBML_OVERFLOW","shaka.util.EbmlParser.DYNAMIC_SIZES.length","shaka.util.Error.Code.JS_INTEGER_OVERFLOW","elementSize","shaka.util.EbmlElement","shaka.util.EbmlParser.prototype.parseVint_","firstByte","readUint8","shaka.util.EbmlElement.prototype.getUint","getUint8","shaka.media.WebmSegmentIndexParser","shaka.media.WebmSegmentIndexParser.prototype.parseCuePoint_","cuePointElement","shaka.media.WebmSegmentIndexParser.CUE_TIME_ID","cueTimeElement","parseElement","shaka.util.Error.Code.WEBM_CUE_TIME_ELEMENT_MISSING","shaka.media.WebmSegmentIndexParser.CUE_TRACK_POSITIONS_ID","unscaledTime","getUint","cueTrackPositionsElement","shaka.util.Error.Code.WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING","cueTrackParser","relativeOffset","shaka.media.WebmSegmentIndexParser.CUE_CLUSTER_POSITION","shaka.dash.SegmentBase.createInitSegment","initialization","resolvedUris","range","shaka.dash.SegmentBase.createSegmentIndexFromUris","requestInitSegment","containerType","presentationTimeline","fitLast","isLastPeriod","localRequest","segmentIndex","createSegmentIndex","create","async","results","indexData","notifySegments","fit","findSegmentPosition","find","getSegmentReference","shaka.dash.SegmentBase.fromInheritance_","frame","segmentBase","shaka.dash.SegmentList.createStream","segmentIndexMap","shaka.dash.SegmentList.fromInheritance_","mediaSegments","shaka.dash.SegmentList.parseMediaSegments_","segmentList","segmentLists","findChildren","urlNode","mediaUri","segmentInfo","shaka.util.Error.Code.DASH_NO_SEGMENT_INFO","shaka.dash.SegmentList.createSegmentReferences_","prevEndTime","getSegmentAvailabilityStart","dynamic","initSegmentReference","shaka.dash.SegmentTemplate.createStream","isUpdate","shaka.dash.SegmentTemplate.createInitSegment_","shaka.dash.SegmentTemplate.fromInheritance_","repId","filledTemplate","mediaTemplate","indexTemplate","shaka.util.Error.Code.DASH_UNSUPPORTED_CONTAINER","shaka.util.Error.Code.DASH_WEBM_MISSING_INIT","notifyMaxSegmentDuration","notifyMinSegmentStartTime","segmentIndexFunctions","shaka.dash.SegmentTemplate.createFromDuration_","template","periodTime","shaka.dash.SegmentTemplate.createFromTimeline_","segmentReplacement","segmentId","g","shouldFit","wrapper","segmentTemplate","shaka.util.DataViewReader.Endianness","shaka.util.DataViewReader.prototype.hasMoreData","shaka.util.DataViewReader.prototype.getPosition","getLength","shaka.util.DataViewReader.prototype.getLength","shaka.util.DataViewReader.prototype.readUint8","throwOutOfBounds_","shaka.util.DataViewReader.prototype.readUint16","getUint16","shaka.util.DataViewReader.prototype.readUint32","readInt32","shaka.util.DataViewReader.prototype.readInt32","getInt32","shaka.util.DataViewReader.prototype.readUint64","low","high","shaka.util.DataViewReader.prototype.readBytes","shaka.util.DataViewReader.prototype.skip","rewind","shaka.util.DataViewReader.prototype.rewind","seek","shaka.util.DataViewReader.prototype.seek","readTerminatedString","shaka.util.DataViewReader.prototype.readTerminatedString","shaka.util.DataViewReader.prototype.throwOutOfBounds_","Mp4Parser","shaka.util.Mp4Parser.prototype.box","definition","typeCode","shaka.util.Mp4Parser.typeFromString_","headers_","BASIC_BOX","shaka.util.Mp4Parser.prototype.fullBox","FULL_BOX","shaka.util.Mp4Parser.prototype.stop","shaka.util.Mp4Parser.prototype.parse","partialOkay","wrapped","shaka.util.Mp4Parser.prototype.parseNext","absStart","boxDefinition","version","flags","versionAndFlags","payloadSize","payloadReader","skipLength","shaka.util.Mp4Parser.children","shaka.util.Mp4Parser.sampleDescription","shaka.util.Mp4Parser.allData","SegmentIndex","shaka.media.SegmentIndex.prototype.destroy","shaka.media.SegmentIndex.prototype.find","shaka.media.SegmentIndex.prototype.get","shaka.media.SegmentIndex.prototype.offset","merge","shaka.media.SegmentIndex.prototype.merge","newReferences","r1","r2","nextPosition","evict","shaka.media.SegmentIndex.prototype.evict","splice","shaka.util.EbmlParser.prototype.hasMoreData","shaka.media.WebmSegmentIndexParser.prototype.parse","cuesData","shaka.media.WebmSegmentIndexParser.EBML_ID","shaka.util.Error.Code.WEBM_EBML_HEADER_ELEMENT_MISSING","segmentElement","shaka.media.WebmSegmentIndexParser.SEGMENT_ID","shaka.util.Error.Code.WEBM_SEGMENT_ELEMENT_MISSING","infoElement","segmentOffset","shaka.media.WebmSegmentIndexParser.INFO_ID","shaka.util.Error.Code.WEBM_INFO_ELEMENT_MISSING","durationScale","timecodeScaleNanoseconds","shaka.media.WebmSegmentIndexParser.TIMECODE_SCALE_ID","shaka.media.WebmSegmentIndexParser.DURATION_ID","getFloat32","shaka.util.Error.Code.EBML_BAD_FLOATING_POINT_SIZE","getFloat64","shaka.util.Error.Code.WEBM_DURATION_ELEMENT_MISSING","shaka.media.WebmSegmentIndexParser.CUES_ID","timecodeScale","cuesElement","shaka.util.Error.Code.WEBM_CUES_ELEMENT_MISSING","lastTime","lastOffset","shaka.media.WebmSegmentIndexParser.CUE_POINT_ID","tuple","parseCuePoint_","currentOffset","shaka.media.ManifestParser","shaka.media.ManifestParser.registerParserByExtension","extension","parserFactory","shaka.media.ManifestParser.parsersByExtension","shaka.media.PresentationTimeline","presentationStartTime","presentationDelay","autoCorrectDrift","presentationDelay_","segmentAvailabilityDuration_","maxSegmentDuration_","maxSegmentEndTime_","clockOffset_","static_","userSeekStart_","autoCorrectDrift_","createSegmentRequest","shaka.dash.DashParser","manifestUris_","manifest_","periodIds_","globalId_","segmentIndexMap_","updatePeriod_","averageUpdateDuration_","updateTimer_","shaka.dash.DashParser.prototype.onUpdate_","updateDelay","requestManifest_","setUpdateTimer_","onUpdate_","shaka.dash.DashParser.prototype.requestManifest_","unshift","shaka.dash.DashParser.prototype.parseManifest_","finalManifestUri","mpd","xlinkOperation","dash","xlinkFailGracefully","finalMpd","shaka.dash.DashParser.prototype.processManifest_","Functional","XmlUtils","manifestBaseUris","locations","absoluteLocations","ignoreMinBufferTime","minBufferTime","segmentAvailabilityDuration","suggestedPresentationDelay","maxSegmentDuration","mpdType","defaultPresentationDelay","periods","timingElements","periodInfo","adaptationSet","representation","indexRangeWarningGiven","presentationDuration","prevEnd","periodNodes","givenDuration","nextStart","parsePeriod_","parsePeriods_","periodId","filterNewPeriod","filterAllPeriods","setStatic","durationDerivedFromPeriods","availabilityWindowOverride","setSegmentAvailabilityDuration","shaka.dash.DashParser.prototype.parseUtcTiming_","schemesAndValues","clockSyncUri","createFallbackPromiseChain","sv","requestForTiming_","date","parseUtcTiming_","setClockOffset","processManifest_","parseManifest_","updateDuration","shaka.dash.DashParser.prototype.parsePeriod_","createFrame_","eventStreamNodes","adaptationSets","adaptationSetNodes","representationIds","shaka.util.Error.Code.DASH_DUPLICATE_REPRESENTATION_ID","normalAdaptationSets","as","trickModeAdaptationSets","trickModeFor","trickModeSet","trickModeVideo","targetId","normalSet","videoSets","getSetsOfType_","audioSets","shaka.util.Error.Code.DASH_EMPTY_PERIOD","createVariants_","textSets","shaka.dash.DashParser.prototype.getSetsOfType_","shaka.dash.DashParser.prototype.createVariants_","allowedByKeySystem","shaka.dash.DashParser.prototype.setUpdateTimer_","finalDelay","shaka.dash.DashParser.MIN_UPDATE_PERIOD_","shaka.dash.DashParser.prototype.createFrame_","parent","emsgSchemeIdUris","numChannels","parseNumber","evalDivision","schemeIdUris","inBandEventStreams","schemeIdUri","shaka.dash.DashParser.prototype.parseAudioChannels_","audioChannelConfigs","intValue","parseInt","hexValue","numBits","parseAudioChannels_","shaka.dash.DashParser.guessContentType_","shaka.dash.DashParser.prototype.requestForTiming_","requestUris","shaka.net.NetworkingEngine.RequestType.TIMING","shaka.hls.Playlist","tags","shaka.hls.Tag","attributes","shaka.hls.Tag.prototype.getAttributeValue","shaka.hls.Segment","registerParserByExtension","registerParserByMime","shaka.media.ManifestParser.registerParserByMime","shaka.media.ManifestParser.parsersByMime","probeSupport","shaka.media.ManifestParser.probeSupport","shaka.util.Platform.supportsMediaSource","parsersByMime","parsersByExtension","testExtensions","testMimeTypes","shaka.util.Platform.supportsMediaType","shaka.media.ManifestParser.create","Factory","shaka.media.ManifestParser.getFactory_","getFactory_","ManifestParser","factory","shaka.util.Error.Code.UNABLE_TO_GUESS_MANIFEST_TYPE","getMimeType","shaka.media.ManifestParser.getMimeType","getExtension","shaka.media.ManifestParser.getExtension","filenamePieces","uriPieces","uriFilename","isSupported","shaka.media.ManifestParser.isSupported","PresentationTimeline","shaka.media.PresentationTimeline.prototype.getDuration","duration_","shaka.media.PresentationTimeline.prototype.setDuration","getPresentationStartTime","shaka.media.PresentationTimeline.prototype.getPresentationStartTime","presentationStartTime_","shaka.media.PresentationTimeline.prototype.setClockOffset","shaka.media.PresentationTimeline.prototype.setStatic","isStatic","shaka.media.PresentationTimeline.prototype.setSegmentAvailabilityDuration","setDelay","shaka.media.PresentationTimeline.prototype.setDelay","delay","getDelay","shaka.media.PresentationTimeline.prototype.getDelay","shaka.media.PresentationTimeline.prototype.notifySegments","lastReferenceEndTime","shaka.media.PresentationTimeline.prototype.notifyMinSegmentStartTime","shaka.media.PresentationTimeline.prototype.notifyMaxSegmentDuration","shaka.media.PresentationTimeline.prototype.offset","shaka.media.PresentationTimeline.prototype.isLive","isInProgress","shaka.media.PresentationTimeline.prototype.isInProgress","shaka.media.PresentationTimeline.prototype.getSegmentAvailabilityStart","setUserSeekStart","shaka.media.PresentationTimeline.prototype.setUserSeekStart","getSegmentAvailabilityEnd","shaka.media.PresentationTimeline.prototype.getSegmentAvailabilityEnd","getLiveEdge_","getSafeSeekRangeStart","shaka.media.PresentationTimeline.prototype.getSafeSeekRangeStart","earliestSegmentTime","availabilityStart","availabilityEnd","desiredStart","getSeekRangeStart","shaka.media.PresentationTimeline.prototype.getSeekRangeStart","getSeekRangeEnd","shaka.media.PresentationTimeline.prototype.getSeekRangeEnd","usingPresentationStartTime","shaka.media.PresentationTimeline.prototype.usingPresentationStartTime","DashParser","shaka.dash.DashParser.prototype","shaka.dash.DashParser.prototype.configure","shaka.dash.DashParser.prototype.start","shaka.dash.DashParser.prototype.stop","shaka.dash.DashParser.prototype.update","shaka.dash.DashParser.prototype.onExpirationUpdated","shaka.dash.DashParser.prototype.parseAdaptationSet_","main","roleElements","roleValues","SUBTITLE","unrecognizedEssentialProperty","essentialProperties","schemeId","accessibilities","channelId","closedCaptionsValue","captionStr","channel","channelAndLanguage","contentProtectionElems","contentProtection","shaka.dash.ContentProtection.parseFromAdaptationSet","customScheme","representations","shaka.util.Error.Code.DASH_EMPTY_ADAPTATION_SET","repIds","parseRepresentation_","shaka.dash.DashParser.prototype.parseRepresentation_","isPrimary","shaka.dash.DashParser.prototype.verifyRepresentation_","verifyRepresentation_","streamInfo","shaka.dash.SegmentBase.createStream","representationIndex","indexRangeElem","indexUris","indexRange","representationUri","ref","shaka.dash.ContentProtection.parseFromRepresentation","repContext","asUnknown","repUnencrypted","asInfo","repInfo","shaka.util.Error.Code.DASH_NO_COMMON_KEY_SYSTEM","originalId","presentationTimeOffset","encrypted","shaka.dash.DashParser.prototype.parseEventStream_","eventNode","presentationTime","eventElement","onTimelineRegionAdded","requestInitSegment_","shaka.dash.DashParser.prototype.requestInitSegment_","shaka.util.Networking.createSegmentRequest","shaka.hls.Tag.prototype.toString","tagStr","appendages","attrToStr","attr","shaka.hls.Tag.prototype.getAttribute","shaka.hls.Utils","shaka.hls.Utils.filterTagsByName","tag","shaka.hls.Utils.getFirstTagWithName","tagsWithName","shaka.hls.Utils.findMediaTags","groupId","typeAttr","groupIdAttr","shaka.hls.Utils.constructAbsoluteUri","parentAbsoluteUri","shaka.hls.Utils.isComment","shaka.util.TextParser","shaka.util.TextParser.prototype.skipWhitespace","readRegex","shaka.util.TextParser.prototype.readRegex","regex","indexOf_","atEnd","shaka.util.TextParser.prototype.readRegexReturnCapture_","shaka.hls.ManifestTextParser","shaka.hls.ManifestTextParser.prototype.parsePlaylist","absolutePlaylistUri","lines","shaka.util.Error.Code.HLS_PLAYLIST_HEADER_MISSING","playlistType","MASTER","parseTag_","shaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGS.includes","MEDIA","shaka.hls.ManifestTextParser.SEGMENT_TAGS.includes","shaka.util.Error.Code.HLS_INVALID_PLAYLIST_HIERARCHY","parseSegments_","segmentsData","tagUri","shaka.hls.Attribute","shaka.hls.ManifestTextParser.prototype.parseSegments_","absoluteMediaPlaylistUri","playlistTags","segmentTags","absoluteSegmentUri","verbatimSegmentUri","shaka.hls.ManifestTextParser.prototype.parseTag_","word","blocks","shaka.util.Error.Code.INVALID_HLS_TAG","blockAttrs","blockValue","valueRegex","attributeRegex","shaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGS","shaka.hls.ManifestTextParser.SEGMENT_TAGS","shaka.net.DataUriPlugin","shaka.net.DataUriPlugin.parse","originalUri","shaka.hls.HlsParser","mediaTagsToStreamInfosMap_","variantUriSet_","uriToStreamInfosMap_","presentationTimeline_","masterPlaylistUri_","manifestTextParser_","updatePlaylistDelay_","updatePlaylistTimer_","shaka.hls.HlsParser.prototype.onUpdate_","presentationType_","shaka.hls.HlsParser.PresentationType_.VOD","maxTargetDuration_","minTargetDuration_","segmentsToNotifyByStream_","groupIdToClosedCaptionsMap_","aesEncrypted_","shaka.hls.HlsParser.prototype.updateStream_","Utils","PresentationType","manifestUri","playlist","mediaSequenceTag","startPosition","newestSegment","shaka.hls.HlsParser.PresentationType_","parsePlaylist","createSegments_","setPresentationType_","shaka.hls.HlsParser.prototype.filterLegacyCodecs_","streamInfos","codec","shaka.hls.HlsParser.prototype.createVariant_","shaka.hls.HlsParser.prototype.createStreamInfoFromMediaTag_","allCodecs","verbatimMediaPlaylistUri","defaultAttr","autoselectAttr","channelsAttribute","shaka.hls.HlsParser.getRequiredAttributeValue_","getAttributeValue","channels","channelcountstring","createStreamInfo_","shaka.hls.HlsParser.prototype.createStreamInfo_","drmTags","drmTag","keyFormat","drmParser","minTimestamp","segmentKeyTags","shaka.hls.HlsParser.KEYFORMATS_TO_DRM_PARSERS_","shaka.util.Error.Code.HLS_KEYFORMATS_NOT_SUPPORTED","shaka.hls.HlsParser.prototype.determinePresentationType_","presentationTypeTag","endListTag","isVod","isEvent","targetDurationTag","getRequiredTag_","targetDuration","determinePresentationType_","shaka.hls.HlsParser.prototype.guessCodecs_","guessCodecsSafe_","shaka.util.Error.Code.HLS_COULD_NOT_GUESS_CODECS","guessCodecs_","shaka.hls.HlsParser.prototype.guessMimeType_","RequestType","firstSegmentUri","parsedUri","headRequest","contentMimeType","shaka.hls.HlsParser.EXTENSION_MAP_BY_CONTENT_TYPE_","makeNetworkRequest_","shaka.util.Error.Code.HLS_COULD_NOT_GUESS_MIME_TYPE","guessMimeType_","createInitSegmentReference_","maxTimestamp","shaka.hls.HlsParser.prototype.createInitSegmentReference_","mapTags","shaka.util.Error.Code.HLS_MULTIPLE_MEDIA_INIT_SECTIONS_FOUND","verbatimInitSegmentUri","mapTag","absoluteInitSegmentUri","byterange","shaka.hls.HlsParser.prototype.createSegmentReference_","previousReference","hlsSegment","extinfValues","shaka.hls.HlsParser.prototype.notifySegments_","shaka.hls.HlsParser.prototype.createSegments_","hlsSegments","firstSegmentRef","initSegmentRef","firstStartTime","reference","createSegmentReference_","shaka.hls.HlsParser.prototype.getStartTime_","segmentRef","fetches","responses","segmentResponse","initSegmentResponse","fetchPartialSegment_","shaka.hls.HlsParser.prototype.getStartTimeFromMp4Segment_","mediaData","shaka.util.Error.Code.HLS_COULD_NOT_PARSE_SEGMENT_START_TIME","parsedMedia","baseTime","getStartTimeFromMp4Segment_","shaka.hls.HlsParser.prototype.getStartTimeFromTsSegment_","fail","packetStart","syncByte","flagsAndPacketId","adaptationFieldControl","startCode","ptsDtsIndicator","pesHeaderLengthRemaining","pts0","pts1","pts2","shaka.hls.HlsParser.TS_TIMESCALE_","getStartTimeFromTsSegment_","shaka.hls.HlsParser.prototype.getStartTimeFromTextSegment_","textEngine","getStartTimeFromTextSegment_","getStartTime_","notifySegments_","shaka.hls.HlsParser.prototype.fetchPartialSegment_","partialRequest","fullRequest","shaka.hls.HlsParser.PARTIAL_SEGMENT_SIZE_","shaka.hls.HlsParser.prototype.guessCodecsSafe_","formats","shaka.hls.HlsParser.CODEC_REGEXPS_BY_CONTENT_TYPE_","attributeName","shaka.util.Error.Code.HLS_REQUIRED_ATTRIBUTE_MISSING","shaka.hls.HlsParser.prototype.getRequiredTag_","shaka.util.Error.Code.HLS_REQUIRED_TAG_MISSING","shaka.hls.HlsParser.prototype.requestManifest_","DataUriPlugin","shaka.util.Error.Code.MALFORMED_DATA_URI","infoAndData","dataStr","encoding","typeAndEncoding","shaka.util.Error.Code.UNKNOWN_DATA_URI_ENCODING","HlsParser","shaka.hls.HlsParser.prototype","shaka.hls.HlsParser.prototype.configure","shaka.hls.HlsParser.prototype.start","shaka.hls.HlsParser.prototype.parseManifest_","minFirstTimestamp","maxFirstTimestamp","minDuration","shaka.util.Error.Code.HLS_MASTER_PLAYLIST_NOT_PROVIDED","shaka.hls.HlsParser.prototype.createPeriod_","mediaTags","textStreamTags","textStreamPromises","closedCaptionsTags","variantTags","variantsPromises","allVariants","shaka.hls.HlsParser.prototype.createTextStream_","createStreamInfoFromMediaTag_","createTextStream_","shaka.hls.HlsParser.prototype.parseClosedCaptions_","languageValue","instreamId","parseClosedCaptions_","shaka.hls.HlsParser.prototype.createVariantsForTag_","codecsString","resolutionAttr","resBlocks","audioGroupId","videoGroupId","textCodecs","subGroupId","textTags","promises","audioStreamInfos","videoStreamInfos","ignoreStream","videoCodecs","streamURI","firstAudioStreamURI","defaultCodecs","shaka.hls.HlsParser.filterDuplicateCodecs_","seen","shortCodec","shaka.util.MimeUtils.getCodecParts_","shaka.hls.HlsParser.prototype.createStreamInfoFromVariantTag_","closedCaptionsAttr","createStreamInfoFromVariantTag_","filterLegacyCodecs_","shaka.hls.HlsParser.prototype.createVariants_","audioInfos","videoInfos","audioInfo","videoInfo","audioStream","videoStream","audioDrmInfos","videoDrmInfos","variantUriKey","videoStreamUri","audioStreamUri","createVariant_","createVariantsForTag_","createPeriod_","shaka.util.Error.Code.HLS_AES_128_ENCRYPTION_NOT_SUPPORTED","isLive_","createPresentationTimeline_","rolloverSeconds","shaka.hls.HlsParser.prototype.stop","pending","shaka.hls.HlsParser.prototype.update","updates","updateStream_","shaka.hls.HlsParser.prototype.onExpirationUpdated","shaka.hls.HlsParser.AUDIO_CODEC_REGEXPS_","shaka.hls.HlsParser.VIDEO_CODEC_REGEXPS_","shaka.hls.HlsParser.TEXT_CODEC_REGEXPS_","shaka.hls.HlsParser.AUDIO_EXTENSIONS_TO_MIME_TYPES_","shaka.hls.HlsParser.VIDEO_EXTENSIONS_TO_MIME_TYPES_","shaka.hls.HlsParser.TEXT_EXTENSIONS_TO_MIME_TYPES_","shaka.hls.HlsParser.prototype.setPresentationType_","shaka.hls.HlsParser.prototype.makeNetworkRequest_","shaka.hls.HlsParser.widevineDrmParser_","VALID_METHODS","parsedData","VOD","EVENT","LIVE","useText","getFrameFor_","shaka.media.ActiveStreamMap.Frame","history_","root","candidates","shaka.media.AdaptationSet.canTransitionBetween_","shaka.media.AdaptationSet.areRolesEqual_","codecsA","codecsB","areRolesEqual_","aSet","bSet","mainRole","example","fallback_","shaka.media.PreferenceBasedCriteria","channelCount","role_","channelCount_","thresholdWhenStarving","thresholdWhenSatisfied","shaka.media.BufferingObserver.State.SATISFIED","thresholds_","shaka.media.BufferingObserver.State.STARVING","shaka.media.AdaptationSet","canInclude","shaka.media.ExampleBasedCriteria","shortList","current","byLanguage","shaka.util.LanguageUtils.getLocaleForVariant","shaka.media.PreferenceBasedCriteria.filterByLanguage_","byPrimary","byRole","filterVariantsByRole_","indexOf","shaka.media.PreferenceBasedCriteria.filterVariantsByRole_","byChannel","shaka.media.AdaptationSet.areAdaptable","STARVING","SATISFIED","implementation","stallThresholdSeconds","wasMakingProgress_","shouldBeMakingProgress","value_","lastUpdateSeconds_","stallThresholdSeconds_","onStall_","this.onStall_","mediaElement","bufferedStart","bufferedEnd","timeInSeconds","shaka.media.GapJumpingController","stallDetector","timeline_","onEvent_","seekingEventReceived_","prevReadyState_","didFireLargeGap_","stallDetector_","hadSegmentAppended_","onPollGapJump_","gapJumpTimer_","shaka.media.GapJumpingController.prototype.onPollGapJump_","readyState","seeking","threshold","gapIndex","impl","wallTimeSeconds","stallSeconds","jumpTo","seekEnd","isGapSmall","jumpSize","jumpLargeGap","jumpLargeGaps","mediaElement_","observers_","pollingLoop_","pollAllObservers_","poll","getAllVariantsFrom","findPeriodForTime","bestGuess","manifest","currentPeriod_","onChangedPeriods_","this.onChangedPeriods_","harness","harness_","isBuffering_","rate_","getRate","timer_","movePlayhead","pollRate_","apply_","rate","calculateCurrentRate_","applyRate_","oldRate","setRate","newRate","shaka.media.VideoWrapper","onSeek","onSeek_","startTime_","mover_","shaka.media.VideoWrapper.PlayheadMover","setStartTime_","delaySetStartTime_","shaka.media.VideoWrapper.prototype.getTime","shaka.media.VideoWrapper.prototype.delaySetStartTime_","readyEvent","shaka.media.VideoWrapper.prototype.setStartTime_","startListeningToSeeks_","moveTo","shaka.media.VideoWrapper.prototype.startListeningToSeeks_","targetTime_","remainingAttempts_","onLoaded","started_","minBufferTime_","lastCorrectiveSeek_","gapController_","createStallDetector_","detector","shaka.media.StallDetector","shaka.media.StallDetector.MediaElementImplementation","onStall","doThis","videoWrapper_","onSeeking_","getTime","targetTime","reposition_","shaka.media.GapJumpingController.BROWSER_GAP_TOLERANCE","clampSeekToDuration_","clampTime_","checkWindowTimer_","onPollWindow_","seekStart","minSeekRange_","durationBackoff","isBuffered","shaka.media.TimeRangesUtils.isBuffered.bind","rebufferingGoal","safeSeekOffset","safe","seekSafe","this.onAddRegion_","regions_","oldPosition_","onEnter_","this.onEnter_","onExit_","this.onExit_","onSkip_","this.onSkip_","rules_","weWere","weAre","shaka.media.RegionObserver.RelativePosition_.IN_THE_REGION","invoke","shaka.media.RegionObserver.RelativePosition_.BEFORE_THE_REGION","shaka.media.RegionObserver.RelativePosition_.AFTER_THE_REGION","shaka.media.GapJumpingController.prototype.release","onSegmentAppended","shaka.media.GapJumpingController.prototype.onSegmentAppended","shaka.media.PlayheadObserverManager","shaka.media.PeriodObserver","positionInSeconds","expectedPeriod","findCurrentPeriod_","shaka.util.Periods.findPeriodForTime","actualPeriod","shaka.media.PlayRateController","shaka.media.VideoWrapper.prototype.release","this.onSeek_","shaka.media.SrcEqualsPlayhead","setStartTime","notifyOfBufferingChange","shaka.media.MediaSourcePlayhead","shaka.media.RegionTimeline","shaka.media.RegionObserver","wasSeeking","previousPosition","currentPosition","rule","BEFORE_THE_REGION","IN_THE_REGION","AFTER_THE_REGION","shaka.media.StreamingEngine","bufferingGoalScale_","setupPeriodPromise_","canSwitchPeriod_","canSwitchStream_","mediaStates_","failureCallbackBackoff_","unloadingTextStream_","textStreamSequenceId_","shaka.media.StreamingEngine.prototype.getBufferingAudio","getStream_","shaka.media.StreamingEngine.prototype.getBufferingVideo","shaka.media.StreamingEngine.prototype.getStream_","state","shaka.media.StreamingEngine.prototype.loadNewTextStream","currentSequenceId","mediaSourceEngine","streamMap","streamSet","streamText","needPeriodIndex","setupStreams_","isTextVisible","alwaysStreamText","getPresentationTime","findPeriodForTime_","createMediaState_","scheduleUpdate_","shaka.media.StreamingEngine.prototype.setTrickPlay","mediaState","switchInternal_","normalVideo","shaka.media.StreamingEngine.prototype.switchVariant","clearBuffer","safeMargin","shaka.media.StreamingEngine.prototype.switchInternal_","force","ignoreTextStreamFailures","loadNewTextStream","periodIndex","findPeriodContainingStream_","needSamePeriod","mediaStates","ms","forceClearBuffer_","canSwitchRecord","shaka.media.StreamingEngine.prototype.shouldAbortCurrentRequest_","newSegmentSize","newSegment","getSegmentReferenceNeeded_","bandwidthEstimate","safetyBuffer","bytesToLoad_","shouldAbortCurrentRequest_","cancelUpdate_","clearBuffer_","shaka.media.StreamingEngine.prototype.forceClearBuffer_","bufferStart","shaka.media.StreamingEngine.prototype.initStreams_","resumeAt","shaka.media.StreamingEngine.prototype.setDuration_","setDuration_","shaka.media.StreamingEngine.prototype.createMediaState_","lastStream","lastSegmentReference","restoreStreamAfterTrickPlay","needInitSegment","performingUpdate","updateTimer","waitingToClearBuffer","clearBufferSafeMargin","waitingToFlushBuffer","clearingBuffer","recovering","hasError","shaka.media.StreamingEngine.prototype.setupPeriod_","resolved","shaka.media.StreamingEngine.prototype.setupStreams_","parallelWork","shaka.media.StreamingEngine.prototype.onUpdate_","shaka.media.StreamingEngine.prototype.update_","isCaptionState","timeNeeded","getTimeNeeded_","currentPeriodIndex","bufferedAhead","shaka.media.MediaSourceEngine.prototype.bufferedAheadOf","bufferedAheadOf","scaledBufferingGoal","unscaledBufferingGoal","bufferingGoal","textState","minTimeNeeded","otherState","maxRunAhead","shaka.media.StreamingEngine.prototype.fetchAndAppend_","currentPeriod","followingPeriod","initSourceBuffer","shaka.media.StreamingEngine.prototype.initSourceBuffer_","setStreamProperties","shaka.media.MediaSourceEngine.prototype.setStreamProperties","timestampOffset_","appendInit","fetch_","fetchInit","initSegment","initSourceBuffer_","shaka.media.StreamingEngine.APPEND_WINDOW_START_FUDGE_","shaka.media.StreamingEngine.APPEND_WINDOW_END_FUDGE_","fetchSegment","shaka.media.StreamingEngine.prototype.append_","evict_","shaka.media.StreamingEngine.prototype.evict_","bufferBehind","overflow","append_","shaka.media.StreamingEngine.prototype.handleStartup_","setupPeriod_","onCanSwitch","onStartupComplete","handleStartup_","shaka.media.StreamingEngine.prototype.handleQuotaExceeded_","waitingForAnotherStreamToRecover","percentBefore","fatalError_","handleQuotaExceeded_","handleStreamingError_","fetchAndAppend_","update_","shaka.media.StreamingEngine.prototype.handlePeriodTransition_","allAreIdle","shaka.media.StreamingEngine.isIdle_","allReady","needPeriod","chosenStreams","onChooseStreams","shaka.util.Error.Category.STREAMING","shaka.util.Error.Code.INVALID_STREAMS_CHOSEN","initStreams_","handlePeriodTransition_","shaka.media.StreamingEngine.prototype.getTimeNeeded_","lastPeriodIndex","lastPeriod","shaka.media.StreamingEngine.prototype.getSegmentReferenceNeeded_","getSegmentReferenceIfAvailable_","lookupTime","lookupSegmentPosition_","optimalPosition","shaka.media.StreamingEngine.prototype.getSegmentReferenceIfAvailable_","shaka.media.StreamingEngine.prototype.findPeriodForTime_","shaka.media.StreamingEngine.prototype.findPeriodContainingStream_","shaka.media.StreamingEngine.prototype.fetch_","shaka.media.StreamingEngine.prototype.clearBuffer_","shaka.media.StreamingEngine.prototype.scheduleUpdate_","shaka.media.StreamingEngine.prototype.cancelUpdate_","shaka.media.StreamingEngine.prototype.handleStreamingError_","failureCallback","shaka.net.HttpPluginUtils.makeResponse","responseURL","requestType","fromCache","shaka.util.Error.Code.BAD_HTTP_STATUS","shaka.net.HttpFetchPlugin","progressUpdated","shaka.net.HttpFetchPlugin.Headers_","controller","shaka.net.HttpFetchPlugin.AbortController_","abortStatus","canceled","timedOut","timeoutMs","shaka.net.HttpFetchPlugin.request_","signal","credentials","shaka.net.HttpXHRPlugin","xhr","shaka.net.HttpXHRPlugin.Xhr_","lastLoaded","responseType","withCredentials","onabort","xhr.onabort","onload","xhr.onload","headerLines","onerror","xhr.onerror","shaka.util.Error.Code.HTTP_ERROR","ontimeout","xhr.ontimeout","shaka.util.Error.Code.TIMEOUT","onprogress","xhr.onprogress","lowercasedKey","send","pending_","nextId_","onProgress","groups_","onProgress_","estimator_","shaka.offline.DownloadProgressEstimator","queue","estimatedByteLength","onDownloaded","open","estimate","group","fetchSegment_","action","shaka.util.Error.Category.STORAGE","close","actualDownloaded_","transaction","storeName","transaction_","store_","promise_","transaction.onabort","transaction.onerror","oncomplete","transaction.oncomplete","forEachEntry","req","openCursor","onsuccess","req.onsuccess","cursor","continue","connection","startReadOnlyOperation","store","startOperation_","startReadWriteOperation","shaka.offline.indexeddb.DBOperation","stopTracking_","shaka.offline.indexeddb.DBConnection","getCell","mechanismName","cellName","mechanism","shaka.util.Error.Code.MISSING_STORAGE_CELL","cell","shaka.offline.StorageMuxer.registry_.set","shaka.media.StreamingEngine.prototype.destroy","shaka.media.StreamingEngine.prototype.configure","failureRetryParams","shaka.media.StreamingEngine.prototype.start","initialStreams","onInitialStreamsSetup","parseEMSG_","shaka.media.StreamingEngine.prototype.parseEMSG_","presentationTimeDelta","eventDuration","messageData","onManifestUpdate","emsg","HttpFetchPlugin","request_","fetch","ReadableStream","arrayBuffer","contentLengthRaw","contentLength","shaka.net.HttpFetchPlugin.fetch_","shaka.net.HttpFetchPlugin.ReadableStream_","getReader","readObj","done","shaka.net.HttpFetchPlugin.isSupported","AbortController_","ReadableStream_","Headers_","shaka.net.NetworkingEngine.PluginPriority.PREFERRED","HttpXHRPlugin","Xhr_","shaka.net.NetworkingEngine.PluginPriority.FALLBACK","actual","estimatedDownloaded_","shaka.offline.DownloadManager","shaka.offline.indexeddb.EmeSessionStorageCell","connection_","shaka.offline.indexeddb.StorageMechanism.SESSION_ID_STORE","sessionIds","shaka.offline.StorageMuxer","destroys","mechanisms_","mech","initPromises","erase","mechanisms","alreadyInitialized","shaka.offline.StorageMuxer.registry_","shaka.offline.StorageMuxer.register","unregister","shaka.offline.StorageMuxer.registry_.delete","shaka.util.Error.Code.NEW_KEY_OPERATION_NOT_SUPPORTED","remove_","onRemove","get_","missing","shaka.util.Error.Code.KEY_NOT_FOUND","convertManifest_","old","originalManifestUri","expiration","shaka.offline.indexeddb.V1StorageCell.convertPeriod_","appMetadata","convertPeriod_","fillMissingVariants_","variantIds","nextId","variantId","shaka.offline.indexeddb.V1StorageCell.fillMissingVariants_","shaka.offline.indexeddb.V1StorageCell.convertStream_","convertStream_","initSegmentKey","shaka.offline.indexeddb.V1StorageCell.getKeyFromSegmentUri_","shaka.offline.indexeddb.V1StorageCell.convertSegment_","convertSegment_","dataKey","convertSegmentData_","getKeyFromSegmentUri_","shaka.util.Error.Code.MALFORMED_OFFLINE_URI","segmentStore","manifestStore","isFixedKey","segmentStore_","manifestStore_","isFixedKey_","add_","request.onsuccess","mechanism_","cell_","key_","asString_","shaka.offline.OfflineUri","fromPeriodDB","audioStreams","videoStreams","createVariants","audios","videos","variantMap","fromStreamDB_","refs","fromSegmentDB_","streamDB","fromInitSegmentDB_","segmentDB","shaka.offline.OfflineManifestParser","shaka.offline.OfflineScheme","offlineUri","shaka.offline.OfflineUri.parse","shaka.offline.OfflineScheme.getManifest_","shaka.offline.OfflineScheme.getSegment_","deleted","bucket","shaka.offline.SessionDeleter.isCompatible_","doDelete_","shaka.media.DrmEngine.prototype.initForRemoval","initForRemoval","licenseUri","shaka.media.DrmEngine.prototype.removeSession","tasks","removeSession","isCompatible_","comp","y","startingAt","startingWith","startTimeOfLoad","implementation_","currentlyAt_","currentlyWith_","waitForWork_","requests_","currentStep_","isAlive_","mainLoopPromise_","mainLoop_","doOneThing_","interruptible","onCancel","newRoute","onStart","onSkip","takeNextStep_","getNext","enterNode","onEnd","currentRoute_","handleError","onIdle","startNewRoute","onEnter","unblockMainLoop_","shaka.text.SimpleTextDisplayer","mode","shaka.text.SimpleTextDisplayer.TextTrackLabel_","textTrack_","shakaCue","vttCue","VTTCue","shaka.text.Cue.writingMode.VERTICAL_RIGHT_TO_LEFT","shaka.text.SimpleTextDisplayer.removeWhere_","predicate","oldState","shaka.util.ConfigUtils.mergeConfigObjects","destination","source","overrides","ignoreKeys","isValid","subPath","subTemplate","subMergeValid","fieldName","configObject","last","searchIndex","nameStart","abrMaxHeight","downlink","saveData","drm","streaming","startAtSegmentBoundary","stallEnabled","stallThreshold","stallSkip","offline","trackSelectionCallback","tracks","progressCallback","usePersistentLicense","abrFactory","abr","enabled","minWidth","maxWidth","minHeight","maxHeight","minPixels","maxPixels","minBandwidth","preferredAudioLanguage","preferredTextLanguage","preferredVariantRole","preferredTextRole","playRangeStart","playRangeEnd","textDisplayFactory","offline.trackSelectionCallback","selectedVariants","languages","tracksByHeight","selectedTracks","middleIndex","mergeConfigObjects","individualizationServer","shaka.util.PlayerConfiguration.createDefault","closed_","start_","timestamp","currentTimeSeconds","open_","getTimeSpentIn","sum","entry","stateHistory_","shaka.util.StateHistory","switchHistory_","shaka.util.SwitchHistory","shaka.Player","dependencyInjector","loadMode_","shaka.Player.LoadMode.NOT_LOADED","isTextVisible_","abrManagerFactory_","nextExternalStreamId_","loadingTextStreams_","switchingPeriods_","deferredVariant_","deferredVariantClearBuffer_","deferredVariantClearBufferSafeMargin_","deferredTextStream_","activeStreams_","shaka.media.ActiveStreamMap","defaultConfig_","maxHwRes_","stats_","currentAdaptationSetCriteria_","currentTextLanguage_","currentTextRole_","networkingEngine_","shaka.Player.prototype.createNetworkingEngine","bytesDownloaded","createNetworkingEngine","detachNode_","attachNode_","unloadNode_","parserNode_","manifestNode_","mediaSourceNode_","drmNode_","loadNode_","srcEqualsDrmNode_","srcEqualsNode_","actions","wants","shaka.Player.prototype.onAttach_","videoErrorToShakaError_","onVideoError_","onAttach_","onDetach_","onUnload_","shaka.Player.prototype.onInitializeMediaSourceEngine_","closedCaptionsParser","TextDisplayerFactory","onInitializeMediaSourceEngine_","shaka.Player.prototype.onInitializeParser_","assetUri_","onInitializeParser_","shaka.Player.prototype.onParseManifest_","regionTimeline_","setListeners","onAddRegion","onRegionEvent_","filterNewPeriod_","filterAllPeriods_","findSimilarRegion_","isSimilar","similarRegion","shaka.util.Error.Code.NO_PERIODS","shaka.Player.filterForAVVariants_","isAVVariant","hasAVVariant","onParseManifest_","shaka.Player.prototype.onInitializeDrm_","drmEngine_","onKeyStatus_","onExpirationUpdated_","initForPlayback","shaka.util.Periods.getAllVariantsFrom","onInitializeDrm_","shaka.Player.prototype.onLoad_","updateStateHistory","onRateChange","AbrManagerFactory","rebufferThreshold","adjustedTime","shaka.util.Stats","updateStateHistory_","onRateChange_","shaka.Player.prototype.createTextStreamsForClosedCaptions_","closedCaptionsMap","textStream","CLOSED_CAPTION","createTextStreamsForClosedCaptions_","shaka.Player.applyPlayRange_","fullDuration","attach","abrManager_","addVariantToSwitchHistory_","streamingEngine_","switchVariant","onAdaptation_","shaka.Player.prototype.createPlayhead","shaka.media.StreamingEngine.prototype.seeked","checkBuffered","atPeriodIndex","isAllBuffered","seeked","createPlayhead","shaka.Player.prototype.createPlayheadObserversForMSE_","periodObserver","onChangedPeriods","onTracksChanged_","onChangePeriod_","regionObserver","onExit","onEnterRegion","onExitRegion","onSkipRegion","createPlayheadObserversForMSE_","delta","startBufferManagement_","shaka.Player.prototype.createStreamingEngine","playhead_","createStreamingEngine","shaka.Player.prototype.chooseCodecsAndFilterManifest_","variantCodecs","baseVideoCodec","baseAudioCodec","variantsByCodecs","bestCodecs","lowestAverageBandwidth","num","averageBandwidth","chooseCodecsAndFilterManifest_","shaka.Player.LoadMode.MEDIA_SOURCE","shaka.Player.prototype.adjustStartTime_","getAdjustedTime","getBufferingAudio","getBufferingVideo","getPresentationPeriod_","audioStartTime","videoStartTime","adjustStartTime_","hasPrimary","chooseVariant_","loadLatencySeconds_","onLoad_","shaka.Player.prototype.onInitializeSrcEqualsDrm_","onInitializeSrcEqualsDrm_","shaka.Player.prototype.onSrcEquals_","playRateController_","audioTracks","textTracks","shaka.Player.LoadMode.SRC_EQUALS","fullyLoaded","HTMLMediaElement","abortedError","onSrcEquals_","walker_","shaka.routing.Walker","walkerImplementation","at","goingTo","getNextStep_","getNextMatchingAllDependencies_","shaka.offline.indexeddb.V1StorageCell.prototype","hasFixedKeySpace","addSegments","shaka.offline.indexeddb.StorageMechanism.V1_SEGMENT_STORE","removeSegments","getSegments","shaka.offline.indexeddb.V1StorageCell.convertSegmentData_","addManifests","shaka.offline.indexeddb.StorageMechanism.V1_MANIFEST_STORE","updateManifestExpiration","newExpiration","removeManifests","getManifests","manifests","shaka.offline.indexeddb.V1StorageCell.convertManifest_","getAllManifests","shaka.offline.indexeddb.V2StorageCell.prototype","shaka.offline.indexeddb.StorageMechanism.prototype","shaka.offline.indexeddb.StorageMechanism.DB_NAME","shaka.offline.indexeddb.StorageMechanism.VERSION","open.onsuccess","db","db_","stores","shaka.offline.indexeddb.V1StorageCell","v1_","shaka.offline.indexeddb.StorageMechanism.V2_MANIFEST_STORE","shaka.offline.indexeddb.StorageMechanism.V2_SEGMENT_STORE","shaka.offline.indexeddb.V2StorageCell","v2_","shaka.offline.indexeddb.StorageMechanism.V3_MANIFEST_STORE","shaka.offline.indexeddb.StorageMechanism.V3_SEGMENT_STORE","v3_","contains","sessions_","onupgradeneeded","open.onupgradeneeded","storeNames","autoIncrement","open.onerror","shaka.util.Error.Code.INDEXED_DB_ERROR","getCells","getEmeSessionCell","del","deleteDatabase","onblocked","del.onblocked","del.onsuccess","del.onerror","shaka.offline.indexeddb.StorageMechanism.deleteAll_","indexedDB","shaka.offline.indexeddb.StorageMechanism","shaka.offline.OfflineManifestParser.prototype","shaka.offline.OfflineManifestParser.prototype.configure","shaka.offline.OfflineManifestParser.prototype.start","uriString","muxer","converter","uri_","shaka.offline.ManifestConverter","fromManifestDB","manifestDB","shaka.offline.OfflineManifestParser.prototype.stop","shaka.offline.OfflineManifestParser.prototype.update","shaka.offline.OfflineManifestParser.prototype.onExpirationUpdated","foundSession","OfflineScheme","getManifest_","getSegment_","SimpleTextDisplayer","shaka.text.SimpleTextDisplayer.prototype.remove","removeInRange","shaka.text.SimpleTextDisplayer.prototype.append","convertToTextTrackCue","shaka.text.SimpleTextDisplayer.convertToTextTrackCue_","textTrackCues","sortedCues","addCue","shaka.text.SimpleTextDisplayer.prototype.destroy","removeIt","shaka.text.SimpleTextDisplayer.prototype.isTextVisible","setTextVisibility","shaka.text.SimpleTextDisplayer.prototype.setTextVisibility","convertToConfigObject","shaka.util.ConfigUtils.convertToConfigObject","PlayerConfiguration","shaka.util.PlayerConfiguration","shaka.util.PlayerConfiguration.mergeConfigObjects","Player","shaka.Player.prototype.destroy","events","shaka.Player.LoadMode.DESTROYED","events.onStart","events.onEnd","events.onCancel","events.onError","events.onSkip","shaka.Player.version","shaka.Deprecate.onPending_","shaka.Deprecate.onExpired_","shaka.Player.restrictedStatuses_","shaka.Player.supportPlugins_","shaka.Player.prototype.onUnload_","playheadObservers_","bufferPoller_","mediaSourceEngine_","updateBufferState_","shaka.Player.prototype.startBufferManagement_","shaka.media.BufferingObserver","satisfiedThreshold","shaka.Player.TYPICAL_BUFFERING_THRESHOLD_","bufferObserver_","previousState_","pollBufferState_","fudge","liveEdge","bufferedToEnd","bufferLead","newState","shaka.Player.prototype.applyConfig_","activeVariant","chooseStreamsAndSwitch_","oldTextDisplayer","lastTextFactory_","onAbrStatusChanged_","shaka.Player.prototype.addVariantToSwitchHistory_","fromAdaptation","shaka.Player.prototype.addTextStreamToSwitchHistory_","shaka.Player.prototype.defaultConfig_","config.streaming.failureCallback","defaultStreamingFailureCallback_","config.textDisplayFactory","self","shaka.Player.prototype.filterAllPeriods_","shaka.util.StreamUtils.filterNewPeriod.bind","filterPeriod","validPeriodsCount","shaka.util.ArrayUtils.count","check","shaka.util.Error.Code.CONTENT_UNSUPPORTED_BY_BROWSER","shaka.util.Error.Code.UNPLAYABLE_PERIOD","checkRestrictedVariants_","shaka.Player.prototype.switchVariant_","onVariantChanged_","shaka.Player.prototype.switchTextStream_","onTextChanged_","shaka.Player.prototype.updateBufferState_","shaka.Player.prototype.updateStateHistory_","history","shaka.Player.prototype.chooseVariant_","playableVariants","shaka.Player.prototype.chooseStreamsAndSwitch_","switchVariant_","chosenText","subset","chooseTextStream_","shouldStreamText_","addTextStreamToSwitchHistory_","switchTextStream_","shaka.Player.prototype.onAdaptation_","delayDispatchEvent_","shaka.Player.prototype.onTracksChanged_","shaka.Player.prototype.onVariantChanged_","shaka.Player.prototype.onTextChanged_","shaka.Player.prototype.onTextTrackVisibility_","shaka.Player.prototype.onAbrStatusChanged_","newStatus","shaka.Player.prototype.onRegionEvent_","eventName","detail","shaka.Player.prototype.videoErrorToShakaError_","msExtendedCode","shaka.util.Error.Code.VIDEO_ERROR","shaka.Player.prototype.onKeyStatus_","keyStatusMap","isGlobalStatus","shaka.util.StreamUtils.getVariantStreams","keyStatus","shaka.Player.prototype.onExpirationUpdated_","shaka.Player.prototype.checkRestrictedVariants_","hasPlayable","hasAppRestrict","missingKeys","badKeyStatuses","shaka.util.Error.Code.RESTRICTIONS_CANNOT_BE_MET","hasAppRestrictions","restrictedKeyStatuses","shaka.Player.prototype.delayDispatchEvent_","shaka.Player.getLanguagesFrom_","shaka.Player.getLanguageAndRolesFrom_","languageToRoles","pairings","shaka.Player.prototype.getPresentationPeriod_","shaka.Player.prototype.getPresentationVariant_","shaka.Player.prototype.createAbortLoadError_","shaka.Player.prototype.getNextMatchingAllDependencies_","destinationNode","nextNode","resetNode","shaka.Player.prototype.wrapWalkerListenersWithPromise_","listeners.onCancel","createAbortLoadError_","listeners.onEnd","listeners.onError","listeners.onSkip","shaka.Player.registerSupportPlugin","shaka.Player.isBrowserSupported","shaka.Player.probeSupport","basicType","shaka.Player.prototype.attach","initializeMediaSource","wrapWalkerListenersWithPromise_","detach","shaka.Player.prototype.detach","shaka.Player.prototype.unload","currentPayload","shaka.Player.prototype.load","shaka.Deprecate.deprecateFeature","payload.factory","canPlayMediaSource","shouldUseSrcEquals_","shaka.util.Error.Code.NO_VIDEO_ELEMENT","shaka.Player.prototype.shouldUseSrcEquals_","shaka.Player.prototype.configure","applyConfig_","shaka.Player.prototype.getConfiguration","resetConfiguration","shaka.Player.prototype.resetConfiguration","getLoadMode","shaka.Player.prototype.getLoadMode","getMediaElement","shaka.Player.prototype.getMediaElement","shaka.Player.prototype.getNetworkingEngine","shaka.Player.prototype.getAssetUri","getManifestUri","shaka.Player.prototype.getManifestUri","shaka.Player.prototype.isLive","shaka.Player.prototype.isInProgress","isAudioOnly","shaka.Player.prototype.isAudioOnly","videoTracks","videoHeight","seekRange","shaka.Player.prototype.seekRange","seekable","shaka.Player.prototype.keySystem","shaka.Player.prototype.drmInfo","getExpiration","shaka.Player.prototype.getExpiration","shaka.Player.prototype.isBuffering","getPlaybackRate","shaka.Player.prototype.getPlaybackRate","trickPlay","shaka.Player.prototype.trickPlay","setTrickPlay","cancelTrickPlay","shaka.Player.prototype.cancelTrickPlay","getVariantTracks","shaka.Player.prototype.getVariantTracks","currentVariant","getPresentationVariant_","shaka.Player.prototype.getSelectableVariants_","getSelectableVariants_","shaka.util.StreamUtils.html5TrackToGenericShakaTrack_","getTextTracks","shaka.Player.prototype.getTextTracks","currentText","shaka.Player.prototype.getPresentationText_","getPresentationText_","shaka.Player.prototype.getSelectableText_","getSelectableText_","selectTextTrack","shaka.Player.prototype.selectTextTrack","textTrack","selectEmbeddedTextTrack","shaka.Player.prototype.selectEmbeddedTextTrack","usingEmbeddedTextTrack","shaka.Player.prototype.usingEmbeddedTextTrack","activeTrack","selectVariantTrack","shaka.Player.prototype.selectVariantTrack","audioTrack","getAudioLanguagesAndRoles","shaka.Player.prototype.getAudioLanguagesAndRoles","getTextLanguagesAndRoles","shaka.Player.prototype.getTextLanguagesAndRoles","getAudioLanguages","shaka.Player.prototype.getAudioLanguages","getTextLanguages","shaka.Player.prototype.getTextLanguages","selectAudioLanguage","shaka.Player.prototype.selectAudioLanguage","selectTextLanguage","shaka.Player.prototype.selectTextLanguage","isTextTrackVisible","shaka.Player.prototype.isTextTrackVisible","expected","setTextTrackVisibility","shaka.Player.prototype.setTextTrackVisibility","isVisible","newVisibility","oldVisibilty","onTextTrackVisibility_","getPlayheadTimeAsDate","shaka.Player.prototype.getPlayheadTimeAsDate","getStartDate","startDate","getPresentationStartTimeAsDate","shaka.Player.prototype.getPresentationStartTimeAsDate","getBufferedInfo","shaka.Player.prototype.getBufferedInfo","total","getStats","shaka.Player.prototype.getStats","streamBandwidth","decodedFrames","droppedFrames","estimatedBandwidth","loadLatency","playTime","pauseTime","bufferingTime","switchHistory","stateHistory","totalDroppedFrames_","dropped","totalDecodedFrames_","decoded","variantBandwidth_","bandwidthEstimate_","width_","height_","getCopy","addTextTrack","shaka.Player.prototype.addTextTrack","mime","nextPeriodIndex","nextPeriodStart","segmentReference","activeText","shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_TEXT_TO_LIVE_STREAM","shaka.Player.prototype.setMaxHardwareResolution","retryStreaming","shaka.Player.prototype.retryStreaming","getManifest","shaka.Player.prototype.getManifest","getManifestParserFactory","shaka.Player.prototype.getManifestParserFactory","shaka.Player.prototype","shaka.Player.prototype.filterNewPeriod_","hasPlayableVariant","curDrmInfo","shaka.Player.prototype.onChooseStreams_","chooseStreams_","chosenAudio","startingUp","preferredTextLocale","audioLocale","textLocale","shaka.util.LanguageUtils.areLanguageCompatible","canSwitch_","shaka.Player.prototype.canSwitch_","onManifestUpdate_","shaka.Player.prototype.onManifestUpdate_","onSegmentAppended_","shaka.Player.prototype.onSegmentAppended_","shaka.Player.prototype.onError_","firstPeriod","firstPeriodDB","content","shaka.offline.StoredContentUtils.getTracks_","getTracks_","shaka.util.StreamUtils.getPlayableVariants","getEstimate_","bitRate","waitOnDestroy_","onDestroy_","filterByCommonCodecs","common","shaka.util.ManifestFilter.VariantCodecSummarySet","shaka.util.ManifestFilter.VariantCodecSummarySet.fromVariants","onlyKeep","summary","shaka.util.ManifestFilter.VariantCodecSummary","audioMime_","audioCodec_","videoMime_","videoCodec_","all_","fromVariants","shaka.offline.Storage","shaka.util.Error.Code.LOCAL_PLAYER_INSTANCE_REQUIRED","storeInProgress_","segmentsFromStore_","openOperations_","destroyNetworkingEngine","destroyer_","shaka.util.Destroyer","instance","shaka.offline.Storage.getCapabilities_","manifestDb","isVideo","shaka.offline.Storage.prototype.removeFromDRM_","net","drmConfig","sessionIdCell","deletedSessionIds","shaka.util.Error.Code.STORAGE_NOT_SUPPORTED","shaka.offline.Storage.deleteLicenseFor_","shaka.offline.Storage.prototype.removeFromStorage_","storage","removed","pendingContent","toRemove","segmentIds","shaka.offline.Storage.getAllSegmentIds_","shaka.offline.StoredContentUtils.fromManifestDB","shaka.offline.Storage.prototype.createStream_","downloader","estimator","streamDb","downloadGroup","shaka.offline.Storage.forEachSegment_","getSegmentEstimate","shaka.offline.Storage.prototype.checkDestroyed_","shaka.offline.Storage.prototype.requireSupport_","shaka.offline.Storage.support","shaka.offline.Storage.prototype.startOperation_","shaka.offline.Storage.getStreamSet_","shaka.offline.Storage.validatePeriod_","texts","shaka.Player.LoadMode","Storage","shaka.offline.Storage.prototype.destroy","shaka.offline.Storage.prototype.configure","usedLegacyConfig","shaka.offline.Storage.prototype.getConfiguration","shaka.offline.Storage.prototype.getNetworkingEngine","shaka.offline.Storage.prototype.store","shaka.offline.Storage.prototype.store_","getParser","activeHandle","drmError","requireSupport_","shaka.util.Error.Code.STORE_ALREADY_IN_PROGRESS","shaka.offline.Storage.prototype.parseManifest","checkDestroyed_","parseManifest","shaka.util.Error.Code.CANNOT_STORE_LIVE_OFFLINE","shaka.offline.Storage.prototype.createDrmEngine","shaka.media.DrmEngine.prototype.initForStorage","usePersistentLicenses","initForStorage","createDrmEngine","shaka.offline.Storage.prototype.filterManifest_","filterByRestrictions","maxHwResolution","shaka.util.ManifestFilter.filterByRestrictions","filterByMediaSourceSupport","supported","filterByDrmSupport","rollingFilter","previous","allTracks","chosenTracks","textIds","shaka.offline.Storage.validateManifest_","filterManifest_","getActive","handle","shaka.offline.Storage.prototype.downloadManifest_","fromManifest","shaka.offline.StoredContentUtils.fromManifest","progress","shaka.offline.Storage.prototype.createOfflineManifest_","shaka.offline.StreamBandwidthEstimator","shaka.offline.Storage.prototype.createPeriod_","audioBitRate","shaka.offline.StreamBandwidthEstimator.DEFAULT_AUDIO_BITRATE_","videoBitRate","estimateByStreamId_","shaka.offline.StreamBandwidthEstimator.DEFAULT_TEXT_BITRATE_","streamDBs","createStream_","getSessionIds","shaka.util.Error.Code.NO_INIT_DATA_FOR_OFFLINE","createOfflineManifest_","waitToFinish","downloadManifest_","getStoreInProgress","shaka.offline.Storage.prototype.getStoreInProgress","shaka.offline.Storage.prototype.remove","contentUri","shaka.offline.Storage.prototype.remove_","nullableUri","removeFromDRM_","removeFromStorage_","removeEmeSessions","shaka.offline.Storage.prototype.removeEmeSessions","shaka.offline.Storage.prototype.removeEmeSessions_","removeEmeSessions_","hasRemaining","cells","forEachEmeSessionCell","shaka.offline.Storage.prototype.list","forEachCell","shaka.offline.Storage.prototype.list_","shaka.offline.Storage.deleteAll","installAll","shaka.polyfill.installAll","shaka.polyfill.polyfills_.length","shaka.polyfill.polyfills_","polyfill","shaka.polyfill.polyfills_.splice","shaka.polyfill.polyfills_.push","shaka.polyfill.Fullscreen.proxyEvent_","eventType","newEvent","Event","shaka.polyfill.InputEvent.addEventListener_","HTMLInputElement","shaka.polyfill.MediaSource.stubAbort_","MediaSource.prototype.addSourceBuffer","sourceBuffer.abort","shaka.polyfill.MediaSource.ignoreUpdateEnd_","eventSuppressed_","ignoreUpdateEnd_","shaka.polyfill.MediaSource.cleanUpListeners_","shaka.polyfill.PatchedMediaKeysApple.requestMediaKeySystemAccess","supportedConfigurations","shaka.polyfill.PatchedMediaKeysApple.MediaKeySystemAccess","cfg","newCfg","ranAnyTests","success","cap","isTypeSupported","checkConfig_","WebKitMediaKeys","unsupportedKeySystemError","DOMException","oldMediaKeys","setMedia","shaka.polyfill.PatchedMediaKeysApple.MediaKeys","certificate","shaka.polyfill.PatchedMediaKeysApple.MediaKeys.prototype.setMedia","shaka.polyfill.PatchedMediaKeysApple.onWebkitNeedKey_","shaka.polyfill.PatchedMediaKeysApple.MediaKeySession","nativeMediaKeys","nativeMediaKeySession_","nativeMediaKeys_","updatePromise_","closed","shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap","event2","appendWithLength","rebuiltInitData","initDataArray","dataview","contentIdArray","shaka.polyfill.PatchedMediaKeysApple.rebuildInitData_","shaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype.updateKeyStatus_","status_","shaka.util.Pssh","psshBox","cencKeyIds","dataBoundaries","shaka.polyfill.PatchedMediaKeysMs.requestMediaKeySystemAccess","shaka.polyfill.PatchedMediaKeysMs.MediaKeySystemAccess","MSMediaKeys","shaka.polyfill.PatchedMediaKeysMs.MediaKeys","shaka.polyfill.PatchedMediaKeysMs.MediaKeys.prototype.setMedia","shaka.polyfill.PatchedMediaKeysMs.onMsNeedKey_","setMediaKeysDeferred","shaka.polyfill.PatchedMediaKeysMs.MediaKeySession","shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap","initCustomEvent","shaka.polyfill.PatchedMediaKeysMs.normaliseInitData_","unfilteredInitDatas","currPssh","dedupedInitDatas","targetLength","normalisedInitData","shaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.updateKeyStatus_","shaka.polyfill.PatchedMediaKeysNop.requestMediaKeySystemAccess","shaka.polyfill.PatchedMediaKeysNop.setMediaKeys","shaka.polyfill.PatchedMediaKeysNop.MediaKeys","TypeError","register","shaka.polyfill.register","shaka.polyfill.Fullscreen.install","proto","Element","requestFullscreen","Document","mozFullScreenElement","mozFullScreenEnabled","shaka.polyfill.IndexedDB.install","shaka.polyfill.InputEvent.install","shaka.polyfill.Languages.install","shaka.polyfill.MathRound.install","shaka.polyfill.MediaSource.install","shaka.polyfill.MediaSource.patchCastIsTypeSupported_","originalIsTypeSupported","dolbyVisionRegex","MediaSource.isTypeSupported","pieces","basicMimeType","kv","isHDR","isDolbyVision","codecList","shaka.polyfill.MediaSource.rejectTsContent_","shaka.polyfill.MediaSource.patchEndOfStreamEvents_","MediaSource.prototype.endOfStream","newDuration","cleanUpHandlerInstalled","shaka.polyfill.MediaSource.patchRemovalRange_","originalRemove","SourceBuffer","SourceBuffer.prototype.remove","shaka.polyfill.MediaSource.rejectCodec_","createMediaKeys","shaka.polyfill.PatchedMediaKeysApple.MediaKeySystemAccess.prototype.createMediaKeys","shaka.polyfill.PatchedMediaKeysApple.MediaKeySystemAccess.prototype.getConfiguration","configuration_","shaka.polyfill.PatchedMediaKeysApple.MediaKeys.prototype.createSession","sessionType","shaka.polyfill.PatchedMediaKeysApple.MediaKeys.prototype.setServerCertificate","shaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype","shaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype.generateRequest","updateKeyStatus_","generateRequestPromise_","shaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype.load","shaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype.update","shaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype.close","shaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype.remove","shaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype.onWebkitKeyMessage_","messageType","shaka_polyfill_PatchedMediaKeysApple_MediaKeySession_prototype$onWebkitKeyAdded_","shaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype.onWebkitKeyAdded_","shaka_polyfill_PatchedMediaKeysApple_MediaKeySession_prototype$onWebkitKeyError_","shaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype.onWebkitKeyError_","errorCode","WebKitMediaKeyError","shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.prototype","shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.prototype.forEach","fn","shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.KEY_ID_","shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.prototype.get","shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.prototype.has","fakeKeyId","entries","shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.prototype.entries","shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.prototype.keys","shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.prototype.values","shaka.polyfill.PatchedMediaKeysApple.install","shaka.polyfill.PatchedMediaKeysApple.setMediaKeys","parseBox_","shaka.util.Pssh.prototype.parseBox_","systemId","numKeyIds","dataSize","systemIds","shaka.polyfill.PatchedMediaKeysMs.MediaKeySystemAccess.prototype.createMediaKeys","shaka.polyfill.PatchedMediaKeysMs.MediaKeySystemAccess.prototype.getConfiguration","shaka.polyfill.PatchedMediaKeysMs.MediaKeys.prototype.createSession","shaka.polyfill.PatchedMediaKeysMs.MediaKeys.prototype.setServerCertificate","shaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype","shaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.generateRequest","shaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.load","shaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.update","shaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.close","shaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.remove","shaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.onMsKeyMessage_","onMsKeyAdded_","shaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.onMsKeyAdded_","onMsKeyError_","shaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.onMsKeyError_","MSMediaKeyError","shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype","shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.forEach","shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.KEY_ID_","shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.get","shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.has","shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.entries","shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.keys","shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.values","shaka.polyfill.PatchedMediaKeysMs.install","MediaKeySystemAccess","shaka.polyfill.PatchedMediaKeysMs.setMediaKeys","shaka.polyfill.PatchedMediaKeysNop.MediaKeys.prototype.createSession","shaka.polyfill.PatchedMediaKeysNop.MediaKeys.prototype.setServerCertificate","shaka.polyfill.PatchedMediaKeysNop.MediaKeySystemAccess","shaka.polyfill.PatchedMediaKeysNop.MediaKeySystemAccess.prototype.getConfiguration","shaka.polyfill.PatchedMediaKeysNop.MediaKeySystemAccess.prototype.createMediaKeys","shaka.polyfill.PatchedMediaKeysNop.install","shaka.polyfill.PatchedMediaKeysWebkit.prefix_","api","prefix","shaka.polyfill.PatchedMediaKeysWebkit.requestMediaKeySystemAccess","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySystemAccess","shaka.polyfill.PatchedMediaKeysWebkit.setMediaKeys","allowPersistentState","tmpVideo","canPlayType","unsupportedError","media_","newSessions_","sessionMap_","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.setMedia","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.findSession_","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession","keySystem_","type_","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.generate_","offlineSessionId","mangledInitData","generateKeyRequestName","shaka.polyfill.PatchedMediaKeysWebkit.prefixApi_","generatePromise_","exception2","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.updateKeyStatus_","shaka.polyfill.PiPWebkit.proxyEvent_","shaka.polyfill.PiPWebkit.PIP_MODE_","pictureInPictureElement","shaka.polyfill.PiPWebkit.requestPictureInPicture_","webkitSupportsPresentationMode","shaka.polyfill.PiPWebkit.exitPictureInPicture_","pipElement","shaka.polyfill.PiPWebkit.INLINE_MODE_","shaka.polyfill.VideoPlaybackQuality.webkit_","shaka.polyfill.VTTCue.from3ArgsTextTrackCue_","shaka.polyfill.VTTCue.from6ArgsTextTrackCue_","shaka.text.TtmlTextParser","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySystemAccess.prototype.createMediaKeys","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySystemAccess.prototype.getConfiguration","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.createSession","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.setServerCertificate","onWebkitNeedKey_","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.onWebkitNeedKey_","shaka_polyfill_PatchedMediaKeysWebkit_MediaKeys_prototype$onWebkitKeyMessage_","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.onWebkitKeyMessage_","findSession_","shaka_polyfill_PatchedMediaKeysWebkit_MediaKeys_prototype$onWebkitKeyAdded_","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.onWebkitKeyAdded_","shaka_polyfill_PatchedMediaKeysWebkit_MediaKeys_prototype$onWebkitKeyError_","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.onWebkitKeyError_","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.handleError","MediaKeyError","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.update_","licenseString","addKeyName","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.generateRequest","generate_","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.load","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.update","nextUpdatePromise","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.close","cancelKeyRequestName","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.remove","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.forEach","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.KEY_ID_","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.get","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.has","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.entries","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.keys","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.values","shaka.polyfill.PatchedMediaKeysWebkit.install","webkitGenerateKeyRequest","generateKeyRequest","MediaKeys","shaka.polyfill.PiPWebkit.install","HTMLVideoElement","requestPictureInPicture","shaka.polyfill.VideoPlayPromise.install","originalPlay","HTMLMediaElement.prototype.play","shaka.polyfill.VideoPlaybackQuality.install","getVideoPlaybackQuality","shaka.polyfill.VTTCue.install","constructorLength","TextTrackCue","shaka.text.TtmlTextParser.prototype.parseInit","shaka.text.TtmlTextParser.prototype.parseMedia","shaka.util.Error.Code.INVALID_XML","tt","tts","shaka.text.TtmlTextParser.parameterNs_","subFrameRate","frameRateMultiplier","tickRate","spaceStyle","whitespaceTrim","rateInfo","shaka.text.TtmlTextParser.RateInfo_","metadataElements","shaka.text.TtmlTextParser.getLeafNodes_","styles","regionElements","cueRegions","percentage","extent","regionElement","globalResults","shaka.text.TtmlTextParser.percentValues_.exec","globalExtent","shaka.text.TtmlTextParser.pixelValues_.exec","globalWidth","globalHeight","shaka.text.TtmlTextParser.getStyleAttributeFromRegion_","shaka.text.CueRegion.units.PX","origin","cueRegion","textNodes","shaka.text.TtmlTextParser.parseCue_","shaka.text.TtmlTextParser.percentValues_","shaka.text.TtmlTextParser.unitValues_","shaka.text.TtmlTextParser.pixelValues_","shaka.text.TtmlTextParser.timeColonFormatFrames_","shaka.text.TtmlTextParser.timeColonFormat_","shaka.text.TtmlTextParser.timeColonFormatMilliseconds_","shaka.text.TtmlTextParser.timeFramesFormat_","shaka.text.TtmlTextParser.timeTickFormat_","shaka.text.TtmlTextParser.timeHMSFormat_","shaka.text.TtmlTextParser.textAlignToLineAlign_","shaka.text.Cue.lineAlign.CENTER","shaka.text.Cue.lineAlign.END","shaka.text.TtmlTextParser.textAlignToPositionAlign_","shaka.text.Cue.positionAlign.LEFT","shaka.text.Cue.positionAlign.CENTER","shaka.text.Cue.positionAlign.RIGHT","childNodes","isSpanChildOfP","leafChildren","cueElement","shaka.text.TtmlTextParser.addNewLines_","trimmed","shaka.text.TtmlTextParser.parseTime_","shaka.util.Error.Code.INVALID_TEXT_CUE","shaka.text.TtmlTextParser.getElementFromCollection_","regionId","regionsWithId","shaka.text.TtmlTextParser.addStyle_","imageElement","shaka.text.TtmlTextParser.getStyleAttribute_","shaka.text.Cue.direction.HORIZONTAL_RIGHT_TO_LEFT","shaka.text.Cue.writingMode.VERTICAL_LEFT_TO_RIGHT","align","color","backgroundColor","shaka.text.Cue.fontWeight.BOLD","wrapOption","backgroundImageType","backgroundImageEncoding","backgroundImageData","textDecorationRegion","shaka.text.TtmlTextParser.addTextDecoration_","textDecorationElement","shaka.text.TtmlTextParser.getStyleAttributeFromElement_","decoration","shaka.text.Cue.textDecoration.UNDERLINE","shaka.text.Cue.textDecoration.LINE_THROUGH","shaka.text.Cue.textDecoration.OVERLINE","regionChildren","shaka.text.TtmlTextParser.styleNs_","style","collection","prefixName","parentNode","itemName","shaka.text.TtmlTextParser.timeColonFormatFrames_.test","shaka.text.TtmlTextParser.timeColonFormatFrames_.exec","hours","minutes","frames","shaka.text.TtmlTextParser.parseTimeFromRegex_","shaka.text.TtmlTextParser.timeColonFormatMilliseconds_.test","shaka.text.TtmlTextParser.timeFramesFormat_.test","shaka.text.TtmlTextParser.timeFramesFormat_.exec","shaka.text.TtmlTextParser.timeTickFormat_.test","shaka.text.TtmlTextParser.timeTickFormat_.exec","shaka.text.TtmlTextParser.timeHMSFormat_.test","multiplierResults","shaka.text.Mp4TtmlParser","shaka.text.VttTextParser","regions","shaka.text.VttTextParser.getRegionById_","shaka.text.Cue.lineInterpretation.PERCENTAGE","shaka.text.VttTextParser.parseTime_","shaka.text.Mp4VttParser","settings","shaka.text.Mp4VttParser.assembleCue_","readRegexReturnCapture_","shaka.text.VttTextParser.parseCueSetting","skipWhitespace","shaka.text.Mp4TtmlParser.prototype.parseInit","sawSTPP","shaka.util.Error.Code.INVALID_MP4_TTML","shaka.text.Mp4TtmlParser.prototype.parseMedia","sawMDAT","shaka.text.VttTextParser.prototype.parseInit","shaka.text.VttTextParser.prototype.parseMedia","shaka.util.Error.Code.INVALID_TEXT_HEADER","cueTimeMatch","mpegTimeMatch","cueTime","shaka.text.VttTextParser.MPEG_TIMESCALE_","shaka.text.CueRegion.units.LINES","shaka.text.CueRegion.scrollMode.UP","expect","timeOffset","shaka.text.Mp4VttParser.prototype.parseInit","sawWVTT","shaka.util.Error.Code.INVALID_MP4_VTT","shaka.text.Mp4VttParser.prototype.parseMedia","rawPayload","presentations","sawTFDT","sawTRUN","defaultDuration","sampleCount","samples","sampleIndex","sample","sampleSize","presentation","totalSize","payloadType","shaka.text.Mp4VttParser.parseVTTC_","createHTMLElement","createElement","createVideoElement","asHTMLElement","original","asHTMLMediaElement","removeAllChildren","playerElement","getElementById","errorElement","playerElement2","errorElement2","ShakaPlayer","shakaPlayer","hlsManifestUrl","dataset","shaka","isBrowserSupported","appendErrors","screen","errors","innerHTML"],"mappings":"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CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO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","file":"scripts.88c5504e.js","sourceRoot":"..","sourcesContent":["/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * A lightweight readable stream implemention that handles event dispatching.\n * Objects that inherit from streams should call init in their constructors.\n */\n'use strict';\n\nvar Stream = function() {\n  this.init = function() {\n    var listeners = {};\n    /**\n     * Add a listener for a specified event type.\n     * @param type {string} the event name\n     * @param listener {function} the callback to be invoked when an event of\n     * the specified type occurs\n     */\n    this.on = function(type, listener) {\n      if (!listeners[type]) {\n        listeners[type] = [];\n      }\n      listeners[type] = listeners[type].concat(listener);\n    };\n    /**\n     * Remove a listener for a specified event type.\n     * @param type {string} the event name\n     * @param listener {function} a function previously registered for this\n     * type of event through `on`\n     */\n    this.off = function(type, listener) {\n      var index;\n      if (!listeners[type]) {\n        return false;\n      }\n      index = listeners[type].indexOf(listener);\n      listeners[type] = listeners[type].slice();\n      listeners[type].splice(index, 1);\n      return index > -1;\n    };\n    /**\n     * Trigger an event of the specified type on this stream. Any additional\n     * arguments to this function are passed as parameters to event listeners.\n     * @param type {string} the event name\n     */\n    this.trigger = function(type) {\n      var callbacks, i, length, args;\n      callbacks = listeners[type];\n      if (!callbacks) {\n        return;\n      }\n      // Slicing the arguments on every invocation of this method\n      // can add a significant amount of overhead. Avoid the\n      // intermediate object creation for the common case of a\n      // single callback argument\n      if (arguments.length === 2) {\n        length = callbacks.length;\n        for (i = 0; i < length; ++i) {\n          callbacks[i].call(this, arguments[1]);\n        }\n      } else {\n        args = [];\n        i = arguments.length;\n        for (i = 1; i < arguments.length; ++i) {\n          args.push(arguments[i]);\n        }\n        length = callbacks.length;\n        for (i = 0; i < length; ++i) {\n          callbacks[i].apply(this, args);\n        }\n      }\n    };\n    /**\n     * Destroys the stream and cleans up.\n     */\n    this.dispose = function() {\n      listeners = {};\n    };\n  };\n};\n\n/**\n * Forwards all `data` events on this stream to the destination stream. The\n * destination stream should provide a method `push` to receive the data\n * events as they arrive.\n * @param destination {stream} the stream that will receive all `data` events\n * @param autoFlush {boolean} if false, we will not call `flush` on the destination\n *                            when the current stream emits a 'done' event\n * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n */\nStream.prototype.pipe = function(destination) {\n  this.on('data', function(data) {\n    destination.push(data);\n  });\n\n  this.on('done', function(flushSource) {\n    destination.flush(flushSource);\n  });\n\n  return destination;\n};\n\n// Default stream functions that are expected to be overridden to perform\n// actual work. These are provided by the prototype as a sort of no-op\n// implementation so that we don't have to check for their existence in the\n// `pipe` function above.\nStream.prototype.push = function(data) {\n  this.trigger('data', data);\n};\n\nStream.prototype.flush = function(flushSource) {\n  this.trigger('done', flushSource);\n};\n\nmodule.exports = Stream;\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js');\n\nvar AdtsStream;\n\nvar\n  ADTS_SAMPLING_FREQUENCIES = [\n    96000,\n    88200,\n    64000,\n    48000,\n    44100,\n    32000,\n    24000,\n    22050,\n    16000,\n    12000,\n    11025,\n    8000,\n    7350\n  ];\n\n/*\n * Accepts a ElementaryStream and emits data events with parsed\n * AAC Audio Frames of the individual packets. Input audio in ADTS\n * format is unpacked and re-emitted as AAC frames.\n *\n * @see http://wiki.multimedia.cx/index.php?title=ADTS\n * @see http://wiki.multimedia.cx/?title=Understanding_AAC\n */\nAdtsStream = function() {\n  var buffer;\n\n  AdtsStream.prototype.init.call(this);\n\n  this.push = function(packet) {\n    var\n      i = 0,\n      frameNum = 0,\n      frameLength,\n      protectionSkipBytes,\n      frameEnd,\n      oldBuffer,\n      sampleCount,\n      adtsFrameDuration;\n\n    if (packet.type !== 'audio') {\n      // ignore non-audio data\n      return;\n    }\n\n    // Prepend any data in the buffer to the input data so that we can parse\n    // aac frames the cross a PES packet boundary\n    if (buffer) {\n      oldBuffer = buffer;\n      buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);\n      buffer.set(oldBuffer);\n      buffer.set(packet.data, oldBuffer.byteLength);\n    } else {\n      buffer = packet.data;\n    }\n\n    // unpack any ADTS frames which have been fully received\n    // for details on the ADTS header, see http://wiki.multimedia.cx/index.php?title=ADTS\n    while (i + 5 < buffer.length) {\n\n      // Loook for the start of an ADTS header..\n      if (buffer[i] !== 0xFF || (buffer[i + 1] & 0xF6) !== 0xF0) {\n        // If a valid header was not found,  jump one forward and attempt to\n        // find a valid ADTS header starting at the next byte\n        i++;\n        continue;\n      }\n\n      // The protection skip bit tells us if we have 2 bytes of CRC data at the\n      // end of the ADTS header\n      protectionSkipBytes = (~buffer[i + 1] & 0x01) * 2;\n\n      // Frame length is a 13 bit integer starting 16 bits from the\n      // end of the sync sequence\n      frameLength = ((buffer[i + 3] & 0x03) << 11) |\n        (buffer[i + 4] << 3) |\n        ((buffer[i + 5] & 0xe0) >> 5);\n\n      sampleCount = ((buffer[i + 6] & 0x03) + 1) * 1024;\n      adtsFrameDuration = (sampleCount * 90000) /\n        ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2];\n\n      frameEnd = i + frameLength;\n\n      // If we don't have enough data to actually finish this ADTS frame, return\n      // and wait for more data\n      if (buffer.byteLength < frameEnd) {\n        return;\n      }\n\n      // Otherwise, deliver the complete AAC frame\n      this.trigger('data', {\n        pts: packet.pts + (frameNum * adtsFrameDuration),\n        dts: packet.dts + (frameNum * adtsFrameDuration),\n        sampleCount: sampleCount,\n        audioobjecttype: ((buffer[i + 2] >>> 6) & 0x03) + 1,\n        channelcount: ((buffer[i + 2] & 1) << 2) |\n          ((buffer[i + 3] & 0xc0) >>> 6),\n        samplerate: ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2],\n        samplingfrequencyindex: (buffer[i + 2] & 0x3c) >>> 2,\n        // assume ISO/IEC 14496-12 AudioSampleEntry default of 16\n        samplesize: 16,\n        data: buffer.subarray(i + 7 + protectionSkipBytes, frameEnd)\n      });\n\n      // If the buffer is empty, clear it and return\n      if (buffer.byteLength === frameEnd) {\n        buffer = undefined;\n        return;\n      }\n\n      frameNum++;\n\n      // Remove the finished frame from the buffer and start the process again\n      buffer = buffer.subarray(frameEnd);\n    }\n  };\n  this.flush = function() {\n    this.trigger('done');\n  };\n};\n\nAdtsStream.prototype = new Stream();\n\nmodule.exports = AdtsStream;\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nvar ExpGolomb;\n\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding\n * scheme used by h264.\n */\nExpGolomb = function(workingData) {\n  var\n    // the number of bytes left to examine in workingData\n    workingBytesAvailable = workingData.byteLength,\n\n    // the current word being examined\n    workingWord = 0, // :uint\n\n    // the number of bits left to examine in the current word\n    workingBitsAvailable = 0; // :uint;\n\n  // ():uint\n  this.length = function() {\n    return (8 * workingBytesAvailable);\n  };\n\n  // ():uint\n  this.bitsAvailable = function() {\n    return (8 * workingBytesAvailable) + workingBitsAvailable;\n  };\n\n  // ():void\n  this.loadWord = function() {\n    var\n      position = workingData.byteLength - workingBytesAvailable,\n      workingBytes = new Uint8Array(4),\n      availableBytes = Math.min(4, workingBytesAvailable);\n\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n\n    workingBytes.set(workingData.subarray(position,\n                                          position + availableBytes));\n    workingWord = new DataView(workingBytes.buffer).getUint32(0);\n\n    // track the amount of workingData that has been processed\n    workingBitsAvailable = availableBytes * 8;\n    workingBytesAvailable -= availableBytes;\n  };\n\n  // (count:int):void\n  this.skipBits = function(count) {\n    var skipBytes; // :int\n    if (workingBitsAvailable > count) {\n      workingWord          <<= count;\n      workingBitsAvailable -= count;\n    } else {\n      count -= workingBitsAvailable;\n      skipBytes = Math.floor(count / 8);\n\n      count -= (skipBytes * 8);\n      workingBytesAvailable -= skipBytes;\n\n      this.loadWord();\n\n      workingWord <<= count;\n      workingBitsAvailable -= count;\n    }\n  };\n\n  // (size:int):uint\n  this.readBits = function(size) {\n    var\n      bits = Math.min(workingBitsAvailable, size), // :uint\n      valu = workingWord >>> (32 - bits); // :uint\n    // if size > 31, handle error\n    workingBitsAvailable -= bits;\n    if (workingBitsAvailable > 0) {\n      workingWord <<= bits;\n    } else if (workingBytesAvailable > 0) {\n      this.loadWord();\n    }\n\n    bits = size - bits;\n    if (bits > 0) {\n      return valu << bits | this.readBits(bits);\n    }\n    return valu;\n  };\n\n  // ():uint\n  this.skipLeadingZeros = function() {\n    var leadingZeroCount; // :uint\n    for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\n      if ((workingWord & (0x80000000 >>> leadingZeroCount)) !== 0) {\n        // the first bit of working word is 1\n        workingWord <<= leadingZeroCount;\n        workingBitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    }\n\n    // we exhausted workingWord and still have not found a 1\n    this.loadWord();\n    return leadingZeroCount + this.skipLeadingZeros();\n  };\n\n  // ():void\n  this.skipUnsignedExpGolomb = function() {\n    this.skipBits(1 + this.skipLeadingZeros());\n  };\n\n  // ():void\n  this.skipExpGolomb = function() {\n    this.skipBits(1 + this.skipLeadingZeros());\n  };\n\n  // ():uint\n  this.readUnsignedExpGolomb = function() {\n    var clz = this.skipLeadingZeros(); // :uint\n    return this.readBits(clz + 1) - 1;\n  };\n\n  // ():int\n  this.readExpGolomb = function() {\n    var valu = this.readUnsignedExpGolomb(); // :int\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return (1 + valu) >>> 1; // add 1 to make it even, and divide by 2\n    }\n    return -1 * (valu >>> 1); // divide by two then make it negative\n  };\n\n  // Some convenience functions\n  // :Boolean\n  this.readBoolean = function() {\n    return this.readBits(1) === 1;\n  };\n\n  // ():int\n  this.readUnsignedByte = function() {\n    return this.readBits(8);\n  };\n\n  this.loadWord();\n};\n\nmodule.exports = ExpGolomb;\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js');\nvar ExpGolomb = require('../utils/exp-golomb.js');\n\nvar H264Stream, NalByteStream;\nvar PROFILES_WITH_OPTIONAL_SPS_DATA;\n\n/**\n * Accepts a NAL unit byte stream and unpacks the embedded NAL units.\n */\nNalByteStream = function() {\n  var\n    syncPoint = 0,\n    i,\n    buffer;\n  NalByteStream.prototype.init.call(this);\n\n  /*\n   * Scans a byte stream and triggers a data event with the NAL units found.\n   * @param {Object} data Event received from H264Stream\n   * @param {Uint8Array} data.data The h264 byte stream to be scanned\n   *\n   * @see H264Stream.push\n   */\n  this.push = function(data) {\n    var swapBuffer;\n\n    if (!buffer) {\n      buffer = data.data;\n    } else {\n      swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);\n      swapBuffer.set(buffer);\n      swapBuffer.set(data.data, buffer.byteLength);\n      buffer = swapBuffer;\n    }\n\n    // Rec. ITU-T H.264, Annex B\n    // scan for NAL unit boundaries\n\n    // a match looks like this:\n    // 0 0 1 .. NAL .. 0 0 1\n    // ^ sync point        ^ i\n    // or this:\n    // 0 0 1 .. NAL .. 0 0 0\n    // ^ sync point        ^ i\n\n    // advance the sync point to a NAL start, if necessary\n    for (; syncPoint < buffer.byteLength - 3; syncPoint++) {\n      if (buffer[syncPoint + 2] === 1) {\n        // the sync point is properly aligned\n        i = syncPoint + 5;\n        break;\n      }\n    }\n\n    while (i < buffer.byteLength) {\n      // look at the current byte to determine if we've hit the end of\n      // a NAL unit boundary\n      switch (buffer[i]) {\n      case 0:\n        // skip past non-sync sequences\n        if (buffer[i - 1] !== 0) {\n          i += 2;\n          break;\n        } else if (buffer[i - 2] !== 0) {\n          i++;\n          break;\n        }\n\n        // deliver the NAL unit if it isn't empty\n        if (syncPoint + 3 !== i - 2) {\n          this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n        }\n\n        // drop trailing zeroes\n        do {\n          i++;\n        } while (buffer[i] !== 1 && i < buffer.length);\n        syncPoint = i - 2;\n        i += 3;\n        break;\n      case 1:\n        // skip past non-sync sequences\n        if (buffer[i - 1] !== 0 ||\n            buffer[i - 2] !== 0) {\n          i += 3;\n          break;\n        }\n\n        // deliver the NAL unit\n        this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n        syncPoint = i - 2;\n        i += 3;\n        break;\n      default:\n        // the current byte isn't a one or zero, so it cannot be part\n        // of a sync sequence\n        i += 3;\n        break;\n      }\n    }\n    // filter out the NAL units that were delivered\n    buffer = buffer.subarray(syncPoint);\n    i -= syncPoint;\n    syncPoint = 0;\n  };\n\n  this.flush = function() {\n    // deliver the last buffered NAL unit\n    if (buffer && buffer.byteLength > 3) {\n      this.trigger('data', buffer.subarray(syncPoint + 3));\n    }\n    // reset the stream state\n    buffer = null;\n    syncPoint = 0;\n    this.trigger('done');\n  };\n};\nNalByteStream.prototype = new Stream();\n\n// values of profile_idc that indicate additional fields are included in the SPS\n// see Recommendation ITU-T H.264 (4/2013),\n// 7.3.2.1.1 Sequence parameter set data syntax\nPROFILES_WITH_OPTIONAL_SPS_DATA = {\n  100: true,\n  110: true,\n  122: true,\n  244: true,\n  44: true,\n  83: true,\n  86: true,\n  118: true,\n  128: true,\n  138: true,\n  139: true,\n  134: true\n};\n\n/**\n * Accepts input from a ElementaryStream and produces H.264 NAL unit data\n * events.\n */\nH264Stream = function() {\n  var\n    nalByteStream = new NalByteStream(),\n    self,\n    trackId,\n    currentPts,\n    currentDts,\n\n    discardEmulationPreventionBytes,\n    readSequenceParameterSet,\n    skipScalingList;\n\n  H264Stream.prototype.init.call(this);\n  self = this;\n\n  /*\n   * Pushes a packet from a stream onto the NalByteStream\n   *\n   * @param {Object} packet - A packet received from a stream\n   * @param {Uint8Array} packet.data - The raw bytes of the packet\n   * @param {Number} packet.dts - Decode timestamp of the packet\n   * @param {Number} packet.pts - Presentation timestamp of the packet\n   * @param {Number} packet.trackId - The id of the h264 track this packet came from\n   * @param {('video'|'audio')} packet.type - The type of packet\n   *\n   */\n  this.push = function(packet) {\n    if (packet.type !== 'video') {\n      return;\n    }\n    trackId = packet.trackId;\n    currentPts = packet.pts;\n    currentDts = packet.dts;\n\n    nalByteStream.push(packet);\n  };\n\n  /*\n   * Identify NAL unit types and pass on the NALU, trackId, presentation and decode timestamps\n   * for the NALUs to the next stream component.\n   * Also, preprocess caption and sequence parameter NALUs.\n   *\n   * @param {Uint8Array} data - A NAL unit identified by `NalByteStream.push`\n   * @see NalByteStream.push\n   */\n  nalByteStream.on('data', function(data) {\n    var\n      event = {\n        trackId: trackId,\n        pts: currentPts,\n        dts: currentDts,\n        data: data\n      };\n\n    switch (data[0] & 0x1f) {\n    case 0x05:\n      event.nalUnitType = 'slice_layer_without_partitioning_rbsp_idr';\n      break;\n    case 0x06:\n      event.nalUnitType = 'sei_rbsp';\n      event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n      break;\n    case 0x07:\n      event.nalUnitType = 'seq_parameter_set_rbsp';\n      event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n      event.config = readSequenceParameterSet(event.escapedRBSP);\n      break;\n    case 0x08:\n      event.nalUnitType = 'pic_parameter_set_rbsp';\n      break;\n    case 0x09:\n      event.nalUnitType = 'access_unit_delimiter_rbsp';\n      break;\n\n    default:\n      break;\n    }\n    // This triggers data on the H264Stream\n    self.trigger('data', event);\n  });\n  nalByteStream.on('done', function() {\n    self.trigger('done');\n  });\n\n  this.flush = function() {\n    nalByteStream.flush();\n  };\n\n  /**\n   * Advance the ExpGolomb decoder past a scaling list. The scaling\n   * list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count {number} the number of entries in this scaling list\n   * @param expGolombDecoder {object} an ExpGolomb pointed to the\n   * start of a scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */\n  skipScalingList = function(count, expGolombDecoder) {\n    var\n      lastScale = 8,\n      nextScale = 8,\n      j,\n      deltaScale;\n\n    for (j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = expGolombDecoder.readExpGolomb();\n        nextScale = (lastScale + deltaScale + 256) % 256;\n      }\n\n      lastScale = (nextScale === 0) ? lastScale : nextScale;\n    }\n  };\n\n  /**\n   * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n   * Sequence Payload\"\n   * @param data {Uint8Array} the bytes of a RBSP from a NAL\n   * unit\n   * @return {Uint8Array} the RBSP without any Emulation\n   * Prevention Bytes\n   */\n  discardEmulationPreventionBytes = function(data) {\n    var\n      length = data.byteLength,\n      emulationPreventionBytesPositions = [],\n      i = 1,\n      newLength, newData;\n\n    // Find all `Emulation Prevention Bytes`\n    while (i < length - 2) {\n      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n        emulationPreventionBytesPositions.push(i + 2);\n        i += 2;\n      } else {\n        i++;\n      }\n    }\n\n    // If no Emulation Prevention Bytes were found just return the original\n    // array\n    if (emulationPreventionBytesPositions.length === 0) {\n      return data;\n    }\n\n    // Create a new array to hold the NAL unit data\n    newLength = length - emulationPreventionBytesPositions.length;\n    newData = new Uint8Array(newLength);\n    var sourceIndex = 0;\n\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\n        // Skip this byte\n        sourceIndex++;\n        // Remove this position index\n        emulationPreventionBytesPositions.shift();\n      }\n      newData[i] = data[sourceIndex];\n    }\n\n    return newData;\n  };\n\n  /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @param data {Uint8Array} the bytes of a sequence parameter set\n   * @return {object} an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */\n  readSequenceParameterSet = function(data) {\n    var\n      frameCropLeftOffset = 0,\n      frameCropRightOffset = 0,\n      frameCropTopOffset = 0,\n      frameCropBottomOffset = 0,\n      sarScale = 1,\n      expGolombDecoder, profileIdc, levelIdc, profileCompatibility,\n      chromaFormatIdc, picOrderCntType,\n      numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1,\n      picHeightInMapUnitsMinus1,\n      frameMbsOnlyFlag,\n      scalingListCount,\n      sarRatio,\n      aspectRatioIdc,\n      i;\n\n    expGolombDecoder = new ExpGolomb(data);\n    profileIdc = expGolombDecoder.readUnsignedByte(); // profile_idc\n    profileCompatibility = expGolombDecoder.readUnsignedByte(); // constraint_set[0-5]_flag\n    levelIdc = expGolombDecoder.readUnsignedByte(); // level_idc u(8)\n    expGolombDecoder.skipUnsignedExpGolomb(); // seq_parameter_set_id\n\n    // some profiles have more optional data we don't need\n    if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {\n      chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();\n      if (chromaFormatIdc === 3) {\n        expGolombDecoder.skipBits(1); // separate_colour_plane_flag\n      }\n      expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_luma_minus8\n      expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_chroma_minus8\n      expGolombDecoder.skipBits(1); // qpprime_y_zero_transform_bypass_flag\n      if (expGolombDecoder.readBoolean()) { // seq_scaling_matrix_present_flag\n        scalingListCount = (chromaFormatIdc !== 3) ? 8 : 12;\n        for (i = 0; i < scalingListCount; i++) {\n          if (expGolombDecoder.readBoolean()) { // seq_scaling_list_present_flag[ i ]\n            if (i < 6) {\n              skipScalingList(16, expGolombDecoder);\n            } else {\n              skipScalingList(64, expGolombDecoder);\n            }\n          }\n        }\n      }\n    }\n\n    expGolombDecoder.skipUnsignedExpGolomb(); // log2_max_frame_num_minus4\n    picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();\n\n    if (picOrderCntType === 0) {\n      expGolombDecoder.readUnsignedExpGolomb(); // log2_max_pic_order_cnt_lsb_minus4\n    } else if (picOrderCntType === 1) {\n      expGolombDecoder.skipBits(1); // delta_pic_order_always_zero_flag\n      expGolombDecoder.skipExpGolomb(); // offset_for_non_ref_pic\n      expGolombDecoder.skipExpGolomb(); // offset_for_top_to_bottom_field\n      numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        expGolombDecoder.skipExpGolomb(); // offset_for_ref_frame[ i ]\n      }\n    }\n\n    expGolombDecoder.skipUnsignedExpGolomb(); // max_num_ref_frames\n    expGolombDecoder.skipBits(1); // gaps_in_frame_num_value_allowed_flag\n\n    picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n    picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n\n    frameMbsOnlyFlag = expGolombDecoder.readBits(1);\n    if (frameMbsOnlyFlag === 0) {\n      expGolombDecoder.skipBits(1); // mb_adaptive_frame_field_flag\n    }\n\n    expGolombDecoder.skipBits(1); // direct_8x8_inference_flag\n    if (expGolombDecoder.readBoolean()) { // frame_cropping_flag\n      frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();\n      frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();\n      frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();\n      frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();\n    }\n    if (expGolombDecoder.readBoolean()) {\n      // vui_parameters_present_flag\n      if (expGolombDecoder.readBoolean()) {\n        // aspect_ratio_info_present_flag\n        aspectRatioIdc = expGolombDecoder.readUnsignedByte();\n        switch (aspectRatioIdc) {\n          case 1: sarRatio = [1, 1]; break;\n          case 2: sarRatio = [12, 11]; break;\n          case 3: sarRatio = [10, 11]; break;\n          case 4: sarRatio = [16, 11]; break;\n          case 5: sarRatio = [40, 33]; break;\n          case 6: sarRatio = [24, 11]; break;\n          case 7: sarRatio = [20, 11]; break;\n          case 8: sarRatio = [32, 11]; break;\n          case 9: sarRatio = [80, 33]; break;\n          case 10: sarRatio = [18, 11]; break;\n          case 11: sarRatio = [15, 11]; break;\n          case 12: sarRatio = [64, 33]; break;\n          case 13: sarRatio = [160, 99]; break;\n          case 14: sarRatio = [4, 3]; break;\n          case 15: sarRatio = [3, 2]; break;\n          case 16: sarRatio = [2, 1]; break;\n          case 255: {\n            sarRatio = [expGolombDecoder.readUnsignedByte() << 8 |\n                        expGolombDecoder.readUnsignedByte(),\n                        expGolombDecoder.readUnsignedByte() << 8 |\n                        expGolombDecoder.readUnsignedByte() ];\n            break;\n          }\n        }\n        if (sarRatio) {\n          sarScale = sarRatio[0] / sarRatio[1];\n        }\n      }\n    }\n    return {\n      profileIdc: profileIdc,\n      levelIdc: levelIdc,\n      profileCompatibility: profileCompatibility,\n      width: Math.ceil((((picWidthInMbsMinus1 + 1) * 16) - frameCropLeftOffset * 2 - frameCropRightOffset * 2) * sarScale),\n      height: ((2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16) - (frameCropTopOffset * 2) - (frameCropBottomOffset * 2)\n    };\n  };\n\n};\nH264Stream.prototype = new Stream();\n\nmodule.exports = {\n  H264Stream: H264Stream,\n  NalByteStream: NalByteStream\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\nmodule.exports = {\n  adts: require('./adts'),\n  h264: require('./h264')\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Functions that generate fragmented MP4s suitable for use with Media\n * Source Extensions.\n */\n'use strict';\n\nvar UINT32_MAX = Math.pow(2, 32) - 1;\n\nvar box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd,\n    trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex,\n    trun, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR,\n    AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;\n\n// pre-calculate constants\n(function() {\n  var i;\n  types = {\n    avc1: [], // codingname\n    avcC: [],\n    btrt: [],\n    dinf: [],\n    dref: [],\n    esds: [],\n    ftyp: [],\n    hdlr: [],\n    mdat: [],\n    mdhd: [],\n    mdia: [],\n    mfhd: [],\n    minf: [],\n    moof: [],\n    moov: [],\n    mp4a: [], // codingname\n    mvex: [],\n    mvhd: [],\n    sdtp: [],\n    smhd: [],\n    stbl: [],\n    stco: [],\n    stsc: [],\n    stsd: [],\n    stsz: [],\n    stts: [],\n    styp: [],\n    tfdt: [],\n    tfhd: [],\n    traf: [],\n    trak: [],\n    trun: [],\n    trex: [],\n    tkhd: [],\n    vmhd: []\n  };\n\n  // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\n  // don't throw an error\n  if (typeof Uint8Array === 'undefined') {\n    return;\n  }\n\n  for (i in types) {\n    if (types.hasOwnProperty(i)) {\n      types[i] = [\n        i.charCodeAt(0),\n        i.charCodeAt(1),\n        i.charCodeAt(2),\n        i.charCodeAt(3)\n      ];\n    }\n  }\n\n  MAJOR_BRAND = new Uint8Array([\n    'i'.charCodeAt(0),\n    's'.charCodeAt(0),\n    'o'.charCodeAt(0),\n    'm'.charCodeAt(0)\n  ]);\n  AVC1_BRAND = new Uint8Array([\n    'a'.charCodeAt(0),\n    'v'.charCodeAt(0),\n    'c'.charCodeAt(0),\n    '1'.charCodeAt(0)\n  ]);\n  MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\n  VIDEO_HDLR = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x56, 0x69, 0x64, 0x65,\n    0x6f, 0x48, 0x61, 0x6e,\n    0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n  ]);\n  AUDIO_HDLR = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x53, 0x6f, 0x75, 0x6e,\n    0x64, 0x48, 0x61, 0x6e,\n    0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n  ]);\n  HDLR_TYPES = {\n    video: VIDEO_HDLR,\n    audio: AUDIO_HDLR\n  };\n  DREF = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // entry_count\n    0x00, 0x00, 0x00, 0x0c, // entry_size\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\n    0x00, // version 0\n    0x00, 0x00, 0x01 // entry_flags\n  ]);\n  SMHD = new Uint8Array([\n    0x00,             // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00,       // balance, 0 means centered\n    0x00, 0x00        // reserved\n  ]);\n  STCO = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n  ]);\n  STSC = STCO;\n  STSZ = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n  ]);\n  STTS = STCO;\n  VMHD = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x01, // flags\n    0x00, 0x00, // graphicsmode\n    0x00, 0x00,\n    0x00, 0x00,\n    0x00, 0x00 // opcolor\n  ]);\n}());\n\nbox = function(type) {\n  var\n    payload = [],\n    size = 0,\n    i,\n    result,\n    view;\n\n  for (i = 1; i < arguments.length; i++) {\n    payload.push(arguments[i]);\n  }\n\n  i = payload.length;\n\n  // calculate the total size we need to allocate\n  while (i--) {\n    size += payload[i].byteLength;\n  }\n  result = new Uint8Array(size + 8);\n  view = new DataView(result.buffer, result.byteOffset, result.byteLength);\n  view.setUint32(0, result.byteLength);\n  result.set(type, 4);\n\n  // copy the payload into the result\n  for (i = 0, size = 8; i < payload.length; i++) {\n    result.set(payload[i], size);\n    size += payload[i].byteLength;\n  }\n  return result;\n};\n\ndinf = function() {\n  return box(types.dinf, box(types.dref, DREF));\n};\n\nesds = function(track) {\n  return box(types.esds, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n\n    // ES_Descriptor\n    0x03, // tag, ES_DescrTag\n    0x19, // length\n    0x00, 0x00, // ES_ID\n    0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\n\n    // DecoderConfigDescriptor\n    0x04, // tag, DecoderConfigDescrTag\n    0x11, // length\n    0x40, // object type\n    0x15,  // streamType\n    0x00, 0x06, 0x00, // bufferSizeDB\n    0x00, 0x00, 0xda, 0xc0, // maxBitrate\n    0x00, 0x00, 0xda, 0xc0, // avgBitrate\n\n    // DecoderSpecificInfo\n    0x05, // tag, DecoderSpecificInfoTag\n    0x02, // length\n    // ISO/IEC 14496-3, AudioSpecificConfig\n    // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\n    (track.audioobjecttype << 3) | (track.samplingfrequencyindex >>> 1),\n    (track.samplingfrequencyindex << 7) | (track.channelcount << 3),\n    0x06, 0x01, 0x02 // GASpecificConfig\n  ]));\n};\n\nftyp = function() {\n  return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\n};\n\nhdlr = function(type) {\n  return box(types.hdlr, HDLR_TYPES[type]);\n};\nmdat = function(data) {\n  return box(types.mdat, data);\n};\nmdhd = function(track) {\n  var result = new Uint8Array([\n    0x00,                   // version 0\n    0x00, 0x00, 0x00,       // flags\n    0x00, 0x00, 0x00, 0x02, // creation_time\n    0x00, 0x00, 0x00, 0x03, // modification_time\n    0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n\n    (track.duration >>> 24) & 0xFF,\n    (track.duration >>> 16) & 0xFF,\n    (track.duration >>>  8) & 0xFF,\n    track.duration & 0xFF,  // duration\n    0x55, 0xc4,             // 'und' language (undetermined)\n    0x00, 0x00\n  ]);\n\n  // Use the sample rate from the track metadata, when it is\n  // defined. The sample rate can be parsed out of an ADTS header, for\n  // instance.\n  if (track.samplerate) {\n    result[12] = (track.samplerate >>> 24) & 0xFF;\n    result[13] = (track.samplerate >>> 16) & 0xFF;\n    result[14] = (track.samplerate >>>  8) & 0xFF;\n    result[15] = (track.samplerate)        & 0xFF;\n  }\n\n  return box(types.mdhd, result);\n};\nmdia = function(track) {\n  return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\n};\nmfhd = function(sequenceNumber) {\n  return box(types.mfhd, new Uint8Array([\n    0x00,\n    0x00, 0x00, 0x00, // flags\n    (sequenceNumber & 0xFF000000) >> 24,\n    (sequenceNumber & 0xFF0000) >> 16,\n    (sequenceNumber & 0xFF00) >> 8,\n    sequenceNumber & 0xFF // sequence_number\n  ]));\n};\nminf = function(track) {\n  return box(types.minf,\n             track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD),\n             dinf(),\n             stbl(track));\n};\nmoof = function(sequenceNumber, tracks) {\n  var\n    trackFragments = [],\n    i = tracks.length;\n  // build traf boxes for each track fragment\n  while (i--) {\n    trackFragments[i] = traf(tracks[i]);\n  }\n  return box.apply(null, [\n    types.moof,\n    mfhd(sequenceNumber)\n  ].concat(trackFragments));\n};\n/**\n * Returns a movie box.\n * @param tracks {array} the tracks associated with this movie\n * @see ISO/IEC 14496-12:2012(E), section 8.2.1\n */\nmoov = function(tracks) {\n  var\n    i = tracks.length,\n    boxes = [];\n\n  while (i--) {\n    boxes[i] = trak(tracks[i]);\n  }\n\n  return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\n};\nmvex = function(tracks) {\n  var\n    i = tracks.length,\n    boxes = [];\n\n  while (i--) {\n    boxes[i] = trex(tracks[i]);\n  }\n  return box.apply(null, [types.mvex].concat(boxes));\n};\nmvhd = function(duration) {\n  var\n    bytes = new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01, // creation_time\n      0x00, 0x00, 0x00, 0x02, // modification_time\n      0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n      (duration & 0xFF000000) >> 24,\n      (duration & 0xFF0000) >> 16,\n      (duration & 0xFF00) >> 8,\n      duration & 0xFF, // duration\n      0x00, 0x01, 0x00, 0x00, // 1.0 rate\n      0x01, 0x00, // 1.0 volume\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]);\n  return box(types.mvhd, bytes);\n};\n\nsdtp = function(track) {\n  var\n    samples = track.samples || [],\n    bytes = new Uint8Array(4 + samples.length),\n    flags,\n    i;\n\n  // leave the full box header (4 bytes) all zero\n\n  // write the sample table\n  for (i = 0; i < samples.length; i++) {\n    flags = samples[i].flags;\n\n    bytes[i + 4] = (flags.dependsOn << 4) |\n      (flags.isDependedOn << 2) |\n      (flags.hasRedundancy);\n  }\n\n  return box(types.sdtp,\n             bytes);\n};\n\nstbl = function(track) {\n  return box(types.stbl,\n             stsd(track),\n             box(types.stts, STTS),\n             box(types.stsc, STSC),\n             box(types.stsz, STSZ),\n             box(types.stco, STCO));\n};\n\n(function() {\n  var videoSample, audioSample;\n\n  stsd = function(track) {\n\n    return box(types.stsd, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01\n    ]), track.type === 'video' ? videoSample(track) : audioSample(track));\n  };\n\n  videoSample = function(track) {\n    var\n      sps = track.sps || [],\n      pps = track.pps || [],\n      sequenceParameterSets = [],\n      pictureParameterSets = [],\n      i;\n\n    // assemble the SPSs\n    for (i = 0; i < sps.length; i++) {\n      sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\n      sequenceParameterSets.push((sps[i].byteLength & 0xFF)); // sequenceParameterSetLength\n      sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\n    }\n\n    // assemble the PPSs\n    for (i = 0; i < pps.length; i++) {\n      pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\n      pictureParameterSets.push((pps[i].byteLength & 0xFF));\n      pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\n    }\n\n    return box(types.avc1, new Uint8Array([\n      0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      (track.width & 0xff00) >> 8,\n      track.width & 0xff, // width\n      (track.height & 0xff00) >> 8,\n      track.height & 0xff, // height\n      0x00, 0x48, 0x00, 0x00, // horizresolution\n      0x00, 0x48, 0x00, 0x00, // vertresolution\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // frame_count\n      0x13,\n      0x76, 0x69, 0x64, 0x65,\n      0x6f, 0x6a, 0x73, 0x2d,\n      0x63, 0x6f, 0x6e, 0x74,\n      0x72, 0x69, 0x62, 0x2d,\n      0x68, 0x6c, 0x73, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // compressorname\n      0x00, 0x18, // depth = 24\n      0x11, 0x11 // pre_defined = -1\n    ]), box(types.avcC, new Uint8Array([\n      0x01, // configurationVersion\n      track.profileIdc, // AVCProfileIndication\n      track.profileCompatibility, // profile_compatibility\n      track.levelIdc, // AVCLevelIndication\n      0xff // lengthSizeMinusOne, hard-coded to 4 bytes\n    ].concat([\n      sps.length // numOfSequenceParameterSets\n    ]).concat(sequenceParameterSets).concat([\n      pps.length // numOfPictureParameterSets\n    ]).concat(pictureParameterSets))), // \"PPS\"\n            box(types.btrt, new Uint8Array([\n              0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n              0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n              0x00, 0x2d, 0xc6, 0xc0\n            ])) // avgBitrate\n              );\n  };\n\n  audioSample = function(track) {\n    return box(types.mp4a, new Uint8Array([\n\n      // SampleEntry, ISO/IEC 14496-12\n      0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n\n      // AudioSampleEntry, ISO/IEC 14496-12\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      (track.channelcount & 0xff00) >> 8,\n      (track.channelcount & 0xff), // channelcount\n\n      (track.samplesize & 0xff00) >> 8,\n      (track.samplesize & 0xff), // samplesize\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n\n      (track.samplerate & 0xff00) >> 8,\n      (track.samplerate & 0xff),\n      0x00, 0x00 // samplerate, 16.16\n\n      // MP4AudioSampleEntry, ISO/IEC 14496-14\n    ]), esds(track));\n  };\n}());\n\ntkhd = function(track) {\n  var result = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x07, // flags\n    0x00, 0x00, 0x00, 0x00, // creation_time\n    0x00, 0x00, 0x00, 0x00, // modification_time\n    (track.id & 0xFF000000) >> 24,\n    (track.id & 0xFF0000) >> 16,\n    (track.id & 0xFF00) >> 8,\n    track.id & 0xFF, // track_ID\n    0x00, 0x00, 0x00, 0x00, // reserved\n    (track.duration & 0xFF000000) >> 24,\n    (track.duration & 0xFF0000) >> 16,\n    (track.duration & 0xFF00) >> 8,\n    track.duration & 0xFF, // duration\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, // layer\n    0x00, 0x00, // alternate_group\n    0x01, 0x00, // non-audio track volume\n    0x00, 0x00, // reserved\n    0x00, 0x01, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x01, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n    (track.width & 0xFF00) >> 8,\n    track.width & 0xFF,\n    0x00, 0x00, // width\n    (track.height & 0xFF00) >> 8,\n    track.height & 0xFF,\n    0x00, 0x00 // height\n  ]);\n\n  return box(types.tkhd, result);\n};\n\n/**\n * Generate a track fragment (traf) box. A traf box collects metadata\n * about tracks in a movie fragment (moof) box.\n */\ntraf = function(track) {\n  var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun,\n      sampleDependencyTable, dataOffset,\n      upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;\n\n  trackFragmentHeader = box(types.tfhd, new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x3a, // flags\n    (track.id & 0xFF000000) >> 24,\n    (track.id & 0xFF0000) >> 16,\n    (track.id & 0xFF00) >> 8,\n    (track.id & 0xFF), // track_ID\n    0x00, 0x00, 0x00, 0x01, // sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x00, 0x00, 0x00  // default_sample_flags\n  ]));\n\n  upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / (UINT32_MAX + 1));\n  lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % (UINT32_MAX + 1));\n\n  trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([\n    0x01, // version 1\n    0x00, 0x00, 0x00, // flags\n    // baseMediaDecodeTime\n    (upperWordBaseMediaDecodeTime >>> 24) & 0xFF,\n    (upperWordBaseMediaDecodeTime >>> 16) & 0xFF,\n    (upperWordBaseMediaDecodeTime >>>  8) & 0xFF,\n    upperWordBaseMediaDecodeTime & 0xFF,\n    (lowerWordBaseMediaDecodeTime >>> 24) & 0xFF,\n    (lowerWordBaseMediaDecodeTime >>> 16) & 0xFF,\n    (lowerWordBaseMediaDecodeTime >>>  8) & 0xFF,\n    lowerWordBaseMediaDecodeTime & 0xFF\n  ]));\n\n  // the data offset specifies the number of bytes from the start of\n  // the containing moof to the first payload byte of the associated\n  // mdat\n  dataOffset = (32 + // tfhd\n                20 + // tfdt\n                8 +  // traf header\n                16 + // mfhd\n                8 +  // moof header\n                8);  // mdat header\n\n  // audio tracks require less metadata\n  if (track.type === 'audio') {\n    trackFragmentRun = trun(track, dataOffset);\n    return box(types.traf,\n               trackFragmentHeader,\n               trackFragmentDecodeTime,\n               trackFragmentRun);\n  }\n\n  // video tracks should contain an independent and disposable samples\n  // box (sdtp)\n  // generate one and adjust offsets to match\n  sampleDependencyTable = sdtp(track);\n  trackFragmentRun = trun(track,\n                          sampleDependencyTable.length + dataOffset);\n  return box(types.traf,\n             trackFragmentHeader,\n             trackFragmentDecodeTime,\n             trackFragmentRun,\n             sampleDependencyTable);\n};\n\n/**\n * Generate a track box.\n * @param track {object} a track definition\n * @return {Uint8Array} the track box\n */\ntrak = function(track) {\n  track.duration = track.duration || 0xffffffff;\n  return box(types.trak,\n             tkhd(track),\n             mdia(track));\n};\n\ntrex = function(track) {\n  var result = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    (track.id & 0xFF000000) >> 24,\n    (track.id & 0xFF0000) >> 16,\n    (track.id & 0xFF00) >> 8,\n    (track.id & 0xFF), // track_ID\n    0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n  ]);\n  // the last two bytes of default_sample_flags is the sample\n  // degradation priority, a hint about the importance of this sample\n  // relative to others. Lower the degradation priority for all sample\n  // types other than video.\n  if (track.type !== 'video') {\n    result[result.length - 1] = 0x00;\n  }\n\n  return box(types.trex, result);\n};\n\n(function() {\n  var audioTrun, videoTrun, trunHeader;\n\n  // This method assumes all samples are uniform. That is, if a\n  // duration is present for the first sample, it will be present for\n  // all subsequent samples.\n  // see ISO/IEC 14496-12:2012, Section 8.8.8.1\n  trunHeader = function(samples, offset) {\n    var durationPresent = 0, sizePresent = 0,\n        flagsPresent = 0, compositionTimeOffset = 0;\n\n    // trun flag constants\n    if (samples.length) {\n      if (samples[0].duration !== undefined) {\n        durationPresent = 0x1;\n      }\n      if (samples[0].size !== undefined) {\n        sizePresent = 0x2;\n      }\n      if (samples[0].flags !== undefined) {\n        flagsPresent = 0x4;\n      }\n      if (samples[0].compositionTimeOffset !== undefined) {\n        compositionTimeOffset = 0x8;\n      }\n    }\n\n    return [\n      0x00, // version 0\n      0x00,\n      durationPresent | sizePresent | flagsPresent | compositionTimeOffset,\n      0x01, // flags\n      (samples.length & 0xFF000000) >>> 24,\n      (samples.length & 0xFF0000) >>> 16,\n      (samples.length & 0xFF00) >>> 8,\n      samples.length & 0xFF, // sample_count\n      (offset & 0xFF000000) >>> 24,\n      (offset & 0xFF0000) >>> 16,\n      (offset & 0xFF00) >>> 8,\n      offset & 0xFF // data_offset\n    ];\n  };\n\n  videoTrun = function(track, offset) {\n    var bytes, samples, sample, i;\n\n    samples = track.samples || [];\n    offset += 8 + 12 + (16 * samples.length);\n\n    bytes = trunHeader(samples, offset);\n\n    for (i = 0; i < samples.length; i++) {\n      sample = samples[i];\n      bytes = bytes.concat([\n        (sample.duration & 0xFF000000) >>> 24,\n        (sample.duration & 0xFF0000) >>> 16,\n        (sample.duration & 0xFF00) >>> 8,\n        sample.duration & 0xFF, // sample_duration\n        (sample.size & 0xFF000000) >>> 24,\n        (sample.size & 0xFF0000) >>> 16,\n        (sample.size & 0xFF00) >>> 8,\n        sample.size & 0xFF, // sample_size\n        (sample.flags.isLeading << 2) | sample.flags.dependsOn,\n        (sample.flags.isDependedOn << 6) |\n          (sample.flags.hasRedundancy << 4) |\n          (sample.flags.paddingValue << 1) |\n          sample.flags.isNonSyncSample,\n        sample.flags.degradationPriority & 0xF0 << 8,\n        sample.flags.degradationPriority & 0x0F, // sample_flags\n        (sample.compositionTimeOffset & 0xFF000000) >>> 24,\n        (sample.compositionTimeOffset & 0xFF0000) >>> 16,\n        (sample.compositionTimeOffset & 0xFF00) >>> 8,\n        sample.compositionTimeOffset & 0xFF // sample_composition_time_offset\n      ]);\n    }\n    return box(types.trun, new Uint8Array(bytes));\n  };\n\n  audioTrun = function(track, offset) {\n    var bytes, samples, sample, i;\n\n    samples = track.samples || [];\n    offset += 8 + 12 + (8 * samples.length);\n\n    bytes = trunHeader(samples, offset);\n\n    for (i = 0; i < samples.length; i++) {\n      sample = samples[i];\n      bytes = bytes.concat([\n        (sample.duration & 0xFF000000) >>> 24,\n        (sample.duration & 0xFF0000) >>> 16,\n        (sample.duration & 0xFF00) >>> 8,\n        sample.duration & 0xFF, // sample_duration\n        (sample.size & 0xFF000000) >>> 24,\n        (sample.size & 0xFF0000) >>> 16,\n        (sample.size & 0xFF00) >>> 8,\n        sample.size & 0xFF]); // sample_size\n    }\n\n    return box(types.trun, new Uint8Array(bytes));\n  };\n\n  trun = function(track, offset) {\n    if (track.type === 'audio') {\n      return audioTrun(track, offset);\n    }\n\n    return videoTrun(track, offset);\n  };\n}());\n\nmodule.exports = {\n  ftyp: ftyp,\n  mdat: mdat,\n  moof: moof,\n  moov: moov,\n  initSegment: function(tracks) {\n    var\n      fileType = ftyp(),\n      movie = moov(tracks),\n      result;\n\n    result = new Uint8Array(fileType.byteLength + movie.byteLength);\n    result.set(fileType);\n    result.set(movie, fileType.byteLength);\n    return result;\n  }\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\nvar toUnsigned = function(value) {\n  return value >>> 0;\n};\n\nmodule.exports = {\n  toUnsigned: toUnsigned\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Utilities to detect basic properties and metadata about MP4s.\n */\n'use strict';\n\nvar toUnsigned = require('../utils/bin').toUnsigned;\nvar findBox, parseType, timescale, startTime, getVideoTrackIds;\n\n// Find the data for a box specified by its path\nfindBox = function(data, path) {\n  var results = [],\n      i, size, type, end, subresults;\n\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return null;\n  }\n\n  for (i = 0; i < data.byteLength;) {\n    size  = toUnsigned(data[i]     << 24 |\n                       data[i + 1] << 16 |\n                       data[i + 2] <<  8 |\n                       data[i + 3]);\n\n    type = parseType(data.subarray(i + 4, i + 8));\n\n    end = size > 1 ? i + size : data.byteLength;\n\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, end));\n      } else {\n        // recursively search for the next box along the path\n        subresults = findBox(data.subarray(i + 8, end), path.slice(1));\n        if (subresults.length) {\n          results = results.concat(subresults);\n        }\n      }\n    }\n    i = end;\n  }\n\n  // we've finished searching all of data\n  return results;\n};\n\n/**\n * Returns the string representation of an ASCII encoded four byte buffer.\n * @param buffer {Uint8Array} a four-byte buffer to translate\n * @return {string} the corresponding string\n */\nparseType = function(buffer) {\n  var result = '';\n  result += String.fromCharCode(buffer[0]);\n  result += String.fromCharCode(buffer[1]);\n  result += String.fromCharCode(buffer[2]);\n  result += String.fromCharCode(buffer[3]);\n  return result;\n};\n\n/**\n * Parses an MP4 initialization segment and extracts the timescale\n * values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * ```\n * @param init {Uint8Array} the bytes of the init segment\n * @return {object} a hash of track ids to timescale values or null if\n * the init segment is malformed.\n */\ntimescale = function(init) {\n  var\n    result = {},\n    traks = findBox(init, ['moov', 'trak']);\n\n  // mdhd timescale\n  return traks.reduce(function(result, trak) {\n    var tkhd, version, index, id, mdhd;\n\n    tkhd = findBox(trak, ['tkhd'])[0];\n    if (!tkhd) {\n      return null;\n    }\n    version = tkhd[0];\n    index = version === 0 ? 12 : 20;\n    id = toUnsigned(tkhd[index]     << 24 |\n                    tkhd[index + 1] << 16 |\n                    tkhd[index + 2] <<  8 |\n                    tkhd[index + 3]);\n\n    mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n    if (!mdhd) {\n      return null;\n    }\n    version = mdhd[0];\n    index = version === 0 ? 12 : 20;\n    result[id] = toUnsigned(mdhd[index]     << 24 |\n                            mdhd[index + 1] << 16 |\n                            mdhd[index + 2] <<  8 |\n                            mdhd[index + 3]);\n    return result;\n  }, result);\n};\n\n/**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param timescale {object} a hash of track ids to timescale values.\n * @return {number} the earliest base media decode start time for the\n * fragment, in seconds\n */\nstartTime = function(timescale, fragment) {\n  var trafs, baseTimes, result;\n\n  // we need info from two childrend of each track fragment box\n  trafs = findBox(fragment, ['moof', 'traf']);\n\n  // determine the start times for each track\n  baseTimes = [].concat.apply([], trafs.map(function(traf) {\n    return findBox(traf, ['tfhd']).map(function(tfhd) {\n      var id, scale, baseTime;\n\n      // get the track id from the tfhd\n      id = toUnsigned(tfhd[4] << 24 |\n                      tfhd[5] << 16 |\n                      tfhd[6] <<  8 |\n                      tfhd[7]);\n      // assume a 90kHz clock if no timescale was specified\n      scale = timescale[id] || 90e3;\n\n      // get the base media decode time from the tfdt\n      baseTime = findBox(traf, ['tfdt']).map(function(tfdt) {\n        var version, result;\n\n        version = tfdt[0];\n        result = toUnsigned(tfdt[4] << 24 |\n                            tfdt[5] << 16 |\n                            tfdt[6] <<  8 |\n                            tfdt[7]);\n        if (version ===  1) {\n          result *= Math.pow(2, 32);\n          result += toUnsigned(tfdt[8]  << 24 |\n                               tfdt[9]  << 16 |\n                               tfdt[10] <<  8 |\n                               tfdt[11]);\n        }\n        return result;\n      })[0];\n      baseTime = baseTime || Infinity;\n\n      // convert base time to seconds\n      return baseTime / scale;\n    });\n  }));\n\n  // return the minimum\n  result = Math.min.apply(null, baseTimes);\n  return isFinite(result) ? result : 0;\n};\n\n/**\n  * Find the trackIds of the video tracks in this source.\n  * Found by parsing the Handler Reference and Track Header Boxes:\n  *   moov > trak > mdia > hdlr\n  *   moov > trak > tkhd\n  *\n  * @param {Uint8Array} init - The bytes of the init segment for this source\n  * @return {Number[]} A list of trackIds\n  *\n  * @see ISO-BMFF-12/2015, Section 8.4.3\n **/\ngetVideoTrackIds = function(init) {\n  var traks = findBox(init, ['moov', 'trak']);\n  var videoTrackIds = [];\n\n  traks.forEach(function(trak) {\n    var hdlrs = findBox(trak, ['mdia', 'hdlr']);\n    var tkhds = findBox(trak, ['tkhd']);\n\n    hdlrs.forEach(function(hdlr, index) {\n      var handlerType = parseType(hdlr.subarray(8, 12));\n      var tkhd = tkhds[index];\n      var view;\n      var version;\n      var trackId;\n\n      if (handlerType === 'vide') {\n        view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n        version = view.getUint8(0);\n        trackId = (version === 0) ? view.getUint32(12) : view.getUint32(20);\n\n        videoTrackIds.push(trackId);\n      }\n    });\n  });\n\n  return videoTrackIds;\n};\n\nmodule.exports = {\n  findBox: findBox,\n  parseType: parseType,\n  timescale: timescale,\n  startTime: startTime,\n  videoTrackIds: getVideoTrackIds\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n// Convert an array of nal units into an array of frames with each frame being\n// composed of the nal units that make up that frame\n// Also keep track of cummulative data about the frame from the nal units such\n// as the frame duration, starting pts, etc.\nvar groupNalsIntoFrames = function(nalUnits) {\n  var\n    i,\n    currentNal,\n    currentFrame = [],\n    frames = [];\n\n  currentFrame.byteLength = 0;\n\n  for (i = 0; i < nalUnits.length; i++) {\n    currentNal = nalUnits[i];\n\n    // Split on 'aud'-type nal units\n    if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n      // Since the very first nal unit is expected to be an AUD\n      // only push to the frames array when currentFrame is not empty\n      if (currentFrame.length) {\n        currentFrame.duration = currentNal.dts - currentFrame.dts;\n        frames.push(currentFrame);\n      }\n      currentFrame = [currentNal];\n      currentFrame.byteLength = currentNal.data.byteLength;\n      currentFrame.pts = currentNal.pts;\n      currentFrame.dts = currentNal.dts;\n    } else {\n      // Specifically flag key frames for ease of use later\n      if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n        currentFrame.keyFrame = true;\n      }\n      currentFrame.duration = currentNal.dts - currentFrame.dts;\n      currentFrame.byteLength += currentNal.data.byteLength;\n      currentFrame.push(currentNal);\n    }\n  }\n\n  // For the last frame, use the duration of the previous frame if we\n  // have nothing better to go on\n  if (frames.length &&\n      (!currentFrame.duration ||\n       currentFrame.duration <= 0)) {\n    currentFrame.duration = frames[frames.length - 1].duration;\n  }\n\n  // Push the final frame\n  frames.push(currentFrame);\n  return frames;\n};\n\n// Convert an array of frames into an array of Gop with each Gop being composed\n// of the frames that make up that Gop\n// Also keep track of cummulative data about the Gop from the frames such as the\n// Gop duration, starting pts, etc.\nvar groupFramesIntoGops = function(frames) {\n  var\n    i,\n    currentFrame,\n    currentGop = [],\n    gops = [];\n\n  // We must pre-set some of the values on the Gop since we\n  // keep running totals of these values\n  currentGop.byteLength = 0;\n  currentGop.nalCount = 0;\n  currentGop.duration = 0;\n  currentGop.pts = frames[0].pts;\n  currentGop.dts = frames[0].dts;\n\n  // store some metadata about all the Gops\n  gops.byteLength = 0;\n  gops.nalCount = 0;\n  gops.duration = 0;\n  gops.pts = frames[0].pts;\n  gops.dts = frames[0].dts;\n\n  for (i = 0; i < frames.length; i++) {\n    currentFrame = frames[i];\n\n    if (currentFrame.keyFrame) {\n      // Since the very first frame is expected to be an keyframe\n      // only push to the gops array when currentGop is not empty\n      if (currentGop.length) {\n        gops.push(currentGop);\n        gops.byteLength += currentGop.byteLength;\n        gops.nalCount += currentGop.nalCount;\n        gops.duration += currentGop.duration;\n      }\n\n      currentGop = [currentFrame];\n      currentGop.nalCount = currentFrame.length;\n      currentGop.byteLength = currentFrame.byteLength;\n      currentGop.pts = currentFrame.pts;\n      currentGop.dts = currentFrame.dts;\n      currentGop.duration = currentFrame.duration;\n    } else {\n      currentGop.duration += currentFrame.duration;\n      currentGop.nalCount += currentFrame.length;\n      currentGop.byteLength += currentFrame.byteLength;\n      currentGop.push(currentFrame);\n    }\n  }\n\n  if (gops.length && currentGop.duration <= 0) {\n    currentGop.duration = gops[gops.length - 1].duration;\n  }\n  gops.byteLength += currentGop.byteLength;\n  gops.nalCount += currentGop.nalCount;\n  gops.duration += currentGop.duration;\n\n  // push the final Gop\n  gops.push(currentGop);\n  return gops;\n};\n\n/*\n * Search for the first keyframe in the GOPs and throw away all frames\n * until that keyframe. Then extend the duration of the pulled keyframe\n * and pull the PTS and DTS of the keyframe so that it covers the time\n * range of the frames that were disposed.\n *\n * @param {Array} gops video GOPs\n * @returns {Array} modified video GOPs\n */\nvar extendFirstKeyFrame = function(gops) {\n  var currentGop;\n\n  if (!gops[0][0].keyFrame && gops.length > 1) {\n    // Remove the first GOP\n    currentGop = gops.shift();\n\n    gops.byteLength -= currentGop.byteLength;\n    gops.nalCount -= currentGop.nalCount;\n\n    // Extend the first frame of what is now the\n    // first gop to cover the time period of the\n    // frames we just removed\n    gops[0][0].dts = currentGop.dts;\n    gops[0][0].pts = currentGop.pts;\n    gops[0][0].duration += currentGop.duration;\n  }\n\n  return gops;\n};\n\n/**\n * Default sample object\n * see ISO/IEC 14496-12:2012, section 8.6.4.3\n */\nvar createDefaultSample = function() {\n  return {\n    size: 0,\n    flags: {\n      isLeading: 0,\n      dependsOn: 1,\n      isDependedOn: 0,\n      hasRedundancy: 0,\n      degradationPriority: 0,\n      isNonSyncSample: 1\n    }\n  };\n};\n\n/*\n * Collates information from a video frame into an object for eventual\n * entry into an MP4 sample table.\n *\n * @param {Object} frame the video frame\n * @param {Number} dataOffset the byte offset to position the sample\n * @return {Object} object containing sample table info for a frame\n */\nvar sampleForFrame = function(frame, dataOffset) {\n  var sample = createDefaultSample();\n\n  sample.dataOffset = dataOffset;\n  sample.compositionTimeOffset = frame.pts - frame.dts;\n  sample.duration = frame.duration;\n  sample.size = 4 * frame.length; // Space for nal unit size\n  sample.size += frame.byteLength;\n\n  if (frame.keyFrame) {\n    sample.flags.dependsOn = 2;\n    sample.flags.isNonSyncSample = 0;\n  }\n\n  return sample;\n};\n\n// generate the track's sample table from an array of gops\nvar generateSampleTable = function(gops, baseDataOffset) {\n  var\n    h, i,\n    sample,\n    currentGop,\n    currentFrame,\n    dataOffset = baseDataOffset || 0,\n    samples = [];\n\n  for (h = 0; h < gops.length; h++) {\n    currentGop = gops[h];\n\n    for (i = 0; i < currentGop.length; i++) {\n      currentFrame = currentGop[i];\n\n      sample = sampleForFrame(currentFrame, dataOffset);\n\n      dataOffset += sample.size;\n\n      samples.push(sample);\n    }\n  }\n  return samples;\n};\n\n// generate the track's raw mdat data from an array of gops\nvar concatenateNalData = function(gops) {\n  var\n    h, i, j,\n    currentGop,\n    currentFrame,\n    currentNal,\n    dataOffset = 0,\n    nalsByteLength = gops.byteLength,\n    numberOfNals = gops.nalCount,\n    totalByteLength = nalsByteLength + 4 * numberOfNals,\n    data = new Uint8Array(totalByteLength),\n    view = new DataView(data.buffer);\n\n  // For each Gop..\n  for (h = 0; h < gops.length; h++) {\n    currentGop = gops[h];\n\n    // For each Frame..\n    for (i = 0; i < currentGop.length; i++) {\n      currentFrame = currentGop[i];\n\n      // For each NAL..\n      for (j = 0; j < currentFrame.length; j++) {\n        currentNal = currentFrame[j];\n\n        view.setUint32(dataOffset, currentNal.data.byteLength);\n        dataOffset += 4;\n        data.set(currentNal.data, dataOffset);\n        dataOffset += currentNal.data.byteLength;\n      }\n    }\n  }\n  return data;\n};\n\nmodule.exports = {\n  groupNalsIntoFrames: groupNalsIntoFrames,\n  groupFramesIntoGops: groupFramesIntoGops,\n  extendFirstKeyFrame: extendFirstKeyFrame,\n  generateSampleTable: generateSampleTable,\n  concatenateNalData: concatenateNalData\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\nvar highPrefix = [33, 16, 5, 32, 164, 27];\nvar lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];\nvar zeroFill = function(count) {\n  var a = [];\n  while (count--) {\n    a.push(0);\n  }\n  return a;\n};\n\nvar makeTable = function(metaTable) {\n  return Object.keys(metaTable).reduce(function(obj, key) {\n    obj[key] = new Uint8Array(metaTable[key].reduce(function(arr, part) {\n      return arr.concat(part);\n    }, []));\n    return obj;\n  }, {});\n};\n\n// Frames-of-silence to use for filling in missing AAC frames\nvar coneOfSilence = {\n  96000: [highPrefix, [227, 64], zeroFill(154), [56]],\n  88200: [highPrefix, [231], zeroFill(170), [56]],\n  64000: [highPrefix, [248, 192], zeroFill(240), [56]],\n  48000: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],\n  44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],\n  32000: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],\n  24000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],\n  16000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],\n  12000: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],\n  11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],\n  8000: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]\n};\n\nmodule.exports = makeTable(coneOfSilence);\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\nvar\n  ONE_SECOND_IN_TS = 90000, // 90kHz clock\n  secondsToVideoTs,\n  secondsToAudioTs,\n  videoTsToSeconds,\n  audioTsToSeconds,\n  audioTsToVideoTs,\n  videoTsToAudioTs;\n\nsecondsToVideoTs = function(seconds) {\n  return seconds * ONE_SECOND_IN_TS;\n};\n\nsecondsToAudioTs = function(seconds, sampleRate) {\n  return seconds * sampleRate;\n};\n\nvideoTsToSeconds = function(timestamp) {\n  return timestamp / ONE_SECOND_IN_TS;\n};\n\naudioTsToSeconds = function(timestamp, sampleRate) {\n  return timestamp / sampleRate;\n};\n\naudioTsToVideoTs = function(timestamp, sampleRate) {\n  return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\n};\n\nvideoTsToAudioTs = function(timestamp, sampleRate) {\n  return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\n};\n\nmodule.exports = {\n  secondsToVideoTs: secondsToVideoTs,\n  secondsToAudioTs: secondsToAudioTs,\n  videoTsToSeconds: videoTsToSeconds,\n  audioTsToSeconds: audioTsToSeconds,\n  audioTsToVideoTs: audioTsToVideoTs,\n  videoTsToAudioTs: videoTsToAudioTs\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\nvar coneOfSilence = require('../data/silence');\nvar clock = require('../utils/clock');\n\nvar ONE_SECOND_IN_TS = 90000; // 90kHz clock\n\n/**\n * Sum the `byteLength` properties of the data in each AAC frame\n */\nvar sumFrameByteLengths = function(array) {\n  var\n    i,\n    currentObj,\n    sum = 0;\n\n  // sum the byteLength's all each nal unit in the frame\n  for (i = 0; i < array.length; i++) {\n    currentObj = array[i];\n    sum += currentObj.data.byteLength;\n  }\n\n  return sum;\n};\n\n// Possibly pad (prefix) the audio track with silence if appending this track\n// would lead to the introduction of a gap in the audio buffer\nvar prefixWithSilence = function(\n  track,\n  frames,\n  audioAppendStartTs,\n  videoBaseMediaDecodeTime\n) {\n  var\n    baseMediaDecodeTimeTs,\n    frameDuration = 0,\n    audioGapDuration = 0,\n    audioFillFrameCount = 0,\n    audioFillDuration = 0,\n    silentFrame,\n    i;\n\n  if (!frames.length) {\n    return;\n  }\n\n  baseMediaDecodeTimeTs =\n    clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate);\n  // determine frame clock duration based on sample rate, round up to avoid overfills\n  frameDuration = Math.ceil(ONE_SECOND_IN_TS / (track.samplerate / 1024));\n\n  if (audioAppendStartTs && videoBaseMediaDecodeTime) {\n    // insert the shortest possible amount (audio gap or audio to video gap)\n    audioGapDuration =\n      baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime);\n    // number of full frames in the audio gap\n    audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);\n    audioFillDuration = audioFillFrameCount * frameDuration;\n  }\n\n  // don't attempt to fill gaps smaller than a single frame or larger\n  // than a half second\n  if (audioFillFrameCount < 1 || audioFillDuration > ONE_SECOND_IN_TS / 2) {\n    return;\n  }\n\n  silentFrame = coneOfSilence[track.samplerate];\n\n  if (!silentFrame) {\n    // we don't have a silent frame pregenerated for the sample rate, so use a frame\n    // from the content instead\n    silentFrame = frames[0].data;\n  }\n\n  for (i = 0; i < audioFillFrameCount; i++) {\n    frames.splice(i, 0, {\n      data: silentFrame\n    });\n  }\n\n  track.baseMediaDecodeTime -=\n    Math.floor(clock.videoTsToAudioTs(audioFillDuration, track.samplerate));\n};\n\n// If the audio segment extends before the earliest allowed dts\n// value, remove AAC frames until starts at or after the earliest\n// allowed DTS so that we don't end up with a negative baseMedia-\n// DecodeTime for the audio track\nvar trimAdtsFramesByEarliestDts = function(adtsFrames, track, earliestAllowedDts) {\n  if (track.minSegmentDts >= earliestAllowedDts) {\n    return adtsFrames;\n  }\n\n  // We will need to recalculate the earliest segment Dts\n  track.minSegmentDts = Infinity;\n\n  return adtsFrames.filter(function(currentFrame) {\n    // If this is an allowed frame, keep it and record it's Dts\n    if (currentFrame.dts >= earliestAllowedDts) {\n      track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\n      track.minSegmentPts = track.minSegmentDts;\n      return true;\n    }\n    // Otherwise, discard it\n    return false;\n  });\n};\n\n// generate the track's raw mdat data from an array of frames\nvar generateSampleTable = function(frames) {\n  var\n    i,\n    currentFrame,\n    samples = [];\n\n  for (i = 0; i < frames.length; i++) {\n    currentFrame = frames[i];\n    samples.push({\n      size: currentFrame.data.byteLength,\n      duration: 1024 // For AAC audio, all samples contain 1024 samples\n    });\n  }\n  return samples;\n};\n\n// generate the track's sample table from an array of frames\nvar concatenateFrameData = function(frames) {\n  var\n    i,\n    currentFrame,\n    dataOffset = 0,\n    data = new Uint8Array(sumFrameByteLengths(frames));\n\n  for (i = 0; i < frames.length; i++) {\n    currentFrame = frames[i];\n\n    data.set(currentFrame.data, dataOffset);\n    dataOffset += currentFrame.data.byteLength;\n  }\n  return data;\n};\n\nmodule.exports = {\n  prefixWithSilence: prefixWithSilence,\n  trimAdtsFramesByEarliestDts: trimAdtsFramesByEarliestDts,\n  generateSampleTable: generateSampleTable,\n  concatenateFrameData: concatenateFrameData\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\nvar ONE_SECOND_IN_TS = 90000; // 90kHz clock\n\n/**\n * Store information about the start and end of the track and the\n * duration for each frame/sample we process in order to calculate\n * the baseMediaDecodeTime\n */\nvar collectDtsInfo = function(track, data) {\n  if (typeof data.pts === 'number') {\n    if (track.timelineStartInfo.pts === undefined) {\n      track.timelineStartInfo.pts = data.pts;\n    }\n\n    if (track.minSegmentPts === undefined) {\n      track.minSegmentPts = data.pts;\n    } else {\n      track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\n    }\n\n    if (track.maxSegmentPts === undefined) {\n      track.maxSegmentPts = data.pts;\n    } else {\n      track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\n    }\n  }\n\n  if (typeof data.dts === 'number') {\n    if (track.timelineStartInfo.dts === undefined) {\n      track.timelineStartInfo.dts = data.dts;\n    }\n\n    if (track.minSegmentDts === undefined) {\n      track.minSegmentDts = data.dts;\n    } else {\n      track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\n    }\n\n    if (track.maxSegmentDts === undefined) {\n      track.maxSegmentDts = data.dts;\n    } else {\n      track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\n    }\n  }\n};\n\n/**\n * Clear values used to calculate the baseMediaDecodeTime between\n * tracks\n */\nvar clearDtsInfo = function(track) {\n  delete track.minSegmentDts;\n  delete track.maxSegmentDts;\n  delete track.minSegmentPts;\n  delete track.maxSegmentPts;\n};\n\n/**\n * Calculate the track's baseMediaDecodeTime based on the earliest\n * DTS the transmuxer has ever seen and the minimum DTS for the\n * current track\n * @param track {object} track metadata configuration\n * @param keepOriginalTimestamps {boolean} If true, keep the timestamps\n *        in the source; false to adjust the first segment to start at 0.\n */\nvar calculateTrackBaseMediaDecodeTime = function(track, keepOriginalTimestamps) {\n  var\n    baseMediaDecodeTime,\n    scale,\n    minSegmentDts = track.minSegmentDts;\n\n  // Optionally adjust the time so the first segment starts at zero.\n  if (!keepOriginalTimestamps) {\n    minSegmentDts -= track.timelineStartInfo.dts;\n  }\n\n  // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\n  // we want the start of the first segment to be placed\n  baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;\n\n  // Add to that the distance this segment is from the very first\n  baseMediaDecodeTime += minSegmentDts;\n\n  // baseMediaDecodeTime must not become negative\n  baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);\n\n  if (track.type === 'audio') {\n    // Audio has a different clock equal to the sampling_rate so we need to\n    // scale the PTS values into the clock rate of the track\n    scale = track.samplerate / ONE_SECOND_IN_TS;\n    baseMediaDecodeTime *= scale;\n    baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);\n  }\n\n  return baseMediaDecodeTime;\n};\n\nmodule.exports = {\n  clearDtsInfo: clearDtsInfo,\n  calculateTrackBaseMediaDecodeTime: calculateTrackBaseMediaDecodeTime,\n  collectDtsInfo: collectDtsInfo\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Reads in-band caption information from a video elementary\n * stream. Captions must follow the CEA-708 standard for injection\n * into an MPEG-2 transport streams.\n * @see https://en.wikipedia.org/wiki/CEA-708\n * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n */\n\n'use strict';\n\n// Supplemental enhancement information (SEI) NAL units have a\n// payload type field to indicate how they are to be\n// interpreted. CEAS-708 caption content is always transmitted with\n// payload type 0x04.\nvar USER_DATA_REGISTERED_ITU_T_T35 = 4,\n    RBSP_TRAILING_BITS = 128;\n\n/**\n  * Parse a supplemental enhancement information (SEI) NAL unit.\n  * Stops parsing once a message of type ITU T T35 has been found.\n  *\n  * @param bytes {Uint8Array} the bytes of a SEI NAL unit\n  * @return {object} the parsed SEI payload\n  * @see Rec. ITU-T H.264, 7.3.2.3.1\n  */\nvar parseSei = function(bytes) {\n  var\n    i = 0,\n    result = {\n      payloadType: -1,\n      payloadSize: 0\n    },\n    payloadType = 0,\n    payloadSize = 0;\n\n  // go through the sei_rbsp parsing each each individual sei_message\n  while (i < bytes.byteLength) {\n    // stop once we have hit the end of the sei_rbsp\n    if (bytes[i] === RBSP_TRAILING_BITS) {\n      break;\n    }\n\n    // Parse payload type\n    while (bytes[i] === 0xFF) {\n      payloadType += 255;\n      i++;\n    }\n    payloadType += bytes[i++];\n\n    // Parse payload size\n    while (bytes[i] === 0xFF) {\n      payloadSize += 255;\n      i++;\n    }\n    payloadSize += bytes[i++];\n\n    // this sei_message is a 608/708 caption so save it and break\n    // there can only ever be one caption message in a frame's sei\n    if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\n      result.payloadType = payloadType;\n      result.payloadSize = payloadSize;\n      result.payload = bytes.subarray(i, i + payloadSize);\n      break;\n    }\n\n    // skip the payload and parse the next message\n    i += payloadSize;\n    payloadType = 0;\n    payloadSize = 0;\n  }\n\n  return result;\n};\n\n// see ANSI/SCTE 128-1 (2013), section 8.1\nvar parseUserData = function(sei) {\n  // itu_t_t35_contry_code must be 181 (United States) for\n  // captions\n  if (sei.payload[0] !== 181) {\n    return null;\n  }\n\n  // itu_t_t35_provider_code should be 49 (ATSC) for captions\n  if (((sei.payload[1] << 8) | sei.payload[2]) !== 49) {\n    return null;\n  }\n\n  // the user_identifier should be \"GA94\" to indicate ATSC1 data\n  if (String.fromCharCode(sei.payload[3],\n                          sei.payload[4],\n                          sei.payload[5],\n                          sei.payload[6]) !== 'GA94') {\n    return null;\n  }\n\n  // finally, user_data_type_code should be 0x03 for caption data\n  if (sei.payload[7] !== 0x03) {\n    return null;\n  }\n\n  // return the user_data_type_structure and strip the trailing\n  // marker bits\n  return sei.payload.subarray(8, sei.payload.length - 1);\n};\n\n// see CEA-708-D, section 4.4\nvar parseCaptionPackets = function(pts, userData) {\n  var results = [], i, count, offset, data;\n\n  // if this is just filler, return immediately\n  if (!(userData[0] & 0x40)) {\n    return results;\n  }\n\n  // parse out the cc_data_1 and cc_data_2 fields\n  count = userData[0] & 0x1f;\n  for (i = 0; i < count; i++) {\n    offset = i * 3;\n    data = {\n      type: userData[offset + 2] & 0x03,\n      pts: pts\n    };\n\n    // capture cc data when cc_valid is 1\n    if (userData[offset + 2] & 0x04) {\n      data.ccData = (userData[offset + 3] << 8) | userData[offset + 4];\n      results.push(data);\n    }\n  }\n  return results;\n};\n\nvar discardEmulationPreventionBytes = function(data) {\n    var\n      length = data.byteLength,\n      emulationPreventionBytesPositions = [],\n      i = 1,\n      newLength, newData;\n\n    // Find all `Emulation Prevention Bytes`\n    while (i < length - 2) {\n      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n        emulationPreventionBytesPositions.push(i + 2);\n        i += 2;\n      } else {\n        i++;\n      }\n    }\n\n    // If no Emulation Prevention Bytes were found just return the original\n    // array\n    if (emulationPreventionBytesPositions.length === 0) {\n      return data;\n    }\n\n    // Create a new array to hold the NAL unit data\n    newLength = length - emulationPreventionBytesPositions.length;\n    newData = new Uint8Array(newLength);\n    var sourceIndex = 0;\n\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\n        // Skip this byte\n        sourceIndex++;\n        // Remove this position index\n        emulationPreventionBytesPositions.shift();\n      }\n      newData[i] = data[sourceIndex];\n    }\n\n    return newData;\n};\n\n// exports\nmodule.exports = {\n  parseSei: parseSei,\n  parseUserData: parseUserData,\n  parseCaptionPackets: parseCaptionPackets,\n  discardEmulationPreventionBytes: discardEmulationPreventionBytes,\n  USER_DATA_REGISTERED_ITU_T_T35: USER_DATA_REGISTERED_ITU_T_T35\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Reads in-band caption information from a video elementary\n * stream. Captions must follow the CEA-708 standard for injection\n * into an MPEG-2 transport streams.\n * @see https://en.wikipedia.org/wiki/CEA-708\n * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n */\n\n'use strict';\n\n// -----------------\n// Link To Transport\n// -----------------\n\nvar Stream = require('../utils/stream');\nvar cea708Parser = require('../tools/caption-packet-parser');\n\nvar CaptionStream = function() {\n\n  CaptionStream.prototype.init.call(this);\n\n  this.captionPackets_ = [];\n\n  this.ccStreams_ = [\n    new Cea608Stream(0, 0), // eslint-disable-line no-use-before-define\n    new Cea608Stream(0, 1), // eslint-disable-line no-use-before-define\n    new Cea608Stream(1, 0), // eslint-disable-line no-use-before-define\n    new Cea608Stream(1, 1) // eslint-disable-line no-use-before-define\n  ];\n\n  this.reset();\n\n  // forward data and done events from CCs to this CaptionStream\n  this.ccStreams_.forEach(function(cc) {\n    cc.on('data', this.trigger.bind(this, 'data'));\n    cc.on('done', this.trigger.bind(this, 'done'));\n  }, this);\n\n};\n\nCaptionStream.prototype = new Stream();\nCaptionStream.prototype.push = function(event) {\n  var sei, userData, newCaptionPackets;\n\n  // only examine SEI NALs\n  if (event.nalUnitType !== 'sei_rbsp') {\n    return;\n  }\n\n  // parse the sei\n  sei = cea708Parser.parseSei(event.escapedRBSP);\n\n  // ignore everything but user_data_registered_itu_t_t35\n  if (sei.payloadType !== cea708Parser.USER_DATA_REGISTERED_ITU_T_T35) {\n    return;\n  }\n\n  // parse out the user data payload\n  userData = cea708Parser.parseUserData(sei);\n\n  // ignore unrecognized userData\n  if (!userData) {\n    return;\n  }\n\n  // Sometimes, the same segment # will be downloaded twice. To stop the\n  // caption data from being processed twice, we track the latest dts we've\n  // received and ignore everything with a dts before that. However, since\n  // data for a specific dts can be split across packets on either side of\n  // a segment boundary, we need to make sure we *don't* ignore the packets\n  // from the *next* segment that have dts === this.latestDts_. By constantly\n  // tracking the number of packets received with dts === this.latestDts_, we\n  // know how many should be ignored once we start receiving duplicates.\n  if (event.dts < this.latestDts_) {\n    // We've started getting older data, so set the flag.\n    this.ignoreNextEqualDts_ = true;\n    return;\n  } else if ((event.dts === this.latestDts_) && (this.ignoreNextEqualDts_)) {\n    this.numSameDts_--;\n    if (!this.numSameDts_) {\n      // We've received the last duplicate packet, time to start processing again\n      this.ignoreNextEqualDts_ = false;\n    }\n    return;\n  }\n\n  // parse out CC data packets and save them for later\n  newCaptionPackets = cea708Parser.parseCaptionPackets(event.pts, userData);\n  this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);\n  if (this.latestDts_ !== event.dts) {\n    this.numSameDts_ = 0;\n  }\n  this.numSameDts_++;\n  this.latestDts_ = event.dts;\n};\n\nCaptionStream.prototype.flush = function() {\n  // make sure we actually parsed captions before proceeding\n  if (!this.captionPackets_.length) {\n    this.ccStreams_.forEach(function(cc) {\n      cc.flush();\n    }, this);\n    return;\n  }\n\n  // In Chrome, the Array#sort function is not stable so add a\n  // presortIndex that we can use to ensure we get a stable-sort\n  this.captionPackets_.forEach(function(elem, idx) {\n    elem.presortIndex = idx;\n  });\n\n  // sort caption byte-pairs based on their PTS values\n  this.captionPackets_.sort(function(a, b) {\n    if (a.pts === b.pts) {\n      return a.presortIndex - b.presortIndex;\n    }\n    return a.pts - b.pts;\n  });\n\n  this.captionPackets_.forEach(function(packet) {\n    if (packet.type < 2) {\n      // Dispatch packet to the right Cea608Stream\n      this.dispatchCea608Packet(packet);\n    }\n    // this is where an 'else' would go for a dispatching packets\n    // to a theoretical Cea708Stream that handles SERVICEn data\n  }, this);\n\n  this.captionPackets_.length = 0;\n  this.ccStreams_.forEach(function(cc) {\n    cc.flush();\n  }, this);\n  return;\n};\n\nCaptionStream.prototype.reset = function() {\n  this.latestDts_ = null;\n  this.ignoreNextEqualDts_ = false;\n  this.numSameDts_ = 0;\n  this.activeCea608Channel_ = [null, null];\n  this.ccStreams_.forEach(function(ccStream) {\n    ccStream.reset();\n  });\n};\n\n// From the CEA-608 spec:\n/*\n * When XDS sub-packets are interleaved with other services, the end of each sub-packet shall be followed\n * by a control pair to change to a different service. When any of the control codes from 0x10 to 0x1F is\n * used to begin a control code pair, it indicates the return to captioning or Text data. The control code pair\n * and subsequent data should then be processed according to the FCC rules. It may be necessary for the\n * line 21 data encoder to automatically insert a control code pair (i.e. RCL, RU2, RU3, RU4, RDC, or RTD)\n * to switch to captioning or Text.\n*/\n// With that in mind, we ignore any data between an XDS control code and a\n// subsequent closed-captioning control code.\nCaptionStream.prototype.dispatchCea608Packet = function(packet) {\n  // NOTE: packet.type is the CEA608 field\n  if (this.setsTextOrXDSActive(packet)) {\n    this.activeCea608Channel_[packet.type] = null;\n  } else if (this.setsChannel1Active(packet)) {\n    this.activeCea608Channel_[packet.type] = 0;\n  } else if (this.setsChannel2Active(packet)) {\n    this.activeCea608Channel_[packet.type] = 1;\n  }\n  if (this.activeCea608Channel_[packet.type] === null) {\n    // If we haven't received anything to set the active channel, or the\n    // packets are Text/XDS data, discard the data; we don't want jumbled\n    // captions\n    return;\n  }\n  this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);\n};\n\nCaptionStream.prototype.setsChannel1Active = function(packet) {\n  return ((packet.ccData & 0x7800) === 0x1000);\n};\nCaptionStream.prototype.setsChannel2Active = function(packet) {\n  return ((packet.ccData & 0x7800) === 0x1800);\n};\nCaptionStream.prototype.setsTextOrXDSActive = function(packet) {\n  return ((packet.ccData & 0x7100) === 0x0100) ||\n    ((packet.ccData & 0x78fe) === 0x102a) ||\n    ((packet.ccData & 0x78fe) === 0x182a);\n};\n\n// ----------------------\n// Session to Application\n// ----------------------\n\n// This hash maps non-ASCII, special, and extended character codes to their\n// proper Unicode equivalent. The first keys that are only a single byte\n// are the non-standard ASCII characters, which simply map the CEA608 byte\n// to the standard ASCII/Unicode. The two-byte keys that follow are the CEA608\n// character codes, but have their MSB bitmasked with 0x03 so that a lookup\n// can be performed regardless of the field and data channel on which the\n// character code was received.\nvar CHARACTER_TRANSLATION = {\n  0x2a: 0xe1,     // \n  0x5c: 0xe9,     // \n  0x5e: 0xed,     // \n  0x5f: 0xf3,     // \n  0x60: 0xfa,     // \n  0x7b: 0xe7,     // \n  0x7c: 0xf7,     // \n  0x7d: 0xd1,     // \n  0x7e: 0xf1,     // \n  0x7f: 0x2588,   // \n  0x0130: 0xae,   // \n  0x0131: 0xb0,   // \n  0x0132: 0xbd,   // \n  0x0133: 0xbf,   // \n  0x0134: 0x2122, // \n  0x0135: 0xa2,   // \n  0x0136: 0xa3,   // \n  0x0137: 0x266a, // \n  0x0138: 0xe0,   // \n  0x0139: 0xa0,   //\n  0x013a: 0xe8,   // \n  0x013b: 0xe2,   // \n  0x013c: 0xea,   // \n  0x013d: 0xee,   // \n  0x013e: 0xf4,   // \n  0x013f: 0xfb,   // \n  0x0220: 0xc1,   // \n  0x0221: 0xc9,   // \n  0x0222: 0xd3,   // \n  0x0223: 0xda,   // \n  0x0224: 0xdc,   // \n  0x0225: 0xfc,   // \n  0x0226: 0x2018, // \n  0x0227: 0xa1,   // \n  0x0228: 0x2a,   // *\n  0x0229: 0x27,   // '\n  0x022a: 0x2014, // \n  0x022b: 0xa9,   // \n  0x022c: 0x2120, // \n  0x022d: 0x2022, // \n  0x022e: 0x201c, // \n  0x022f: 0x201d, // \n  0x0230: 0xc0,   // \n  0x0231: 0xc2,   // \n  0x0232: 0xc7,   // \n  0x0233: 0xc8,   // \n  0x0234: 0xca,   // \n  0x0235: 0xcb,   // \n  0x0236: 0xeb,   // \n  0x0237: 0xce,   // \n  0x0238: 0xcf,   // \n  0x0239: 0xef,   // \n  0x023a: 0xd4,   // \n  0x023b: 0xd9,   // \n  0x023c: 0xf9,   // \n  0x023d: 0xdb,   // \n  0x023e: 0xab,   // \n  0x023f: 0xbb,   // \n  0x0320: 0xc3,   // \n  0x0321: 0xe3,   // \n  0x0322: 0xcd,   // \n  0x0323: 0xcc,   // \n  0x0324: 0xec,   // \n  0x0325: 0xd2,   // \n  0x0326: 0xf2,   // \n  0x0327: 0xd5,   // \n  0x0328: 0xf5,   // \n  0x0329: 0x7b,   // {\n  0x032a: 0x7d,   // }\n  0x032b: 0x5c,   // \\\n  0x032c: 0x5e,   // ^\n  0x032d: 0x5f,   // _\n  0x032e: 0x7c,   // |\n  0x032f: 0x7e,   // ~\n  0x0330: 0xc4,   // \n  0x0331: 0xe4,   // \n  0x0332: 0xd6,   // \n  0x0333: 0xf6,   // \n  0x0334: 0xdf,   // \n  0x0335: 0xa5,   // \n  0x0336: 0xa4,   // \n  0x0337: 0x2502, // \n  0x0338: 0xc5,   // \n  0x0339: 0xe5,   // \n  0x033a: 0xd8,   // \n  0x033b: 0xf8,   // \n  0x033c: 0x250c, // \n  0x033d: 0x2510, // \n  0x033e: 0x2514, // \n  0x033f: 0x2518  // \n};\n\nvar getCharFromCode = function(code) {\n  if (code === null) {\n    return '';\n  }\n  code = CHARACTER_TRANSLATION[code] || code;\n  return String.fromCharCode(code);\n};\n\n// the index of the last row in a CEA-608 display buffer\nvar BOTTOM_ROW = 14;\n\n// This array is used for mapping PACs -> row #, since there's no way of\n// getting it through bit logic.\nvar ROWS = [0x1100, 0x1120, 0x1200, 0x1220, 0x1500, 0x1520, 0x1600, 0x1620,\n            0x1700, 0x1720, 0x1000, 0x1300, 0x1320, 0x1400, 0x1420];\n\n// CEA-608 captions are rendered onto a 34x15 matrix of character\n// cells. The \"bottom\" row is the last element in the outer array.\nvar createDisplayBuffer = function() {\n  var result = [], i = BOTTOM_ROW + 1;\n  while (i--) {\n    result.push('');\n  }\n  return result;\n};\n\nvar Cea608Stream = function(field, dataChannel) {\n  Cea608Stream.prototype.init.call(this);\n\n  this.field_ = field || 0;\n  this.dataChannel_ = dataChannel || 0;\n\n  this.name_ = 'CC' + (((this.field_ << 1) | this.dataChannel_) + 1);\n\n  this.setConstants();\n  this.reset();\n\n  this.push = function(packet) {\n    var data, swap, char0, char1, text;\n    // remove the parity bits\n    data = packet.ccData & 0x7f7f;\n\n    // ignore duplicate control codes; the spec demands they're sent twice\n    if (data === this.lastControlCode_) {\n      this.lastControlCode_ = null;\n      return;\n    }\n\n    // Store control codes\n    if ((data & 0xf000) === 0x1000) {\n      this.lastControlCode_ = data;\n    } else if (data !== this.PADDING_) {\n      this.lastControlCode_ = null;\n    }\n\n    char0 = data >>> 8;\n    char1 = data & 0xff;\n\n    if (data === this.PADDING_) {\n      return;\n\n    } else if (data === this.RESUME_CAPTION_LOADING_) {\n      this.mode_ = 'popOn';\n\n    } else if (data === this.END_OF_CAPTION_) {\n      // If an EOC is received while in paint-on mode, the displayed caption\n      // text should be swapped to non-displayed memory as if it was a pop-on\n      // caption. Because of that, we should explicitly switch back to pop-on\n      // mode\n      this.mode_ = 'popOn';\n      this.clearFormatting(packet.pts);\n      // if a caption was being displayed, it's gone now\n      this.flushDisplayed(packet.pts);\n\n      // flip memory\n      swap = this.displayed_;\n      this.displayed_ = this.nonDisplayed_;\n      this.nonDisplayed_ = swap;\n\n      // start measuring the time to display the caption\n      this.startPts_ = packet.pts;\n\n    } else if (data === this.ROLL_UP_2_ROWS_) {\n      this.rollUpRows_ = 2;\n      this.setRollUp(packet.pts);\n    } else if (data === this.ROLL_UP_3_ROWS_) {\n      this.rollUpRows_ = 3;\n      this.setRollUp(packet.pts);\n    } else if (data === this.ROLL_UP_4_ROWS_) {\n      this.rollUpRows_ = 4;\n      this.setRollUp(packet.pts);\n    } else if (data === this.CARRIAGE_RETURN_) {\n      this.clearFormatting(packet.pts);\n      this.flushDisplayed(packet.pts);\n      this.shiftRowsUp_();\n      this.startPts_ = packet.pts;\n\n    } else if (data === this.BACKSPACE_) {\n      if (this.mode_ === 'popOn') {\n        this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n      } else {\n        this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n      }\n    } else if (data === this.ERASE_DISPLAYED_MEMORY_) {\n      this.flushDisplayed(packet.pts);\n      this.displayed_ = createDisplayBuffer();\n    } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {\n      this.nonDisplayed_ = createDisplayBuffer();\n\n    } else if (data === this.RESUME_DIRECT_CAPTIONING_) {\n      if (this.mode_ !== 'paintOn') {\n        // NOTE: This should be removed when proper caption positioning is\n        // implemented\n        this.flushDisplayed(packet.pts);\n        this.displayed_ = createDisplayBuffer();\n      }\n      this.mode_ = 'paintOn';\n      this.startPts_ = packet.pts;\n\n    // Append special characters to caption text\n    } else if (this.isSpecialCharacter(char0, char1)) {\n      // Bitmask char0 so that we can apply character transformations\n      // regardless of field and data channel.\n      // Then byte-shift to the left and OR with char1 so we can pass the\n      // entire character code to `getCharFromCode`.\n      char0 = (char0 & 0x03) << 8;\n      text = getCharFromCode(char0 | char1);\n      this[this.mode_](packet.pts, text);\n      this.column_++;\n\n    // Append extended characters to caption text\n    } else if (this.isExtCharacter(char0, char1)) {\n      // Extended characters always follow their \"non-extended\" equivalents.\n      // IE if a \"\" is desired, you'll always receive \"e\"; non-compliant\n      // decoders are supposed to drop the \"\", while compliant decoders\n      // backspace the \"e\" and insert \"\".\n\n      // Delete the previous character\n      if (this.mode_ === 'popOn') {\n        this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n      } else {\n        this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n      }\n\n      // Bitmask char0 so that we can apply character transformations\n      // regardless of field and data channel.\n      // Then byte-shift to the left and OR with char1 so we can pass the\n      // entire character code to `getCharFromCode`.\n      char0 = (char0 & 0x03) << 8;\n      text = getCharFromCode(char0 | char1);\n      this[this.mode_](packet.pts, text);\n      this.column_++;\n\n    // Process mid-row codes\n    } else if (this.isMidRowCode(char0, char1)) {\n      // Attributes are not additive, so clear all formatting\n      this.clearFormatting(packet.pts);\n\n      // According to the standard, mid-row codes\n      // should be replaced with spaces, so add one now\n      this[this.mode_](packet.pts, ' ');\n      this.column_++;\n\n      if ((char1 & 0xe) === 0xe) {\n        this.addFormatting(packet.pts, ['i']);\n      }\n\n      if ((char1 & 0x1) === 0x1) {\n        this.addFormatting(packet.pts, ['u']);\n      }\n\n    // Detect offset control codes and adjust cursor\n    } else if (this.isOffsetControlCode(char0, char1)) {\n      // Cursor position is set by indent PAC (see below) in 4-column\n      // increments, with an additional offset code of 1-3 to reach any\n      // of the 32 columns specified by CEA-608. So all we need to do\n      // here is increment the column cursor by the given offset.\n      this.column_ += (char1 & 0x03);\n\n    // Detect PACs (Preamble Address Codes)\n    } else if (this.isPAC(char0, char1)) {\n\n      // There's no logic for PAC -> row mapping, so we have to just\n      // find the row code in an array and use its index :(\n      var row = ROWS.indexOf(data & 0x1f20);\n\n      // Configure the caption window if we're in roll-up mode\n      if (this.mode_ === 'rollUp') {\n        // This implies that the base row is incorrectly set.\n        // As per the recommendation in CEA-608(Base Row Implementation), defer to the number\n        // of roll-up rows set.\n        if (row - this.rollUpRows_ + 1 < 0) {\n          row = this.rollUpRows_ - 1;\n        }\n\n        this.setRollUp(packet.pts, row);\n      }\n\n      if (row !== this.row_) {\n        // formatting is only persistent for current row\n        this.clearFormatting(packet.pts);\n        this.row_ = row;\n      }\n      // All PACs can apply underline, so detect and apply\n      // (All odd-numbered second bytes set underline)\n      if ((char1 & 0x1) && (this.formatting_.indexOf('u') === -1)) {\n          this.addFormatting(packet.pts, ['u']);\n      }\n\n      if ((data & 0x10) === 0x10) {\n        // We've got an indent level code. Each successive even number\n        // increments the column cursor by 4, so we can get the desired\n        // column position by bit-shifting to the right (to get n/2)\n        // and multiplying by 4.\n        this.column_ = ((data & 0xe) >> 1) * 4;\n      }\n\n      if (this.isColorPAC(char1)) {\n        // it's a color code, though we only support white, which\n        // can be either normal or italicized. white italics can be\n        // either 0x4e or 0x6e depending on the row, so we just\n        // bitwise-and with 0xe to see if italics should be turned on\n        if ((char1 & 0xe) === 0xe) {\n          this.addFormatting(packet.pts, ['i']);\n        }\n      }\n\n    // We have a normal character in char0, and possibly one in char1\n    } else if (this.isNormalChar(char0)) {\n      if (char1 === 0x00) {\n        char1 = null;\n      }\n      text = getCharFromCode(char0);\n      text += getCharFromCode(char1);\n      this[this.mode_](packet.pts, text);\n      this.column_ += text.length;\n\n    } // finish data processing\n\n  };\n};\nCea608Stream.prototype = new Stream();\n// Trigger a cue point that captures the current state of the\n// display buffer\nCea608Stream.prototype.flushDisplayed = function(pts) {\n  var content = this.displayed_\n    // remove spaces from the start and end of the string\n    .map(function(row) {\n      try {\n        return row.trim();\n      } catch (e) {\n        // Ordinarily, this shouldn't happen. However, caption\n        // parsing errors should not throw exceptions and\n        // break playback.\n        // eslint-disable-next-line no-console\n        console.error('Skipping malformed caption.');\n        return '';\n      }\n    })\n    // combine all text rows to display in one cue\n    .join('\\n')\n    // and remove blank rows from the start and end, but not the middle\n    .replace(/^\\n+|\\n+$/g, '');\n\n  if (content.length) {\n    this.trigger('data', {\n      startPts: this.startPts_,\n      endPts: pts,\n      text: content,\n      stream: this.name_\n    });\n  }\n};\n\n/**\n * Zero out the data, used for startup and on seek\n */\nCea608Stream.prototype.reset = function() {\n  this.mode_ = 'popOn';\n  // When in roll-up mode, the index of the last row that will\n  // actually display captions. If a caption is shifted to a row\n  // with a lower index than this, it is cleared from the display\n  // buffer\n  this.topRow_ = 0;\n  this.startPts_ = 0;\n  this.displayed_ = createDisplayBuffer();\n  this.nonDisplayed_ = createDisplayBuffer();\n  this.lastControlCode_ = null;\n\n  // Track row and column for proper line-breaking and spacing\n  this.column_ = 0;\n  this.row_ = BOTTOM_ROW;\n  this.rollUpRows_ = 2;\n\n  // This variable holds currently-applied formatting\n  this.formatting_ = [];\n};\n\n/**\n * Sets up control code and related constants for this instance\n */\nCea608Stream.prototype.setConstants = function() {\n  // The following attributes have these uses:\n  // ext_ :    char0 for mid-row codes, and the base for extended\n  //           chars (ext_+0, ext_+1, and ext_+2 are char0s for\n  //           extended codes)\n  // control_: char0 for control codes, except byte-shifted to the\n  //           left so that we can do this.control_ | CONTROL_CODE\n  // offset_:  char0 for tab offset codes\n  //\n  // It's also worth noting that control codes, and _only_ control codes,\n  // differ between field 1 and field2. Field 2 control codes are always\n  // their field 1 value plus 1. That's why there's the \"| field\" on the\n  // control value.\n  if (this.dataChannel_ === 0) {\n    this.BASE_     = 0x10;\n    this.EXT_      = 0x11;\n    this.CONTROL_  = (0x14 | this.field_) << 8;\n    this.OFFSET_   = 0x17;\n  } else if (this.dataChannel_ === 1) {\n    this.BASE_     = 0x18;\n    this.EXT_      = 0x19;\n    this.CONTROL_  = (0x1c | this.field_) << 8;\n    this.OFFSET_   = 0x1f;\n  }\n\n  // Constants for the LSByte command codes recognized by Cea608Stream. This\n  // list is not exhaustive. For a more comprehensive listing and semantics see\n  // http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\n  // Padding\n  this.PADDING_                    = 0x0000;\n  // Pop-on Mode\n  this.RESUME_CAPTION_LOADING_     = this.CONTROL_ | 0x20;\n  this.END_OF_CAPTION_             = this.CONTROL_ | 0x2f;\n  // Roll-up Mode\n  this.ROLL_UP_2_ROWS_             = this.CONTROL_ | 0x25;\n  this.ROLL_UP_3_ROWS_             = this.CONTROL_ | 0x26;\n  this.ROLL_UP_4_ROWS_             = this.CONTROL_ | 0x27;\n  this.CARRIAGE_RETURN_            = this.CONTROL_ | 0x2d;\n  // paint-on mode\n  this.RESUME_DIRECT_CAPTIONING_   = this.CONTROL_ | 0x29;\n  // Erasure\n  this.BACKSPACE_                  = this.CONTROL_ | 0x21;\n  this.ERASE_DISPLAYED_MEMORY_     = this.CONTROL_ | 0x2c;\n  this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2e;\n};\n\n/**\n * Detects if the 2-byte packet data is a special character\n *\n * Special characters have a second byte in the range 0x30 to 0x3f,\n * with the first byte being 0x11 (for data channel 1) or 0x19 (for\n * data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an special character\n */\nCea608Stream.prototype.isSpecialCharacter = function(char0, char1) {\n  return (char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f);\n};\n\n/**\n * Detects if the 2-byte packet data is an extended character\n *\n * Extended characters have a second byte in the range 0x20 to 0x3f,\n * with the first byte being 0x12 or 0x13 (for data channel 1) or\n * 0x1a or 0x1b (for data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an extended character\n */\nCea608Stream.prototype.isExtCharacter = function(char0, char1) {\n  return ((char0 === (this.EXT_ + 1) || char0 === (this.EXT_ + 2)) &&\n    (char1 >= 0x20 && char1 <= 0x3f));\n};\n\n/**\n * Detects if the 2-byte packet is a mid-row code\n *\n * Mid-row codes have a second byte in the range 0x20 to 0x2f, with\n * the first byte being 0x11 (for data channel 1) or 0x19 (for data\n * channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are a mid-row code\n */\nCea608Stream.prototype.isMidRowCode = function(char0, char1) {\n  return (char0 === this.EXT_ && (char1 >= 0x20 && char1 <= 0x2f));\n};\n\n/**\n * Detects if the 2-byte packet is an offset control code\n *\n * Offset control codes have a second byte in the range 0x21 to 0x23,\n * with the first byte being 0x17 (for data channel 1) or 0x1f (for\n * data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an offset control code\n */\nCea608Stream.prototype.isOffsetControlCode = function(char0, char1) {\n  return (char0 === this.OFFSET_ && (char1 >= 0x21 && char1 <= 0x23));\n};\n\n/**\n * Detects if the 2-byte packet is a Preamble Address Code\n *\n * PACs have a first byte in the range 0x10 to 0x17 (for data channel 1)\n * or 0x18 to 0x1f (for data channel 2), with the second byte in the\n * range 0x40 to 0x7f.\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are a PAC\n */\nCea608Stream.prototype.isPAC = function(char0, char1) {\n  return (char0 >= this.BASE_ && char0 < (this.BASE_ + 8) &&\n    (char1 >= 0x40 && char1 <= 0x7f));\n};\n\n/**\n * Detects if a packet's second byte is in the range of a PAC color code\n *\n * PAC color codes have the second byte be in the range 0x40 to 0x4f, or\n * 0x60 to 0x6f.\n *\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the byte is a color PAC\n */\nCea608Stream.prototype.isColorPAC = function(char1) {\n  return ((char1 >= 0x40 && char1 <= 0x4f) || (char1 >= 0x60 && char1 <= 0x7f));\n};\n\n/**\n * Detects if a single byte is in the range of a normal character\n *\n * Normal text bytes are in the range 0x20 to 0x7f.\n *\n * @param  {Integer} char  The byte\n * @return {Boolean}       Whether the byte is a normal character\n */\nCea608Stream.prototype.isNormalChar = function(char) {\n  return (char >= 0x20 && char <= 0x7f);\n};\n\n/**\n * Configures roll-up\n *\n * @param  {Integer} pts         Current PTS\n * @param  {Integer} newBaseRow  Used by PACs to slide the current window to\n *                               a new position\n */\nCea608Stream.prototype.setRollUp = function(pts, newBaseRow) {\n  // Reset the base row to the bottom row when switching modes\n  if (this.mode_ !== 'rollUp') {\n    this.row_ = BOTTOM_ROW;\n    this.mode_ = 'rollUp';\n    // Spec says to wipe memories when switching to roll-up\n    this.flushDisplayed(pts);\n    this.nonDisplayed_ = createDisplayBuffer();\n    this.displayed_ = createDisplayBuffer();\n  }\n\n  if (newBaseRow !== undefined && newBaseRow !== this.row_) {\n    // move currently displayed captions (up or down) to the new base row\n    for (var i = 0; i < this.rollUpRows_; i++) {\n      this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];\n      this.displayed_[this.row_ - i] = '';\n    }\n  }\n\n  if (newBaseRow === undefined) {\n    newBaseRow = this.row_;\n  }\n\n  this.topRow_ = newBaseRow - this.rollUpRows_ + 1;\n};\n\n// Adds the opening HTML tag for the passed character to the caption text,\n// and keeps track of it for later closing\nCea608Stream.prototype.addFormatting = function(pts, format) {\n  this.formatting_ = this.formatting_.concat(format);\n  var text = format.reduce(function(text, format) {\n    return text + '<' + format + '>';\n  }, '');\n  this[this.mode_](pts, text);\n};\n\n// Adds HTML closing tags for current formatting to caption text and\n// clears remembered formatting\nCea608Stream.prototype.clearFormatting = function(pts) {\n  if (!this.formatting_.length) {\n    return;\n  }\n  var text = this.formatting_.reverse().reduce(function(text, format) {\n    return text + '</' + format + '>';\n  }, '');\n  this.formatting_ = [];\n  this[this.mode_](pts, text);\n};\n\n// Mode Implementations\nCea608Stream.prototype.popOn = function(pts, text) {\n  var baseRow = this.nonDisplayed_[this.row_];\n\n  // buffer characters\n  baseRow += text;\n  this.nonDisplayed_[this.row_] = baseRow;\n};\n\nCea608Stream.prototype.rollUp = function(pts, text) {\n  var baseRow = this.displayed_[this.row_];\n\n  baseRow += text;\n  this.displayed_[this.row_] = baseRow;\n\n};\n\nCea608Stream.prototype.shiftRowsUp_ = function() {\n  var i;\n  // clear out inactive rows\n  for (i = 0; i < this.topRow_; i++) {\n    this.displayed_[i] = '';\n  }\n  for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) {\n    this.displayed_[i] = '';\n  }\n  // shift displayed rows up\n  for (i = this.topRow_; i < this.row_; i++) {\n    this.displayed_[i] = this.displayed_[i + 1];\n  }\n  // clear out the bottom row\n  this.displayed_[this.row_] = '';\n};\n\nCea608Stream.prototype.paintOn = function(pts, text) {\n  var baseRow = this.displayed_[this.row_];\n\n  baseRow += text;\n  this.displayed_[this.row_] = baseRow;\n};\n\n// exports\nmodule.exports = {\n  CaptionStream: CaptionStream,\n  Cea608Stream: Cea608Stream\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nmodule.exports = {\n  H264_STREAM_TYPE: 0x1B,\n  ADTS_STREAM_TYPE: 0x0F,\n  METADATA_STREAM_TYPE: 0x15\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Accepts program elementary stream (PES) data events and corrects\n * decode and presentation time stamps to account for a rollover\n * of the 33 bit value.\n */\n\n'use strict';\n\nvar Stream = require('../utils/stream');\n\nvar MAX_TS = 8589934592;\n\nvar RO_THRESH = 4294967296;\n\nvar handleRollover = function(value, reference) {\n  var direction = 1;\n\n  if (value > reference) {\n    // If the current timestamp value is greater than our reference timestamp and we detect a\n    // timestamp rollover, this means the roll over is happening in the opposite direction.\n    // Example scenario: Enter a long stream/video just after a rollover occurred. The reference\n    // point will be set to a small number, e.g. 1. The user then seeks backwards over the\n    // rollover point. In loading this segment, the timestamp values will be very large,\n    // e.g. 2^33 - 1. Since this comes before the data we loaded previously, we want to adjust\n    // the time stamp to be `value - 2^33`.\n    direction = -1;\n  }\n\n  // Note: A seek forwards or back that is greater than the RO_THRESH (2^32, ~13 hours) will\n  // cause an incorrect adjustment.\n  while (Math.abs(reference - value) > RO_THRESH) {\n    value += (direction * MAX_TS);\n  }\n\n  return value;\n};\n\nvar TimestampRolloverStream = function(type) {\n  var lastDTS, referenceDTS;\n\n  TimestampRolloverStream.prototype.init.call(this);\n\n  this.type_ = type;\n\n  this.push = function(data) {\n    if (data.type !== this.type_) {\n      return;\n    }\n\n    if (referenceDTS === undefined) {\n      referenceDTS = data.dts;\n    }\n\n    data.dts = handleRollover(data.dts, referenceDTS);\n    data.pts = handleRollover(data.pts, referenceDTS);\n\n    lastDTS = data.dts;\n\n    this.trigger('data', data);\n  };\n\n  this.flush = function() {\n    referenceDTS = lastDTS;\n    this.trigger('done');\n  };\n\n  this.discontinuity = function() {\n    referenceDTS = void 0;\n    lastDTS = void 0;\n  };\n\n};\n\nTimestampRolloverStream.prototype = new Stream();\n\nmodule.exports = {\n  TimestampRolloverStream: TimestampRolloverStream,\n  handleRollover: handleRollover\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Accepts program elementary stream (PES) data events and parses out\n * ID3 metadata from them, if present.\n * @see http://id3.org/id3v2.3.0\n */\n'use strict';\nvar\n  Stream = require('../utils/stream'),\n  StreamTypes = require('./stream-types'),\n  // return a percent-encoded representation of the specified byte range\n  // @see http://en.wikipedia.org/wiki/Percent-encoding\n  percentEncode = function(bytes, start, end) {\n    var i, result = '';\n    for (i = start; i < end; i++) {\n      result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n    }\n    return result;\n  },\n  // return the string representation of the specified byte range,\n  // interpreted as UTf-8.\n  parseUtf8 = function(bytes, start, end) {\n    return decodeURIComponent(percentEncode(bytes, start, end));\n  },\n  // return the string representation of the specified byte range,\n  // interpreted as ISO-8859-1.\n  parseIso88591 = function(bytes, start, end) {\n    return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n  },\n  parseSyncSafeInteger = function(data) {\n    return (data[0] << 21) |\n            (data[1] << 14) |\n            (data[2] << 7) |\n            (data[3]);\n  },\n  tagParsers = {\n    TXXX: function(tag) {\n      var i;\n      if (tag.data[0] !== 3) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n\n      for (i = 1; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the text fields\n          tag.description = parseUtf8(tag.data, 1, i);\n          // do not include the null terminator in the tag value\n          tag.value = parseUtf8(tag.data, i + 1, tag.data.length).replace(/\\0*$/, '');\n          break;\n        }\n      }\n      tag.data = tag.value;\n    },\n    WXXX: function(tag) {\n      var i;\n      if (tag.data[0] !== 3) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n\n      for (i = 1; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the description and URL fields\n          tag.description = parseUtf8(tag.data, 1, i);\n          tag.url = parseUtf8(tag.data, i + 1, tag.data.length);\n          break;\n        }\n      }\n    },\n    PRIV: function(tag) {\n      var i;\n\n      for (i = 0; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the description and URL fields\n          tag.owner = parseIso88591(tag.data, 0, i);\n          break;\n        }\n      }\n      tag.privateData = tag.data.subarray(i + 1);\n      tag.data = tag.privateData;\n    }\n  },\n  MetadataStream;\n\nMetadataStream = function(options) {\n  var\n    settings = {\n      debug: !!(options && options.debug),\n\n      // the bytes of the program-level descriptor field in MP2T\n      // see ISO/IEC 13818-1:2013 (E), section 2.6 \"Program and\n      // program element descriptors\"\n      descriptor: options && options.descriptor\n    },\n    // the total size in bytes of the ID3 tag being parsed\n    tagSize = 0,\n    // tag data that is not complete enough to be parsed\n    buffer = [],\n    // the total number of bytes currently in the buffer\n    bufferSize = 0,\n    i;\n\n  MetadataStream.prototype.init.call(this);\n\n  // calculate the text track in-band metadata track dispatch type\n  // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\n  this.dispatchType = StreamTypes.METADATA_STREAM_TYPE.toString(16);\n  if (settings.descriptor) {\n    for (i = 0; i < settings.descriptor.length; i++) {\n      this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\n    }\n  }\n\n  this.push = function(chunk) {\n    var tag, frameStart, frameSize, frame, i, frameHeader;\n    if (chunk.type !== 'timed-metadata') {\n      return;\n    }\n\n    // if data_alignment_indicator is set in the PES header,\n    // we must have the start of a new ID3 tag. Assume anything\n    // remaining in the buffer was malformed and throw it out\n    if (chunk.dataAlignmentIndicator) {\n      bufferSize = 0;\n      buffer.length = 0;\n    }\n\n    // ignore events that don't look like ID3 data\n    if (buffer.length === 0 &&\n        (chunk.data.length < 10 ||\n          chunk.data[0] !== 'I'.charCodeAt(0) ||\n          chunk.data[1] !== 'D'.charCodeAt(0) ||\n          chunk.data[2] !== '3'.charCodeAt(0))) {\n      if (settings.debug) {\n        // eslint-disable-next-line no-console\n        console.log('Skipping unrecognized metadata packet');\n      }\n      return;\n    }\n\n    // add this chunk to the data we've collected so far\n\n    buffer.push(chunk);\n    bufferSize += chunk.data.byteLength;\n\n    // grab the size of the entire frame from the ID3 header\n    if (buffer.length === 1) {\n      // the frame size is transmitted as a 28-bit integer in the\n      // last four bytes of the ID3 header.\n      // The most significant bit of each byte is dropped and the\n      // results concatenated to recover the actual value.\n      tagSize = parseSyncSafeInteger(chunk.data.subarray(6, 10));\n\n      // ID3 reports the tag size excluding the header but it's more\n      // convenient for our comparisons to include it\n      tagSize += 10;\n    }\n\n    // if the entire frame has not arrived, wait for more data\n    if (bufferSize < tagSize) {\n      return;\n    }\n\n    // collect the entire frame so it can be parsed\n    tag = {\n      data: new Uint8Array(tagSize),\n      frames: [],\n      pts: buffer[0].pts,\n      dts: buffer[0].dts\n    };\n    for (i = 0; i < tagSize;) {\n      tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\n      i += buffer[0].data.byteLength;\n      bufferSize -= buffer[0].data.byteLength;\n      buffer.shift();\n    }\n\n    // find the start of the first frame and the end of the tag\n    frameStart = 10;\n    if (tag.data[5] & 0x40) {\n      // advance the frame start past the extended header\n      frameStart += 4; // header size field\n      frameStart += parseSyncSafeInteger(tag.data.subarray(10, 14));\n\n      // clip any padding off the end\n      tagSize -= parseSyncSafeInteger(tag.data.subarray(16, 20));\n    }\n\n    // parse one or more ID3 frames\n    // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n    do {\n      // determine the number of bytes in this frame\n      frameSize = parseSyncSafeInteger(tag.data.subarray(frameStart + 4, frameStart + 8));\n      if (frameSize < 1) {\n         // eslint-disable-next-line no-console\n        return console.log('Malformed ID3 frame encountered. Skipping metadata parsing.');\n      }\n      frameHeader = String.fromCharCode(tag.data[frameStart],\n                                        tag.data[frameStart + 1],\n                                        tag.data[frameStart + 2],\n                                        tag.data[frameStart + 3]);\n\n\n      frame = {\n        id: frameHeader,\n        data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\n      };\n      frame.key = frame.id;\n      if (tagParsers[frame.id]) {\n        tagParsers[frame.id](frame);\n\n        // handle the special PRIV frame used to indicate the start\n        // time for raw AAC data\n        if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\n          var\n            d = frame.data,\n            size = ((d[3] & 0x01)  << 30) |\n                   (d[4]  << 22) |\n                   (d[5] << 14) |\n                   (d[6] << 6) |\n                   (d[7] >>> 2);\n\n          size *= 4;\n          size += d[7] & 0x03;\n          frame.timeStamp = size;\n          // in raw AAC, all subsequent data will be timestamped based\n          // on the value of this frame\n          // we couldn't have known the appropriate pts and dts before\n          // parsing this ID3 tag so set those values now\n          if (tag.pts === undefined && tag.dts === undefined) {\n            tag.pts = frame.timeStamp;\n            tag.dts = frame.timeStamp;\n          }\n          this.trigger('timestamp', frame);\n        }\n      }\n      tag.frames.push(frame);\n\n      frameStart += 10; // advance past the frame header\n      frameStart += frameSize; // advance past the frame body\n    } while (frameStart < tagSize);\n    this.trigger('data', tag);\n  };\n};\nMetadataStream.prototype = new Stream();\n\nmodule.exports = MetadataStream;\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * A stream-based mp2t to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\nvar Stream = require('../utils/stream.js'),\n  CaptionStream = require('./caption-stream'),\n  StreamTypes = require('./stream-types'),\n  TimestampRolloverStream = require('./timestamp-rollover-stream').TimestampRolloverStream;\n\nvar m2tsStreamTypes = require('./stream-types.js');\n\n// object types\nvar TransportPacketStream, TransportParseStream, ElementaryStream;\n\n// constants\nvar\n  MP2T_PACKET_LENGTH = 188, // bytes\n  SYNC_BYTE = 0x47;\n\n/**\n * Splits an incoming stream of binary data into MPEG-2 Transport\n * Stream packets.\n */\nTransportPacketStream = function() {\n  var\n    buffer = new Uint8Array(MP2T_PACKET_LENGTH),\n    bytesInBuffer = 0;\n\n  TransportPacketStream.prototype.init.call(this);\n\n   // Deliver new bytes to the stream.\n\n  /**\n   * Split a stream of data into M2TS packets\n  **/\n  this.push = function(bytes) {\n    var\n      startIndex = 0,\n      endIndex = MP2T_PACKET_LENGTH,\n      everything;\n\n    // If there are bytes remaining from the last segment, prepend them to the\n    // bytes that were pushed in\n    if (bytesInBuffer) {\n      everything = new Uint8Array(bytes.byteLength + bytesInBuffer);\n      everything.set(buffer.subarray(0, bytesInBuffer));\n      everything.set(bytes, bytesInBuffer);\n      bytesInBuffer = 0;\n    } else {\n      everything = bytes;\n    }\n\n    // While we have enough data for a packet\n    while (endIndex < everything.byteLength) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (everything[startIndex] === SYNC_BYTE && everything[endIndex] === SYNC_BYTE) {\n        // We found a packet so emit it and jump one whole packet forward in\n        // the stream\n        this.trigger('data', everything.subarray(startIndex, endIndex));\n        startIndex += MP2T_PACKET_LENGTH;\n        endIndex += MP2T_PACKET_LENGTH;\n        continue;\n      }\n      // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n      startIndex++;\n      endIndex++;\n    }\n\n    // If there was some data left over at the end of the segment that couldn't\n    // possibly be a whole packet, keep it because it might be the start of a packet\n    // that continues in the next segment\n    if (startIndex < everything.byteLength) {\n      buffer.set(everything.subarray(startIndex), 0);\n      bytesInBuffer = everything.byteLength - startIndex;\n    }\n  };\n\n  /**\n   * Passes identified M2TS packets to the TransportParseStream to be parsed\n  **/\n  this.flush = function() {\n    // If the buffer contains a whole packet when we are being flushed, emit it\n    // and empty the buffer. Otherwise hold onto the data because it may be\n    // important for decoding the next segment\n    if (bytesInBuffer === MP2T_PACKET_LENGTH && buffer[0] === SYNC_BYTE) {\n      this.trigger('data', buffer);\n      bytesInBuffer = 0;\n    }\n    this.trigger('done');\n  };\n};\nTransportPacketStream.prototype = new Stream();\n\n/**\n * Accepts an MP2T TransportPacketStream and emits data events with parsed\n * forms of the individual transport stream packets.\n */\nTransportParseStream = function() {\n  var parsePsi, parsePat, parsePmt, self;\n  TransportParseStream.prototype.init.call(this);\n  self = this;\n\n  this.packetsWaitingForPmt = [];\n  this.programMapTable = undefined;\n\n  parsePsi = function(payload, psi) {\n    var offset = 0;\n\n    // PSI packets may be split into multiple sections and those\n    // sections may be split into multiple packets. If a PSI\n    // section starts in this packet, the payload_unit_start_indicator\n    // will be true and the first byte of the payload will indicate\n    // the offset from the current position to the start of the\n    // section.\n    if (psi.payloadUnitStartIndicator) {\n      offset += payload[offset] + 1;\n    }\n\n    if (psi.type === 'pat') {\n      parsePat(payload.subarray(offset), psi);\n    } else {\n      parsePmt(payload.subarray(offset), psi);\n    }\n  };\n\n  parsePat = function(payload, pat) {\n    pat.section_number = payload[7]; // eslint-disable-line camelcase\n    pat.last_section_number = payload[8]; // eslint-disable-line camelcase\n\n    // skip the PSI header and parse the first PMT entry\n    self.pmtPid = (payload[10] & 0x1F) << 8 | payload[11];\n    pat.pmtPid = self.pmtPid;\n  };\n\n  /**\n   * Parse out the relevant fields of a Program Map Table (PMT).\n   * @param payload {Uint8Array} the PMT-specific portion of an MP2T\n   * packet. The first byte in this array should be the table_id\n   * field.\n   * @param pmt {object} the object that should be decorated with\n   * fields parsed from the PMT.\n   */\n  parsePmt = function(payload, pmt) {\n    var sectionLength, tableEnd, programInfoLength, offset;\n\n    // PMTs can be sent ahead of the time when they should actually\n    // take effect. We don't believe this should ever be the case\n    // for HLS but we'll ignore \"forward\" PMT declarations if we see\n    // them. Future PMT declarations have the current_next_indicator\n    // set to zero.\n    if (!(payload[5] & 0x01)) {\n      return;\n    }\n\n    // overwrite any existing program map table\n    self.programMapTable = {\n      video: null,\n      audio: null,\n      'timed-metadata': {}\n    };\n\n    // the mapping table ends at the end of the current section\n    sectionLength = (payload[1] & 0x0f) << 8 | payload[2];\n    tableEnd = 3 + sectionLength - 4;\n\n    // to determine where the table is, we have to figure out how\n    // long the program info descriptors are\n    programInfoLength = (payload[10] & 0x0f) << 8 | payload[11];\n\n    // advance the offset to the first entry in the mapping table\n    offset = 12 + programInfoLength;\n    while (offset < tableEnd) {\n      var streamType = payload[offset];\n      var pid = (payload[offset + 1] & 0x1F) << 8 | payload[offset + 2];\n\n      // only map a single elementary_pid for audio and video stream types\n      // TODO: should this be done for metadata too? for now maintain behavior of\n      //       multiple metadata streams\n      if (streamType === StreamTypes.H264_STREAM_TYPE &&\n          self.programMapTable.video === null) {\n        self.programMapTable.video = pid;\n      } else if (streamType === StreamTypes.ADTS_STREAM_TYPE &&\n                 self.programMapTable.audio === null) {\n        self.programMapTable.audio = pid;\n      } else if (streamType === StreamTypes.METADATA_STREAM_TYPE) {\n        // map pid to stream type for metadata streams\n        self.programMapTable['timed-metadata'][pid] = streamType;\n      }\n\n      // move to the next table entry\n      // skip past the elementary stream descriptors, if present\n      offset += ((payload[offset + 3] & 0x0F) << 8 | payload[offset + 4]) + 5;\n    }\n\n    // record the map on the packet as well\n    pmt.programMapTable = self.programMapTable;\n  };\n\n  /**\n   * Deliver a new MP2T packet to the next stream in the pipeline.\n   */\n  this.push = function(packet) {\n    var\n      result = {},\n      offset = 4;\n\n    result.payloadUnitStartIndicator = !!(packet[1] & 0x40);\n\n    // pid is a 13-bit field starting at the last bit of packet[1]\n    result.pid = packet[1] & 0x1f;\n    result.pid <<= 8;\n    result.pid |= packet[2];\n\n    // if an adaption field is present, its length is specified by the\n    // fifth byte of the TS packet header. The adaptation field is\n    // used to add stuffing to PES packets that don't fill a complete\n    // TS packet, and to specify some forms of timing and control data\n    // that we do not currently use.\n    if (((packet[3] & 0x30) >>> 4) > 0x01) {\n      offset += packet[offset] + 1;\n    }\n\n    // parse the rest of the packet based on the type\n    if (result.pid === 0) {\n      result.type = 'pat';\n      parsePsi(packet.subarray(offset), result);\n      this.trigger('data', result);\n    } else if (result.pid === this.pmtPid) {\n      result.type = 'pmt';\n      parsePsi(packet.subarray(offset), result);\n      this.trigger('data', result);\n\n      // if there are any packets waiting for a PMT to be found, process them now\n      while (this.packetsWaitingForPmt.length) {\n        this.processPes_.apply(this, this.packetsWaitingForPmt.shift());\n      }\n    } else if (this.programMapTable === undefined) {\n      // When we have not seen a PMT yet, defer further processing of\n      // PES packets until one has been parsed\n      this.packetsWaitingForPmt.push([packet, offset, result]);\n    } else {\n      this.processPes_(packet, offset, result);\n    }\n  };\n\n  this.processPes_ = function(packet, offset, result) {\n    // set the appropriate stream type\n    if (result.pid === this.programMapTable.video) {\n      result.streamType = StreamTypes.H264_STREAM_TYPE;\n    } else if (result.pid === this.programMapTable.audio) {\n      result.streamType = StreamTypes.ADTS_STREAM_TYPE;\n    } else {\n      // if not video or audio, it is timed-metadata or unknown\n      // if unknown, streamType will be undefined\n      result.streamType = this.programMapTable['timed-metadata'][result.pid];\n    }\n\n    result.type = 'pes';\n    result.data = packet.subarray(offset);\n\n    this.trigger('data', result);\n  };\n\n};\nTransportParseStream.prototype = new Stream();\nTransportParseStream.STREAM_TYPES  = {\n  h264: 0x1b,\n  adts: 0x0f\n};\n\n/**\n * Reconsistutes program elementary stream (PES) packets from parsed\n * transport stream packets. That is, if you pipe an\n * mp2t.TransportParseStream into a mp2t.ElementaryStream, the output\n * events will be events which capture the bytes for individual PES\n * packets plus relevant metadata that has been extracted from the\n * container.\n */\nElementaryStream = function() {\n  var\n    self = this,\n    // PES packet fragments\n    video = {\n      data: [],\n      size: 0\n    },\n    audio = {\n      data: [],\n      size: 0\n    },\n    timedMetadata = {\n      data: [],\n      size: 0\n    },\n    parsePes = function(payload, pes) {\n      var ptsDtsFlags;\n\n      // get the packet length, this will be 0 for video\n      pes.packetLength = 6 + ((payload[4] << 8) | payload[5]);\n\n      // find out if this packets starts a new keyframe\n      pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0;\n      // PES packets may be annotated with a PTS value, or a PTS value\n      // and a DTS value. Determine what combination of values is\n      // available to work with.\n      ptsDtsFlags = payload[7];\n\n      // PTS and DTS are normally stored as a 33-bit number.  Javascript\n      // performs all bitwise operations on 32-bit integers but javascript\n      // supports a much greater range (52-bits) of integer using standard\n      // mathematical operations.\n      // We construct a 31-bit value using bitwise operators over the 31\n      // most significant bits and then multiply by 4 (equal to a left-shift\n      // of 2) before we add the final 2 least significant bits of the\n      // timestamp (equal to an OR.)\n      if (ptsDtsFlags & 0xC0) {\n        // the PTS and DTS are not written out directly. For information\n        // on how they are encoded, see\n        // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n        pes.pts = (payload[9] & 0x0E) << 27 |\n          (payload[10] & 0xFF) << 20 |\n          (payload[11] & 0xFE) << 12 |\n          (payload[12] & 0xFF) <<  5 |\n          (payload[13] & 0xFE) >>>  3;\n        pes.pts *= 4; // Left shift by 2\n        pes.pts += (payload[13] & 0x06) >>> 1; // OR by the two LSBs\n        pes.dts = pes.pts;\n        if (ptsDtsFlags & 0x40) {\n          pes.dts = (payload[14] & 0x0E) << 27 |\n            (payload[15] & 0xFF) << 20 |\n            (payload[16] & 0xFE) << 12 |\n            (payload[17] & 0xFF) << 5 |\n            (payload[18] & 0xFE) >>> 3;\n          pes.dts *= 4; // Left shift by 2\n          pes.dts += (payload[18] & 0x06) >>> 1; // OR by the two LSBs\n        }\n      }\n      // the data section starts immediately after the PES header.\n      // pes_header_data_length specifies the number of header bytes\n      // that follow the last byte of the field.\n      pes.data = payload.subarray(9 + payload[8]);\n    },\n    /**\n      * Pass completely parsed PES packets to the next stream in the pipeline\n     **/\n    flushStream = function(stream, type, forceFlush) {\n      var\n        packetData = new Uint8Array(stream.size),\n        event = {\n          type: type\n        },\n        i = 0,\n        offset = 0,\n        packetFlushable = false,\n        fragment;\n\n      // do nothing if there is not enough buffered data for a complete\n      // PES header\n      if (!stream.data.length || stream.size < 9) {\n        return;\n      }\n      event.trackId = stream.data[0].pid;\n\n      // reassemble the packet\n      for (i = 0; i < stream.data.length; i++) {\n        fragment = stream.data[i];\n\n        packetData.set(fragment.data, offset);\n        offset += fragment.data.byteLength;\n      }\n\n      // parse assembled packet's PES header\n      parsePes(packetData, event);\n\n      // non-video PES packets MUST have a non-zero PES_packet_length\n      // check that there is enough stream data to fill the packet\n      packetFlushable = type === 'video' || event.packetLength <= stream.size;\n\n      // flush pending packets if the conditions are right\n      if (forceFlush || packetFlushable) {\n        stream.size = 0;\n        stream.data.length = 0;\n      }\n\n      // only emit packets that are complete. this is to avoid assembling\n      // incomplete PES packets due to poor segmentation\n      if (packetFlushable) {\n        self.trigger('data', event);\n      }\n    };\n\n  ElementaryStream.prototype.init.call(this);\n\n  /**\n   * Identifies M2TS packet types and parses PES packets using metadata\n   * parsed from the PMT\n   **/\n  this.push = function(data) {\n    ({\n      pat: function() {\n        // we have to wait for the PMT to arrive as well before we\n        // have any meaningful metadata\n      },\n      pes: function() {\n        var stream, streamType;\n\n        switch (data.streamType) {\n        case StreamTypes.H264_STREAM_TYPE:\n        case m2tsStreamTypes.H264_STREAM_TYPE:\n          stream = video;\n          streamType = 'video';\n          break;\n        case StreamTypes.ADTS_STREAM_TYPE:\n          stream = audio;\n          streamType = 'audio';\n          break;\n        case StreamTypes.METADATA_STREAM_TYPE:\n          stream = timedMetadata;\n          streamType = 'timed-metadata';\n          break;\n        default:\n          // ignore unknown stream types\n          return;\n        }\n\n        // if a new packet is starting, we can flush the completed\n        // packet\n        if (data.payloadUnitStartIndicator) {\n          flushStream(stream, streamType, true);\n        }\n\n        // buffer this fragment until we are sure we've received the\n        // complete payload\n        stream.data.push(data);\n        stream.size += data.data.byteLength;\n      },\n      pmt: function() {\n        var\n          event = {\n            type: 'metadata',\n            tracks: []\n          },\n          programMapTable = data.programMapTable;\n\n        // translate audio and video streams to tracks\n        if (programMapTable.video !== null) {\n          event.tracks.push({\n            timelineStartInfo: {\n              baseMediaDecodeTime: 0\n            },\n            id: +programMapTable.video,\n            codec: 'avc',\n            type: 'video'\n          });\n        }\n        if (programMapTable.audio !== null) {\n          event.tracks.push({\n            timelineStartInfo: {\n              baseMediaDecodeTime: 0\n            },\n            id: +programMapTable.audio,\n            codec: 'adts',\n            type: 'audio'\n          });\n        }\n\n        self.trigger('data', event);\n      }\n    })[data.type]();\n  };\n\n  /**\n   * Flush any remaining input. Video PES packets may be of variable\n   * length. Normally, the start of a new video packet can trigger the\n   * finalization of the previous packet. That is not possible if no\n   * more video is forthcoming, however. In that case, some other\n   * mechanism (like the end of the file) has to be employed. When it is\n   * clear that no additional data is forthcoming, calling this method\n   * will flush the buffered packets.\n   */\n  this.flush = function() {\n    // !!THIS ORDER IS IMPORTANT!!\n    // video first then audio\n    flushStream(video, 'video');\n    flushStream(audio, 'audio');\n    flushStream(timedMetadata, 'timed-metadata');\n    this.trigger('done');\n  };\n};\nElementaryStream.prototype = new Stream();\n\nvar m2ts = {\n  PAT_PID: 0x0000,\n  MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH,\n  TransportPacketStream: TransportPacketStream,\n  TransportParseStream: TransportParseStream,\n  ElementaryStream: ElementaryStream,\n  TimestampRolloverStream: TimestampRolloverStream,\n  CaptionStream: CaptionStream.CaptionStream,\n  Cea608Stream: CaptionStream.Cea608Stream,\n  MetadataStream: require('./metadata-stream')\n};\n\nfor (var type in StreamTypes) {\n  if (StreamTypes.hasOwnProperty(type)) {\n    m2ts[type] = StreamTypes[type];\n  }\n}\n\nmodule.exports = m2ts;\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Utilities to detect basic properties and metadata about Aac data.\n */\n'use strict';\n\nvar ADTS_SAMPLING_FREQUENCIES = [\n  96000,\n  88200,\n  64000,\n  48000,\n  44100,\n  32000,\n  24000,\n  22050,\n  16000,\n  12000,\n  11025,\n  8000,\n  7350\n];\n\nvar isLikelyAacData = function(data) {\n  if ((data[0] === 'I'.charCodeAt(0)) &&\n      (data[1] === 'D'.charCodeAt(0)) &&\n      (data[2] === '3'.charCodeAt(0))) {\n    return true;\n  }\n  return false;\n};\n\nvar parseSyncSafeInteger = function(data) {\n  return (data[0] << 21) |\n          (data[1] << 14) |\n          (data[2] << 7) |\n          (data[3]);\n};\n\n// return a percent-encoded representation of the specified byte range\n// @see http://en.wikipedia.org/wiki/Percent-encoding\nvar percentEncode = function(bytes, start, end) {\n  var i, result = '';\n  for (i = start; i < end; i++) {\n    result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n  }\n  return result;\n};\n\n// return the string representation of the specified byte range,\n// interpreted as ISO-8859-1.\nvar parseIso88591 = function(bytes, start, end) {\n  return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n};\n\nvar parseId3TagSize = function(header, byteIndex) {\n  var\n    returnSize = (header[byteIndex + 6] << 21) |\n                 (header[byteIndex + 7] << 14) |\n                 (header[byteIndex + 8] << 7) |\n                 (header[byteIndex + 9]),\n    flags = header[byteIndex + 5],\n    footerPresent = (flags & 16) >> 4;\n\n  if (footerPresent) {\n    return returnSize + 20;\n  }\n  return returnSize + 10;\n};\n\nvar parseAdtsSize = function(header, byteIndex) {\n  var\n    lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\n    middle = header[byteIndex + 4] << 3,\n    highTwo = header[byteIndex + 3] & 0x3 << 11;\n\n  return (highTwo | middle) | lowThree;\n};\n\nvar parseType = function(header, byteIndex) {\n  if ((header[byteIndex] === 'I'.charCodeAt(0)) &&\n      (header[byteIndex + 1] === 'D'.charCodeAt(0)) &&\n      (header[byteIndex + 2] === '3'.charCodeAt(0))) {\n    return 'timed-metadata';\n  } else if ((header[byteIndex] & 0xff === 0xff) &&\n             ((header[byteIndex + 1] & 0xf0) === 0xf0)) {\n    return 'audio';\n  }\n  return null;\n};\n\nvar parseSampleRate = function(packet) {\n  var i = 0;\n\n  while (i + 5 < packet.length) {\n    if (packet[i] !== 0xFF || (packet[i + 1] & 0xF6) !== 0xF0) {\n      // If a valid header was not found,  jump one forward and attempt to\n      // find a valid ADTS header starting at the next byte\n      i++;\n      continue;\n    }\n    return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 0x3c) >>> 2];\n  }\n\n  return null;\n};\n\nvar parseAacTimestamp = function(packet) {\n  var frameStart, frameSize, frame, frameHeader;\n\n  // find the start of the first frame and the end of the tag\n  frameStart = 10;\n  if (packet[5] & 0x40) {\n    // advance the frame start past the extended header\n    frameStart += 4; // header size field\n    frameStart += parseSyncSafeInteger(packet.subarray(10, 14));\n  }\n\n  // parse one or more ID3 frames\n  // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n  do {\n    // determine the number of bytes in this frame\n    frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));\n    if (frameSize < 1) {\n      return null;\n    }\n    frameHeader = String.fromCharCode(packet[frameStart],\n                                      packet[frameStart + 1],\n                                      packet[frameStart + 2],\n                                      packet[frameStart + 3]);\n\n    if (frameHeader === 'PRIV') {\n      frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);\n\n      for (var i = 0; i < frame.byteLength; i++) {\n        if (frame[i] === 0) {\n          var owner = parseIso88591(frame, 0, i);\n          if (owner === 'com.apple.streaming.transportStreamTimestamp') {\n            var d = frame.subarray(i + 1);\n            var size = ((d[3] & 0x01)  << 30) |\n                       (d[4]  << 22) |\n                       (d[5] << 14) |\n                       (d[6] << 6) |\n                       (d[7] >>> 2);\n            size *= 4;\n            size += d[7] & 0x03;\n\n            return size;\n          }\n          break;\n        }\n      }\n    }\n\n    frameStart += 10; // advance past the frame header\n    frameStart += frameSize; // advance past the frame body\n  } while (frameStart < packet.byteLength);\n  return null;\n};\n\nmodule.exports = {\n  isLikelyAacData: isLikelyAacData,\n  parseId3TagSize: parseId3TagSize,\n  parseAdtsSize: parseAdtsSize,\n  parseType: parseType,\n  parseSampleRate: parseSampleRate,\n  parseAacTimestamp: parseAacTimestamp\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * A stream-based aac to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\nvar Stream = require('../utils/stream.js');\nvar aacUtils = require('./utils');\n\n// Constants\nvar AacStream;\n\n/**\n * Splits an incoming stream of binary data into ADTS and ID3 Frames.\n */\n\nAacStream = function() {\n  var\n    everything = new Uint8Array(),\n    timeStamp = 0;\n\n  AacStream.prototype.init.call(this);\n\n  this.setTimestamp = function(timestamp) {\n    timeStamp = timestamp;\n  };\n\n  this.push = function(bytes) {\n    var\n      frameSize = 0,\n      byteIndex = 0,\n      bytesLeft,\n      chunk,\n      packet,\n      tempLength;\n\n    // If there are bytes remaining from the last segment, prepend them to the\n    // bytes that were pushed in\n    if (everything.length) {\n      tempLength = everything.length;\n      everything = new Uint8Array(bytes.byteLength + tempLength);\n      everything.set(everything.subarray(0, tempLength));\n      everything.set(bytes, tempLength);\n    } else {\n      everything = bytes;\n    }\n\n    while (everything.length - byteIndex >= 3) {\n      if ((everything[byteIndex] === 'I'.charCodeAt(0)) &&\n          (everything[byteIndex + 1] === 'D'.charCodeAt(0)) &&\n          (everything[byteIndex + 2] === '3'.charCodeAt(0))) {\n\n        // Exit early because we don't have enough to parse\n        // the ID3 tag header\n        if (everything.length - byteIndex < 10) {\n          break;\n        }\n\n        // check framesize\n        frameSize = aacUtils.parseId3TagSize(everything, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        // Add to byteIndex to support multiple ID3 tags in sequence\n        if (byteIndex + frameSize > everything.length) {\n          break;\n        }\n        chunk = {\n          type: 'timed-metadata',\n          data: everything.subarray(byteIndex, byteIndex + frameSize)\n        };\n        this.trigger('data', chunk);\n        byteIndex += frameSize;\n        continue;\n      } else if (((everything[byteIndex] & 0xff) === 0xff) &&\n                 ((everything[byteIndex + 1] & 0xf0) === 0xf0)) {\n\n        // Exit early because we don't have enough to parse\n        // the ADTS frame header\n        if (everything.length - byteIndex < 7) {\n          break;\n        }\n\n        frameSize = aacUtils.parseAdtsSize(everything, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (byteIndex + frameSize > everything.length) {\n          break;\n        }\n\n        packet = {\n          type: 'audio',\n          data: everything.subarray(byteIndex, byteIndex + frameSize),\n          pts: timeStamp,\n          dts: timeStamp\n        };\n        this.trigger('data', packet);\n        byteIndex += frameSize;\n        continue;\n      }\n      byteIndex++;\n    }\n    bytesLeft = everything.length - byteIndex;\n\n    if (bytesLeft > 0) {\n      everything = everything.subarray(byteIndex);\n    } else {\n      everything = new Uint8Array();\n    }\n  };\n};\n\nAacStream.prototype = new Stream();\n\nmodule.exports = AacStream;\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * A stream-based mp2t to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js');\nvar mp4 = require('./mp4-generator.js');\nvar frameUtils = require('./frame-utils');\nvar audioFrameUtils = require('./audio-frame-utils');\nvar trackDecodeInfo = require('./track-decode-info');\nvar m2ts = require('../m2ts/m2ts.js');\nvar AdtsStream = require('../codecs/adts.js');\nvar H264Stream = require('../codecs/h264').H264Stream;\nvar AacStream = require('../aac');\nvar isLikelyAacData = require('../aac/utils').isLikelyAacData;\n\n// constants\nvar AUDIO_PROPERTIES = [\n  'audioobjecttype',\n  'channelcount',\n  'samplerate',\n  'samplingfrequencyindex',\n  'samplesize'\n];\n\nvar VIDEO_PROPERTIES = [\n  'width',\n  'height',\n  'profileIdc',\n  'levelIdc',\n  'profileCompatibility'\n];\n\n// object types\nvar VideoSegmentStream, AudioSegmentStream, Transmuxer, CoalesceStream;\n\n/**\n * Compare two arrays (even typed) for same-ness\n */\nvar arrayEquals = function(a, b) {\n  var\n    i;\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  // compare the value of each element in the array\n  for (i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar generateVideoSegmentTimingInfo = function(\n  baseMediaDecodeTime,\n  startDts,\n  startPts,\n  endDts,\n  endPts,\n  prependedContentDuration\n) {\n  var\n    ptsOffsetFromDts = startPts - startDts,\n    decodeDuration = endDts - startDts,\n    presentationDuration = endPts - startPts;\n\n  // The PTS and DTS values are based on the actual stream times from the segment,\n  // however, the player time values will reflect a start from the baseMediaDecodeTime.\n  // In order to provide relevant values for the player times, base timing info on the\n  // baseMediaDecodeTime and the DTS and PTS durations of the segment.\n  return {\n    start: {\n      dts: baseMediaDecodeTime,\n      pts: baseMediaDecodeTime + ptsOffsetFromDts\n    },\n    end: {\n      dts: baseMediaDecodeTime + decodeDuration,\n      pts: baseMediaDecodeTime + presentationDuration\n    },\n    prependedContentDuration: prependedContentDuration,\n    baseMediaDecodeTime: baseMediaDecodeTime\n  };\n};\n\n/**\n * Constructs a single-track, ISO BMFF media segment from AAC data\n * events. The output of this stream can be fed to a SourceBuffer\n * configured with a suitable initialization segment.\n * @param track {object} track metadata configuration\n * @param options {object} transmuxer options object\n * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n *        in the source; false to adjust the first segment to start at 0.\n */\nAudioSegmentStream = function(track, options) {\n  var\n    adtsFrames = [],\n    sequenceNumber = 0,\n    earliestAllowedDts = 0,\n    audioAppendStartTs = 0,\n    videoBaseMediaDecodeTime = Infinity;\n\n  options = options || {};\n\n  AudioSegmentStream.prototype.init.call(this);\n\n  this.push = function(data) {\n    trackDecodeInfo.collectDtsInfo(track, data);\n\n    if (track) {\n      AUDIO_PROPERTIES.forEach(function(prop) {\n        track[prop] = data[prop];\n      });\n    }\n\n    // buffer audio data until end() is called\n    adtsFrames.push(data);\n  };\n\n  this.setEarliestDts = function(earliestDts) {\n    earliestAllowedDts = earliestDts - track.timelineStartInfo.baseMediaDecodeTime;\n  };\n\n  this.setVideoBaseMediaDecodeTime = function(baseMediaDecodeTime) {\n    videoBaseMediaDecodeTime = baseMediaDecodeTime;\n  };\n\n  this.setAudioAppendStart = function(timestamp) {\n    audioAppendStartTs = timestamp;\n  };\n\n  this.flush = function() {\n    var\n      frames,\n      moof,\n      mdat,\n      boxes;\n\n    // return early if no audio data has been observed\n    if (adtsFrames.length === 0) {\n      this.trigger('done', 'AudioSegmentStream');\n      return;\n    }\n\n    frames = audioFrameUtils.trimAdtsFramesByEarliestDts(\n      adtsFrames, track, earliestAllowedDts);\n    track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(\n      track, options.keepOriginalTimestamps);\n\n    audioFrameUtils.prefixWithSilence(\n      track, frames, audioAppendStartTs, videoBaseMediaDecodeTime);\n\n    // we have to build the index from byte locations to\n    // samples (that is, adts frames) in the audio data\n    track.samples = audioFrameUtils.generateSampleTable(frames);\n\n    // concatenate the audio data to constuct the mdat\n    mdat = mp4.mdat(audioFrameUtils.concatenateFrameData(frames));\n\n    adtsFrames = [];\n\n    moof = mp4.moof(sequenceNumber, [track]);\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n\n    // bump the sequence number for next time\n    sequenceNumber++;\n\n    boxes.set(moof);\n    boxes.set(mdat, moof.byteLength);\n\n    trackDecodeInfo.clearDtsInfo(track);\n\n    this.trigger('data', {track: track, boxes: boxes});\n    this.trigger('done', 'AudioSegmentStream');\n  };\n};\n\nAudioSegmentStream.prototype = new Stream();\n\n/**\n * Constructs a single-track, ISO BMFF media segment from H264 data\n * events. The output of this stream can be fed to a SourceBuffer\n * configured with a suitable initialization segment.\n * @param track {object} track metadata configuration\n * @param options {object} transmuxer options object\n * @param options.alignGopsAtEnd {boolean} If true, start from the end of the\n *        gopsToAlignWith list when attempting to align gop pts\n * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n *        in the source; false to adjust the first segment to start at 0.\n */\nVideoSegmentStream = function(track, options) {\n  var\n    sequenceNumber = 0,\n    nalUnits = [],\n    gopsToAlignWith = [],\n    config,\n    pps;\n\n  options = options || {};\n\n  VideoSegmentStream.prototype.init.call(this);\n\n  delete track.minPTS;\n\n  this.gopCache_ = [];\n\n  /**\n    * Constructs a ISO BMFF segment given H264 nalUnits\n    * @param {Object} nalUnit A data event representing a nalUnit\n    * @param {String} nalUnit.nalUnitType\n    * @param {Object} nalUnit.config Properties for a mp4 track\n    * @param {Uint8Array} nalUnit.data The nalUnit bytes\n    * @see lib/codecs/h264.js\n   **/\n  this.push = function(nalUnit) {\n    trackDecodeInfo.collectDtsInfo(track, nalUnit);\n\n    // record the track config\n    if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n      config = nalUnit.config;\n      track.sps = [nalUnit.data];\n\n      VIDEO_PROPERTIES.forEach(function(prop) {\n        track[prop] = config[prop];\n      }, this);\n    }\n\n    if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' &&\n        !pps) {\n      pps = nalUnit.data;\n      track.pps = [nalUnit.data];\n    }\n\n    // buffer video until flush() is called\n    nalUnits.push(nalUnit);\n  };\n\n  /**\n    * Pass constructed ISO BMFF track and boxes on to the\n    * next stream in the pipeline\n   **/\n  this.flush = function() {\n    var\n      frames,\n      gopForFusion,\n      gops,\n      moof,\n      mdat,\n      boxes,\n      prependedContentDuration = 0,\n      firstGop,\n      lastGop;\n\n    // Throw away nalUnits at the start of the byte stream until\n    // we find the first AUD\n    while (nalUnits.length) {\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n        break;\n      }\n      nalUnits.shift();\n    }\n\n    // Return early if no video data has been observed\n    if (nalUnits.length === 0) {\n      this.resetStream_();\n      this.trigger('done', 'VideoSegmentStream');\n      return;\n    }\n\n    // Organize the raw nal-units into arrays that represent\n    // higher-level constructs such as frames and gops\n    // (group-of-pictures)\n    frames = frameUtils.groupNalsIntoFrames(nalUnits);\n    gops = frameUtils.groupFramesIntoGops(frames);\n\n    // If the first frame of this fragment is not a keyframe we have\n    // a problem since MSE (on Chrome) requires a leading keyframe.\n    //\n    // We have two approaches to repairing this situation:\n    // 1) GOP-FUSION:\n    //    This is where we keep track of the GOPS (group-of-pictures)\n    //    from previous fragments and attempt to find one that we can\n    //    prepend to the current fragment in order to create a valid\n    //    fragment.\n    // 2) KEYFRAME-PULLING:\n    //    Here we search for the first keyframe in the fragment and\n    //    throw away all the frames between the start of the fragment\n    //    and that keyframe. We then extend the duration and pull the\n    //    PTS of the keyframe forward so that it covers the time range\n    //    of the frames that were disposed of.\n    //\n    // #1 is far prefereable over #2 which can cause \"stuttering\" but\n    // requires more things to be just right.\n    if (!gops[0][0].keyFrame) {\n      // Search for a gop for fusion from our gopCache\n      gopForFusion = this.getGopForFusion_(nalUnits[0], track);\n\n      if (gopForFusion) {\n        // in order to provide more accurate timing information about the segment, save\n        // the number of seconds prepended to the original segment due to GOP fusion\n        prependedContentDuration = gopForFusion.duration;\n\n        gops.unshift(gopForFusion);\n        // Adjust Gops' metadata to account for the inclusion of the\n        // new gop at the beginning\n        gops.byteLength += gopForFusion.byteLength;\n        gops.nalCount += gopForFusion.nalCount;\n        gops.pts = gopForFusion.pts;\n        gops.dts = gopForFusion.dts;\n        gops.duration += gopForFusion.duration;\n      } else {\n        // If we didn't find a candidate gop fall back to keyframe-pulling\n        gops = frameUtils.extendFirstKeyFrame(gops);\n      }\n    }\n\n    // Trim gops to align with gopsToAlignWith\n    if (gopsToAlignWith.length) {\n      var alignedGops;\n\n      if (options.alignGopsAtEnd) {\n        alignedGops = this.alignGopsAtEnd_(gops);\n      } else {\n        alignedGops = this.alignGopsAtStart_(gops);\n      }\n\n      if (!alignedGops) {\n        // save all the nals in the last GOP into the gop cache\n        this.gopCache_.unshift({\n          gop: gops.pop(),\n          pps: track.pps,\n          sps: track.sps\n        });\n\n        // Keep a maximum of 6 GOPs in the cache\n        this.gopCache_.length = Math.min(6, this.gopCache_.length);\n\n        // Clear nalUnits\n        nalUnits = [];\n\n        // return early no gops can be aligned with desired gopsToAlignWith\n        this.resetStream_();\n        this.trigger('done', 'VideoSegmentStream');\n        return;\n      }\n\n      // Some gops were trimmed. clear dts info so minSegmentDts and pts are correct\n      // when recalculated before sending off to CoalesceStream\n      trackDecodeInfo.clearDtsInfo(track);\n\n      gops = alignedGops;\n    }\n\n    trackDecodeInfo.collectDtsInfo(track, gops);\n\n    // First, we have to build the index from byte locations to\n    // samples (that is, frames) in the video data\n    track.samples = frameUtils.generateSampleTable(gops);\n\n    // Concatenate the video data and construct the mdat\n    mdat = mp4.mdat(frameUtils.concatenateNalData(gops));\n\n    track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(\n      track, options.keepOriginalTimestamps);\n\n    this.trigger('processedGopsInfo', gops.map(function(gop) {\n      return {\n        pts: gop.pts,\n        dts: gop.dts,\n        byteLength: gop.byteLength\n      };\n    }));\n\n    firstGop = gops[0];\n    lastGop = gops[gops.length - 1];\n\n    this.trigger(\n      'segmentTimingInfo',\n      generateVideoSegmentTimingInfo(\n        track.baseMediaDecodeTime,\n        firstGop.dts,\n        firstGop.pts,\n        lastGop.dts + lastGop.duration,\n        lastGop.pts + lastGop.duration,\n        prependedContentDuration));\n\n    // save all the nals in the last GOP into the gop cache\n    this.gopCache_.unshift({\n      gop: gops.pop(),\n      pps: track.pps,\n      sps: track.sps\n    });\n\n    // Keep a maximum of 6 GOPs in the cache\n    this.gopCache_.length = Math.min(6, this.gopCache_.length);\n\n    // Clear nalUnits\n    nalUnits = [];\n\n    this.trigger('baseMediaDecodeTime', track.baseMediaDecodeTime);\n    this.trigger('timelineStartInfo', track.timelineStartInfo);\n\n    moof = mp4.moof(sequenceNumber, [track]);\n\n    // it would be great to allocate this array up front instead of\n    // throwing away hundreds of media segment fragments\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n\n    // Bump the sequence number for next time\n    sequenceNumber++;\n\n    boxes.set(moof);\n    boxes.set(mdat, moof.byteLength);\n\n    this.trigger('data', {track: track, boxes: boxes});\n\n    this.resetStream_();\n\n    // Continue with the flush process now\n    this.trigger('done', 'VideoSegmentStream');\n  };\n\n  this.resetStream_ = function() {\n    trackDecodeInfo.clearDtsInfo(track);\n\n    // reset config and pps because they may differ across segments\n    // for instance, when we are rendition switching\n    config = undefined;\n    pps = undefined;\n  };\n\n  // Search for a candidate Gop for gop-fusion from the gop cache and\n  // return it or return null if no good candidate was found\n  this.getGopForFusion_ = function(nalUnit) {\n    var\n      halfSecond = 45000, // Half-a-second in a 90khz clock\n      allowableOverlap = 10000, // About 3 frames @ 30fps\n      nearestDistance = Infinity,\n      dtsDistance,\n      nearestGopObj,\n      currentGop,\n      currentGopObj,\n      i;\n\n    // Search for the GOP nearest to the beginning of this nal unit\n    for (i = 0; i < this.gopCache_.length; i++) {\n      currentGopObj = this.gopCache_[i];\n      currentGop = currentGopObj.gop;\n\n      // Reject Gops with different SPS or PPS\n      if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) ||\n          !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\n        continue;\n      }\n\n      // Reject Gops that would require a negative baseMediaDecodeTime\n      if (currentGop.dts < track.timelineStartInfo.dts) {\n        continue;\n      }\n\n      // The distance between the end of the gop and the start of the nalUnit\n      dtsDistance = (nalUnit.dts - currentGop.dts) - currentGop.duration;\n\n      // Only consider GOPS that start before the nal unit and end within\n      // a half-second of the nal unit\n      if (dtsDistance >= -allowableOverlap &&\n          dtsDistance <= halfSecond) {\n\n        // Always use the closest GOP we found if there is more than\n        // one candidate\n        if (!nearestGopObj ||\n            nearestDistance > dtsDistance) {\n          nearestGopObj = currentGopObj;\n          nearestDistance = dtsDistance;\n        }\n      }\n    }\n\n    if (nearestGopObj) {\n      return nearestGopObj.gop;\n    }\n    return null;\n  };\n\n  // trim gop list to the first gop found that has a matching pts with a gop in the list\n  // of gopsToAlignWith starting from the START of the list\n  this.alignGopsAtStart_ = function(gops) {\n    var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;\n\n    byteLength = gops.byteLength;\n    nalCount = gops.nalCount;\n    duration = gops.duration;\n    alignIndex = gopIndex = 0;\n\n    while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {\n      align = gopsToAlignWith[alignIndex];\n      gop = gops[gopIndex];\n\n      if (align.pts === gop.pts) {\n        break;\n      }\n\n      if (gop.pts > align.pts) {\n        // this current gop starts after the current gop we want to align on, so increment\n        // align index\n        alignIndex++;\n        continue;\n      }\n\n      // current gop starts before the current gop we want to align on. so increment gop\n      // index\n      gopIndex++;\n      byteLength -= gop.byteLength;\n      nalCount -= gop.nalCount;\n      duration -= gop.duration;\n    }\n\n    if (gopIndex === 0) {\n      // no gops to trim\n      return gops;\n    }\n\n    if (gopIndex === gops.length) {\n      // all gops trimmed, skip appending all gops\n      return null;\n    }\n\n    alignedGops = gops.slice(gopIndex);\n    alignedGops.byteLength = byteLength;\n    alignedGops.duration = duration;\n    alignedGops.nalCount = nalCount;\n    alignedGops.pts = alignedGops[0].pts;\n    alignedGops.dts = alignedGops[0].dts;\n\n    return alignedGops;\n  };\n\n  // trim gop list to the first gop found that has a matching pts with a gop in the list\n  // of gopsToAlignWith starting from the END of the list\n  this.alignGopsAtEnd_ = function(gops) {\n    var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;\n\n    alignIndex = gopsToAlignWith.length - 1;\n    gopIndex = gops.length - 1;\n    alignEndIndex = null;\n    matchFound = false;\n\n    while (alignIndex >= 0 && gopIndex >= 0) {\n      align = gopsToAlignWith[alignIndex];\n      gop = gops[gopIndex];\n\n      if (align.pts === gop.pts) {\n        matchFound = true;\n        break;\n      }\n\n      if (align.pts > gop.pts) {\n        alignIndex--;\n        continue;\n      }\n\n      if (alignIndex === gopsToAlignWith.length - 1) {\n        // gop.pts is greater than the last alignment candidate. If no match is found\n        // by the end of this loop, we still want to append gops that come after this\n        // point\n        alignEndIndex = gopIndex;\n      }\n\n      gopIndex--;\n    }\n\n    if (!matchFound && alignEndIndex === null) {\n      return null;\n    }\n\n    var trimIndex;\n\n    if (matchFound) {\n      trimIndex = gopIndex;\n    } else {\n      trimIndex = alignEndIndex;\n    }\n\n    if (trimIndex === 0) {\n      return gops;\n    }\n\n    var alignedGops = gops.slice(trimIndex);\n    var metadata = alignedGops.reduce(function(total, gop) {\n      total.byteLength += gop.byteLength;\n      total.duration += gop.duration;\n      total.nalCount += gop.nalCount;\n      return total;\n    }, { byteLength: 0, duration: 0, nalCount: 0 });\n\n    alignedGops.byteLength = metadata.byteLength;\n    alignedGops.duration = metadata.duration;\n    alignedGops.nalCount = metadata.nalCount;\n    alignedGops.pts = alignedGops[0].pts;\n    alignedGops.dts = alignedGops[0].dts;\n\n    return alignedGops;\n  };\n\n  this.alignGopsWith = function(newGopsToAlignWith) {\n    gopsToAlignWith = newGopsToAlignWith;\n  };\n};\n\nVideoSegmentStream.prototype = new Stream();\n\n/**\n * A Stream that can combine multiple streams (ie. audio & video)\n * into a single output segment for MSE. Also supports audio-only\n * and video-only streams.\n * @param options {object} transmuxer options object\n * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n *        in the source; false to adjust the first segment to start at media timeline start.\n */\nCoalesceStream = function(options, metadataStream) {\n  // Number of Tracks per output segment\n  // If greater than 1, we combine multiple\n  // tracks into a single segment\n  this.numberOfTracks = 0;\n  this.metadataStream = metadataStream;\n\n  options = options || {};\n\n  if (typeof options.remux !== 'undefined') {\n    this.remuxTracks = !!options.remux;\n  } else {\n    this.remuxTracks = true;\n  }\n\n  if (typeof options.keepOriginalTimestamps === 'boolean') {\n    this.keepOriginalTimestamps = options.keepOriginalTimestamps;\n  }\n\n  this.pendingTracks = [];\n  this.videoTrack = null;\n  this.pendingBoxes = [];\n  this.pendingCaptions = [];\n  this.pendingMetadata = [];\n  this.pendingBytes = 0;\n  this.emittedTracks = 0;\n\n  CoalesceStream.prototype.init.call(this);\n\n  // Take output from multiple\n  this.push = function(output) {\n    // buffer incoming captions until the associated video segment\n    // finishes\n    if (output.text) {\n      return this.pendingCaptions.push(output);\n    }\n    // buffer incoming id3 tags until the final flush\n    if (output.frames) {\n      return this.pendingMetadata.push(output);\n    }\n\n    // Add this track to the list of pending tracks and store\n    // important information required for the construction of\n    // the final segment\n    this.pendingTracks.push(output.track);\n    this.pendingBoxes.push(output.boxes);\n    this.pendingBytes += output.boxes.byteLength;\n\n    if (output.track.type === 'video') {\n      this.videoTrack = output.track;\n    }\n    if (output.track.type === 'audio') {\n      this.audioTrack = output.track;\n    }\n  };\n};\n\nCoalesceStream.prototype = new Stream();\nCoalesceStream.prototype.flush = function(flushSource) {\n  var\n    offset = 0,\n    event = {\n      captions: [],\n      captionStreams: {},\n      metadata: [],\n      info: {}\n    },\n    caption,\n    id3,\n    initSegment,\n    timelineStartPts = 0,\n    i;\n\n  if (this.pendingTracks.length < this.numberOfTracks) {\n    if (flushSource !== 'VideoSegmentStream' &&\n        flushSource !== 'AudioSegmentStream') {\n      // Return because we haven't received a flush from a data-generating\n      // portion of the segment (meaning that we have only recieved meta-data\n      // or captions.)\n      return;\n    } else if (this.remuxTracks) {\n      // Return until we have enough tracks from the pipeline to remux (if we\n      // are remuxing audio and video into a single MP4)\n      return;\n    } else if (this.pendingTracks.length === 0) {\n      // In the case where we receive a flush without any data having been\n      // received we consider it an emitted track for the purposes of coalescing\n      // `done` events.\n      // We do this for the case where there is an audio and video track in the\n      // segment but no audio data. (seen in several playlists with alternate\n      // audio tracks and no audio present in the main TS segments.)\n      this.emittedTracks++;\n\n      if (this.emittedTracks >= this.numberOfTracks) {\n        this.trigger('done');\n        this.emittedTracks = 0;\n      }\n      return;\n    }\n  }\n\n  if (this.videoTrack) {\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n    VIDEO_PROPERTIES.forEach(function(prop) {\n      event.info[prop] = this.videoTrack[prop];\n    }, this);\n  } else if (this.audioTrack) {\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n    AUDIO_PROPERTIES.forEach(function(prop) {\n      event.info[prop] = this.audioTrack[prop];\n    }, this);\n  }\n\n  if (this.pendingTracks.length === 1) {\n    event.type = this.pendingTracks[0].type;\n  } else {\n    event.type = 'combined';\n  }\n\n  this.emittedTracks += this.pendingTracks.length;\n\n  initSegment = mp4.initSegment(this.pendingTracks);\n\n  // Create a new typed array to hold the init segment\n  event.initSegment = new Uint8Array(initSegment.byteLength);\n\n  // Create an init segment containing a moov\n  // and track definitions\n  event.initSegment.set(initSegment);\n\n  // Create a new typed array to hold the moof+mdats\n  event.data = new Uint8Array(this.pendingBytes);\n\n  // Append each moof+mdat (one per track) together\n  for (i = 0; i < this.pendingBoxes.length; i++) {\n    event.data.set(this.pendingBoxes[i], offset);\n    offset += this.pendingBoxes[i].byteLength;\n  }\n\n  // Translate caption PTS times into second offsets to match the\n  // video timeline for the segment, and add track info\n  for (i = 0; i < this.pendingCaptions.length; i++) {\n    caption = this.pendingCaptions[i];\n\n    caption.startTime = caption.startPts;\n    if (!this.keepOriginalTimestamps) {\n      caption.startTime -= timelineStartPts;\n    }\n    caption.startTime /= 90e3;\n\n    caption.endTime = caption.endPts;\n    if (!this.keepOriginalTimestamps) {\n      caption.endTime -= timelineStartPts;\n    }\n    caption.endTime /= 90e3;\n\n    event.captionStreams[caption.stream] = true;\n    event.captions.push(caption);\n  }\n\n  // Translate ID3 frame PTS times into second offsets to match the\n  // video timeline for the segment\n  for (i = 0; i < this.pendingMetadata.length; i++) {\n    id3 = this.pendingMetadata[i];\n\n    id3.cueTime = id3.pts;\n    if (!this.keepOriginalTimestamps) {\n      id3.cueTime -= timelineStartPts;\n    }\n    id3.cueTime /= 90e3;\n\n    event.metadata.push(id3);\n  }\n\n  // We add this to every single emitted segment even though we only need\n  // it for the first\n  event.metadata.dispatchType = this.metadataStream.dispatchType;\n\n  // Reset stream state\n  this.pendingTracks.length = 0;\n  this.videoTrack = null;\n  this.pendingBoxes.length = 0;\n  this.pendingCaptions.length = 0;\n  this.pendingBytes = 0;\n  this.pendingMetadata.length = 0;\n\n  // Emit the built segment\n  this.trigger('data', event);\n\n  // Only emit `done` if all tracks have been flushed and emitted\n  if (this.emittedTracks >= this.numberOfTracks) {\n    this.trigger('done');\n    this.emittedTracks = 0;\n  }\n};\n/**\n * A Stream that expects MP2T binary data as input and produces\n * corresponding media segments, suitable for use with Media Source\n * Extension (MSE) implementations that support the ISO BMFF byte\n * stream format, like Chrome.\n */\nTransmuxer = function(options) {\n  var\n    self = this,\n    hasFlushed = true,\n    videoTrack,\n    audioTrack;\n\n  Transmuxer.prototype.init.call(this);\n\n  options = options || {};\n  this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n  this.transmuxPipeline_ = {};\n\n  this.setupAacPipeline = function() {\n    var pipeline = {};\n    this.transmuxPipeline_ = pipeline;\n\n    pipeline.type = 'aac';\n    pipeline.metadataStream = new m2ts.MetadataStream();\n\n    // set up the parsing pipeline\n    pipeline.aacStream = new AacStream();\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n    pipeline.adtsStream = new AdtsStream();\n    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n    pipeline.headOfPipeline = pipeline.aacStream;\n\n    pipeline.aacStream\n      .pipe(pipeline.audioTimestampRolloverStream)\n      .pipe(pipeline.adtsStream);\n    pipeline.aacStream\n      .pipe(pipeline.timedMetadataTimestampRolloverStream)\n      .pipe(pipeline.metadataStream)\n      .pipe(pipeline.coalesceStream);\n\n    pipeline.metadataStream.on('timestamp', function(frame) {\n      pipeline.aacStream.setTimestamp(frame.timeStamp);\n    });\n\n    pipeline.aacStream.on('data', function(data) {\n      if (data.type === 'timed-metadata' && !pipeline.audioSegmentStream) {\n        audioTrack = audioTrack || {\n          timelineStartInfo: {\n            baseMediaDecodeTime: self.baseMediaDecodeTime\n          },\n          codec: 'adts',\n          type: 'audio'\n        };\n        // hook up the audio segment stream to the first track with aac data\n        pipeline.coalesceStream.numberOfTracks++;\n        pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);\n        // Set up the final part of the audio pipeline\n        pipeline.adtsStream\n          .pipe(pipeline.audioSegmentStream)\n          .pipe(pipeline.coalesceStream);\n      }\n    });\n\n    // Re-emit any data coming from the coalesce stream to the outside world\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n    // Let the consumer know we have finished flushing the entire pipeline\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n  };\n\n  this.setupTsPipeline = function() {\n    var pipeline = {};\n    this.transmuxPipeline_ = pipeline;\n\n    pipeline.type = 'ts';\n    pipeline.metadataStream = new m2ts.MetadataStream();\n\n    // set up the parsing pipeline\n    pipeline.packetStream = new m2ts.TransportPacketStream();\n    pipeline.parseStream = new m2ts.TransportParseStream();\n    pipeline.elementaryStream = new m2ts.ElementaryStream();\n    pipeline.videoTimestampRolloverStream = new m2ts.TimestampRolloverStream('video');\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n    pipeline.adtsStream = new AdtsStream();\n    pipeline.h264Stream = new H264Stream();\n    pipeline.captionStream = new m2ts.CaptionStream();\n    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n    pipeline.headOfPipeline = pipeline.packetStream;\n\n    // disassemble MPEG2-TS packets into elementary streams\n    pipeline.packetStream\n      .pipe(pipeline.parseStream)\n      .pipe(pipeline.elementaryStream);\n\n    // !!THIS ORDER IS IMPORTANT!!\n    // demux the streams\n    pipeline.elementaryStream\n      .pipe(pipeline.videoTimestampRolloverStream)\n      .pipe(pipeline.h264Stream);\n    pipeline.elementaryStream\n      .pipe(pipeline.audioTimestampRolloverStream)\n      .pipe(pipeline.adtsStream);\n\n    pipeline.elementaryStream\n      .pipe(pipeline.timedMetadataTimestampRolloverStream)\n      .pipe(pipeline.metadataStream)\n      .pipe(pipeline.coalesceStream);\n\n    // Hook up CEA-608/708 caption stream\n    pipeline.h264Stream.pipe(pipeline.captionStream)\n      .pipe(pipeline.coalesceStream);\n\n    pipeline.elementaryStream.on('data', function(data) {\n      var i;\n\n      if (data.type === 'metadata') {\n        i = data.tracks.length;\n\n        // scan the tracks listed in the metadata\n        while (i--) {\n          if (!videoTrack && data.tracks[i].type === 'video') {\n            videoTrack = data.tracks[i];\n            videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n          } else if (!audioTrack && data.tracks[i].type === 'audio') {\n            audioTrack = data.tracks[i];\n            audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n          }\n        }\n\n        // hook up the video segment stream to the first track with h264 data\n        if (videoTrack && !pipeline.videoSegmentStream) {\n          pipeline.coalesceStream.numberOfTracks++;\n          pipeline.videoSegmentStream = new VideoSegmentStream(videoTrack, options);\n\n          pipeline.videoSegmentStream.on('timelineStartInfo', function(timelineStartInfo) {\n          // When video emits timelineStartInfo data after a flush, we forward that\n          // info to the AudioSegmentStream, if it exists, because video timeline\n          // data takes precedence.\n            if (audioTrack) {\n              audioTrack.timelineStartInfo = timelineStartInfo;\n              // On the first segment we trim AAC frames that exist before the\n              // very earliest DTS we have seen in video because Chrome will\n              // interpret any video track with a baseMediaDecodeTime that is\n              // non-zero as a gap.\n              pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts);\n            }\n          });\n\n          pipeline.videoSegmentStream.on('processedGopsInfo',\n            self.trigger.bind(self, 'gopInfo'));\n          pipeline.videoSegmentStream.on('segmentTimingInfo',\n            self.trigger.bind(self, 'videoSegmentTimingInfo'));\n\n          pipeline.videoSegmentStream.on('baseMediaDecodeTime', function(baseMediaDecodeTime) {\n            if (audioTrack) {\n              pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);\n            }\n          });\n\n          // Set up the final part of the video pipeline\n          pipeline.h264Stream\n            .pipe(pipeline.videoSegmentStream)\n            .pipe(pipeline.coalesceStream);\n        }\n\n        if (audioTrack && !pipeline.audioSegmentStream) {\n          // hook up the audio segment stream to the first track with aac data\n          pipeline.coalesceStream.numberOfTracks++;\n          pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);\n\n          // Set up the final part of the audio pipeline\n          pipeline.adtsStream\n            .pipe(pipeline.audioSegmentStream)\n            .pipe(pipeline.coalesceStream);\n        }\n      }\n    });\n\n    // Re-emit any data coming from the coalesce stream to the outside world\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n    // Let the consumer know we have finished flushing the entire pipeline\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n  };\n\n  // hook up the segment streams once track metadata is delivered\n  this.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {\n    var pipeline = this.transmuxPipeline_;\n\n    if (!options.keepOriginalTimestamps) {\n      this.baseMediaDecodeTime = baseMediaDecodeTime;\n    }\n\n    if (audioTrack) {\n      audioTrack.timelineStartInfo.dts = undefined;\n      audioTrack.timelineStartInfo.pts = undefined;\n      trackDecodeInfo.clearDtsInfo(audioTrack);\n      if (!options.keepOriginalTimestamps) {\n        audioTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\n      }\n      if (pipeline.audioTimestampRolloverStream) {\n        pipeline.audioTimestampRolloverStream.discontinuity();\n      }\n    }\n    if (videoTrack) {\n      if (pipeline.videoSegmentStream) {\n        pipeline.videoSegmentStream.gopCache_ = [];\n        pipeline.videoTimestampRolloverStream.discontinuity();\n      }\n      videoTrack.timelineStartInfo.dts = undefined;\n      videoTrack.timelineStartInfo.pts = undefined;\n      trackDecodeInfo.clearDtsInfo(videoTrack);\n      pipeline.captionStream.reset();\n      if (!options.keepOriginalTimestamps) {\n        videoTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\n      }\n    }\n\n    if (pipeline.timedMetadataTimestampRolloverStream) {\n      pipeline.timedMetadataTimestampRolloverStream.discontinuity();\n    }\n  };\n\n  this.setAudioAppendStart = function(timestamp) {\n    if (audioTrack) {\n      this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);\n    }\n  };\n\n  this.alignGopsWith = function(gopsToAlignWith) {\n    if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {\n      this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);\n    }\n  };\n\n  // feed incoming data to the front of the parsing pipeline\n  this.push = function(data) {\n    if (hasFlushed) {\n      var isAac = isLikelyAacData(data);\n\n      if (isAac && this.transmuxPipeline_.type !== 'aac') {\n        this.setupAacPipeline();\n      } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\n        this.setupTsPipeline();\n      }\n      hasFlushed = false;\n    }\n    this.transmuxPipeline_.headOfPipeline.push(data);\n  };\n\n  // flush any buffered data\n  this.flush = function() {\n      hasFlushed = true;\n    // Start at the top of the pipeline and flush all pending work\n    this.transmuxPipeline_.headOfPipeline.flush();\n  };\n\n  // Caption data has to be reset when seeking outside buffered range\n  this.resetCaptions = function() {\n    if (this.transmuxPipeline_.captionStream) {\n      this.transmuxPipeline_.captionStream.reset();\n    }\n  };\n\n};\nTransmuxer.prototype = new Stream();\n\nmodule.exports = {\n  Transmuxer: Transmuxer,\n  VideoSegmentStream: VideoSegmentStream,\n  AudioSegmentStream: AudioSegmentStream,\n  AUDIO_PROPERTIES: AUDIO_PROPERTIES,\n  VIDEO_PROPERTIES: VIDEO_PROPERTIES,\n  // exported for testing\n  generateVideoSegmentTimingInfo: generateVideoSegmentTimingInfo\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Parse the internal MP4 structure into an equivalent javascript\n * object.\n */\n'use strict';\n\nvar\n  inspectMp4,\n  textifyMp4,\n\n  parseType = require('../mp4/probe').parseType,\n  parseMp4Date = function(seconds) {\n    return new Date(seconds * 1000 - 2082844800000);\n  },\n  parseSampleFlags = function(flags) {\n    return {\n      isLeading: (flags[0] & 0x0c) >>> 2,\n      dependsOn: flags[0] & 0x03,\n      isDependedOn: (flags[1] & 0xc0) >>> 6,\n      hasRedundancy: (flags[1] & 0x30) >>> 4,\n      paddingValue: (flags[1] & 0x0e) >>> 1,\n      isNonSyncSample: flags[1] & 0x01,\n      degradationPriority: (flags[2] << 8) | flags[3]\n    };\n  },\n  nalParse = function(avcStream) {\n    var\n      avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n      result = [],\n      i,\n      length;\n    for (i = 0; i + 4 < avcStream.length; i += length) {\n      length = avcView.getUint32(i);\n      i += 4;\n\n      // bail if this doesn't appear to be an H264 stream\n      if (length <= 0) {\n        result.push('<span style=\\'color:red;\\'>MALFORMED DATA</span>');\n        continue;\n      }\n\n      switch (avcStream[i] & 0x1F) {\n      case 0x01:\n        result.push('slice_layer_without_partitioning_rbsp');\n        break;\n      case 0x05:\n        result.push('slice_layer_without_partitioning_rbsp_idr');\n        break;\n      case 0x06:\n        result.push('sei_rbsp');\n        break;\n      case 0x07:\n        result.push('seq_parameter_set_rbsp');\n        break;\n      case 0x08:\n        result.push('pic_parameter_set_rbsp');\n        break;\n      case 0x09:\n        result.push('access_unit_delimiter_rbsp');\n        break;\n      default:\n        result.push('UNKNOWN NAL - ' + avcStream[i] & 0x1F);\n        break;\n      }\n    }\n    return result;\n  },\n\n  // registry of handlers for individual mp4 box types\n  parse = {\n    // codingname, not a first-class box type. stsd entries share the\n    // same format as real boxes so the parsing infrastructure can be\n    // shared\n    avc1: function(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        dataReferenceIndex: view.getUint16(6),\n        width: view.getUint16(24),\n        height: view.getUint16(26),\n        horizresolution: view.getUint16(28) + (view.getUint16(30) / 16),\n        vertresolution: view.getUint16(32) + (view.getUint16(34) / 16),\n        frameCount: view.getUint16(40),\n        depth: view.getUint16(74),\n        config: inspectMp4(data.subarray(78, data.byteLength))\n      };\n    },\n    avcC: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          configurationVersion: data[0],\n          avcProfileIndication: data[1],\n          profileCompatibility: data[2],\n          avcLevelIndication: data[3],\n          lengthSizeMinusOne: data[4] & 0x03,\n          sps: [],\n          pps: []\n        },\n        numOfSequenceParameterSets = data[5] & 0x1f,\n        numOfPictureParameterSets,\n        nalSize,\n        offset,\n        i;\n\n      // iterate past any SPSs\n      offset = 6;\n      for (i = 0; i < numOfSequenceParameterSets; i++) {\n        nalSize = view.getUint16(offset);\n        offset += 2;\n        result.sps.push(new Uint8Array(data.subarray(offset, offset + nalSize)));\n        offset += nalSize;\n      }\n      // iterate past any PPSs\n      numOfPictureParameterSets = data[offset];\n      offset++;\n      for (i = 0; i < numOfPictureParameterSets; i++) {\n        nalSize = view.getUint16(offset);\n        offset += 2;\n        result.pps.push(new Uint8Array(data.subarray(offset, offset + nalSize)));\n        offset += nalSize;\n      }\n      return result;\n    },\n    btrt: function(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        bufferSizeDB: view.getUint32(0),\n        maxBitrate: view.getUint32(4),\n        avgBitrate: view.getUint32(8)\n      };\n    },\n    esds: function(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        esId: (data[6] << 8) | data[7],\n        streamPriority: data[8] & 0x1f,\n        decoderConfig: {\n          objectProfileIndication: data[11],\n          streamType: (data[12] >>> 2) & 0x3f,\n          bufferSize: (data[13] << 16) | (data[14] << 8) | data[15],\n          maxBitrate: (data[16] << 24) |\n            (data[17] << 16) |\n            (data[18] <<  8) |\n            data[19],\n          avgBitrate: (data[20] << 24) |\n            (data[21] << 16) |\n            (data[22] <<  8) |\n            data[23],\n          decoderConfigDescriptor: {\n            tag: data[24],\n            length: data[25],\n            audioObjectType: (data[26] >>> 3) & 0x1f,\n            samplingFrequencyIndex: ((data[26] & 0x07) << 1) |\n              ((data[27] >>> 7) & 0x01),\n            channelConfiguration: (data[27] >>> 3) & 0x0f\n          }\n        }\n      };\n    },\n    ftyp: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          majorBrand: parseType(data.subarray(0, 4)),\n          minorVersion: view.getUint32(4),\n          compatibleBrands: []\n        },\n        i = 8;\n      while (i < data.byteLength) {\n        result.compatibleBrands.push(parseType(data.subarray(i, i + 4)));\n        i += 4;\n      }\n      return result;\n    },\n    dinf: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    dref: function(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        dataReferences: inspectMp4(data.subarray(8))\n      };\n    },\n    hdlr: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          version: view.getUint8(0),\n          flags: new Uint8Array(data.subarray(1, 4)),\n          handlerType: parseType(data.subarray(8, 12)),\n          name: ''\n        },\n        i = 8;\n\n      // parse out the name field\n      for (i = 24; i < data.byteLength; i++) {\n        if (data[i] === 0x00) {\n          // the name field is null-terminated\n          i++;\n          break;\n        }\n        result.name += String.fromCharCode(data[i]);\n      }\n      // decode UTF-8 to javascript's internal representation\n      // see http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\n      result.name = decodeURIComponent(escape(result.name));\n\n      return result;\n    },\n    mdat: function(data) {\n      return {\n        byteLength: data.byteLength,\n        nals: nalParse(data)\n      };\n    },\n    mdhd: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        i = 4,\n        language,\n        result = {\n          version: view.getUint8(0),\n          flags: new Uint8Array(data.subarray(1, 4)),\n          language: ''\n        };\n      if (result.version === 1) {\n        i += 4;\n        result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n        i += 8;\n        result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 8;\n        result.duration = view.getUint32(i); // truncating top 4 bytes\n      } else {\n        result.creationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.modificationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 4;\n        result.duration = view.getUint32(i);\n      }\n      i += 4;\n      // language is stored as an ISO-639-2/T code in an array of three 5-bit fields\n      // each field is the packed difference between its ASCII value and 0x60\n      language = view.getUint16(i);\n      result.language += String.fromCharCode((language >> 10) + 0x60);\n      result.language += String.fromCharCode(((language & 0x03e0) >> 5) + 0x60);\n      result.language += String.fromCharCode((language & 0x1f) + 0x60);\n\n      return result;\n    },\n    mdia: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    mfhd: function(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        sequenceNumber: (data[4] << 24) |\n          (data[5] << 16) |\n          (data[6] << 8) |\n          (data[7])\n      };\n    },\n    minf: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    // codingname, not a first-class box type. stsd entries share the\n    // same format as real boxes so the parsing infrastructure can be\n    // shared\n    mp4a: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          // 6 bytes reserved\n          dataReferenceIndex: view.getUint16(6),\n          // 4 + 4 bytes reserved\n          channelcount: view.getUint16(16),\n          samplesize: view.getUint16(18),\n          // 2 bytes pre_defined\n          // 2 bytes reserved\n          samplerate: view.getUint16(24) + (view.getUint16(26) / 65536)\n        };\n\n      // if there are more bytes to process, assume this is an ISO/IEC\n      // 14496-14 MP4AudioSampleEntry and parse the ESDBox\n      if (data.byteLength > 28) {\n        result.streamDescriptor = inspectMp4(data.subarray(28))[0];\n      }\n      return result;\n    },\n    moof: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    moov: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    mvex: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    mvhd: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        i = 4,\n        result = {\n          version: view.getUint8(0),\n          flags: new Uint8Array(data.subarray(1, 4))\n        };\n\n      if (result.version === 1) {\n        i += 4;\n        result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n        i += 8;\n        result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 8;\n        result.duration = view.getUint32(i); // truncating top 4 bytes\n      } else {\n        result.creationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.modificationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 4;\n        result.duration = view.getUint32(i);\n      }\n      i += 4;\n\n      // convert fixed-point, base 16 back to a number\n      result.rate = view.getUint16(i) + (view.getUint16(i + 2) / 16);\n      i += 4;\n      result.volume = view.getUint8(i) + (view.getUint8(i + 1) / 8);\n      i += 2;\n      i += 2;\n      i += 2 * 4;\n      result.matrix = new Uint32Array(data.subarray(i, i + (9 * 4)));\n      i += 9 * 4;\n      i += 6 * 4;\n      result.nextTrackId = view.getUint32(i);\n      return result;\n    },\n    pdin: function(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        rate: view.getUint32(4),\n        initialDelay: view.getUint32(8)\n      };\n    },\n    sdtp: function(data) {\n      var\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          samples: []\n        }, i;\n\n      for (i = 4; i < data.byteLength; i++) {\n        result.samples.push({\n          dependsOn: (data[i] & 0x30) >> 4,\n          isDependedOn: (data[i] & 0x0c) >> 2,\n          hasRedundancy: data[i] & 0x03\n        });\n      }\n      return result;\n    },\n    sidx: function(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n            version: data[0],\n            flags: new Uint8Array(data.subarray(1, 4)),\n            references: [],\n            referenceId: view.getUint32(4),\n            timescale: view.getUint32(8),\n            earliestPresentationTime: view.getUint32(12),\n            firstOffset: view.getUint32(16)\n          },\n          referenceCount = view.getUint16(22),\n          i;\n\n      for (i = 24; referenceCount; i += 12, referenceCount--) {\n        result.references.push({\n          referenceType: (data[i] & 0x80) >>> 7,\n          referencedSize: view.getUint32(i) & 0x7FFFFFFF,\n          subsegmentDuration: view.getUint32(i + 4),\n          startsWithSap: !!(data[i + 8] & 0x80),\n          sapType: (data[i + 8] & 0x70) >>> 4,\n          sapDeltaTime: view.getUint32(i + 8) & 0x0FFFFFFF\n        });\n      }\n\n      return result;\n    },\n    smhd: function(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        balance: data[4] + (data[5] / 256)\n      };\n    },\n    stbl: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    stco: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          chunkOffsets: []\n        },\n        entryCount = view.getUint32(4),\n        i;\n      for (i = 8; entryCount; i += 4, entryCount--) {\n        result.chunkOffsets.push(view.getUint32(i));\n      }\n      return result;\n    },\n    stsc: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        entryCount = view.getUint32(4),\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          sampleToChunks: []\n        },\n        i;\n      for (i = 8; entryCount; i += 12, entryCount--) {\n        result.sampleToChunks.push({\n          firstChunk: view.getUint32(i),\n          samplesPerChunk: view.getUint32(i + 4),\n          sampleDescriptionIndex: view.getUint32(i + 8)\n        });\n      }\n      return result;\n    },\n    stsd: function(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        sampleDescriptions: inspectMp4(data.subarray(8))\n      };\n    },\n    stsz: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          sampleSize: view.getUint32(4),\n          entries: []\n        },\n        i;\n      for (i = 12; i < data.byteLength; i += 4) {\n        result.entries.push(view.getUint32(i));\n      }\n      return result;\n    },\n    stts: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          timeToSamples: []\n        },\n        entryCount = view.getUint32(4),\n        i;\n\n      for (i = 8; entryCount; i += 8, entryCount--) {\n        result.timeToSamples.push({\n          sampleCount: view.getUint32(i),\n          sampleDelta: view.getUint32(i + 4)\n        });\n      }\n      return result;\n    },\n    styp: function(data) {\n      return parse.ftyp(data);\n    },\n    tfdt: function(data) {\n      var result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        baseMediaDecodeTime: data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]\n      };\n      if (result.version === 1) {\n        result.baseMediaDecodeTime *= Math.pow(2, 32);\n        result.baseMediaDecodeTime += data[8] << 24 | data[9] << 16 | data[10] << 8 | data[11];\n      }\n      return result;\n    },\n    tfhd: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          trackId: view.getUint32(4)\n        },\n        baseDataOffsetPresent = result.flags[2] & 0x01,\n        sampleDescriptionIndexPresent = result.flags[2] & 0x02,\n        defaultSampleDurationPresent = result.flags[2] & 0x08,\n        defaultSampleSizePresent = result.flags[2] & 0x10,\n        defaultSampleFlagsPresent = result.flags[2] & 0x20,\n        durationIsEmpty = result.flags[0] & 0x010000,\n        defaultBaseIsMoof =  result.flags[0] & 0x020000,\n        i;\n\n      i = 8;\n      if (baseDataOffsetPresent) {\n        i += 4; // truncate top 4 bytes\n        // FIXME: should we read the full 64 bits?\n        result.baseDataOffset = view.getUint32(12);\n        i += 4;\n      }\n      if (sampleDescriptionIndexPresent) {\n        result.sampleDescriptionIndex = view.getUint32(i);\n        i += 4;\n      }\n      if (defaultSampleDurationPresent) {\n        result.defaultSampleDuration = view.getUint32(i);\n        i += 4;\n      }\n      if (defaultSampleSizePresent) {\n        result.defaultSampleSize = view.getUint32(i);\n        i += 4;\n      }\n      if (defaultSampleFlagsPresent) {\n        result.defaultSampleFlags = view.getUint32(i);\n      }\n      if (durationIsEmpty) {\n        result.durationIsEmpty = true;\n      }\n      if (!baseDataOffsetPresent && defaultBaseIsMoof) {\n        result.baseDataOffsetIsMoof = true;\n      }\n      return result;\n    },\n    tkhd: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        i = 4,\n        result = {\n          version: view.getUint8(0),\n          flags: new Uint8Array(data.subarray(1, 4))\n        };\n      if (result.version === 1) {\n        i += 4;\n        result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n        i += 8;\n        result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n        i += 4;\n        result.trackId = view.getUint32(i);\n        i += 4;\n        i += 8;\n        result.duration = view.getUint32(i); // truncating top 4 bytes\n      } else {\n        result.creationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.modificationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.trackId = view.getUint32(i);\n        i += 4;\n        i += 4;\n        result.duration = view.getUint32(i);\n      }\n      i += 4;\n      i += 2 * 4;\n      result.layer = view.getUint16(i);\n      i += 2;\n      result.alternateGroup = view.getUint16(i);\n      i += 2;\n      // convert fixed-point, base 16 back to a number\n      result.volume = view.getUint8(i) + (view.getUint8(i + 1) / 8);\n      i += 2;\n      i += 2;\n      result.matrix = new Uint32Array(data.subarray(i, i + (9 * 4)));\n      i += 9 * 4;\n      result.width = view.getUint16(i) + (view.getUint16(i + 2) / 16);\n      i += 4;\n      result.height = view.getUint16(i) + (view.getUint16(i + 2) / 16);\n      return result;\n    },\n    traf: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    trak: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    trex: function(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        trackId: view.getUint32(4),\n        defaultSampleDescriptionIndex: view.getUint32(8),\n        defaultSampleDuration: view.getUint32(12),\n        defaultSampleSize: view.getUint32(16),\n        sampleDependsOn: data[20] & 0x03,\n        sampleIsDependedOn: (data[21] & 0xc0) >> 6,\n        sampleHasRedundancy: (data[21] & 0x30) >> 4,\n        samplePaddingValue: (data[21] & 0x0e) >> 1,\n        sampleIsDifferenceSample: !!(data[21] & 0x01),\n        sampleDegradationPriority: view.getUint16(22)\n      };\n    },\n    trun: function(data) {\n      var\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          samples: []\n        },\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        // Flag interpretation\n        dataOffsetPresent = result.flags[2] & 0x01, // compare with 2nd byte of 0x1\n        firstSampleFlagsPresent = result.flags[2] & 0x04, // compare with 2nd byte of 0x4\n        sampleDurationPresent = result.flags[1] & 0x01, // compare with 2nd byte of 0x100\n        sampleSizePresent = result.flags[1] & 0x02, // compare with 2nd byte of 0x200\n        sampleFlagsPresent = result.flags[1] & 0x04, // compare with 2nd byte of 0x400\n        sampleCompositionTimeOffsetPresent = result.flags[1] & 0x08, // compare with 2nd byte of 0x800\n        sampleCount = view.getUint32(4),\n        offset = 8,\n        sample;\n\n      if (dataOffsetPresent) {\n        // 32 bit signed integer\n        result.dataOffset = view.getInt32(offset);\n        offset += 4;\n      }\n\n      // Overrides the flags for the first sample only. The order of\n      // optional values will be: duration, size, compositionTimeOffset\n      if (firstSampleFlagsPresent && sampleCount) {\n        sample = {\n          flags: parseSampleFlags(data.subarray(offset, offset + 4))\n        };\n        offset += 4;\n        if (sampleDurationPresent) {\n          sample.duration = view.getUint32(offset);\n          offset += 4;\n        }\n        if (sampleSizePresent) {\n          sample.size = view.getUint32(offset);\n          offset += 4;\n        }\n        if (sampleCompositionTimeOffsetPresent) {\n          // Note: this should be a signed int if version is 1\n          sample.compositionTimeOffset = view.getUint32(offset);\n          offset += 4;\n        }\n        result.samples.push(sample);\n        sampleCount--;\n      }\n\n      while (sampleCount--) {\n        sample = {};\n        if (sampleDurationPresent) {\n          sample.duration = view.getUint32(offset);\n          offset += 4;\n        }\n        if (sampleSizePresent) {\n          sample.size = view.getUint32(offset);\n          offset += 4;\n        }\n        if (sampleFlagsPresent) {\n          sample.flags = parseSampleFlags(data.subarray(offset, offset + 4));\n          offset += 4;\n        }\n        if (sampleCompositionTimeOffsetPresent) {\n          // Note: this should be a signed int if version is 1\n          sample.compositionTimeOffset = view.getUint32(offset);\n          offset += 4;\n        }\n        result.samples.push(sample);\n      }\n      return result;\n    },\n    'url ': function(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4))\n      };\n    },\n    vmhd: function(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        graphicsmode: view.getUint16(4),\n        opcolor: new Uint16Array([view.getUint16(6),\n                                  view.getUint16(8),\n                                  view.getUint16(10)])\n      };\n    }\n  };\n\n\n/**\n * Return a javascript array of box objects parsed from an ISO base\n * media file.\n * @param data {Uint8Array} the binary data of the media to be inspected\n * @return {array} a javascript array of potentially nested box objects\n */\ninspectMp4 = function(data) {\n  var\n    i = 0,\n    result = [],\n    view,\n    size,\n    type,\n    end,\n    box;\n\n  // Convert data from Uint8Array to ArrayBuffer, to follow Dataview API\n  var ab = new ArrayBuffer(data.length);\n  var v = new Uint8Array(ab);\n  for (var z = 0; z < data.length; ++z) {\n      v[z] = data[z];\n  }\n  view = new DataView(ab);\n\n  while (i < data.byteLength) {\n    // parse box data\n    size = view.getUint32(i);\n    type =  parseType(data.subarray(i + 4, i + 8));\n    end = size > 1 ? i + size : data.byteLength;\n\n    // parse type-specific data\n    box = (parse[type] || function(data) {\n      return {\n        data: data\n      };\n    })(data.subarray(i + 8, end));\n    box.size = size;\n    box.type = type;\n\n    // store this box and move to the next\n    result.push(box);\n    i = end;\n  }\n  return result;\n};\n\n/**\n * Returns a textual representation of the javascript represtentation\n * of an MP4 file. You can use it as an alternative to\n * JSON.stringify() to compare inspected MP4s.\n * @param inspectedMp4 {array} the parsed array of boxes in an MP4\n * file\n * @param depth {number} (optional) the number of ancestor boxes of\n * the elements of inspectedMp4. Assumed to be zero if unspecified.\n * @return {string} a text representation of the parsed MP4\n */\ntextifyMp4 = function(inspectedMp4, depth) {\n  var indent;\n  depth = depth || 0;\n  indent = new Array(depth * 2 + 1).join(' ');\n\n  // iterate over all the boxes\n  return inspectedMp4.map(function(box, index) {\n\n    // list the box type first at the current indentation level\n    return indent + box.type + '\\n' +\n\n      // the type is already included and handle child boxes separately\n      Object.keys(box).filter(function(key) {\n        return key !== 'type' && key !== 'boxes';\n\n      // output all the box properties\n      }).map(function(key) {\n        var prefix = indent + '  ' + key + ': ',\n            value = box[key];\n\n        // print out raw bytes as hexademical\n        if (value instanceof Uint8Array || value instanceof Uint32Array) {\n          var bytes = Array.prototype.slice.call(new Uint8Array(value.buffer, value.byteOffset, value.byteLength))\n              .map(function(byte) {\n                return ' ' + ('00' + byte.toString(16)).slice(-2);\n              }).join('').match(/.{1,24}/g);\n          if (!bytes) {\n            return prefix + '<>';\n          }\n          if (bytes.length === 1) {\n            return prefix + '<' + bytes.join('').slice(1) + '>';\n          }\n          return prefix + '<\\n' + bytes.map(function(line) {\n            return indent + '  ' + line;\n          }).join('\\n') + '\\n' + indent + '  >';\n        }\n\n        // stringify generic objects\n        return prefix +\n            JSON.stringify(value, null, 2)\n              .split('\\n').map(function(line, index) {\n                if (index === 0) {\n                  return line;\n                }\n                return indent + '  ' + line;\n              }).join('\\n');\n      }).join('\\n') +\n\n    // recursively textify the child boxes\n    (box.boxes ? '\\n' + textifyMp4(box.boxes, depth + 1) : '');\n  }).join('\\n');\n};\n\nmodule.exports = {\n  inspect: inspectMp4,\n  textify: textifyMp4,\n  parseTfdt: parse.tfdt,\n  parseHdlr: parse.hdlr,\n  parseTfhd: parse.tfhd,\n  parseTrun: parse.trun,\n  parseSidx: parse.sidx\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Reads in-band CEA-708 captions out of FMP4 segments.\n * @see https://en.wikipedia.org/wiki/CEA-708\n */\n'use strict';\n\nvar discardEmulationPreventionBytes = require('../tools/caption-packet-parser').discardEmulationPreventionBytes;\nvar CaptionStream = require('../m2ts/caption-stream').CaptionStream;\nvar probe = require('./probe');\nvar inspect = require('../tools/mp4-inspector');\n\n/**\n  * Maps an offset in the mdat to a sample based on the the size of the samples.\n  * Assumes that `parseSamples` has been called first.\n  *\n  * @param {Number} offset - The offset into the mdat\n  * @param {Object[]} samples - An array of samples, parsed using `parseSamples`\n  * @return {?Object} The matching sample, or null if no match was found.\n  *\n  * @see ISO-BMFF-12/2015, Section 8.8.8\n **/\nvar mapToSample = function(offset, samples) {\n  var approximateOffset = offset;\n\n  for (var i = 0; i < samples.length; i++) {\n    var sample = samples[i];\n\n    if (approximateOffset < sample.size) {\n      return sample;\n    }\n\n    approximateOffset -= sample.size;\n  }\n\n  return null;\n};\n\n/**\n  * Finds SEI nal units contained in a Media Data Box.\n  * Assumes that `parseSamples` has been called first.\n  *\n  * @param {Uint8Array} avcStream - The bytes of the mdat\n  * @param {Object[]} samples - The samples parsed out by `parseSamples`\n  * @param {Number} trackId - The trackId of this video track\n  * @return {Object[]} seiNals - the parsed SEI NALUs found.\n  *   The contents of the seiNal should match what is expected by\n  *   CaptionStream.push (nalUnitType, size, data, escapedRBSP, pts, dts)\n  *\n  * @see ISO-BMFF-12/2015, Section 8.1.1\n  * @see Rec. ITU-T H.264, 7.3.2.3.1\n **/\nvar findSeiNals = function(avcStream, samples, trackId) {\n  var\n    avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n    result = [],\n    seiNal,\n    i,\n    length,\n    lastMatchedSample;\n\n  for (i = 0; i + 4 < avcStream.length; i += length) {\n    length = avcView.getUint32(i);\n    i += 4;\n\n    // Bail if this doesn't appear to be an H264 stream\n    if (length <= 0) {\n      continue;\n    }\n\n    switch (avcStream[i] & 0x1F) {\n    case 0x06:\n      var data = avcStream.subarray(i + 1, i + 1 + length);\n      var matchingSample = mapToSample(i, samples);\n\n      seiNal = {\n        nalUnitType: 'sei_rbsp',\n        size: length,\n        data: data,\n        escapedRBSP: discardEmulationPreventionBytes(data),\n        trackId: trackId\n      };\n\n      if (matchingSample) {\n        seiNal.pts = matchingSample.pts;\n        seiNal.dts = matchingSample.dts;\n        lastMatchedSample = matchingSample;\n      } else {\n        // If a matching sample cannot be found, use the last\n        // sample's values as they should be as close as possible\n        seiNal.pts = lastMatchedSample.pts;\n        seiNal.dts = lastMatchedSample.dts;\n      }\n\n      result.push(seiNal);\n      break;\n    default:\n      break;\n    }\n  }\n\n  return result;\n};\n\n/**\n  * Parses sample information out of Track Run Boxes and calculates\n  * the absolute presentation and decode timestamps of each sample.\n  *\n  * @param {Array<Uint8Array>} truns - The Trun Run boxes to be parsed\n  * @param {Number} baseMediaDecodeTime - base media decode time from tfdt\n      @see ISO-BMFF-12/2015, Section 8.8.12\n  * @param {Object} tfhd - The parsed Track Fragment Header\n  *   @see inspect.parseTfhd\n  * @return {Object[]} the parsed samples\n  *\n  * @see ISO-BMFF-12/2015, Section 8.8.8\n **/\nvar parseSamples = function(truns, baseMediaDecodeTime, tfhd) {\n  var currentDts = baseMediaDecodeTime;\n  var defaultSampleDuration = tfhd.defaultSampleDuration || 0;\n  var defaultSampleSize = tfhd.defaultSampleSize || 0;\n  var trackId = tfhd.trackId;\n  var allSamples = [];\n\n  truns.forEach(function(trun) {\n    // Note: We currently do not parse the sample table as well\n    // as the trun. It's possible some sources will require this.\n    // moov > trak > mdia > minf > stbl\n    var trackRun = inspect.parseTrun(trun);\n    var samples = trackRun.samples;\n\n    samples.forEach(function(sample) {\n      if (sample.duration === undefined) {\n        sample.duration = defaultSampleDuration;\n      }\n      if (sample.size === undefined) {\n        sample.size = defaultSampleSize;\n      }\n      sample.trackId = trackId;\n      sample.dts = currentDts;\n      if (sample.compositionTimeOffset === undefined) {\n        sample.compositionTimeOffset = 0;\n      }\n      sample.pts = currentDts + sample.compositionTimeOffset;\n\n      currentDts += sample.duration;\n    });\n\n    allSamples = allSamples.concat(samples);\n  });\n\n  return allSamples;\n};\n\n/**\n  * Parses out caption nals from an FMP4 segment's video tracks.\n  *\n  * @param {Uint8Array} segment - The bytes of a single segment\n  * @param {Number} videoTrackId - The trackId of a video track in the segment\n  * @return {Object.<Number, Object[]>} A mapping of video trackId to\n  *   a list of seiNals found in that track\n **/\nvar parseCaptionNals = function(segment, videoTrackId) {\n  // To get the samples\n  var trafs = probe.findBox(segment, ['moof', 'traf']);\n  // To get SEI NAL units\n  var mdats = probe.findBox(segment, ['mdat']);\n  var captionNals = {};\n  var mdatTrafPairs = [];\n\n  // Pair up each traf with a mdat as moofs and mdats are in pairs\n  mdats.forEach(function(mdat, index) {\n    var matchingTraf = trafs[index];\n    mdatTrafPairs.push({\n      mdat: mdat,\n      traf: matchingTraf\n    });\n  });\n\n  mdatTrafPairs.forEach(function(pair) {\n    var mdat = pair.mdat;\n    var traf = pair.traf;\n    var tfhd = probe.findBox(traf, ['tfhd']);\n    // Exactly 1 tfhd per traf\n    var headerInfo = inspect.parseTfhd(tfhd[0]);\n    var trackId = headerInfo.trackId;\n    var tfdt = probe.findBox(traf, ['tfdt']);\n    // Either 0 or 1 tfdt per traf\n    var baseMediaDecodeTime = (tfdt.length > 0) ? inspect.parseTfdt(tfdt[0]).baseMediaDecodeTime : 0;\n    var truns = probe.findBox(traf, ['trun']);\n    var samples;\n    var seiNals;\n\n    // Only parse video data for the chosen video track\n    if (videoTrackId === trackId && truns.length > 0) {\n      samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);\n\n      seiNals = findSeiNals(mdat, samples, trackId);\n\n      if (!captionNals[trackId]) {\n        captionNals[trackId] = [];\n      }\n\n      captionNals[trackId] = captionNals[trackId].concat(seiNals);\n    }\n  });\n\n  return captionNals;\n};\n\n/**\n  * Parses out inband captions from an MP4 container and returns\n  * caption objects that can be used by WebVTT and the TextTrack API.\n  * @see https://developer.mozilla.org/en-US/docs/Web/API/VTTCue\n  * @see https://developer.mozilla.org/en-US/docs/Web/API/TextTrack\n  * Assumes that `probe.getVideoTrackIds` and `probe.timescale` have been called first\n  *\n  * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n  * @param {Number} trackId - The id of the video track to parse\n  * @param {Number} timescale - The timescale for the video track from the init segment\n  *\n  * @return {?Object[]} parsedCaptions - A list of captions or null if no video tracks\n  * @return {Number} parsedCaptions[].startTime - The time to show the caption in seconds\n  * @return {Number} parsedCaptions[].endTime - The time to stop showing the caption in seconds\n  * @return {String} parsedCaptions[].text - The visible content of the caption\n **/\nvar parseEmbeddedCaptions = function(segment, trackId, timescale) {\n  var seiNals;\n\n  if (!trackId) {\n    return null;\n  }\n\n  seiNals = parseCaptionNals(segment, trackId);\n\n  return {\n    seiNals: seiNals[trackId],\n    timescale: timescale\n  };\n};\n\n/**\n  * Converts SEI NALUs into captions that can be used by video.js\n **/\nvar CaptionParser = function() {\n  var isInitialized = false;\n  var captionStream;\n\n  // Stores segments seen before trackId and timescale are set\n  var segmentCache;\n  // Stores video track ID of the track being parsed\n  var trackId;\n  // Stores the timescale of the track being parsed\n  var timescale;\n  // Stores captions parsed so far\n  var parsedCaptions;\n\n  /**\n    * A method to indicate whether a CaptionParser has been initalized\n    * @returns {Boolean}\n   **/\n  this.isInitialized = function() {\n    return isInitialized;\n  };\n\n  /**\n    * Initializes the underlying CaptionStream, SEI NAL parsing\n    * and management, and caption collection\n   **/\n  this.init = function() {\n    captionStream = new CaptionStream();\n    isInitialized = true;\n\n    // Collect dispatched captions\n    captionStream.on('data', function(event) {\n      // Convert to seconds in the source's timescale\n      event.startTime = event.startPts / timescale;\n      event.endTime = event.endPts / timescale;\n\n      parsedCaptions.captions.push(event);\n      parsedCaptions.captionStreams[event.stream] = true;\n    });\n  };\n\n  /**\n    * Determines if a new video track will be selected\n    * or if the timescale changed\n    * @return {Boolean}\n   **/\n  this.isNewInit = function(videoTrackIds, timescales) {\n    if ((videoTrackIds && videoTrackIds.length === 0) ||\n        (timescales && typeof timescales === 'object' &&\n          Object.keys(timescales).length === 0)) {\n      return false;\n    }\n\n    return trackId !== videoTrackIds[0] ||\n      timescale !== timescales[trackId];\n  };\n\n  /**\n    * Parses out SEI captions and interacts with underlying\n    * CaptionStream to return dispatched captions\n    *\n    * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n    * @param {Number[]} videoTrackIds - A list of video tracks found in the init segment\n    * @param {Object.<Number, Number>} timescales - The timescales found in the init segment\n    * @see parseEmbeddedCaptions\n    * @see m2ts/caption-stream.js\n   **/\n  this.parse = function(segment, videoTrackIds, timescales) {\n    var parsedData;\n\n    if (!this.isInitialized()) {\n      return null;\n\n    // This is not likely to be a video segment\n    } else if (!videoTrackIds || !timescales) {\n      return null;\n\n    } else if (this.isNewInit(videoTrackIds, timescales)) {\n      // Use the first video track only as there is no\n      // mechanism to switch to other video tracks\n      trackId = videoTrackIds[0];\n      timescale = timescales[trackId];\n\n    // If an init segment has not been seen yet, hold onto segment\n    // data until we have one\n    } else if (!trackId || !timescale) {\n      segmentCache.push(segment);\n      return null;\n    }\n\n    // Now that a timescale and trackId is set, parse cached segments\n    while (segmentCache.length > 0) {\n      var cachedSegment = segmentCache.shift();\n\n      this.parse(cachedSegment, videoTrackIds, timescales);\n    }\n\n    parsedData = parseEmbeddedCaptions(segment, trackId, timescale);\n\n    if (parsedData === null || !parsedData.seiNals) {\n      return null;\n    }\n\n    this.pushNals(parsedData.seiNals);\n    // Force the parsed captions to be dispatched\n    this.flushStream();\n\n    return parsedCaptions;\n  };\n\n  /**\n    * Pushes SEI NALUs onto CaptionStream\n    * @param {Object[]} nals - A list of SEI nals parsed using `parseCaptionNals`\n    * Assumes that `parseCaptionNals` has been called first\n    * @see m2ts/caption-stream.js\n    **/\n  this.pushNals = function(nals) {\n    if (!this.isInitialized() || !nals || nals.length === 0) {\n      return null;\n    }\n\n    nals.forEach(function(nal) {\n      captionStream.push(nal);\n    });\n  };\n\n  /**\n    * Flushes underlying CaptionStream to dispatch processed, displayable captions\n    * @see m2ts/caption-stream.js\n   **/\n  this.flushStream = function() {\n    if (!this.isInitialized()) {\n      return null;\n    }\n\n    captionStream.flush();\n  };\n\n  /**\n    * Reset caption buckets for new data\n   **/\n  this.clearParsedCaptions = function() {\n    parsedCaptions.captions = [];\n    parsedCaptions.captionStreams = {};\n  };\n\n  /**\n    * Resets underlying CaptionStream\n    * @see m2ts/caption-stream.js\n   **/\n  this.resetCaptionStream = function() {\n    if (!this.isInitialized()) {\n      return null;\n    }\n\n    captionStream.reset();\n  };\n\n  /**\n    * Convenience method to clear all captions flushed from the\n    * CaptionStream and still being parsed\n    * @see m2ts/caption-stream.js\n   **/\n  this.clearAllCaptions = function() {\n    this.clearParsedCaptions();\n    this.resetCaptionStream();\n  };\n\n  /**\n    * Reset caption parser\n   **/\n  this.reset = function() {\n    segmentCache = [];\n    trackId = null;\n    timescale = null;\n\n    if (!parsedCaptions) {\n      parsedCaptions = {\n        captions: [],\n        // CC1, CC2, CC3, CC4\n        captionStreams: {}\n      };\n    } else {\n      this.clearParsedCaptions();\n    }\n\n    this.resetCaptionStream();\n  };\n\n  this.reset();\n};\n\nmodule.exports = CaptionParser;\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\nmodule.exports = {\n  generator: require('./mp4-generator'),\n  probe: require('./probe'),\n  Transmuxer: require('./transmuxer').Transmuxer,\n  AudioSegmentStream: require('./transmuxer').AudioSegmentStream,\n  VideoSegmentStream: require('./transmuxer').VideoSegmentStream,\n  CaptionParser: require('./caption-parser')\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * An object that stores the bytes of an FLV tag and methods for\n * querying and manipulating that data.\n * @see http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf\n */\n'use strict';\n\nvar FlvTag;\n\n// (type:uint, extraData:Boolean = false) extends ByteArray\nFlvTag = function(type, extraData) {\n  var\n    // Counter if this is a metadata tag, nal start marker if this is a video\n    // tag. unused if this is an audio tag\n    adHoc = 0, // :uint\n\n    // The default size is 16kb but this is not enough to hold iframe\n    // data and the resizing algorithm costs a bit so we create a larger\n    // starting buffer for video tags\n    bufferStartSize = 16384,\n\n    // checks whether the FLV tag has enough capacity to accept the proposed\n    // write and re-allocates the internal buffers if necessary\n    prepareWrite = function(flv, count) {\n      var\n        bytes,\n        minLength = flv.position + count;\n      if (minLength < flv.bytes.byteLength) {\n        // there's enough capacity so do nothing\n        return;\n      }\n\n      // allocate a new buffer and copy over the data that will not be modified\n      bytes = new Uint8Array(minLength * 2);\n      bytes.set(flv.bytes.subarray(0, flv.position), 0);\n      flv.bytes = bytes;\n      flv.view = new DataView(flv.bytes.buffer);\n    },\n\n    // commonly used metadata properties\n    widthBytes = FlvTag.widthBytes || new Uint8Array('width'.length),\n    heightBytes = FlvTag.heightBytes || new Uint8Array('height'.length),\n    videocodecidBytes = FlvTag.videocodecidBytes || new Uint8Array('videocodecid'.length),\n    i;\n\n  if (!FlvTag.widthBytes) {\n    // calculating the bytes of common metadata names ahead of time makes the\n    // corresponding writes faster because we don't have to loop over the\n    // characters\n    // re-test with test/perf.html if you're planning on changing this\n    for (i = 0; i < 'width'.length; i++) {\n      widthBytes[i] = 'width'.charCodeAt(i);\n    }\n    for (i = 0; i < 'height'.length; i++) {\n      heightBytes[i] = 'height'.charCodeAt(i);\n    }\n    for (i = 0; i < 'videocodecid'.length; i++) {\n      videocodecidBytes[i] = 'videocodecid'.charCodeAt(i);\n    }\n\n    FlvTag.widthBytes = widthBytes;\n    FlvTag.heightBytes = heightBytes;\n    FlvTag.videocodecidBytes = videocodecidBytes;\n  }\n\n  this.keyFrame = false; // :Boolean\n\n  switch (type) {\n  case FlvTag.VIDEO_TAG:\n    this.length = 16;\n    // Start the buffer at 256k\n    bufferStartSize *= 6;\n    break;\n  case FlvTag.AUDIO_TAG:\n    this.length = 13;\n    this.keyFrame = true;\n    break;\n  case FlvTag.METADATA_TAG:\n    this.length = 29;\n    this.keyFrame = true;\n    break;\n  default:\n    throw new Error('Unknown FLV tag type');\n  }\n\n  this.bytes = new Uint8Array(bufferStartSize);\n  this.view = new DataView(this.bytes.buffer);\n  this.bytes[0] = type;\n  this.position = this.length;\n  this.keyFrame = extraData; // Defaults to false\n\n  // presentation timestamp\n  this.pts = 0;\n  // decoder timestamp\n  this.dts = 0;\n\n  // ByteArray#writeBytes(bytes:ByteArray, offset:uint = 0, length:uint = 0)\n  this.writeBytes = function(bytes, offset, length) {\n    var\n      start = offset || 0,\n      end;\n    length = length || bytes.byteLength;\n    end = start + length;\n\n    prepareWrite(this, length);\n    this.bytes.set(bytes.subarray(start, end), this.position);\n\n    this.position += length;\n    this.length = Math.max(this.length, this.position);\n  };\n\n  // ByteArray#writeByte(value:int):void\n  this.writeByte = function(byte) {\n    prepareWrite(this, 1);\n    this.bytes[this.position] = byte;\n    this.position++;\n    this.length = Math.max(this.length, this.position);\n  };\n\n  // ByteArray#writeShort(value:int):void\n  this.writeShort = function(short) {\n    prepareWrite(this, 2);\n    this.view.setUint16(this.position, short);\n    this.position += 2;\n    this.length = Math.max(this.length, this.position);\n  };\n\n  // Negative index into array\n  // (pos:uint):int\n  this.negIndex = function(pos) {\n    return this.bytes[this.length - pos];\n  };\n\n  // The functions below ONLY work when this[0] == VIDEO_TAG.\n  // We are not going to check for that because we dont want the overhead\n  // (nal:ByteArray = null):int\n  this.nalUnitSize = function() {\n    if (adHoc === 0) {\n      return 0;\n    }\n\n    return this.length - (adHoc + 4);\n  };\n\n  this.startNalUnit = function() {\n    // remember position and add 4 bytes\n    if (adHoc > 0) {\n      throw new Error('Attempted to create new NAL wihout closing the old one');\n    }\n\n    // reserve 4 bytes for nal unit size\n    adHoc = this.length;\n    this.length += 4;\n    this.position = this.length;\n  };\n\n  // (nal:ByteArray = null):void\n  this.endNalUnit = function(nalContainer) {\n    var\n      nalStart, // :uint\n      nalLength; // :uint\n\n    // Rewind to the marker and write the size\n    if (this.length === adHoc + 4) {\n      // we started a nal unit, but didnt write one, so roll back the 4 byte size value\n      this.length -= 4;\n    } else if (adHoc > 0) {\n      nalStart = adHoc + 4;\n      nalLength = this.length - nalStart;\n\n      this.position = adHoc;\n      this.view.setUint32(this.position, nalLength);\n      this.position = this.length;\n\n      if (nalContainer) {\n        // Add the tag to the NAL unit\n        nalContainer.push(this.bytes.subarray(nalStart, nalStart + nalLength));\n      }\n    }\n\n    adHoc = 0;\n  };\n\n  /**\n   * Write out a 64-bit floating point valued metadata property. This method is\n   * called frequently during a typical parse and needs to be fast.\n   */\n  // (key:String, val:Number):void\n  this.writeMetaDataDouble = function(key, val) {\n    var i;\n    prepareWrite(this, 2 + key.length + 9);\n\n    // write size of property name\n    this.view.setUint16(this.position, key.length);\n    this.position += 2;\n\n    // this next part looks terrible but it improves parser throughput by\n    // 10kB/s in my testing\n\n    // write property name\n    if (key === 'width') {\n      this.bytes.set(widthBytes, this.position);\n      this.position += 5;\n    } else if (key === 'height') {\n      this.bytes.set(heightBytes, this.position);\n      this.position += 6;\n    } else if (key === 'videocodecid') {\n      this.bytes.set(videocodecidBytes, this.position);\n      this.position += 12;\n    } else {\n      for (i = 0; i < key.length; i++) {\n        this.bytes[this.position] = key.charCodeAt(i);\n        this.position++;\n      }\n    }\n\n    // skip null byte\n    this.position++;\n\n    // write property value\n    this.view.setFloat64(this.position, val);\n    this.position += 8;\n\n    // update flv tag length\n    this.length = Math.max(this.length, this.position);\n    ++adHoc;\n  };\n\n  // (key:String, val:Boolean):void\n  this.writeMetaDataBoolean = function(key, val) {\n    var i;\n    prepareWrite(this, 2);\n    this.view.setUint16(this.position, key.length);\n    this.position += 2;\n    for (i = 0; i < key.length; i++) {\n      // if key.charCodeAt(i) >= 255, handle error\n      prepareWrite(this, 1);\n      this.bytes[this.position] = key.charCodeAt(i);\n      this.position++;\n    }\n    prepareWrite(this, 2);\n    this.view.setUint8(this.position, 0x01);\n    this.position++;\n    this.view.setUint8(this.position, val ? 0x01 : 0x00);\n    this.position++;\n    this.length = Math.max(this.length, this.position);\n    ++adHoc;\n  };\n\n  // ():ByteArray\n  this.finalize = function() {\n    var\n      dtsDelta, // :int\n      len; // :int\n\n    switch (this.bytes[0]) {\n      // Video Data\n    case FlvTag.VIDEO_TAG:\n       // We only support AVC, 1 = key frame (for AVC, a seekable\n       // frame), 2 = inter frame (for AVC, a non-seekable frame)\n      this.bytes[11] = ((this.keyFrame || extraData) ? 0x10 : 0x20) | 0x07;\n      this.bytes[12] = extraData ?  0x00 : 0x01;\n\n      dtsDelta = this.pts - this.dts;\n      this.bytes[13] = (dtsDelta & 0x00FF0000) >>> 16;\n      this.bytes[14] = (dtsDelta & 0x0000FF00) >>>  8;\n      this.bytes[15] = (dtsDelta & 0x000000FF) >>>  0;\n      break;\n\n    case FlvTag.AUDIO_TAG:\n      this.bytes[11] = 0xAF; // 44 kHz, 16-bit stereo\n      this.bytes[12] = extraData ? 0x00 : 0x01;\n      break;\n\n    case FlvTag.METADATA_TAG:\n      this.position = 11;\n      this.view.setUint8(this.position, 0x02); // String type\n      this.position++;\n      this.view.setUint16(this.position, 0x0A); // 10 Bytes\n      this.position += 2;\n      // set \"onMetaData\"\n      this.bytes.set([0x6f, 0x6e, 0x4d, 0x65,\n                      0x74, 0x61, 0x44, 0x61,\n                      0x74, 0x61], this.position);\n      this.position += 10;\n      this.bytes[this.position] = 0x08; // Array type\n      this.position++;\n      this.view.setUint32(this.position, adHoc);\n      this.position = this.length;\n      this.bytes.set([0, 0, 9], this.position);\n      this.position += 3; // End Data Tag\n      this.length = this.position;\n      break;\n    }\n\n    len = this.length - 11;\n\n    // write the DataSize field\n    this.bytes[ 1] = (len & 0x00FF0000) >>> 16;\n    this.bytes[ 2] = (len & 0x0000FF00) >>>  8;\n    this.bytes[ 3] = (len & 0x000000FF) >>>  0;\n    // write the Timestamp\n    this.bytes[ 4] = (this.dts & 0x00FF0000) >>> 16;\n    this.bytes[ 5] = (this.dts & 0x0000FF00) >>>  8;\n    this.bytes[ 6] = (this.dts & 0x000000FF) >>>  0;\n    this.bytes[ 7] = (this.dts & 0xFF000000) >>> 24;\n    // write the StreamID\n    this.bytes[ 8] = 0;\n    this.bytes[ 9] = 0;\n    this.bytes[10] = 0;\n\n    // Sometimes we're at the end of the view and have one slot to write a\n    // uint32, so, prepareWrite of count 4, since, view is uint8\n    prepareWrite(this, 4);\n    this.view.setUint32(this.length, this.length);\n    this.length += 4;\n    this.position += 4;\n\n    // trim down the byte buffer to what is actually being used\n    this.bytes = this.bytes.subarray(0, this.length);\n    this.frameTime = FlvTag.frameTime(this.bytes);\n    // if bytes.bytelength isn't equal to this.length, handle error\n    return this;\n  };\n};\n\nFlvTag.AUDIO_TAG = 0x08; // == 8, :uint\nFlvTag.VIDEO_TAG = 0x09; // == 9, :uint\nFlvTag.METADATA_TAG = 0x12; // == 18, :uint\n\n// (tag:ByteArray):Boolean {\nFlvTag.isAudioFrame = function(tag) {\n  return FlvTag.AUDIO_TAG === tag[0];\n};\n\n// (tag:ByteArray):Boolean {\nFlvTag.isVideoFrame = function(tag) {\n  return FlvTag.VIDEO_TAG === tag[0];\n};\n\n// (tag:ByteArray):Boolean {\nFlvTag.isMetaData = function(tag) {\n  return FlvTag.METADATA_TAG === tag[0];\n};\n\n// (tag:ByteArray):Boolean {\nFlvTag.isKeyFrame = function(tag) {\n  if (FlvTag.isVideoFrame(tag)) {\n    return tag[11] === 0x17;\n  }\n\n  if (FlvTag.isAudioFrame(tag)) {\n    return true;\n  }\n\n  if (FlvTag.isMetaData(tag)) {\n    return true;\n  }\n\n  return false;\n};\n\n// (tag:ByteArray):uint {\nFlvTag.frameTime = function(tag) {\n  var pts = tag[ 4] << 16; // :uint\n  pts |= tag[ 5] <<  8;\n  pts |= tag[ 6] <<  0;\n  pts |= tag[ 7] << 24;\n  return pts;\n};\n\nmodule.exports = FlvTag;\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js');\n\n/**\n * The final stage of the transmuxer that emits the flv tags\n * for audio, video, and metadata. Also tranlates in time and\n * outputs caption data and id3 cues.\n */\nvar CoalesceStream = function(options) {\n  // Number of Tracks per output segment\n  // If greater than 1, we combine multiple\n  // tracks into a single segment\n  this.numberOfTracks = 0;\n  this.metadataStream = options.metadataStream;\n\n  this.videoTags = [];\n  this.audioTags = [];\n  this.videoTrack = null;\n  this.audioTrack = null;\n  this.pendingCaptions = [];\n  this.pendingMetadata = [];\n  this.pendingTracks = 0;\n  this.processedTracks = 0;\n\n  CoalesceStream.prototype.init.call(this);\n\n  // Take output from multiple\n  this.push = function(output) {\n    // buffer incoming captions until the associated video segment\n    // finishes\n    if (output.text) {\n      return this.pendingCaptions.push(output);\n    }\n    // buffer incoming id3 tags until the final flush\n    if (output.frames) {\n      return this.pendingMetadata.push(output);\n    }\n\n    if (output.track.type === 'video') {\n      this.videoTrack = output.track;\n      this.videoTags = output.tags;\n      this.pendingTracks++;\n    }\n    if (output.track.type === 'audio') {\n      this.audioTrack = output.track;\n      this.audioTags = output.tags;\n      this.pendingTracks++;\n    }\n  };\n};\n\nCoalesceStream.prototype = new Stream();\nCoalesceStream.prototype.flush = function(flushSource) {\n  var\n    id3,\n    caption,\n    i,\n    timelineStartPts,\n    event = {\n      tags: {},\n      captions: [],\n      captionStreams: {},\n      metadata: []\n    };\n\n  if (this.pendingTracks < this.numberOfTracks) {\n    if (flushSource !== 'VideoSegmentStream' &&\n        flushSource !== 'AudioSegmentStream') {\n      // Return because we haven't received a flush from a data-generating\n      // portion of the segment (meaning that we have only recieved meta-data\n      // or captions.)\n      return;\n    } else if (this.pendingTracks === 0) {\n      // In the case where we receive a flush without any data having been\n      // received we consider it an emitted track for the purposes of coalescing\n      // `done` events.\n      // We do this for the case where there is an audio and video track in the\n      // segment but no audio data. (seen in several playlists with alternate\n      // audio tracks and no audio present in the main TS segments.)\n      this.processedTracks++;\n\n      if (this.processedTracks < this.numberOfTracks) {\n        return;\n      }\n    }\n  }\n\n  this.processedTracks += this.pendingTracks;\n  this.pendingTracks = 0;\n\n  if (this.processedTracks < this.numberOfTracks) {\n    return;\n  }\n\n  if (this.videoTrack) {\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n  } else if (this.audioTrack) {\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n  }\n\n  event.tags.videoTags = this.videoTags;\n  event.tags.audioTags = this.audioTags;\n\n  // Translate caption PTS times into second offsets into the\n  // video timeline for the segment, and add track info\n  for (i = 0; i < this.pendingCaptions.length; i++) {\n    caption = this.pendingCaptions[i];\n    caption.startTime = caption.startPts - timelineStartPts;\n    caption.startTime /= 90e3;\n    caption.endTime = caption.endPts - timelineStartPts;\n    caption.endTime /= 90e3;\n    event.captionStreams[caption.stream] = true;\n    event.captions.push(caption);\n  }\n\n  // Translate ID3 frame PTS times into second offsets into the\n  // video timeline for the segment\n  for (i = 0; i < this.pendingMetadata.length; i++) {\n    id3 = this.pendingMetadata[i];\n    id3.cueTime = id3.pts - timelineStartPts;\n    id3.cueTime /= 90e3;\n    event.metadata.push(id3);\n  }\n  // We add this to every single emitted segment even though we only need\n  // it for the first\n  event.metadata.dispatchType = this.metadataStream.dispatchType;\n\n  // Reset stream state\n  this.videoTrack = null;\n  this.audioTrack = null;\n  this.videoTags = [];\n  this.audioTags = [];\n  this.pendingCaptions.length = 0;\n  this.pendingMetadata.length = 0;\n  this.pendingTracks = 0;\n  this.processedTracks = 0;\n\n  // Emit the final segment\n  this.trigger('data', event);\n\n  this.trigger('done');\n};\n\nmodule.exports = CoalesceStream;\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nvar TagList = function() {\n  var self = this;\n\n  this.list = [];\n\n  this.push = function(tag) {\n    this.list.push({\n      bytes: tag.bytes,\n      dts: tag.dts,\n      pts: tag.pts,\n      keyFrame: tag.keyFrame,\n      metaDataTag: tag.metaDataTag\n    });\n  };\n\n  Object.defineProperty(this, 'length', {\n    get: function() {\n      return self.list.length;\n    }\n  });\n};\n\nmodule.exports = TagList;\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js');\nvar FlvTag = require('./flv-tag.js');\nvar m2ts = require('../m2ts/m2ts.js');\nvar AdtsStream = require('../codecs/adts.js');\nvar H264Stream = require('../codecs/h264').H264Stream;\nvar CoalesceStream = require('./coalesce-stream.js');\nvar TagList = require('./tag-list.js');\n\nvar\n  Transmuxer,\n  VideoSegmentStream,\n  AudioSegmentStream,\n  collectTimelineInfo,\n  metaDataTag,\n  extraDataTag;\n\n/**\n * Store information about the start and end of the tracka and the\n * duration for each frame/sample we process in order to calculate\n * the baseMediaDecodeTime\n */\ncollectTimelineInfo = function(track, data) {\n  if (typeof data.pts === 'number') {\n    if (track.timelineStartInfo.pts === undefined) {\n      track.timelineStartInfo.pts = data.pts;\n    } else {\n      track.timelineStartInfo.pts =\n        Math.min(track.timelineStartInfo.pts, data.pts);\n    }\n  }\n\n  if (typeof data.dts === 'number') {\n    if (track.timelineStartInfo.dts === undefined) {\n      track.timelineStartInfo.dts = data.dts;\n    } else {\n      track.timelineStartInfo.dts =\n        Math.min(track.timelineStartInfo.dts, data.dts);\n    }\n  }\n};\n\nmetaDataTag = function(track, pts) {\n  var\n    tag = new FlvTag(FlvTag.METADATA_TAG); // :FlvTag\n\n  tag.dts = pts;\n  tag.pts = pts;\n\n  tag.writeMetaDataDouble('videocodecid', 7);\n  tag.writeMetaDataDouble('width', track.width);\n  tag.writeMetaDataDouble('height', track.height);\n\n  return tag;\n};\n\nextraDataTag = function(track, pts) {\n  var\n    i,\n    tag = new FlvTag(FlvTag.VIDEO_TAG, true);\n\n  tag.dts = pts;\n  tag.pts = pts;\n\n  tag.writeByte(0x01);// version\n  tag.writeByte(track.profileIdc);// profile\n  tag.writeByte(track.profileCompatibility);// compatibility\n  tag.writeByte(track.levelIdc);// level\n  tag.writeByte(0xFC | 0x03); // reserved (6 bits), NULA length size - 1 (2 bits)\n  tag.writeByte(0xE0 | 0x01); // reserved (3 bits), num of SPS (5 bits)\n  tag.writeShort(track.sps[0].length); // data of SPS\n  tag.writeBytes(track.sps[0]); // SPS\n\n  tag.writeByte(track.pps.length); // num of PPS (will there ever be more that 1 PPS?)\n  for (i = 0; i < track.pps.length; ++i) {\n    tag.writeShort(track.pps[i].length); // 2 bytes for length of PPS\n    tag.writeBytes(track.pps[i]); // data of PPS\n  }\n\n  return tag;\n};\n\n/**\n * Constructs a single-track, media segment from AAC data\n * events. The output of this stream can be fed to flash.\n */\nAudioSegmentStream = function(track) {\n  var\n    adtsFrames = [],\n    videoKeyFrames = [],\n    oldExtraData;\n\n  AudioSegmentStream.prototype.init.call(this);\n\n  this.push = function(data) {\n    collectTimelineInfo(track, data);\n\n    if (track) {\n      track.audioobjecttype = data.audioobjecttype;\n      track.channelcount = data.channelcount;\n      track.samplerate = data.samplerate;\n      track.samplingfrequencyindex = data.samplingfrequencyindex;\n      track.samplesize = data.samplesize;\n      track.extraData = (track.audioobjecttype << 11) |\n                        (track.samplingfrequencyindex << 7) |\n                        (track.channelcount << 3);\n    }\n\n    data.pts = Math.round(data.pts / 90);\n    data.dts = Math.round(data.dts / 90);\n\n    // buffer audio data until end() is called\n    adtsFrames.push(data);\n  };\n\n  this.flush = function() {\n    var currentFrame, adtsFrame, lastMetaPts, tags = new TagList();\n    // return early if no audio data has been observed\n    if (adtsFrames.length === 0) {\n      this.trigger('done', 'AudioSegmentStream');\n      return;\n    }\n\n    lastMetaPts = -Infinity;\n\n    while (adtsFrames.length) {\n      currentFrame = adtsFrames.shift();\n\n      // write out a metadata frame at every video key frame\n      if (videoKeyFrames.length && currentFrame.pts >= videoKeyFrames[0]) {\n        lastMetaPts = videoKeyFrames.shift();\n        this.writeMetaDataTags(tags, lastMetaPts);\n      }\n\n      // also write out metadata tags every 1 second so that the decoder\n      // is re-initialized quickly after seeking into a different\n      // audio configuration.\n      if (track.extraData !== oldExtraData || currentFrame.pts - lastMetaPts >= 1000) {\n        this.writeMetaDataTags(tags, currentFrame.pts);\n        oldExtraData = track.extraData;\n        lastMetaPts = currentFrame.pts;\n      }\n\n      adtsFrame = new FlvTag(FlvTag.AUDIO_TAG);\n      adtsFrame.pts = currentFrame.pts;\n      adtsFrame.dts = currentFrame.dts;\n\n      adtsFrame.writeBytes(currentFrame.data);\n\n      tags.push(adtsFrame.finalize());\n    }\n\n    videoKeyFrames.length = 0;\n    oldExtraData = null;\n    this.trigger('data', {track: track, tags: tags.list});\n\n    this.trigger('done', 'AudioSegmentStream');\n  };\n\n  this.writeMetaDataTags = function(tags, pts) {\n    var adtsFrame;\n\n    adtsFrame = new FlvTag(FlvTag.METADATA_TAG);\n    // For audio, DTS is always the same as PTS. We want to set the DTS\n    // however so we can compare with video DTS to determine approximate\n    // packet order\n    adtsFrame.pts = pts;\n    adtsFrame.dts = pts;\n\n    // AAC is always 10\n    adtsFrame.writeMetaDataDouble('audiocodecid', 10);\n    adtsFrame.writeMetaDataBoolean('stereo', track.channelcount === 2);\n    adtsFrame.writeMetaDataDouble('audiosamplerate', track.samplerate);\n    // Is AAC always 16 bit?\n    adtsFrame.writeMetaDataDouble('audiosamplesize', 16);\n\n    tags.push(adtsFrame.finalize());\n\n    adtsFrame = new FlvTag(FlvTag.AUDIO_TAG, true);\n    // For audio, DTS is always the same as PTS. We want to set the DTS\n    // however so we can compare with video DTS to determine approximate\n    // packet order\n    adtsFrame.pts = pts;\n    adtsFrame.dts = pts;\n\n    adtsFrame.view.setUint16(adtsFrame.position, track.extraData);\n    adtsFrame.position += 2;\n    adtsFrame.length = Math.max(adtsFrame.length, adtsFrame.position);\n\n    tags.push(adtsFrame.finalize());\n  };\n\n  this.onVideoKeyFrame = function(pts) {\n    videoKeyFrames.push(pts);\n  };\n};\nAudioSegmentStream.prototype = new Stream();\n\n/**\n * Store FlvTags for the h264 stream\n * @param track {object} track metadata configuration\n */\nVideoSegmentStream = function(track) {\n  var\n    nalUnits = [],\n    config,\n    h264Frame;\n  VideoSegmentStream.prototype.init.call(this);\n\n  this.finishFrame = function(tags, frame) {\n    if (!frame) {\n      return;\n    }\n    // Check if keyframe and the length of tags.\n    // This makes sure we write metadata on the first frame of a segment.\n    if (config && track && track.newMetadata &&\n        (frame.keyFrame || tags.length === 0)) {\n      // Push extra data on every IDR frame in case we did a stream change + seek\n      var metaTag = metaDataTag(config, frame.dts).finalize();\n      var extraTag = extraDataTag(track, frame.dts).finalize();\n\n      metaTag.metaDataTag = extraTag.metaDataTag = true;\n\n      tags.push(metaTag);\n      tags.push(extraTag);\n      track.newMetadata = false;\n\n      this.trigger('keyframe', frame.dts);\n    }\n\n    frame.endNalUnit();\n    tags.push(frame.finalize());\n    h264Frame = null;\n  };\n\n  this.push = function(data) {\n    collectTimelineInfo(track, data);\n\n    data.pts = Math.round(data.pts / 90);\n    data.dts = Math.round(data.dts / 90);\n\n    // buffer video until flush() is called\n    nalUnits.push(data);\n  };\n\n  this.flush = function() {\n    var\n      currentNal,\n      tags = new TagList();\n\n    // Throw away nalUnits at the start of the byte stream until we find\n    // the first AUD\n    while (nalUnits.length) {\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n        break;\n      }\n      nalUnits.shift();\n    }\n\n    // return early if no video data has been observed\n    if (nalUnits.length === 0) {\n      this.trigger('done', 'VideoSegmentStream');\n      return;\n    }\n\n    while (nalUnits.length) {\n      currentNal = nalUnits.shift();\n\n      // record the track config\n      if (currentNal.nalUnitType === 'seq_parameter_set_rbsp') {\n        track.newMetadata = true;\n        config = currentNal.config;\n        track.width = config.width;\n        track.height = config.height;\n        track.sps = [currentNal.data];\n        track.profileIdc = config.profileIdc;\n        track.levelIdc = config.levelIdc;\n        track.profileCompatibility = config.profileCompatibility;\n        h264Frame.endNalUnit();\n      } else if (currentNal.nalUnitType === 'pic_parameter_set_rbsp') {\n        track.newMetadata = true;\n        track.pps = [currentNal.data];\n        h264Frame.endNalUnit();\n      } else if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n        if (h264Frame) {\n          this.finishFrame(tags, h264Frame);\n        }\n        h264Frame = new FlvTag(FlvTag.VIDEO_TAG);\n        h264Frame.pts = currentNal.pts;\n        h264Frame.dts = currentNal.dts;\n      } else {\n        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n          // the current sample is a key frame\n          h264Frame.keyFrame = true;\n        }\n        h264Frame.endNalUnit();\n      }\n      h264Frame.startNalUnit();\n      h264Frame.writeBytes(currentNal.data);\n    }\n    if (h264Frame) {\n      this.finishFrame(tags, h264Frame);\n    }\n\n    this.trigger('data', {track: track, tags: tags.list});\n\n    // Continue with the flush process now\n    this.trigger('done', 'VideoSegmentStream');\n  };\n};\n\nVideoSegmentStream.prototype = new Stream();\n\n/**\n * An object that incrementally transmuxes MPEG2 Trasport Stream\n * chunks into an FLV.\n */\nTransmuxer = function(options) {\n  var\n    self = this,\n\n    packetStream, parseStream, elementaryStream,\n    videoTimestampRolloverStream, audioTimestampRolloverStream,\n    timedMetadataTimestampRolloverStream,\n    adtsStream, h264Stream,\n    videoSegmentStream, audioSegmentStream, captionStream,\n    coalesceStream;\n\n  Transmuxer.prototype.init.call(this);\n\n  options = options || {};\n\n  // expose the metadata stream\n  this.metadataStream = new m2ts.MetadataStream();\n\n  options.metadataStream = this.metadataStream;\n\n  // set up the parsing pipeline\n  packetStream = new m2ts.TransportPacketStream();\n  parseStream = new m2ts.TransportParseStream();\n  elementaryStream = new m2ts.ElementaryStream();\n  videoTimestampRolloverStream = new m2ts.TimestampRolloverStream('video');\n  audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n  timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n\n  adtsStream = new AdtsStream();\n  h264Stream = new H264Stream();\n  coalesceStream = new CoalesceStream(options);\n\n  // disassemble MPEG2-TS packets into elementary streams\n  packetStream\n    .pipe(parseStream)\n    .pipe(elementaryStream);\n\n  // !!THIS ORDER IS IMPORTANT!!\n  // demux the streams\n  elementaryStream\n    .pipe(videoTimestampRolloverStream)\n    .pipe(h264Stream);\n  elementaryStream\n    .pipe(audioTimestampRolloverStream)\n    .pipe(adtsStream);\n\n  elementaryStream\n    .pipe(timedMetadataTimestampRolloverStream)\n    .pipe(this.metadataStream)\n    .pipe(coalesceStream);\n  // if CEA-708 parsing is available, hook up a caption stream\n  captionStream = new m2ts.CaptionStream();\n  h264Stream.pipe(captionStream)\n    .pipe(coalesceStream);\n\n  // hook up the segment streams once track metadata is delivered\n  elementaryStream.on('data', function(data) {\n    var i, videoTrack, audioTrack;\n\n    if (data.type === 'metadata') {\n      i = data.tracks.length;\n\n      // scan the tracks listed in the metadata\n      while (i--) {\n        if (data.tracks[i].type === 'video') {\n          videoTrack = data.tracks[i];\n        } else if (data.tracks[i].type === 'audio') {\n          audioTrack = data.tracks[i];\n        }\n      }\n\n      // hook up the video segment stream to the first track with h264 data\n      if (videoTrack && !videoSegmentStream) {\n        coalesceStream.numberOfTracks++;\n        videoSegmentStream = new VideoSegmentStream(videoTrack);\n\n        // Set up the final part of the video pipeline\n        h264Stream\n          .pipe(videoSegmentStream)\n          .pipe(coalesceStream);\n      }\n\n      if (audioTrack && !audioSegmentStream) {\n        // hook up the audio segment stream to the first track with aac data\n        coalesceStream.numberOfTracks++;\n        audioSegmentStream = new AudioSegmentStream(audioTrack);\n\n        // Set up the final part of the audio pipeline\n        adtsStream\n          .pipe(audioSegmentStream)\n          .pipe(coalesceStream);\n\n        if (videoSegmentStream) {\n          videoSegmentStream.on('keyframe', audioSegmentStream.onVideoKeyFrame);\n        }\n      }\n    }\n  });\n\n  // feed incoming data to the front of the parsing pipeline\n  this.push = function(data) {\n    packetStream.push(data);\n  };\n\n  // flush any buffered data\n  this.flush = function() {\n    // Start at the top of the pipeline and flush all pending work\n    packetStream.flush();\n  };\n\n  // Caption data has to be reset when seeking outside buffered range\n  this.resetCaptions = function() {\n    captionStream.reset();\n  };\n\n  // Re-emit any data coming from the coalesce stream to the outside world\n  coalesceStream.on('data', function(event) {\n    self.trigger('data', event);\n  });\n\n  // Let the consumer know we have finished flushing the entire pipeline\n  coalesceStream.on('done', function() {\n    self.trigger('done');\n  });\n};\nTransmuxer.prototype = new Stream();\n\n// forward compatibility\nmodule.exports = Transmuxer;\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nvar FlvTag = require('./flv-tag.js');\n\n// For information on the FLV format, see\n// http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf.\n// Technically, this function returns the header and a metadata FLV tag\n// if duration is greater than zero\n// duration in seconds\n// @return {object} the bytes of the FLV header as a Uint8Array\nvar getFlvHeader = function(duration, audio, video) { // :ByteArray {\n  var\n    headBytes = new Uint8Array(3 + 1 + 1 + 4),\n    head = new DataView(headBytes.buffer),\n    metadata,\n    result,\n    metadataLength;\n\n  // default arguments\n  duration = duration || 0;\n  audio = audio === undefined ? true : audio;\n  video = video === undefined ? true : video;\n\n  // signature\n  head.setUint8(0, 0x46); // 'F'\n  head.setUint8(1, 0x4c); // 'L'\n  head.setUint8(2, 0x56); // 'V'\n\n  // version\n  head.setUint8(3, 0x01);\n\n  // flags\n  head.setUint8(4, (audio ? 0x04 : 0x00) | (video ? 0x01 : 0x00));\n\n  // data offset, should be 9 for FLV v1\n  head.setUint32(5, headBytes.byteLength);\n\n  // init the first FLV tag\n  if (duration <= 0) {\n    // no duration available so just write the first field of the first\n    // FLV tag\n    result = new Uint8Array(headBytes.byteLength + 4);\n    result.set(headBytes);\n    result.set([0, 0, 0, 0], headBytes.byteLength);\n    return result;\n  }\n\n  // write out the duration metadata tag\n  metadata = new FlvTag(FlvTag.METADATA_TAG);\n  metadata.pts = metadata.dts = 0;\n  metadata.writeMetaDataDouble('duration', duration);\n  metadataLength = metadata.finalize().length;\n  result = new Uint8Array(headBytes.byteLength + metadataLength);\n  result.set(headBytes);\n  result.set(head.byteLength, metadataLength);\n\n  return result;\n};\n\nmodule.exports = getFlvHeader;\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\nmodule.exports = {\n  tag: require('./flv-tag'),\n  Transmuxer: require('./transmuxer'),\n  getFlvHeader: require('./flv-header')\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\nmodule.exports = require('./m2ts');\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nvar\n  tagTypes = {\n    0x08: 'audio',\n    0x09: 'video',\n    0x12: 'metadata'\n  },\n  hex = function(val) {\n    return '0x' + ('00' + val.toString(16)).slice(-2).toUpperCase();\n  },\n  hexStringList = function(data) {\n    var arr = [], i;\n\n    while (data.byteLength > 0) {\n      i = 0;\n      arr.push(hex(data[i++]));\n      data = data.subarray(i);\n    }\n    return arr.join(' ');\n  },\n  parseAVCTag = function(tag, obj) {\n    var\n      avcPacketTypes = [\n        'AVC Sequence Header',\n        'AVC NALU',\n        'AVC End-of-Sequence'\n      ],\n      compositionTime = (tag[1] & parseInt('01111111', 2) << 16) | (tag[2] << 8) | tag[3];\n\n    obj = obj || {};\n\n    obj.avcPacketType = avcPacketTypes[tag[0]];\n    obj.CompositionTime = (tag[1] & parseInt('10000000', 2)) ? -compositionTime : compositionTime;\n\n    if (tag[0] === 1) {\n      obj.nalUnitTypeRaw = hexStringList(tag.subarray(4, 100));\n    } else {\n      obj.data = hexStringList(tag.subarray(4));\n    }\n\n    return obj;\n  },\n  parseVideoTag = function(tag, obj) {\n    var\n      frameTypes = [\n        'Unknown',\n        'Keyframe (for AVC, a seekable frame)',\n        'Inter frame (for AVC, a nonseekable frame)',\n        'Disposable inter frame (H.263 only)',\n        'Generated keyframe (reserved for server use only)',\n        'Video info/command frame'\n      ],\n      codecID = tag[0] & parseInt('00001111', 2);\n\n    obj = obj || {};\n\n    obj.frameType = frameTypes[(tag[0] & parseInt('11110000', 2)) >>> 4];\n    obj.codecID = codecID;\n\n    if (codecID === 7) {\n      return parseAVCTag(tag.subarray(1), obj);\n    }\n    return obj;\n  },\n  parseAACTag = function(tag, obj) {\n    var packetTypes = [\n      'AAC Sequence Header',\n      'AAC Raw'\n    ];\n\n    obj = obj || {};\n\n    obj.aacPacketType = packetTypes[tag[0]];\n    obj.data = hexStringList(tag.subarray(1));\n\n    return obj;\n  },\n  parseAudioTag = function(tag, obj) {\n    var\n      formatTable = [\n        'Linear PCM, platform endian',\n        'ADPCM',\n        'MP3',\n        'Linear PCM, little endian',\n        'Nellymoser 16-kHz mono',\n        'Nellymoser 8-kHz mono',\n        'Nellymoser',\n        'G.711 A-law logarithmic PCM',\n        'G.711 mu-law logarithmic PCM',\n        'reserved',\n        'AAC',\n        'Speex',\n        'MP3 8-Khz',\n        'Device-specific sound'\n      ],\n      samplingRateTable = [\n        '5.5-kHz',\n        '11-kHz',\n        '22-kHz',\n        '44-kHz'\n      ],\n      soundFormat = (tag[0] & parseInt('11110000', 2)) >>> 4;\n\n    obj = obj || {};\n\n    obj.soundFormat = formatTable[soundFormat];\n    obj.soundRate = samplingRateTable[(tag[0] & parseInt('00001100', 2)) >>> 2];\n    obj.soundSize = ((tag[0] & parseInt('00000010', 2)) >>> 1) ? '16-bit' : '8-bit';\n    obj.soundType = (tag[0] & parseInt('00000001', 2)) ? 'Stereo' : 'Mono';\n\n    if (soundFormat === 10) {\n      return parseAACTag(tag.subarray(1), obj);\n    }\n    return obj;\n  },\n  parseGenericTag = function(tag) {\n    return {\n      tagType: tagTypes[tag[0]],\n      dataSize: (tag[1] << 16) | (tag[2] << 8) | tag[3],\n      timestamp: (tag[7] << 24) | (tag[4] << 16) | (tag[5] << 8) | tag[6],\n      streamID: (tag[8] << 16) | (tag[9] << 8) | tag[10]\n    };\n  },\n  inspectFlvTag = function(tag) {\n    var header = parseGenericTag(tag);\n    switch (tag[0]) {\n      case 0x08:\n        parseAudioTag(tag.subarray(11), header);\n        break;\n      case 0x09:\n        parseVideoTag(tag.subarray(11), header);\n        break;\n      case 0x12:\n    }\n    return header;\n  },\n  inspectFlv = function(bytes) {\n    var i = 9, // header\n        dataSize,\n        parsedResults = [],\n        tag;\n\n    // traverse the tags\n    i += 4; // skip previous tag size\n    while (i < bytes.byteLength) {\n      dataSize = bytes[i + 1] << 16;\n      dataSize |= bytes[i + 2] << 8;\n      dataSize |= bytes[i + 3];\n      dataSize += 11;\n\n      tag = bytes.subarray(i, i + dataSize);\n      parsedResults.push(inspectFlvTag(tag));\n      i += dataSize + 4;\n    }\n    return parsedResults;\n  },\n  textifyFlv = function(flvTagArray) {\n    return JSON.stringify(flvTagArray, null, 2);\n  };\n\nmodule.exports = {\n  inspectTag: inspectFlvTag,\n  inspect: inspectFlv,\n  textify: textifyFlv\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Utilities to detect basic properties and metadata about TS Segments.\n */\n'use strict';\n\nvar StreamTypes = require('./stream-types.js');\n\nvar parsePid = function(packet) {\n  var pid = packet[1] & 0x1f;\n  pid <<= 8;\n  pid |= packet[2];\n  return pid;\n};\n\nvar parsePayloadUnitStartIndicator = function(packet) {\n  return !!(packet[1] & 0x40);\n};\n\nvar parseAdaptionField = function(packet) {\n  var offset = 0;\n  // if an adaption field is present, its length is specified by the\n  // fifth byte of the TS packet header. The adaptation field is\n  // used to add stuffing to PES packets that don't fill a complete\n  // TS packet, and to specify some forms of timing and control data\n  // that we do not currently use.\n  if (((packet[3] & 0x30) >>> 4) > 0x01) {\n    offset += packet[4] + 1;\n  }\n  return offset;\n};\n\nvar parseType = function(packet, pmtPid) {\n  var pid = parsePid(packet);\n  if (pid === 0) {\n    return 'pat';\n  } else if (pid === pmtPid) {\n    return 'pmt';\n  } else if (pmtPid) {\n    return 'pes';\n  }\n  return null;\n};\n\nvar parsePat = function(packet) {\n  var pusi = parsePayloadUnitStartIndicator(packet);\n  var offset = 4 + parseAdaptionField(packet);\n\n  if (pusi) {\n    offset += packet[offset] + 1;\n  }\n\n  return (packet[offset + 10] & 0x1f) << 8 | packet[offset + 11];\n};\n\nvar parsePmt = function(packet) {\n  var programMapTable = {};\n  var pusi = parsePayloadUnitStartIndicator(packet);\n  var payloadOffset = 4 + parseAdaptionField(packet);\n\n  if (pusi) {\n    payloadOffset += packet[payloadOffset] + 1;\n  }\n\n  // PMTs can be sent ahead of the time when they should actually\n  // take effect. We don't believe this should ever be the case\n  // for HLS but we'll ignore \"forward\" PMT declarations if we see\n  // them. Future PMT declarations have the current_next_indicator\n  // set to zero.\n  if (!(packet[payloadOffset + 5] & 0x01)) {\n    return;\n  }\n\n  var sectionLength, tableEnd, programInfoLength;\n  // the mapping table ends at the end of the current section\n  sectionLength = (packet[payloadOffset + 1] & 0x0f) << 8 | packet[payloadOffset + 2];\n  tableEnd = 3 + sectionLength - 4;\n\n  // to determine where the table is, we have to figure out how\n  // long the program info descriptors are\n  programInfoLength = (packet[payloadOffset + 10] & 0x0f) << 8 | packet[payloadOffset + 11];\n\n  // advance the offset to the first entry in the mapping table\n  var offset = 12 + programInfoLength;\n  while (offset < tableEnd) {\n    var i = payloadOffset + offset;\n    // add an entry that maps the elementary_pid to the stream_type\n    programMapTable[(packet[i + 1] & 0x1F) << 8 | packet[i + 2]] = packet[i];\n\n    // move to the next table entry\n    // skip past the elementary stream descriptors, if present\n    offset += ((packet[i + 3] & 0x0F) << 8 | packet[i + 4]) + 5;\n  }\n  return programMapTable;\n};\n\nvar parsePesType = function(packet, programMapTable) {\n  var pid = parsePid(packet);\n  var type = programMapTable[pid];\n  switch (type) {\n    case StreamTypes.H264_STREAM_TYPE:\n      return 'video';\n    case StreamTypes.ADTS_STREAM_TYPE:\n      return 'audio';\n    case StreamTypes.METADATA_STREAM_TYPE:\n      return 'timed-metadata';\n    default:\n      return null;\n  }\n};\n\nvar parsePesTime = function(packet) {\n  var pusi = parsePayloadUnitStartIndicator(packet);\n  if (!pusi) {\n    return null;\n  }\n\n  var offset = 4 + parseAdaptionField(packet);\n\n  if (offset >= packet.byteLength) {\n    // From the H 222.0 MPEG-TS spec\n    // \"For transport stream packets carrying PES packets, stuffing is needed when there\n    //  is insufficient PES packet data to completely fill the transport stream packet\n    //  payload bytes. Stuffing is accomplished by defining an adaptation field longer than\n    //  the sum of the lengths of the data elements in it, so that the payload bytes\n    //  remaining after the adaptation field exactly accommodates the available PES packet\n    //  data.\"\n    //\n    // If the offset is >= the length of the packet, then the packet contains no data\n    // and instead is just adaption field stuffing bytes\n    return null;\n  }\n\n  var pes = null;\n  var ptsDtsFlags;\n\n  // PES packets may be annotated with a PTS value, or a PTS value\n  // and a DTS value. Determine what combination of values is\n  // available to work with.\n  ptsDtsFlags = packet[offset + 7];\n\n  // PTS and DTS are normally stored as a 33-bit number.  Javascript\n  // performs all bitwise operations on 32-bit integers but javascript\n  // supports a much greater range (52-bits) of integer using standard\n  // mathematical operations.\n  // We construct a 31-bit value using bitwise operators over the 31\n  // most significant bits and then multiply by 4 (equal to a left-shift\n  // of 2) before we add the final 2 least significant bits of the\n  // timestamp (equal to an OR.)\n  if (ptsDtsFlags & 0xC0) {\n    pes = {};\n    // the PTS and DTS are not written out directly. For information\n    // on how they are encoded, see\n    // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n    pes.pts = (packet[offset + 9] & 0x0E) << 27 |\n      (packet[offset + 10] & 0xFF) << 20 |\n      (packet[offset + 11] & 0xFE) << 12 |\n      (packet[offset + 12] & 0xFF) <<  5 |\n      (packet[offset + 13] & 0xFE) >>>  3;\n    pes.pts *= 4; // Left shift by 2\n    pes.pts += (packet[offset + 13] & 0x06) >>> 1; // OR by the two LSBs\n    pes.dts = pes.pts;\n    if (ptsDtsFlags & 0x40) {\n      pes.dts = (packet[offset + 14] & 0x0E) << 27 |\n        (packet[offset + 15] & 0xFF) << 20 |\n        (packet[offset + 16] & 0xFE) << 12 |\n        (packet[offset + 17] & 0xFF) << 5 |\n        (packet[offset + 18] & 0xFE) >>> 3;\n      pes.dts *= 4; // Left shift by 2\n      pes.dts += (packet[offset + 18] & 0x06) >>> 1; // OR by the two LSBs\n    }\n  }\n  return pes;\n};\n\nvar parseNalUnitType = function(type) {\n  switch (type) {\n    case 0x05:\n      return 'slice_layer_without_partitioning_rbsp_idr';\n    case 0x06:\n      return 'sei_rbsp';\n    case 0x07:\n      return 'seq_parameter_set_rbsp';\n    case 0x08:\n      return 'pic_parameter_set_rbsp';\n    case 0x09:\n      return 'access_unit_delimiter_rbsp';\n    default:\n      return null;\n  }\n};\n\nvar videoPacketContainsKeyFrame = function(packet) {\n  var offset = 4 + parseAdaptionField(packet);\n  var frameBuffer = packet.subarray(offset);\n  var frameI = 0;\n  var frameSyncPoint = 0;\n  var foundKeyFrame = false;\n  var nalType;\n\n  // advance the sync point to a NAL start, if necessary\n  for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {\n    if (frameBuffer[frameSyncPoint + 2] === 1) {\n      // the sync point is properly aligned\n      frameI = frameSyncPoint + 5;\n      break;\n    }\n  }\n\n  while (frameI < frameBuffer.byteLength) {\n    // look at the current byte to determine if we've hit the end of\n    // a NAL unit boundary\n    switch (frameBuffer[frameI]) {\n    case 0:\n      // skip past non-sync sequences\n      if (frameBuffer[frameI - 1] !== 0) {\n        frameI += 2;\n        break;\n      } else if (frameBuffer[frameI - 2] !== 0) {\n        frameI++;\n        break;\n      }\n\n      if (frameSyncPoint + 3 !== frameI - 2) {\n        nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n        if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n          foundKeyFrame = true;\n        }\n      }\n\n      // drop trailing zeroes\n      do {\n        frameI++;\n      } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);\n      frameSyncPoint = frameI - 2;\n      frameI += 3;\n      break;\n    case 1:\n      // skip past non-sync sequences\n      if (frameBuffer[frameI - 1] !== 0 ||\n          frameBuffer[frameI - 2] !== 0) {\n        frameI += 3;\n        break;\n      }\n\n      nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n      if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n        foundKeyFrame = true;\n      }\n      frameSyncPoint = frameI - 2;\n      frameI += 3;\n      break;\n    default:\n      // the current byte isn't a one or zero, so it cannot be part\n      // of a sync sequence\n      frameI += 3;\n      break;\n    }\n  }\n  frameBuffer = frameBuffer.subarray(frameSyncPoint);\n  frameI -= frameSyncPoint;\n  frameSyncPoint = 0;\n  // parse the final nal\n  if (frameBuffer && frameBuffer.byteLength > 3) {\n    nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n    if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n      foundKeyFrame = true;\n    }\n  }\n\n  return foundKeyFrame;\n};\n\n\nmodule.exports = {\n  parseType: parseType,\n  parsePat: parsePat,\n  parsePmt: parsePmt,\n  parsePayloadUnitStartIndicator: parsePayloadUnitStartIndicator,\n  parsePesType: parsePesType,\n  parsePesTime: parsePesTime,\n  videoPacketContainsKeyFrame: videoPacketContainsKeyFrame\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Parse mpeg2 transport stream packets to extract basic timing information\n */\n'use strict';\n\nvar StreamTypes = require('../m2ts/stream-types.js');\nvar handleRollover = require('../m2ts/timestamp-rollover-stream.js').handleRollover;\nvar probe = {};\nprobe.ts = require('../m2ts/probe.js');\nprobe.aac = require('../aac/utils.js');\n\n\nvar\n  PES_TIMESCALE = 90000,\n  MP2T_PACKET_LENGTH = 188, // bytes\n  SYNC_BYTE = 0x47;\n\n/**\n * walks through segment data looking for pat and pmt packets to parse out\n * program map table information\n */\nvar parsePsi_ = function(bytes, pmt) {\n  var\n    startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet, type;\n\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pat':\n          if (!pmt.pid) {\n            pmt.pid = probe.ts.parsePat(packet);\n          }\n          break;\n        case 'pmt':\n          if (!pmt.table) {\n            pmt.table = probe.ts.parsePmt(packet);\n          }\n          break;\n        default:\n          break;\n      }\n\n      // Found the pat and pmt, we can stop walking the segment\n      if (pmt.pid && pmt.table) {\n        return;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n};\n\n/**\n * walks through the segment data from the start and end to get timing information\n * for the first and last audio pes packets\n */\nvar parseAudioPes_ = function(bytes, pmt, result) {\n  var\n    startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet, type, pesType, pusi, parsed;\n\n  var endLoop = false;\n\n  // Start walking from start of segment to get first audio packet\n  while (endIndex <= bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE &&\n        (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'audio' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n            if (parsed) {\n              parsed.type = 'audio';\n              result.audio.push(parsed);\n              endLoop = true;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n\n  // Start walking from end of segment to get last audio packet\n  endIndex = bytes.byteLength;\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\n  endLoop = false;\n  while (startIndex >= 0) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE &&\n        (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'audio' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n            if (parsed) {\n              parsed.type = 'audio';\n              result.audio.push(parsed);\n              endLoop = true;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex -= MP2T_PACKET_LENGTH;\n      endIndex -= MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex--;\n    endIndex--;\n  }\n};\n\n/**\n * walks through the segment data from the start and end to get timing information\n * for the first and last video pes packets as well as timing information for the first\n * key frame.\n */\nvar parseVideoPes_ = function(bytes, pmt, result) {\n  var\n    startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet, type, pesType, pusi, parsed, frame, i, pes;\n\n  var endLoop = false;\n\n  var currentFrame = {\n    data: [],\n    size: 0\n  };\n\n  // Start walking from start of segment to get first video packet\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'video') {\n            if (pusi && !endLoop) {\n              parsed = probe.ts.parsePesTime(packet);\n              if (parsed) {\n                parsed.type = 'video';\n                result.video.push(parsed);\n                endLoop = true;\n              }\n            }\n            if (!result.firstKeyFrame) {\n              if (pusi) {\n                if (currentFrame.size !== 0) {\n                  frame = new Uint8Array(currentFrame.size);\n                  i = 0;\n                  while (currentFrame.data.length) {\n                    pes = currentFrame.data.shift();\n                    frame.set(pes, i);\n                    i += pes.byteLength;\n                  }\n                  if (probe.ts.videoPacketContainsKeyFrame(frame)) {\n                    var firstKeyFrame = probe.ts.parsePesTime(frame);\n\n                    // PTS/DTS may not be available. Simply *not* setting\n                    // the keyframe seems to work fine with HLS playback\n                    // and definitely preferable to a crash with TypeError...\n                    if (firstKeyFrame) {\n                      result.firstKeyFrame = firstKeyFrame;\n                      result.firstKeyFrame.type = 'video';\n                    } else {\n                      // eslint-disable-next-line\n                      console.warn(\n                        'Failed to extract PTS/DTS from PES at first keyframe. ' +\n                        'This could be an unusual TS segment, or else mux.js did not ' +\n                        'parse your TS segment correctly. If you know your TS ' +\n                        'segments do contain PTS/DTS on keyframes please file a bug ' +\n                        'report! You can try ffprobe to double check for yourself.'\n                      );\n                    }\n                  }\n                  currentFrame.size = 0;\n                }\n              }\n              currentFrame.data.push(packet);\n              currentFrame.size += packet.byteLength;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop && result.firstKeyFrame) {\n        break;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n\n  // Start walking from end of segment to get last video packet\n  endIndex = bytes.byteLength;\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\n  endLoop = false;\n  while (startIndex >= 0) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'video' && pusi) {\n              parsed = probe.ts.parsePesTime(packet);\n              if (parsed) {\n                parsed.type = 'video';\n                result.video.push(parsed);\n                endLoop = true;\n              }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex -= MP2T_PACKET_LENGTH;\n      endIndex -= MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex--;\n    endIndex--;\n  }\n};\n\n/**\n * Adjusts the timestamp information for the segment to account for\n * rollover and convert to seconds based on pes packet timescale (90khz clock)\n */\nvar adjustTimestamp_ = function(segmentInfo, baseTimestamp) {\n  if (segmentInfo.audio && segmentInfo.audio.length) {\n    var audioBaseTimestamp = baseTimestamp;\n    if (typeof audioBaseTimestamp === 'undefined') {\n      audioBaseTimestamp = segmentInfo.audio[0].dts;\n    }\n    segmentInfo.audio.forEach(function(info) {\n      info.dts = handleRollover(info.dts, audioBaseTimestamp);\n      info.pts = handleRollover(info.pts, audioBaseTimestamp);\n      // time in seconds\n      info.dtsTime = info.dts / PES_TIMESCALE;\n      info.ptsTime = info.pts / PES_TIMESCALE;\n    });\n  }\n\n  if (segmentInfo.video && segmentInfo.video.length) {\n    var videoBaseTimestamp = baseTimestamp;\n    if (typeof videoBaseTimestamp === 'undefined') {\n      videoBaseTimestamp = segmentInfo.video[0].dts;\n    }\n    segmentInfo.video.forEach(function(info) {\n      info.dts = handleRollover(info.dts, videoBaseTimestamp);\n      info.pts = handleRollover(info.pts, videoBaseTimestamp);\n      // time in seconds\n      info.dtsTime = info.dts / PES_TIMESCALE;\n      info.ptsTime = info.pts / PES_TIMESCALE;\n    });\n    if (segmentInfo.firstKeyFrame) {\n      var frame = segmentInfo.firstKeyFrame;\n      frame.dts = handleRollover(frame.dts, videoBaseTimestamp);\n      frame.pts = handleRollover(frame.pts, videoBaseTimestamp);\n      // time in seconds\n      frame.dtsTime = frame.dts / PES_TIMESCALE;\n      frame.ptsTime = frame.dts / PES_TIMESCALE;\n    }\n  }\n};\n\n/**\n * inspects the aac data stream for start and end time information\n */\nvar inspectAac_ = function(bytes) {\n  var\n    endLoop = false,\n    audioCount = 0,\n    sampleRate = null,\n    timestamp = null,\n    frameSize = 0,\n    byteIndex = 0,\n    packet;\n\n  while (bytes.length - byteIndex >= 3) {\n    var type = probe.aac.parseType(bytes, byteIndex);\n    switch (type) {\n      case 'timed-metadata':\n        // Exit early because we don't have enough to parse\n        // the ID3 tag header\n        if (bytes.length - byteIndex < 10) {\n          endLoop = true;\n          break;\n        }\n\n        frameSize = probe.aac.parseId3TagSize(bytes, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > bytes.length) {\n          endLoop = true;\n          break;\n        }\n        if (timestamp === null) {\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n          timestamp = probe.aac.parseAacTimestamp(packet);\n        }\n        byteIndex += frameSize;\n        break;\n      case 'audio':\n        // Exit early because we don't have enough to parse\n        // the ADTS frame header\n        if (bytes.length - byteIndex < 7) {\n          endLoop = true;\n          break;\n        }\n\n        frameSize = probe.aac.parseAdtsSize(bytes, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > bytes.length) {\n          endLoop = true;\n          break;\n        }\n        if (sampleRate === null) {\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n          sampleRate = probe.aac.parseSampleRate(packet);\n        }\n        audioCount++;\n        byteIndex += frameSize;\n        break;\n      default:\n        byteIndex++;\n        break;\n    }\n    if (endLoop) {\n      return null;\n    }\n  }\n  if (sampleRate === null || timestamp === null) {\n    return null;\n  }\n\n  var audioTimescale = PES_TIMESCALE / sampleRate;\n\n  var result = {\n    audio: [\n      {\n        type: 'audio',\n        dts: timestamp,\n        pts: timestamp\n      },\n      {\n        type: 'audio',\n        dts: timestamp + (audioCount * 1024 * audioTimescale),\n        pts: timestamp + (audioCount * 1024 * audioTimescale)\n      }\n    ]\n  };\n\n  return result;\n};\n\n/**\n * inspects the transport stream segment data for start and end time information\n * of the audio and video tracks (when present) as well as the first key frame's\n * start time.\n */\nvar inspectTs_ = function(bytes) {\n  var pmt = {\n    pid: null,\n    table: null\n  };\n\n  var result = {};\n\n  parsePsi_(bytes, pmt);\n\n  for (var pid in pmt.table) {\n    if (pmt.table.hasOwnProperty(pid)) {\n      var type = pmt.table[pid];\n      switch (type) {\n        case StreamTypes.H264_STREAM_TYPE:\n          result.video = [];\n          parseVideoPes_(bytes, pmt, result);\n          if (result.video.length === 0) {\n            delete result.video;\n          }\n          break;\n        case StreamTypes.ADTS_STREAM_TYPE:\n          result.audio = [];\n          parseAudioPes_(bytes, pmt, result);\n          if (result.audio.length === 0) {\n            delete result.audio;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Inspects segment byte data and returns an object with start and end timing information\n *\n * @param {Uint8Array} bytes The segment byte data\n * @param {Number} baseTimestamp Relative reference timestamp used when adjusting frame\n *  timestamps for rollover. This value must be in 90khz clock.\n * @return {Object} Object containing start and end frame timing info of segment.\n */\nvar inspect = function(bytes, baseTimestamp) {\n  var isAacData = probe.aac.isLikelyAacData(bytes);\n\n  var result;\n\n  if (isAacData) {\n    result = inspectAac_(bytes);\n  } else {\n    result = inspectTs_(bytes);\n  }\n\n  if (!result || (!result.audio && !result.video)) {\n    return null;\n  }\n\n  adjustTimestamp_(result, baseTimestamp);\n\n  return result;\n};\n\nmodule.exports = {\n  inspect: inspect,\n  parseAudioPes_: parseAudioPes_\n};\n","/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nvar muxjs = {\n  codecs: require('./codecs'),\n  mp4: require('./mp4'),\n  flv: require('./flv'),\n  mp2t: require('./m2ts')\n};\n\n// include all the tools when the full library is required\nmuxjs.mp4.tools = require('./tools/mp4-inspector');\nmuxjs.flv.tools = require('./tools/flv-inspector');\nmuxjs.mp2t.tools = require('./tools/ts-inspector');\n\n\nmodule.exports = muxjs;\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\ngoog.provide('shaka.util.Dom');\n\ngoog.require('goog.asserts');\n\n\nshaka.util.Dom = class {\n  /**\n   * Creates an element, and cast the type from Element to HTMLElement.\n   *\n   * @param {string} tagName\n   * @return {!HTMLElement}\n   * @export\n   */\n  static createHTMLElement(tagName) {\n    const element =\n      /** @type {!HTMLElement} */ (document.createElement(tagName));\n    return element;\n  }\n\n\n  /**\n   * Creates an element, and cast the type from Element to HTMLElement.\n   *\n   * @return {!HTMLVideoElement}\n   * @export\n   */\n  static createVideoElement() {\n    const video =\n      /** @type {!HTMLVideoElement} */ (document.createElement('video'));\n\n    video.muted = true;\n    video.width = 600;\n    video.height = 400;\n\n    return video;\n  }\n\n\n  /**\n   * Cast a Node/Element to an HTMLElement\n   *\n   * @param {!Node|!Element} original\n   * @return {!HTMLElement}\n   * @export\n   */\n  static asHTMLElement(original) {\n    return /** @type {!HTMLElement}*/ (original);\n  }\n\n\n  /**\n   * Cast a Node/Element to an HTMLMediaElement\n   *\n   * @param {!Node|!Element} original\n   * @return {!HTMLMediaElement}\n   * @export\n   */\n  static asHTMLMediaElement(original) {\n    return /** @type {!HTMLMediaElement}*/ (original);\n  }\n\n\n  /**\n   * Returns the element with a given class name.\n   * Assumes the class name to be unique for a given parent.\n   *\n   * @param {string} className\n   * @param {!HTMLElement} parent\n   * @return {!HTMLElement}\n   */\n  static getElementByClassName(className, parent) {\n    const elements = parent.getElementsByClassName(className);\n    goog.asserts.assert(elements.length == 1,\n        'Should only be one element with class name ' + className);\n\n    return shaka.util.Dom.asHTMLElement(elements[0]);\n  }\n\n\n  /**\n   * Remove all of the child nodes of an element.\n   * @param {!Element} element\n   * @export\n   */\n  static removeAllChildren(element) {\n    while (element.firstChild) {\n      element.removeChild(element.firstChild);\n    }\n  }\n};\n\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Bootstrap for the Google JS Library (Closure).\n *\n * In uncompiled mode base.js will write out Closure's deps file, unless the\n * global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects to\n * include their own deps file(s) from different locations.\n *\n *\n * @provideGoog\n */\n\n\n/**\n * @define {boolean} Overridden to true by the compiler when --closure_pass\n *     or --mark_as_compiled is specified.\n */\nvar COMPILED = false;\n\n\n/**\n * Base namespace for the Closure library.  Checks to see goog is already\n * defined in the current scope before assigning to prevent clobbering if\n * base.js is loaded more than once.\n *\n * @const\n */\nvar goog = goog || {};\n\n\n/**\n * Reference to the global context.  In most cases this will be 'window'.\n */\ngoog.global = this;\n\n\n/**\n * A hook for overriding the define values in uncompiled mode.\n *\n * In uncompiled mode, {@code CLOSURE_UNCOMPILED_DEFINES} may be defined before\n * loading base.js.  If a key is defined in {@code CLOSURE_UNCOMPILED_DEFINES},\n * {@code goog.define} will use the value instead of the default value.  This\n * allows flags to be overwritten without compilation (this is normally\n * accomplished with the compiler's \"define\" flag).\n *\n * Example:\n * <pre>\n *   var CLOSURE_UNCOMPILED_DEFINES = {'goog.DEBUG': false};\n * </pre>\n *\n * @type {Object.<string, (string|number|boolean)>|undefined}\n */\ngoog.global.CLOSURE_UNCOMPILED_DEFINES;\n\n\n/**\n * A hook for overriding the define values in uncompiled or compiled mode,\n * like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In\n * uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.\n *\n * Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or\n * string literals or the compiler will emit an error.\n *\n * While any @define value may be set, only those set with goog.define will be\n * effective for uncompiled code.\n *\n * Example:\n * <pre>\n *   var CLOSURE_DEFINES = {'goog.DEBUG': false};\n * </pre>\n *\n * @type {Object.<string, (string|number|boolean)>|undefined}\n */\ngoog.global.CLOSURE_DEFINES;\n\n\n/**\n * Returns true if the specified value is not undefined.\n * WARNING: Do not use this to test if an object has a property. Use the in\n * operator instead.\n *\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is defined.\n */\ngoog.isDef = function(val) {\n  // void 0 always evaluates to undefined and hence we do not need to depend on\n  // the definition of the global variable named 'undefined'.\n  return val !== void 0;\n};\n\n\n/**\n * Builds an object structure for the provided namespace path, ensuring that\n * names that already exist are not overwritten. For example:\n * \"a.b.c\" -> a = {};a.b={};a.b.c={};\n * Used by goog.provide and goog.exportSymbol.\n * @param {string} name name of the object that this file defines.\n * @param {*=} object the object to expose at the end of the path.\n * @param {Object=} objectToExportTo The object to add the path to; default\n *     is |goog.global|.\n * @private\n */\ngoog.exportPath_ = function(name, object, objectToExportTo) {\n  var parts = name.split('.');\n  var cur = objectToExportTo || goog.global;\n\n  // Internet Explorer exhibits strange behavior when throwing errors from\n  // methods externed in this manner.  See the testExportSymbolExceptions in\n  // base_test.html for an example.\n  if (!(parts[0] in cur) && cur.execScript) {\n    cur.execScript('var ' + parts[0]);\n  }\n\n  // Certain browsers cannot parse code in the form for((a in b); c;);\n  // This pattern is produced by the JSCompiler when it collapses the\n  // statement above into the conditional loop below. To prevent this from\n  // happening, use a for-loop and reserve the init logic as below.\n\n  // Parentheses added to eliminate strict JS warning in Firefox.\n  for (var part; parts.length && (part = parts.shift());) {\n    if (!parts.length && goog.isDef(object)) {\n      // last part and we have an object; use it\n      cur[part] = object;\n    } else if (cur[part]) {\n      cur = cur[part];\n    } else {\n      cur = cur[part] = {};\n    }\n  }\n};\n\n\n/**\n * Defines a named value. In uncompiled mode, the value is retreived from\n * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and\n * has the property specified, and otherwise used the defined defaultValue.\n * When compiled, the default can be overridden using compiler command-line\n * options.\n *\n * @param {string} name The distinguished name to provide.\n * @param {string|number|boolean} defaultValue\n */\ngoog.define = function(name, defaultValue) {\n  var value = defaultValue;\n  if (!COMPILED) {\n    if (goog.global.CLOSURE_UNCOMPILED_DEFINES &&\n        Object.prototype.hasOwnProperty.call(\n            goog.global.CLOSURE_UNCOMPILED_DEFINES, name)) {\n      value = goog.global.CLOSURE_UNCOMPILED_DEFINES[name];\n    } else if (goog.global.CLOSURE_DEFINES &&\n        Object.prototype.hasOwnProperty.call(\n            goog.global.CLOSURE_DEFINES, name)) {\n      value = goog.global.CLOSURE_DEFINES[name];\n    }\n  }\n  goog.exportPath_(name, value);\n};\n\n\n/**\n * @define {boolean} DEBUG is provided as a convenience so that debugging code\n * that should not be included in a production js_binary can be easily stripped\n * by specifying --define goog.DEBUG=false to the JSCompiler. For example, most\n * toString() methods should be declared inside an \"if (goog.DEBUG)\" conditional\n * because they are generally used for debugging purposes and it is difficult\n * for the JSCompiler to statically determine whether they are used.\n */\ngoog.DEBUG = true;\n\n\n/**\n * @define {string} LOCALE defines the locale being used for compilation. It is\n * used to select locale specific data to be compiled in js binary. BUILD rule\n * can specify this value by \"--define goog.LOCALE=<locale_name>\" as JSCompiler\n * option.\n *\n * Take into account that the locale code format is important. You should use\n * the canonical Unicode format with hyphen as a delimiter. Language must be\n * lowercase, Language Script - Capitalized, Region - UPPERCASE.\n * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.\n *\n * See more info about locale codes here:\n * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers\n *\n * For language codes you should use values defined by ISO 693-1. See it here\n * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from\n * this rule: the Hebrew language. For legacy reasons the old code (iw) should\n * be used instead of the new code (he), see http://wiki/Main/IIISynonyms.\n */\ngoog.define('goog.LOCALE', 'en');  // default to en\n\n\n/**\n * @define {boolean} Whether this code is running on trusted sites.\n *\n * On untrusted sites, several native functions can be defined or overridden by\n * external libraries like Prototype, Datejs, and JQuery and setting this flag\n * to false forces closure to use its own implementations when possible.\n *\n * If your JavaScript can be loaded by a third party site and you are wary about\n * relying on non-standard implementations, specify\n * \"--define goog.TRUSTED_SITE=false\" to the JSCompiler.\n */\ngoog.define('goog.TRUSTED_SITE', true);\n\n\n/**\n * @define {boolean} Whether a project is expected to be running in strict mode.\n *\n * This define can be used to trigger alternate implementations compatible with\n * running in EcmaScript Strict mode or warn about unavailable functionality.\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode\n */\ngoog.define('goog.STRICT_MODE_COMPATIBLE', false);\n\n\n/**\n * Creates object stubs for a namespace.  The presence of one or more\n * goog.provide() calls indicate that the file defines the given\n * objects/namespaces.  Provided objects must not be null or undefined.\n * Build tools also scan for provide/require statements\n * to discern dependencies, build dependency files (see deps.js), etc.\n * @see goog.require\n * @param {string} name Namespace provided by this file in the form\n *     \"goog.package.part\".\n */\ngoog.provide = function(name) {\n  if (!COMPILED) {\n    // Ensure that the same namespace isn't provided twice.\n    // A goog.module/goog.provide maps a goog.require to a specific file\n    if (goog.isProvided_(name)) {\n      throw Error('Namespace \"' + name + '\" already declared.');\n    }\n    delete goog.implicitNamespaces_[name];\n\n    var namespace = name;\n    while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {\n      if (goog.getObjectByName(namespace)) {\n        break;\n      }\n      goog.implicitNamespaces_[namespace] = true;\n    }\n  }\n\n  goog.exportPath_(name);\n};\n\n\n/**\n * Forward declares a symbol. This is an indication to the compiler that the\n * symbol may be used in the source yet is not required and may not be provided\n * in compilation.\n *\n * The most common usage of forward declaration is code that takes a type as a\n * function parameter but does not need to require it. By forward declaring\n * instead of requiring, no hard dependency is made, and (if not required\n * elsewhere) the namespace may never be required and thus, not be pulled\n * into the JavaScript binary. If it is required elsewhere, it will be type\n * checked as normal.\n *\n *\n * @param {string} name The namespace to forward declare in the form of\n *     \"goog.package.part\".\n */\ngoog.forwardDeclare = function(name) {};\n\n\nif (!COMPILED) {\n\n  /**\n   * Check if the given name has been goog.provided. This will return false for\n   * names that are available only as implicit namespaces.\n   * @param {string} name name of the object to look for.\n   * @return {boolean} Whether the name has been provided.\n   * @private\n   */\n  goog.isProvided_ = function(name) {\n    return (!goog.implicitNamespaces_[name] &&\n        goog.isDefAndNotNull(goog.getObjectByName(name)));\n  };\n\n  /**\n   * Namespaces implicitly defined by goog.provide. For example,\n   * goog.provide('goog.events.Event') implicitly declares that 'goog' and\n   * 'goog.events' must be namespaces.\n   *\n   * @type {Object.<string, (boolean|undefined)>}\n   * @private\n   */\n  goog.implicitNamespaces_ = {};\n}\n\n\n/**\n * Returns an object based on its fully qualified external name.  The object\n * is not found if null or undefined.  If you are using a compilation pass that\n * renames property names beware that using this function will not find renamed\n * properties.\n *\n * @param {string} name The fully qualified name.\n * @param {Object=} obj The object within which to look; default is\n *     |goog.global|.\n * @return {?} The value (object or primitive) or, if not found, null.\n */\ngoog.getObjectByName = function(name, obj) {\n  var parts = name.split('.');\n  var cur = obj || goog.global;\n  for (var part; part = parts.shift(); ) {\n    if (goog.isDefAndNotNull(cur[part])) {\n      cur = cur[part];\n    } else {\n      return null;\n    }\n  }\n  return cur;\n};\n\n\n/**\n * Globalizes a whole namespace, such as goog or goog.lang.\n *\n * @param {Object} obj The namespace to globalize.\n * @param {Object=} global The object to add the properties to.\n * @deprecated Properties may be explicitly exported to the global scope, but\n *     this should no longer be done in bulk.\n */\ngoog.globalize = function(obj, global) {\n  global = global || goog.global;\n  for (var x in obj) {\n    global[x] = obj[x];\n  }\n};\n\n\n/**\n * Adds a dependency from a file to the files it requires.\n * @param {string} relPath The path to the js file.\n * @param {Array} provides An array of strings with the names of the objects\n *                         this file provides.\n * @param {Array} requires An array of strings with the names of the objects\n *                         this file requires.\n */\ngoog.addDependency = function(relPath, provides, requires) {\n  if (goog.DEPENDENCIES_ENABLED) {\n    var provide, require;\n    var path = relPath.replace(/\\\\/g, '/');\n    var deps = goog.dependencies_;\n    for (var i = 0; provide = provides[i]; i++) {\n      deps.nameToPath[provide] = path;\n    }\n    for (var j = 0; require = requires[j]; j++) {\n      if (!(path in deps.requires)) {\n        deps.requires[path] = {};\n      }\n      deps.requires[path][require] = true;\n    }\n  }\n};\n\n\n\n\n// NOTE(nnaze): The debug DOM loader was included in base.js as an original way\n// to do \"debug-mode\" development.  The dependency system can sometimes be\n// confusing, as can the debug DOM loader's asynchronous nature.\n//\n// With the DOM loader, a call to goog.require() is not blocking -- the script\n// will not load until some point after the current script.  If a namespace is\n// needed at runtime, it needs to be defined in a previous script, or loaded via\n// require() with its registered dependencies.\n// User-defined namespaces may need their own deps file.  See http://go/js_deps,\n// http://go/genjsdeps, or, externally, DepsWriter.\n// https://developers.google.com/closure/library/docs/depswriter\n//\n// Because of legacy clients, the DOM loader can't be easily removed from\n// base.js.  Work is being done to make it disableable or replaceable for\n// different environments (DOM-less JavaScript interpreters like Rhino or V8,\n// for example). See bootstrap/ for more information.\n\n\n/**\n * @define {boolean} Whether to enable the debug loader.\n *\n * If enabled, a call to goog.require() will attempt to load the namespace by\n * appending a script tag to the DOM (if the namespace has been registered).\n *\n * If disabled, goog.require() will simply assert that the namespace has been\n * provided (and depend on the fact that some outside tool correctly ordered\n * the script).\n */\ngoog.define('goog.ENABLE_DEBUG_LOADER', true);\n\n\n/**\n * @param {string} msg\n * @private\n */\ngoog.logToConsole_ = function(msg) {\n  if (goog.global.console) {\n    goog.global.console['error'](msg);\n  }\n};\n\n\n/**\n * Implements a system for the dynamic resolution of dependencies that works in\n * parallel with the BUILD system. Note that all calls to goog.require will be\n * stripped by the JSCompiler when the --closure_pass option is used.\n * @see goog.provide\n * @param {string} name Namespace to include (as was given in goog.provide()) in\n *     the form \"goog.package.part\".\n * @return {?} If called within a goog.module file, the associated namespace or\n *     module otherwise null.\n */\ngoog.require = function(name) {\n\n  // If the object already exists we do not need do do anything.\n  if (!COMPILED) {\n    if (goog.isProvided_(name)) {\n      return null;\n    }\n\n    if (goog.ENABLE_DEBUG_LOADER) {\n      var path = goog.getPathFromDeps_(name);\n      if (path) {\n        goog.included_[path] = true;\n        goog.writeScripts_();\n        return null;\n      }\n    }\n\n    var errorMessage = 'goog.require could not find: ' + name;\n    goog.logToConsole_(errorMessage);\n\n    throw Error(errorMessage);\n  }\n};\n\n\n/**\n * Path for included scripts.\n * @type {string}\n */\ngoog.basePath = '';\n\n\n/**\n * A hook for overriding the base path.\n * @type {string|undefined}\n */\ngoog.global.CLOSURE_BASE_PATH;\n\n\n/**\n * Whether to load Closure's deps file automatically.\n * Shaka sets this to true since we are placing deps.js in a non-standard\n * location.  Running Shaka in uncompiled mode will require loading deps.js\n * explicitly.\n * @type {boolean|undefined}\n */\ngoog.global.CLOSURE_NO_DEPS = true;\n\n\n/**\n * A function to import a single script. This is meant to be overridden when\n * Closure is being run in non-HTML contexts, such as web workers. It's defined\n * in the global scope so that it can be set before base.js is loaded, which\n * allows deps.js to be imported properly.\n *\n * The function is passed the script source, which is a relative URI. It should\n * return true if the script was imported, false otherwise.\n * @type {(function(string): boolean)|undefined}\n */\ngoog.global.CLOSURE_IMPORT_SCRIPT;\n\n\n/**\n * True if goog.dependencies_ is available.\n * @const {boolean}\n */\ngoog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;\n\n\nif (goog.DEPENDENCIES_ENABLED) {\n  /**\n   * Object used to keep track of urls that have already been added. This record\n   * allows the prevention of circular dependencies.\n   * @type {Object}\n   * @private\n   */\n  goog.included_ = {};\n\n\n  /**\n   * This object is used to keep track of dependencies and other data that is\n   * used for loading scripts.\n   * @private\n   * @type {Object}\n   */\n  goog.dependencies_ = {\n    nameToPath: {}, // many to 1\n    requires: {}, // 1 to many\n    // Used when resolving dependencies to prevent us from visiting file twice.\n    visited: {},\n    written: {} // Used to keep track of script files we have written.\n  };\n\n\n  /**\n   * Tries to detect whether is in the context of an HTML document.\n   * @return {boolean} True if it looks like HTML document.\n   * @private\n   */\n  goog.inHtmlDocument_ = function() {\n    var doc = goog.global.document;\n    return typeof doc != 'undefined' &&\n           'write' in doc;  // XULDocument misses write.\n  };\n\n\n  /**\n   * Tries to detect the base path of base.js script that bootstraps Closure.\n   * @private\n   */\n  goog.findBasePath_ = function() {\n    if (goog.global.CLOSURE_BASE_PATH) {\n      goog.basePath = goog.global.CLOSURE_BASE_PATH;\n      return;\n    } else if (!goog.inHtmlDocument_()) {\n      return;\n    }\n    var doc = goog.global.document;\n    var scripts = doc.getElementsByTagName('script');\n    // Search backwards since the current script is in almost all cases the one\n    // that has base.js.\n    for (var i = scripts.length - 1; i >= 0; --i) {\n      var src = (/** @type {!HTMLScriptElement} */ (scripts[i])).src;\n      var qmark = src.lastIndexOf('?');\n      var l = qmark == -1 ? src.length : qmark;\n      if (src.substr(l - 7, 7) == 'base.js') {\n        goog.basePath = src.substr(0, l - 7);\n        return;\n      }\n    }\n  };\n\n\n  /**\n   * Imports a script if, and only if, that script hasn't already been imported.\n   * (Must be called at execution time)\n   * @param {string} src Script source.\n   * @param {string=} sourceText The optionally source text to evaluate\n   * @private\n   */\n  goog.importScript_ = function(src, sourceText) {\n    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||\n        goog.writeScriptTag_;\n    if (importScript(src, sourceText)) {\n      goog.dependencies_.written[src] = true;\n    }\n  };\n\n\n  /**\n   * The default implementation of the import function. Writes a script tag to\n   * import the script.\n   *\n   * @param {string} src The script url.\n   * @param {string=} sourceText The optionally source text to evaluate\n   * @return {boolean} True if the script was imported, false otherwise.\n   * @private\n   */\n  goog.writeScriptTag_ = function(src, sourceText) {\n    if (goog.inHtmlDocument_()) {\n      var doc = goog.global.document;\n\n      // If the user tries to require a new symbol after document load,\n      // something has gone terribly wrong. Doing a document.write would\n      // wipe out the page.\n      if (doc.readyState == 'complete') {\n        // Certain test frameworks load base.js multiple times, which tries\n        // to write deps.js each time. If that happens, just fail silently.\n        // These frameworks wipe the page between each load of base.js, so this\n        // is OK.\n        var isDeps = /\\bdeps.js$/.test(src);\n        if (isDeps) {\n          return false;\n        } else {\n          throw Error('Cannot write \"' + src + '\" after document load');\n        }\n      }\n\n      if (sourceText === undefined) {\n        doc.write(\n            '<script type=\"text/javascript\" src=\"' +\n                src + '\"></' + 'script>');\n      } else {\n        doc.write(\n            '<script type=\"text/javascript\">' +\n              sourceText + '</' + 'script>');\n      }\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n\n  /**\n   * Resolves dependencies based on the dependencies added using addDependency\n   * and calls importScript_ in the correct order.\n   * @private\n   */\n  goog.writeScripts_ = function() {\n    // The scripts we need to write this time.\n    var scripts = [];\n    var seenScript = {};\n    var deps = goog.dependencies_;\n\n    function visitNode(path) {\n      if (path in deps.written) {\n        return;\n      }\n\n      // We have already visited this one. We can get here if we have cyclic\n      // dependencies.\n      if (path in deps.visited) {\n        if (!(path in seenScript)) {\n          seenScript[path] = true;\n          scripts.push(path);\n        }\n        return;\n      }\n\n      deps.visited[path] = true;\n\n      if (path in deps.requires) {\n        for (var requireName in deps.requires[path]) {\n          // If the required name is defined, we assume that it was already\n          // bootstrapped by other means.\n          if (!goog.isProvided_(requireName)) {\n            if (requireName in deps.nameToPath) {\n              visitNode(deps.nameToPath[requireName]);\n            } else {\n              throw Error('Undefined nameToPath for ' + requireName);\n            }\n          }\n        }\n      }\n\n      if (!(path in seenScript)) {\n        seenScript[path] = true;\n        scripts.push(path);\n      }\n    }\n\n    for (var path in goog.included_) {\n      if (!deps.written[path]) {\n        visitNode(path);\n      }\n    }\n\n    // record that we are going to load all these scripts.\n    for (var i = 0; i < scripts.length; i++) {\n      var path = scripts[i];\n      goog.dependencies_.written[path] = true;\n    }\n\n    for (var i = 0; i < scripts.length; i++) {\n      var path = scripts[i];\n      if (path) {\n        goog.importScript_(goog.basePath + path);\n      }\n    }\n  };\n\n\n  /**\n   * Looks at the dependency rules and tries to determine the script file that\n   * fulfills a particular rule.\n   * @param {string} rule In the form goog.namespace.Class or project.script.\n   * @return {?string} Url corresponding to the rule, or null.\n   * @private\n   */\n  goog.getPathFromDeps_ = function(rule) {\n    if (rule in goog.dependencies_.nameToPath) {\n      return goog.dependencies_.nameToPath[rule];\n    } else {\n      return null;\n    }\n  };\n\n  goog.findBasePath_();\n\n  // Allow projects to manage the deps files themselves.\n  if (!goog.global.CLOSURE_NO_DEPS) {\n    goog.importScript_(goog.basePath + 'deps.js');\n  }\n}\n\n\n\n//==============================================================================\n// Language Enhancements\n//==============================================================================\n\n\n/**\n * Returns true if the specified value is defined and not null.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is defined and not null.\n */\ngoog.isDefAndNotNull = function(val) {\n  // Note that undefined == null.\n  return val != null;\n};\n\n\n/**\n * Returns true if the specified value is a string.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is a string.\n */\ngoog.isString = function(val) {\n  return typeof val == 'string';\n};\n\n\n/**\n * Exposes an unobfuscated global namespace path for the given object.\n * Note that fields of the exported object *will* be obfuscated, unless they are\n * exported in turn via this function or goog.exportProperty.\n *\n * Also handy for making public items that are defined in anonymous closures.\n *\n * ex. goog.exportSymbol('public.path.Foo', Foo);\n *\n * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);\n *     public.path.Foo.staticFunction();\n *\n * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',\n *                       Foo.prototype.myMethod);\n *     new public.path.Foo().myMethod();\n *\n * @param {string} publicPath Unobfuscated name to export.\n * @param {*} object Object the name should point to.\n * @param {Object=} objectToExportTo The object to add the path to; default\n *     is goog.global.\n */\ngoog.exportSymbol = function(publicPath, object, objectToExportTo) {\n  goog.exportPath_(publicPath, object, objectToExportTo);\n};\n\n\n/**\n * Exports a property unobfuscated into the object's namespace.\n * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);\n * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);\n * @param {Object} object Object whose static property is being exported.\n * @param {string} publicName Unobfuscated name to export.\n * @param {*} symbol Object the name should point to.\n */\ngoog.exportProperty = function(object, publicName, symbol) {\n  object[publicName] = symbol;\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * Usage:\n * <pre>\n * function ParentClass(a, b) { }\n * ParentClass.prototype.foo = function(a) { };\n *\n * function ChildClass(a, b, c) {\n *   ChildClass.base(this, 'constructor', a, b);\n * }\n * goog.inherits(ChildClass, ParentClass);\n *\n * var child = new ChildClass('a', 'b', 'see');\n * child.foo(); // This works.\n * </pre>\n *\n * @param {Function} childCtor Child class.\n * @param {Function} parentCtor Parent class.\n */\ngoog.inherits = function(childCtor, parentCtor) {\n  /** @constructor */\n  function tempCtor() {}\n  tempCtor.prototype = parentCtor.prototype;\n  childCtor.superClass_ = parentCtor.prototype;\n  childCtor.prototype = new tempCtor();\n  /** @override */\n  childCtor.prototype.constructor = childCtor;\n\n  /**\n   * Calls superclass constructor/method.\n   *\n   * This function is only available if you use goog.inherits to\n   * express inheritance relationships between classes.\n   *\n   * NOTE: This is a replacement for goog.base and for superClass_\n   * property defined in childCtor.\n   *\n   * @param {!Object} me Should always be \"this\".\n   * @param {string} methodName The method name to call. Calling\n   *     superclass constructor can be done with the special string\n   *     'constructor'.\n   * @param {...*} var_args The arguments to pass to superclass\n   *     method/constructor.\n   * @return {*} The return value of the superclass method/constructor.\n   */\n  childCtor.base = function(me, methodName, var_args) {\n    var args = Array.prototype.slice.call(arguments, 2);\n    return parentCtor.prototype[methodName].apply(me, args);\n  };\n};\n\n\n/*\n * To support uncompiled, strict mode bundles that use eval to divide source\n * like so:\n *    eval('someSource;//# sourceUrl sourcefile.js');\n * We need to export the globally defined symbols \"goog\" and \"COMPILED\".\n * Exporting \"goog\" breaks the compiler optimizations, so we required that\n * be defined externally.\n * NOTE: We don't use goog.exportSymbol here because we don't want to trigger\n * extern generation when that compiler option is enabled.\n */\nif (!COMPILED) {\n  goog.global['COMPILED'] = COMPILED;\n}\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.abr.Ewma');\n\ngoog.require('goog.asserts');\n\n\n/**\n * Computes an exponentionally-weighted moving average.\n *\n * @param {number} halfLife The quantity of prior samples (by weight) used\n *   when creating a new estimate.  Those prior samples make up half of the new\n *   estimate.\n * @struct\n * @constructor\n */\nshaka.abr.Ewma = function(halfLife) {\n  goog.asserts.assert(halfLife > 0, 'expected halfLife to be positive');\n\n  /**\n   * Larger values of alpha expire historical data more slowly.\n   * @private {number}\n   */\n  this.alpha_ = Math.exp(Math.log(0.5) / halfLife);\n\n  /** @private {number} */\n  this.estimate_ = 0;\n\n  /** @private {number} */\n  this.totalWeight_ = 0;\n};\n\n\n/**\n * Takes a sample.\n *\n * @param {number} weight\n * @param {number} value\n */\nshaka.abr.Ewma.prototype.sample = function(weight, value) {\n  let adjAlpha = Math.pow(this.alpha_, weight);\n  let newEstimate = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n\n  if (!isNaN(newEstimate)) {\n    this.estimate_ = newEstimate;\n    this.totalWeight_ += weight;\n  }\n};\n\n\n/**\n * @return {number}\n */\nshaka.abr.Ewma.prototype.getEstimate = function() {\n  let zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n  return this.estimate_ / zeroFactor;\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.abr.EwmaBandwidthEstimator');\n\ngoog.require('shaka.abr.Ewma');\n\n\n/**\n * Tracks bandwidth samples and estimates available bandwidth.\n * Based on the minimum of two exponentially-weighted moving averages with\n * different half-lives.\n *\n * @constructor\n * @struct\n */\nshaka.abr.EwmaBandwidthEstimator = function() {\n  /**\n   * A fast-moving average.\n   * Half of the estimate is based on the last 2 seconds of sample history.\n   * @private {!shaka.abr.Ewma}\n   */\n  this.fast_ = new shaka.abr.Ewma(2);\n\n  /**\n   * A slow-moving average.\n   * Half of the estimate is based on the last 5 seconds of sample history.\n   * @private {!shaka.abr.Ewma}\n   */\n  this.slow_ = new shaka.abr.Ewma(5);\n\n  /**\n   * Number of bytes sampled.\n   * @private {number}\n   */\n  this.bytesSampled_ = 0;\n\n\n  /**\n   * Minimum number of bytes sampled before we trust the estimate.  If we have\n   * not sampled much data, our estimate may not be accurate enough to trust.\n   * If bytesSampled_ is less than minTotalBytes_, we use defaultEstimate_.\n   * This specific value is based on experimentation.\n   *\n   * @private {number}\n   * @const\n   */\n  this.minTotalBytes_ = 128e3;  // 128kB\n\n  /**\n   * Minimum number of bytes, under which samples are discarded.  Our models do\n   * not include latency information, so connection startup time (time to first\n   * byte) is considered part of the download time.  Because of this, we should\n   * ignore very small downloads which would cause our estimate to be too low.\n   * This specific value is based on experimentation.\n   *\n   * @private {number}\n   * @const\n   */\n  this.minBytes_ = 16e3;  // 16kB\n};\n\n\n/**\n * Takes a bandwidth sample.\n *\n * @param {number} durationMs The amount of time, in milliseconds, for a\n *   particular request.\n * @param {number} numBytes The total number of bytes transferred in that\n *   request.\n */\nshaka.abr.EwmaBandwidthEstimator.prototype.sample = function(\n    durationMs, numBytes) {\n  if (numBytes < this.minBytes_) {\n    return;\n  }\n\n  let bandwidth = 8000 * numBytes / durationMs;\n  let weight = durationMs / 1000;\n\n  this.bytesSampled_ += numBytes;\n  this.fast_.sample(weight, bandwidth);\n  this.slow_.sample(weight, bandwidth);\n};\n\n\n/**\n * Gets the current bandwidth estimate.\n *\n * @param {number} defaultEstimate\n * @return {number} The bandwidth estimate in bits per second.\n */\nshaka.abr.EwmaBandwidthEstimator.prototype.getBandwidthEstimate =\n    function(defaultEstimate) {\n  if (this.bytesSampled_ < this.minTotalBytes_) {\n    return defaultEstimate;\n  }\n\n  // Take the minimum of these two estimates.  This should have the effect of\n  // adapting down quickly, but up more slowly.\n  return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n};\n\n\n/**\n * @return {boolean} True if there is enough data to produce a meaningful\n *   estimate.\n */\nshaka.abr.EwmaBandwidthEstimator.prototype.hasGoodEstimate = function() {\n  return this.bytesSampled_ >= this.minTotalBytes_;\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.log');\n\n\n/**\n * @namespace shaka.log\n * @summary\n * A console logging framework which is compiled out for deployment.  This is\n * only available when using the uncompiled version.\n * @exportDoc\n */\n\n\n/**\n * Log levels.\n * @enum {number}\n * @exportDoc\n */\nshaka.log.Level = {\n  NONE: 0,\n  ERROR: 1,\n  WARNING: 2,\n  INFO: 3,\n  DEBUG: 4,\n  V1: 5,\n  V2: 6,\n};\n\n\n/**\n * @define {number} the maximum log level.\n */\ngoog.define('shaka.log.MAX_LOG_LEVEL', 3);\n\n\n/**\n * This always logs to the console, even in Release mode.  This should only be\n * used for deprecation messages and things the app should never ignore.\n *\n * @type {function(*, ...*)}\n */\nshaka.log.alwaysError = function() {};\n\n\n/**\n * This always logs to the console, even in Release mode.  This should only be\n * used for deprecation messages and things the app should never ignore.\n *\n * @type {function(*, ...*)}\n */\nshaka.log.alwaysWarn = function() {};\n\n\n/**\n * This log is for when an error occurs.  This should always be accompanied with\n * an error event, thrown exception, or rejected Promise.  Logs are disabled in\n * Release mode, so there should be other methods of detecting the error.\n *\n * @type {function(*, ...*)}\n */\nshaka.log.error = function() {};\n\n\n/**\n * This log is for possible errors or things that may be surprising to a user.\n * For example, if we work around unusual or bad content, we should warn that\n * they should fix their content.  Deprecation messages and messages the app\n * shouldn't ignore should use alwaysWarn instead.\n *\n * @type {function(*, ...*)}\n */\nshaka.log.warning = function() {};\n\n\n/**\n * This log is for messages to the user about what is happening.  For example,\n * when we update a manifest or install a polyfill.\n *\n * @type {function(*, ...*)}\n */\nshaka.log.info = function() {};\n\n\n/**\n * This log is to aid *users* in debugging their content.  This should be for\n * logs about the content and what we do with it.  For example, when we change\n * streams or what we are choosing.\n *\n * @type {function(*, ...*)}\n */\nshaka.log.debug = function() {};\n\n\n/**\n * This log is for debugging Shaka Player itself.  This may be logs about\n * internal states or events.  This may also be for more verbose logs about\n * content, such as for segment appends.\n *\n * @type {function(*, ...*)}\n */\nshaka.log.v1 = function() {};\n\n\n/**\n * This log is for tracing and debugging Shaka Player.  These logs will happen\n * a lot, for example, logging every segment append or every update check.\n * These are mostly used for tracking which calls happen through the code.\n *\n * @type {function(*, ...*)}\n */\nshaka.log.v2 = function() {};\n\n\n// IE8 has no console unless it is opened in advance.\n// IE9 console methods are not Functions and have no bind.\nif (window.console && window.console.log.bind) {\n  shaka.log.alwaysWarn = console.warn.bind(console);\n  shaka.log.alwaysError = console.error.bind(console);\n\n  if (goog.DEBUG) {\n    /** @type {number} */\n    shaka.log.currentLevel;\n\n    /**\n     * Change the log level.  Useful for debugging in uncompiled mode.\n     *\n     * @param {number} level\n     * @exportDoc\n     */\n    shaka.log.setLevel = function(level) {\n      let nop = function() {};\n      let log = shaka.log;\n      const Level = shaka.log.Level;\n\n      shaka.log.currentLevel = level;\n\n      log.error = (level >= Level.ERROR) ? console.error.bind(console) : nop;\n      log.warning = (level >= Level.WARNING) ? console.warn.bind(console) : nop;\n      log.info = (level >= Level.INFO) ? console.info.bind(console) : nop;\n      log.debug = (level >= Level.DEBUG) ? console.log.bind(console) : nop;\n      log.v1 = (level >= Level.V1) ? console.debug.bind(console) : nop;\n      log.v2 = (level >= Level.V2) ? console.debug.bind(console) : nop;\n    };\n\n    shaka.log.setLevel(shaka.log.MAX_LOG_LEVEL);\n  } else {\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.ERROR) {\n      shaka.log.error = console.error.bind(console);\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.WARNING) {\n      shaka.log.warning = console.warn.bind(console);\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.INFO) {\n      shaka.log.info = console.info.bind(console);\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.DEBUG) {\n      shaka.log.debug = console.log.bind(console);\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.V1) {\n      shaka.log.v1 = console.debug.bind(console);\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.V2) {\n      shaka.log.v2 = console.debug.bind(console);\n    }\n  }\n}\n","// Copyright 2008 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Simple utilities for splitting URI strings.\n *\n * Uses features of RFC 3986 for parsing/formatting URIs:\n *   http://www.ietf.org/rfc/rfc3986.txt\n *\n * @author gboyer@google.com (Garrett Boyer) - The \"lightened\" design.\n * @author msamuel@google.com (Mike Samuel) - Domain knowledge and regexes.\n */\n\ngoog.provide('goog.uri.utils');\ngoog.provide('goog.uri.utils.ComponentIndex');\n\n\n/**\n * A regular expression for breaking a URI into its component parts.\n *\n * {@link http://www.ietf.org/rfc/rfc3986.txt} says in Appendix B\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n * disambiguation method used by POSIX regular expressions, it is natural and\n * commonplace to use a regular expression for parsing the potential five\n * components of a URI reference.\n *\n * The following line is the regular expression for breaking-down a\n * well-formed URI reference into its components.\n *\n * <pre>\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n * </pre>\n *\n * The numbers in the second line above are only to assist readability; they\n * indicate the reference points for each subexpression (i.e., each paired\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n * For example, matching the above expression to\n * <pre>\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n * </pre>\n * results in the following subexpression matches:\n * <pre>\n *    $1 = http:\n *    $2 = http\n *    $3 = //www.ics.uci.edu\n *    $4 = www.ics.uci.edu\n *    $5 = /pub/ietf/uri/\n *    $6 = <undefined>\n *    $7 = <undefined>\n *    $8 = #Related\n *    $9 = Related\n * </pre>\n * where <undefined> indicates that the component is not present, as is the\n * case for the query component in the above example. Therefore, we can\n * determine the value of the five components as\n * <pre>\n *    scheme    = $2\n *    authority = $4\n *    path      = $5\n *    query     = $7\n *    fragment  = $9\n * </pre>\n *\n * The regular expression has been modified slightly to expose the\n * userInfo, domain, and port separately from the authority.\n * The modified version yields\n * <pre>\n *    $1 = http              scheme\n *    $2 = <undefined>       userInfo -\\\n *    $3 = www.ics.uci.edu   domain     | authority\n *    $4 = <undefined>       port     -/\n *    $5 = /pub/ietf/uri/    path\n *    $6 = <undefined>       query without ?\n *    $7 = Related           fragment without #\n * </pre>\n * @type {!RegExp}\n * @private\n */\ngoog.uri.utils.splitRe_ = new RegExp(\n    '^' +\n    '(?:' +\n        '([^:/?#.]+)' +                  // scheme - ignore special characters\n                                         // used by other URL parts such as :,\n                                         // ?, /, #, and .\n    ':)?' +\n    '(?://' +\n        '(?:([^/?#]*)@)?' +              // userInfo\n        '([^/#?]*?)' +                   // domain\n        '(?::([0-9]+))?' +               // port\n        '(?=[/#?]|$)' +                  // authority-terminating character\n    ')?' +\n    '([^?#]+)?' +                        // path\n    '(?:\\\\?([^#]*))?' +                  // query\n    '(?:#(.*))?' +                       // fragment\n    '$');\n\n\n/**\n * The index of each URI component in the return value of goog.uri.utils.split.\n * @enum {number}\n */\ngoog.uri.utils.ComponentIndex = {\n  SCHEME: 1,\n  USER_INFO: 2,\n  DOMAIN: 3,\n  PORT: 4,\n  PATH: 5,\n  QUERY_DATA: 6,\n  FRAGMENT: 7\n};\n\n\n/**\n * Splits a URI into its component parts.\n *\n * Each component can be accessed via the component indices; for example:\n * <pre>\n * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];\n * </pre>\n *\n * @param {string} uri The URI string to examine.\n * @return {!Array.<string|undefined>} Each component still URI-encoded.\n *     Each component that is present will contain the encoded value, whereas\n *     components that are not present will be undefined or empty, depending\n *     on the browser's regular expression implementation.  Never null, since\n *     arbitrary strings may still look like path names.\n */\ngoog.uri.utils.split = function(uri) {\n  // See @return comment -- never null.\n  return /** @type {!Array.<string|undefined>} */ (\n      uri.match(goog.uri.utils.splitRe_));\n};\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Class for parsing and formatting URIs.\n *\n * Use new goog.Uri(string) to parse a URI string.\n *\n * e.g: <code>var myUri = new goog.Uri(window.location);</code>\n *\n * Implements RFC 3986 for parsing/formatting URIs.\n * http://www.ietf.org/rfc/rfc3986.txt\n *\n * Some changes have been made to the interface (more like .NETs), though the\n * internal representation is now of un-encoded parts, this will change the\n * behavior slightly.\n *\n */\n\ngoog.provide('goog.Uri');\ngoog.provide('goog.Uri.QueryData');\n\ngoog.require('goog.uri.utils');\ngoog.require('goog.uri.utils.ComponentIndex');\n\n\n\n/**\n * This class contains setters and getters for the parts of the URI.\n * The <code>getXyz</code>/<code>setXyz</code> methods return the decoded part\n * -- so<code>new goog.Uri('/foo%20bar').getPath()</code> will return the\n * decoded path, <code>/foo bar</code>.\n *\n * Reserved characters (see RFC 3986 section 2.2) can be present in\n * their percent-encoded form in scheme, domain, and path URI components and\n * will not be auto-decoded. For example:\n * <code>new goog.Uri('rel%61tive/path%2fto/resource').getPath()</code> will\n * return <code>relative/path%2fto/resource</code>.\n *\n * The constructor accepts an optional unparsed, raw URI string.  The parser\n * is relaxed, so special characters that aren't escaped but don't cause\n * ambiguities will not cause parse failures.\n *\n * All setters return <code>this</code> and so may be chained, a la\n * <code>new goog.Uri('/foo').setFragment('part').toString()</code>.\n *\n * @param {*=} uri Optional string URI to parse, or if a goog.Uri is\n *        passed, a clone is created.\n *\n * @constructor\n */\ngoog.Uri = function(uri) {\n  // Parse in the uri string\n  var m;\n  if (uri instanceof goog.Uri) {\n    this.setScheme(uri.getScheme());\n    this.setUserInfo(uri.getUserInfo());\n    this.setDomain(uri.getDomain());\n    this.setPort(uri.getPort());\n    this.setPath(uri.getPath());\n    this.setQueryData(uri.getQueryData().clone());\n    this.setFragment(uri.getFragment());\n  } else if (uri && (m = goog.uri.utils.split(String(uri)))) {\n    // Set the parts -- decoding as we do so.\n    // COMPATABILITY NOTE - In IE, unmatched fields may be empty strings,\n    // whereas in other browsers they will be undefined.\n    this.setScheme(m[goog.uri.utils.ComponentIndex.SCHEME] || '', true);\n    this.setUserInfo(m[goog.uri.utils.ComponentIndex.USER_INFO] || '', true);\n    this.setDomain(m[goog.uri.utils.ComponentIndex.DOMAIN] || '', true);\n    this.setPort(m[goog.uri.utils.ComponentIndex.PORT]);\n    this.setPath(m[goog.uri.utils.ComponentIndex.PATH] || '', true);\n    this.setQueryData(m[goog.uri.utils.ComponentIndex.QUERY_DATA] || '', true);\n    this.setFragment(m[goog.uri.utils.ComponentIndex.FRAGMENT] || '', true);\n  } else {\n    this.queryData_ = new goog.Uri.QueryData(null, null);\n  }\n};\n\n\n/**\n * Scheme such as \"http\".\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.scheme_ = '';\n\n\n/**\n * User credentials in the form \"username:password\".\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.userInfo_ = '';\n\n\n/**\n * Domain part, e.g. \"www.google.com\".\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.domain_ = '';\n\n\n/**\n * Port, e.g. 8080.\n * @type {?number}\n * @private\n */\ngoog.Uri.prototype.port_ = null;\n\n\n/**\n * Path, e.g. \"/tests/img.png\".\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.path_ = '';\n\n\n/**\n * Object representing query data.\n * @type {!goog.Uri.QueryData}\n * @private\n */\ngoog.Uri.prototype.queryData_;\n\n\n/**\n * The fragment without the #.\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.fragment_ = '';\n\n\n/**\n * @return {string} The string form of the url.\n * @override\n */\ngoog.Uri.prototype.toString = function() {\n  var out = [];\n\n  var scheme = this.getScheme();\n  if (scheme) {\n    out.push(goog.Uri.encodeSpecialChars_(\n        scheme, goog.Uri.reDisallowedInSchemeOrUserInfo_, true), ':');\n  }\n\n  var domain = this.getDomain();\n  if (domain) {\n    out.push('//');\n\n    var userInfo = this.getUserInfo();\n    if (userInfo) {\n      out.push(goog.Uri.encodeSpecialChars_(\n          userInfo, goog.Uri.reDisallowedInSchemeOrUserInfo_, true), '@');\n    }\n\n    out.push(goog.Uri.removeDoubleEncoding_(encodeURIComponent(domain)));\n\n    var port = this.getPort();\n    if (port != null) {\n      out.push(':', String(port));\n    }\n  }\n\n  var path = this.getPath();\n  if (path) {\n    if (this.hasDomain() && path.charAt(0) != '/') {\n      out.push('/');\n    }\n    out.push(goog.Uri.encodeSpecialChars_(\n        path,\n        path.charAt(0) == '/' ?\n            goog.Uri.reDisallowedInAbsolutePath_ :\n            goog.Uri.reDisallowedInRelativePath_,\n        true));\n  }\n\n  var query = this.getEncodedQuery();\n  if (query) {\n    out.push('?', query);\n  }\n\n  var fragment = this.getFragment();\n  if (fragment) {\n    out.push('#', goog.Uri.encodeSpecialChars_(\n        fragment, goog.Uri.reDisallowedInFragment_));\n  }\n  return out.join('');\n};\n\n\n/**\n * Resolves the given relative URI (a goog.Uri object), using the URI\n * represented by this instance as the base URI.\n *\n * There are several kinds of relative URIs:<br>\n * 1. foo - replaces the last part of the path, the whole query and fragment<br>\n * 2. /foo - replaces the the path, the query and fragment<br>\n * 3. //foo - replaces everything from the domain on.  foo is a domain name<br>\n * 4. ?foo - replace the query and fragment<br>\n * 5. #foo - replace the fragment only\n *\n * Additionally, if relative URI has a non-empty path, all \"..\" and \".\"\n * segments will be resolved, as described in RFC 3986.\n *\n * @param {goog.Uri} relativeUri The relative URI to resolve.\n * @return {!goog.Uri} The resolved URI.\n */\ngoog.Uri.prototype.resolve = function(relativeUri) {\n\n  var absoluteUri = this.clone();\n  if (absoluteUri.scheme_ === 'data') {\n    // Cannot have a relative URI to a data URI.\n    absoluteUri = new goog.Uri();\n  }\n\n  // we satisfy these conditions by looking for the first part of relativeUri\n  // that is not blank and applying defaults to the rest\n\n  var overridden = relativeUri.hasScheme();\n\n  if (overridden) {\n    absoluteUri.setScheme(relativeUri.getScheme());\n  } else {\n    overridden = relativeUri.hasUserInfo();\n  }\n\n  if (overridden) {\n    absoluteUri.setUserInfo(relativeUri.getUserInfo());\n  } else {\n    overridden = relativeUri.hasDomain();\n  }\n\n  if (overridden) {\n    absoluteUri.setDomain(relativeUri.getDomain());\n  } else {\n    overridden = relativeUri.hasPort();\n  }\n\n  var path = relativeUri.getPath();\n  if (overridden) {\n    absoluteUri.setPort(relativeUri.getPort());\n  } else {\n    overridden = relativeUri.hasPath();\n    if (overridden) {\n      // resolve path properly\n      if (path.charAt(0) != '/') {\n        // path is relative\n        if (this.hasDomain() && !this.hasPath()) {\n          // RFC 3986, section 5.2.3, case 1\n          path = '/' + path;\n        } else {\n          // RFC 3986, section 5.2.3, case 2\n          var lastSlashIndex = absoluteUri.getPath().lastIndexOf('/');\n          if (lastSlashIndex != -1) {\n            path = absoluteUri.getPath().substr(0, lastSlashIndex + 1) + path;\n          }\n        }\n      }\n      path = goog.Uri.removeDotSegments(path);\n    }\n  }\n\n  if (overridden) {\n    absoluteUri.setPath(path);\n  } else {\n    overridden = relativeUri.hasQuery();\n  }\n\n  if (overridden) {\n    absoluteUri.setQueryData(relativeUri.getQueryData().clone());\n  } else {\n    overridden = relativeUri.hasFragment();\n  }\n\n  if (overridden) {\n    absoluteUri.setFragment(relativeUri.getFragment());\n  }\n\n  return absoluteUri;\n};\n\n\n/**\n * Clones the URI instance.\n * @return {!goog.Uri} New instance of the URI object.\n */\ngoog.Uri.prototype.clone = function() {\n  return new goog.Uri(this);\n};\n\n\n/**\n * @return {string} The encoded scheme/protocol for the URI.\n */\ngoog.Uri.prototype.getScheme = function() {\n  return this.scheme_;\n};\n\n\n/**\n * Sets the scheme/protocol.\n * @param {string} newScheme New scheme value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setScheme = function(newScheme, decode) {\n  this.scheme_ = decode ? goog.Uri.decodeOrEmpty_(newScheme, true) :\n      newScheme;\n\n  // remove an : at the end of the scheme so somebody can pass in\n  // window.location.protocol\n  if (this.scheme_) {\n    this.scheme_ = this.scheme_.replace(/:$/, '');\n  }\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the scheme has been set.\n */\ngoog.Uri.prototype.hasScheme = function() {\n  return !!this.scheme_;\n};\n\n\n/**\n * @return {string} The decoded user info.\n */\ngoog.Uri.prototype.getUserInfo = function() {\n  return this.userInfo_;\n};\n\n\n/**\n * Sets the userInfo.\n * @param {string} newUserInfo New userInfo value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setUserInfo = function(newUserInfo, decode) {\n  this.userInfo_ = decode ? goog.Uri.decodeOrEmpty_(newUserInfo) :\n                   newUserInfo;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the user info has been set.\n */\ngoog.Uri.prototype.hasUserInfo = function() {\n  return !!this.userInfo_;\n};\n\n\n/**\n * @return {string} The decoded domain.\n */\ngoog.Uri.prototype.getDomain = function() {\n  return this.domain_;\n};\n\n\n/**\n * Sets the domain.\n * @param {string} newDomain New domain value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setDomain = function(newDomain, decode) {\n  this.domain_ = decode ? goog.Uri.decodeOrEmpty_(newDomain, true) :\n      newDomain;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the domain has been set.\n */\ngoog.Uri.prototype.hasDomain = function() {\n  return !!this.domain_;\n};\n\n\n/**\n * @return {?number} The port number.\n */\ngoog.Uri.prototype.getPort = function() {\n  return this.port_;\n};\n\n\n/**\n * Sets the port number.\n * @param {*} newPort Port number. Will be explicitly casted to a number.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setPort = function(newPort) {\n  if (newPort) {\n    newPort = Number(newPort);\n    if (isNaN(newPort) || newPort < 0) {\n      throw Error('Bad port number ' + newPort);\n    }\n    this.port_ = newPort;\n  } else {\n    this.port_ = null;\n  }\n\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the port has been set.\n */\ngoog.Uri.prototype.hasPort = function() {\n  return this.port_ != null;\n};\n\n\n/**\n  * @return {string} The decoded path.\n */\ngoog.Uri.prototype.getPath = function() {\n  return this.path_;\n};\n\n\n/**\n * Sets the path.\n * @param {string} newPath New path value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setPath = function(newPath, decode) {\n  this.path_ = decode ? goog.Uri.decodeOrEmpty_(newPath, true) : newPath;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the path has been set.\n */\ngoog.Uri.prototype.hasPath = function() {\n  return !!this.path_;\n};\n\n\n/**\n * @return {boolean} Whether the query string has been set.\n */\ngoog.Uri.prototype.hasQuery = function() {\n  return this.queryData_.toString() !== '';\n};\n\n\n/**\n * Sets the query data.\n * @param {goog.Uri.QueryData|string|undefined} queryData QueryData object.\n * @param {boolean=} decode Optional param for whether to decode new value.\n *     Applies only if queryData is a string.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setQueryData = function(queryData, decode) {\n  if (queryData instanceof goog.Uri.QueryData) {\n    this.queryData_ = queryData;\n  } else {\n    if (!decode) {\n      // QueryData accepts encoded query string, so encode it if\n      // decode flag is not true.\n      queryData = goog.Uri.encodeSpecialChars_(queryData,\n                                               goog.Uri.reDisallowedInQuery_);\n    }\n    this.queryData_ = new goog.Uri.QueryData(queryData, null);\n  }\n\n  return this;\n};\n\n\n/**\n * @return {string} The encoded URI query, not including the ?.\n */\ngoog.Uri.prototype.getEncodedQuery = function() {\n  return this.queryData_.toString();\n};\n\n\n/**\n * @return {string} The decoded URI query, not including the ?.\n */\ngoog.Uri.prototype.getDecodedQuery = function() {\n  return this.queryData_.toDecodedString();\n};\n\n\n/**\n * Returns the query data.\n * @return {!goog.Uri.QueryData} QueryData object.\n */\ngoog.Uri.prototype.getQueryData = function() {\n  return this.queryData_;\n};\n\n\n/**\n * @return {string} The URI fragment, not including the #.\n */\ngoog.Uri.prototype.getFragment = function() {\n  return this.fragment_;\n};\n\n\n/**\n * Sets the URI fragment.\n * @param {string} newFragment New fragment value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setFragment = function(newFragment, decode) {\n  this.fragment_ = decode ? goog.Uri.decodeOrEmpty_(newFragment) :\n                   newFragment;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the URI has a fragment set.\n */\ngoog.Uri.prototype.hasFragment = function() {\n  return !!this.fragment_;\n};\n\n\n//==============================================================================\n// Static members\n//==============================================================================\n\n\n/**\n * Removes dot segments in given path component, as described in\n * RFC 3986, section 5.2.4.\n *\n * @param {string} path A non-empty path component.\n * @return {string} Path component with removed dot segments.\n */\ngoog.Uri.removeDotSegments = function(path) {\n  if (path == '..' || path == '.') {\n    return '';\n\n  } else if (path.indexOf('./') == -1 &&\n             path.indexOf('/.') == -1) {\n    // This optimization detects uris which do not contain dot-segments,\n    // and as a consequence do not require any processing.\n    return path;\n\n  } else {\n    var leadingSlash = (path.lastIndexOf('/', 0) == 0);\n    var segments = path.split('/');\n    var out = [];\n\n    for (var pos = 0; pos < segments.length; ) {\n      var segment = segments[pos++];\n\n      if (segment == '.') {\n        if (leadingSlash && pos == segments.length) {\n          out.push('');\n        }\n      } else if (segment == '..') {\n        if (out.length > 1 || out.length == 1 && out[0] != '') {\n          out.pop();\n        }\n        if (leadingSlash && pos == segments.length) {\n          out.push('');\n        }\n      } else {\n        out.push(segment);\n        leadingSlash = true;\n      }\n    }\n\n    return out.join('/');\n  }\n};\n\n\n/**\n * Decodes a value or returns the empty string if it isn't defined or empty.\n * @param {string|undefined} val Value to decode.\n * @param {boolean=} preserveReserved If true, restricted characters will\n *     not be decoded.\n * @return {string} Decoded value.\n * @private\n */\ngoog.Uri.decodeOrEmpty_ = function(val, preserveReserved) {\n  // Don't use UrlDecode() here because val is not a query parameter.\n  if (!val) {\n    return '';\n  }\n\n  return preserveReserved ? decodeURI(val) : decodeURIComponent(val);\n};\n\n\n/**\n * If unescapedPart is non null, then escapes any characters in it that aren't\n * valid characters in a url and also escapes any special characters that\n * appear in extra.\n *\n * @param {*} unescapedPart The string to encode.\n * @param {RegExp} extra A character set of characters in [\\01-\\177].\n * @param {boolean=} removeDoubleEncoding If true, remove double percent\n *     encoding.\n * @return {?string} null iff unescapedPart == null.\n * @private\n */\ngoog.Uri.encodeSpecialChars_ = function(unescapedPart, extra,\n    removeDoubleEncoding) {\n  if (goog.isString(unescapedPart)) {\n    var encoded = encodeURI(unescapedPart).\n        replace(extra, goog.Uri.encodeChar_);\n    if (removeDoubleEncoding) {\n      // encodeURI double-escapes %XX sequences used to represent restricted\n      // characters in some URI components, remove the double escaping here.\n      encoded = goog.Uri.removeDoubleEncoding_(encoded);\n    }\n    return encoded;\n  }\n  return null;\n};\n\n\n/**\n * Converts a character in [\\01-\\177] to its unicode character equivalent.\n * @param {string} ch One character string.\n * @return {string} Encoded string.\n * @private\n */\ngoog.Uri.encodeChar_ = function(ch) {\n  var n = ch.charCodeAt(0);\n  return '%' + ((n >> 4) & 0xf).toString(16) + (n & 0xf).toString(16);\n};\n\n\n/**\n * Removes double percent-encoding from a string.\n * @param  {string} doubleEncodedString String\n * @return {string} String with double encoding removed.\n * @private\n */\ngoog.Uri.removeDoubleEncoding_ = function(doubleEncodedString) {\n  return doubleEncodedString.replace(/%25([0-9a-fA-F]{2})/g, '%$1');\n};\n\n\n/**\n * Regular expression for characters that are disallowed in the scheme or\n * userInfo part of the URI.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInSchemeOrUserInfo_ = /[#\\/\\?@]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in a relative path.\n * Colon is included due to RFC 3986 3.3.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInRelativePath_ = /[\\#\\?:]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in an absolute path.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInAbsolutePath_ = /[\\#\\?]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in the query.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInQuery_ = /[\\#\\?@]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in the fragment.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInFragment_ = /#/g;\n\n\n\n/**\n * Class used to represent URI query parameters.  It is essentially a hash of\n * name-value pairs, though a name can be present more than once.\n *\n * Has the same interface as the collections in goog.structs.\n *\n * @param {?string=} query Optional encoded query string to parse into\n *     the object.\n * @param {goog.Uri=} uri Optional uri object that should have its\n *     cache invalidated when this object updates. Deprecated -- this\n *     is no longer required.\n * @constructor\n * @final\n */\ngoog.Uri.QueryData = function(query, uri) {\n  /**\n   * Encoded query string, or null if it requires computing from the key map.\n   * @type {?string}\n   * @private\n   */\n  this.encodedQuery_ = query || null;\n};\n\n\n/**\n * If the underlying key map is not yet initialized, it parses the\n * query string and fills the map with parsed data.\n * @private\n */\ngoog.Uri.QueryData.prototype.ensureKeyMapInitialized_ = function() {\n  if (!this.keyMap_) {\n    this.keyMap_ = {};\n    this.count_ = 0;\n\n    if (this.encodedQuery_) {\n      var pairs = this.encodedQuery_.split('&');\n      for (var i = 0; i < pairs.length; i++) {\n        var indexOfEquals = pairs[i].indexOf('=');\n        var name = null;\n        var value = null;\n        if (indexOfEquals >= 0) {\n          name = pairs[i].substring(0, indexOfEquals);\n          value = pairs[i].substring(indexOfEquals + 1);\n        } else {\n          name = pairs[i];\n        }\n        name = decodeURIComponent(name.replace(/\\+/g, ' '));\n        value = value || '';\n        this.add(name, decodeURIComponent(value.replace(/\\+/g, ' ')));\n      }\n    }\n  }\n};\n\n\n/**\n * The map containing name/value or name/array-of-values pairs.\n * May be null if it requires parsing from the query string.\n *\n * We need to use a Map because we cannot guarantee that the key names will\n * not be problematic for IE.\n *\n * @type {Object.<string, !Array.<string>>}\n * @private\n */\ngoog.Uri.QueryData.prototype.keyMap_ = null;\n\n\n/**\n * The number of params, or null if it requires computing.\n * @type {?number}\n * @private\n */\ngoog.Uri.QueryData.prototype.count_ = null;\n\n\n/**\n * @return {?number} The number of parameters.\n */\ngoog.Uri.QueryData.prototype.getCount = function() {\n  this.ensureKeyMapInitialized_();\n  return this.count_;\n};\n\n\n/**\n * Adds a key value pair.\n * @param {string} key Name.\n * @param {*} value Value.\n * @return {!goog.Uri.QueryData} Instance of this object.\n */\ngoog.Uri.QueryData.prototype.add = function(key, value) {\n  this.ensureKeyMapInitialized_();\n  // Invalidate the cache.\n  this.encodedQuery_ = null;\n\n  var values = this.keyMap_.hasOwnProperty(key) && this.keyMap_[key];\n  if (!values) {\n    this.keyMap_[key] = (values = []);\n  }\n  values.push(value);\n  this.count_++;\n  return this;\n};\n\n\n/**\n * @return {string} Encoded query string.\n * @override\n */\ngoog.Uri.QueryData.prototype.toString = function() {\n  if (this.encodedQuery_) {\n    return this.encodedQuery_;\n  }\n\n  if (!this.keyMap_) {\n    return '';\n  }\n\n  var sb = [];\n\n  for (var key in this.keyMap_) {\n    var encodedKey = encodeURIComponent(key);\n    var val = this.keyMap_[key];\n    for (var j = 0; j < val.length; j++) {\n      var param = encodedKey;\n      // Ensure that null and undefined are encoded into the url as\n      // literal strings.\n      if (val[j] !== '') {\n        param += '=' + encodeURIComponent(val[j]);\n      }\n      sb.push(param);\n    }\n  }\n\n  return this.encodedQuery_ = sb.join('&');\n};\n\n\n/**\n * @return {string} Decoded query string.\n */\ngoog.Uri.QueryData.prototype.toDecodedString = function() {\n  return goog.Uri.decodeOrEmpty_(this.toString());\n};\n\n\n/**\n * Clone the query data instance.\n * @return {!goog.Uri.QueryData} New instance of the QueryData object.\n */\ngoog.Uri.QueryData.prototype.clone = function() {\n  var rv = new goog.Uri.QueryData();\n  rv.encodedQuery_ = this.encodedQuery_;\n  if (this.keyMap_) {\n    var cloneMap = {};\n    for (var key in this.keyMap_) {\n      cloneMap[key] = this.keyMap_[key].concat();\n    }\n    rv.keyMap_ = cloneMap;\n    rv.count_ = this.count_;\n  }\n  return rv;\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.DelayedTick');\n\n\n/**\n * This class wraps a function so that we can defer executing the function by X\n * seconds.\n *\n * @final\n */\nshaka.util.DelayedTick = class {\n  /**\n   * @param {function()} onTick\n   */\n  constructor(onTick) {\n    /** @private {function()} */\n    this.onTick_ = onTick;\n\n    /** @private {?function()} */\n    this.cancelPending_ = null;\n  }\n\n  /**\n   * Call |onTick| after |delayInSeconds| has elapsed. If there is already a\n   * pending call to |onTick|, the pending call will be canceled.\n   *\n   * @param {number} delayInSeconds\n   * @return {!shaka.util.DelayedTick}\n   */\n  tickAfter(delayInSeconds) {\n    // We only want one timeout set at a time, so make sure no other timeouts\n    // are running.\n    this.stop();\n\n    // We will wrap these values in a function to allow us to cancel the timeout\n    // we are about to create.\n    let alive = true;\n    let timeoutId = null;\n\n    this.cancelPending_ = () => {\n      window.clearTimeout(timeoutId);\n      alive = false;\n    };\n\n    // For some reason, a timeout may still execute after we have cleared it in\n    // our tests. We will wrap the callback so that we can double-check our\n    // |alive| flag.\n    const onTick = () => {\n      if (alive) {\n        this.onTick_();\n      }\n    };\n\n    timeoutId = window.setTimeout(onTick, delayInSeconds * 1000);\n\n    return this;\n  }\n\n  /**\n   * Cancel any pending calls to |onTick|. If there are no pending calls to\n   * |onTick|, this will be a no-op.\n   */\n  stop() {\n    if (this.cancelPending_) {\n      this.cancelPending_();\n      this.cancelPending_ = null;\n    }\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.Timer');\n\ngoog.require('shaka.util.DelayedTick');\n\n\n/**\n * A timer allows a single function to be executed at a later time or at\n * regular intervals.\n *\n * @final\n * @export\n */\nshaka.util.Timer = class {\n  /**\n   * Create a new timer. A timer is committed to a single callback function.\n   * While there is no technical reason to do this, it is far easier to\n   * understand and use timers when they are connected to one functional idea.\n   *\n   * @param {function()} onTick\n   */\n  constructor(onTick) {\n    /**\n     * Each time our timer \"does work\", we call that a \"tick\". The name comes\n     * from old analog clocks.\n     *\n     * @private {function()}\n     */\n    this.onTick_ = onTick;\n\n    /** @private {shaka.util.DelayedTick} */\n    this.ticker_ = null;\n  }\n\n  /**\n   * Have the timer call |onTick| now.\n   *\n   * @return {!shaka.util.Timer}\n   * @export\n   */\n  tickNow() {\n    this.stop();\n    this.onTick_();\n\n    return this;\n  }\n\n  /**\n   * Have the timer call |onTick| after |seconds| has elapsed unless |stop| is\n   * called first.\n   *\n   * @param {number} seconds\n   * @return {!shaka.util.Timer}\n   * @export\n   */\n  tickAfter(seconds) {\n    this.stop();\n\n    this.ticker_ = new shaka.util.DelayedTick(() => {\n      this.onTick_();\n    }).tickAfter(seconds);\n\n    return this;\n  }\n\n  /**\n   * Have the timer call |onTick| every |seconds| until |stop| is called.\n   *\n   * @param {number} seconds\n   * @return {!shaka.util.Timer}\n   * @export\n   */\n  tickEvery(seconds) {\n    this.stop();\n\n    this.ticker_ = new shaka.util.DelayedTick(() => {\n      // Schedule the timer again first. |onTick_| could cancel the timer and\n      // rescheduling first simplifies the implementation.\n      this.ticker_.tickAfter(seconds);\n      this.onTick_();\n    }).tickAfter(seconds);\n\n    return this;\n  }\n\n  /**\n   * Stop the timer and clear the previous behaviour. The timer is still usable\n   * after calling |stop|.\n   *\n   * @export\n   */\n  stop() {\n    if (this.ticker_) {\n      this.ticker_.stop();\n      this.ticker_ = null;\n    }\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.net.Backoff');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * Backoff represents delay and backoff state.  This is used by NetworkingEngine\n * for individual requests and by StreamingEngine to retry streaming failures.\n *\n * @param {shaka.extern.RetryParameters} parameters\n * @param {boolean=} autoReset  If true, start at a \"first retry\" state and\n *   and auto-reset that state when we reach maxAttempts.\n *   Default set to false.\n *\n * @struct\n * @constructor\n */\nshaka.net.Backoff = function(parameters, autoReset = false) {\n  // Set defaults as we unpack these, so that individual app-level requests in\n  // NetworkingEngine can be missing parameters.\n\n  let defaults = shaka.net.Backoff.defaultRetryParameters();\n\n  /**\n   * @const\n   * @private {number}\n   */\n  this.maxAttempts_ = (parameters.maxAttempts == null) ?\n      defaults.maxAttempts : parameters.maxAttempts;\n\n  goog.asserts.assert(this.maxAttempts_ >= 1, 'maxAttempts should be >= 1');\n\n  /**\n   * @const\n   * @private {number}\n   */\n  this.baseDelay_ = (parameters.baseDelay == null) ?\n      defaults.baseDelay : parameters.baseDelay;\n\n  goog.asserts.assert(this.baseDelay_ >= 0, 'baseDelay should be >= 0');\n\n  /**\n   * @const\n   * @private {number}\n   */\n  this.fuzzFactor_ = (parameters.fuzzFactor == null) ?\n      defaults.fuzzFactor : parameters.fuzzFactor;\n\n  goog.asserts.assert(this.fuzzFactor_ >= 0, 'fuzzFactor should be >= 0');\n\n  /**\n   * @const\n   * @private {number}\n   */\n  this.backoffFactor_ = (parameters.backoffFactor == null) ?\n      defaults.backoffFactor : parameters.backoffFactor;\n\n  goog.asserts.assert(this.backoffFactor_ >= 0, 'backoffFactor should be >= 0');\n\n  /** @private {number} */\n  this.numAttempts_ = 0;\n\n  /** @private {number} */\n  this.nextUnfuzzedDelay_ = this.baseDelay_;\n\n  /** @private {boolean} */\n  this.autoReset_ = autoReset;\n\n  if (this.autoReset_) {\n    // There is no delay before the first attempt.  In StreamingEngine (the\n    // intended user of auto-reset mode), the first attempt was implied, so we\n    // reset numAttempts to 1.  Therefore maxAttempts (which includes the first\n    // attempt) must be at least 2 for us to see a delay.\n    goog.asserts.assert(this.maxAttempts_ >= 2,\n        'maxAttempts must be >= 2 for autoReset == true');\n    this.numAttempts_ = 1;\n  }\n};\n\n\n/**\n * @return {!Promise} Resolves when the caller may make an attempt, possibly\n *   after a delay.  Rejects if no more attempts are allowed.\n */\nshaka.net.Backoff.prototype.attempt = async function() {\n  if (this.numAttempts_ >= this.maxAttempts_) {\n    if (this.autoReset_) {\n      this.reset_();\n    } else {\n      return Promise.reject();\n    }\n  }\n\n  const currentAttempt = this.numAttempts_;\n  this.numAttempts_++;\n\n  if (currentAttempt == 0) {\n    goog.asserts.assert(!this.autoReset_, 'Failed to delay with auto-reset!');\n    return;\n  }\n\n  // We've already tried before, so delay the Promise.\n\n  // Fuzz the delay to avoid tons of clients hitting the server at once\n  // after it recovers from whatever is causing it to fail.\n  const fuzzedDelayMs = shaka.net.Backoff.fuzz_(\n      this.nextUnfuzzedDelay_, this.fuzzFactor_);\n\n  await new Promise((resolve) => {\n    shaka.net.Backoff.defer(fuzzedDelayMs, resolve);\n  });\n\n  // Update delay_ for next time.\n  this.nextUnfuzzedDelay_ *= this.backoffFactor_;\n};\n\n\n/**\n * Gets a copy of the default retry parameters.\n *\n * @return {shaka.extern.RetryParameters}\n */\nshaka.net.Backoff.defaultRetryParameters = function() {\n  // Use a function rather than a constant member so the calling code can\n  // modify the values without affecting other call results.\n  return {\n    maxAttempts: 2,\n    baseDelay: 1000,\n    backoffFactor: 2,\n    fuzzFactor: 0.5,\n    timeout: 0,\n  };\n};\n\n\n/**\n * Fuzz the input value by +/- fuzzFactor.  For example, a fuzzFactor of 0.5\n * will create a random value that is between 50% and 150% of the input value.\n *\n * @param {number} value\n * @param {number} fuzzFactor\n * @return {number} The fuzzed value\n * @private\n */\nshaka.net.Backoff.fuzz_ = function(value, fuzzFactor) {\n  // A random number between -1 and +1.\n  let negToPosOne = (Math.random() * 2.0) - 1.0;\n\n  // A random number between -fuzzFactor and +fuzzFactor.\n  let negToPosFuzzFactor = negToPosOne * fuzzFactor;\n\n  // The original value, fuzzed by +/- fuzzFactor.\n  return value * (1.0 + negToPosFuzzFactor);\n};\n\n\n/**\n * Reset state in autoReset mode.\n * @private\n */\nshaka.net.Backoff.prototype.reset_ = function() {\n  goog.asserts.assert(this.autoReset_, 'Should only be used for auto-reset!');\n  this.numAttempts_ = 1;\n  this.nextUnfuzzedDelay_ = this.baseDelay_;\n};\n\n\n/**\n * This method is only public for testing. It allows us to intercept the\n * time-delay call.\n *\n * @param {number} delayInMs\n * @param {function()} callback\n */\nshaka.net.Backoff.defer = function(delayInMs, callback) {\n  const timer = new shaka.util.Timer(callback);\n  timer.tickAfter(delayInMs / 1000);\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.Error');\n\n\n/**\n * Creates a new Error.\n *\n * @param {shaka.util.Error.Severity} severity\n * @param {shaka.util.Error.Category} category\n * @param {shaka.util.Error.Code} code\n * @param {...*} varArgs\n *\n * @constructor\n * @struct\n * @export\n * @extends {Error}\n * @implements {shaka.extern.Error}\n */\nshaka.util.Error = function(severity, category, code, ...varArgs) {\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.severity = severity;\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.category = category;\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.code = code;\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.data = varArgs;\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.handled = false;\n\n  // This improves the formatting of Errors in failure messages in the tests.\n  if (goog.DEBUG) {\n    let categoryName = 'UNKNOWN';\n    let codeName = 'UNKNOWN';\n\n    for (let k in shaka.util.Error.Category) {\n      if (shaka.util.Error.Category[k] == this.category) {\n        categoryName = k;\n      }\n    }\n    for (let k in shaka.util.Error.Code) {\n      if (shaka.util.Error.Code[k] == this.code) {\n        codeName = k;\n      }\n    }\n\n    /**\n     * A human-readable version of the category and code.\n     * <i>(Only available in uncompiled mode.)</i>\n     *\n     * @const {string}\n     * @exportDoc\n     */\n    this.message = 'Shaka Error ' + categoryName + '.' + codeName +\n                   ' (' + this.data.toString() + ')';\n\n    if (shaka.util.Error.createStack) {\n      try {\n        throw new Error(this.message);\n      } catch (e) {\n        /**\n         * A stack-trace showing where the error occurred.\n         * <i>(Only available in uncompiled mode.)</i>\n         *\n         * @const {string}\n         * @exportDoc\n         */\n        this.stack = e.stack;\n      }\n    }\n  }\n};\n\n\n/**\n * @return {string}\n * @override\n */\nshaka.util.Error.prototype.toString = function() {\n  return 'shaka.util.Error ' + JSON.stringify(this, null, '  ');\n};\n\n\nif (goog.DEBUG) {\n  /**\n   * If true, create a stack trace in Error objects.\n   *\n   * Only available in uncompiled mode, and disabled in tests to avoid issues\n   * with karma-jasmine.  See comments in test/test/boot.js for details.\n   *\n   * @type {boolean}\n   */\n  shaka.util.Error.createStack = true;\n}\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.util.Error.Severity = {\n  /**\n   * An error occurred, but the Player is attempting to recover from the error.\n   *\n   * If the Player cannot ultimately recover, it still may not throw a CRITICAL\n   * error.  For example, retrying for a media segment will never result in\n   * a CRITICAL error (the Player will just retry forever).\n   */\n  'RECOVERABLE': 1,\n\n  /**\n   * A critical error that the library cannot recover from.  These usually cause\n   * the Player to stop loading or updating.  A new manifest must be loaded\n   * to reset the library.\n   */\n  'CRITICAL': 2,\n};\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.util.Error.Category = {\n  /** Errors from the network stack. */\n  'NETWORK': 1,\n\n  /** Errors parsing text streams. */\n  'TEXT': 2,\n\n  /** Errors parsing or processing audio or video streams. */\n  'MEDIA': 3,\n\n  /** Errors parsing the Manifest. */\n  'MANIFEST': 4,\n\n  /** Errors related to streaming. */\n  'STREAMING': 5,\n\n  /** Errors related to DRM. */\n  'DRM': 6,\n\n  /** Miscellaneous errors from the player. */\n  'PLAYER': 7,\n\n  /** Errors related to cast. */\n  'CAST': 8,\n\n  /** Errors in the database storage (offline). */\n  'STORAGE': 9,\n};\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.util.Error.Code = {\n  /**\n   * A network request was made using an unsupported URI scheme.\n   * <br> error.data[0] is the URI.\n   */\n  'UNSUPPORTED_SCHEME': 1000,\n\n  /**\n   * An HTTP network request returned an HTTP status that indicated a failure.\n   * <br> error.data[0] is the URI.\n   * <br> error.data[1] is the status code.\n   * <br> error.data[2] is the response text, or null if the response could not\n   *   be interpretted as text.\n   * <br> error.data[3] is the map of response headers.\n   * <br> error.data[4] is the NetworkingEngine.RequestType of the request,\n   *   if one was provided.\n   */\n  'BAD_HTTP_STATUS': 1001,\n\n  /**\n   * An HTTP network request failed with an error, but not from the server.\n   * <br> error.data[0] is the URI.\n   * <br> error.data[1] is the original error.\n   * <br> error.data[2] is the NetworkingEngine.RequestType of the request.\n   */\n  'HTTP_ERROR': 1002,\n\n  /**\n   * A network request timed out.\n   * <br> error.data[0] is the URI.\n   * <br> error.data[1] is the NetworkingEngine.RequestType of the request,\n   *   if one was provided.\n   */\n  'TIMEOUT': 1003,\n\n  /**\n   * A network request was made with a malformed data URI.\n   * <br> error.data[0] is the URI.\n   */\n  'MALFORMED_DATA_URI': 1004,\n\n  /**\n   * A network request was made with a data URI using an unknown encoding.\n   * <br> error.data[0] is the URI.\n   */\n  'UNKNOWN_DATA_URI_ENCODING': 1005,\n\n  /**\n   * A request filter threw an error.\n   * <br> error.data[0] is the original error.\n   */\n  'REQUEST_FILTER_ERROR': 1006,\n\n  /**\n   * A response filter threw an error.\n   * <br> error.data[0] is the original error.\n   */\n  'RESPONSE_FILTER_ERROR': 1007,\n\n  /**\n   * A testing network request was made with a malformed URI.\n   * This error is only used by unit and integration tests.\n   */\n  'MALFORMED_TEST_URI': 1008,\n\n  /**\n   * An unexpected network request was made to the FakeNetworkingEngine.\n   * This error is only used by unit and integration tests.\n   */\n  'UNEXPECTED_TEST_REQUEST': 1009,\n\n\n  /** The text parser failed to parse a text stream due to an invalid header. */\n  'INVALID_TEXT_HEADER': 2000,\n\n  /** The text parser failed to parse a text stream due to an invalid cue. */\n  'INVALID_TEXT_CUE': 2001,\n\n  // RETIRED: 'INVALID_TEXT_SETTINGS': 2002,\n\n  /**\n   * Was unable to detect the encoding of the response text.  Suggest adding\n   * byte-order-markings to the response data.\n   */\n  'UNABLE_TO_DETECT_ENCODING': 2003,\n\n  /** The response data contains invalid Unicode character encoding. */\n  'BAD_ENCODING': 2004,\n\n  /**\n   * The XML parser failed to parse an xml stream, or the XML lacks mandatory\n   * elements for TTML.\n   * <br> error.data[0] is the URI associated with the XML.\n   */\n  'INVALID_XML': 2005,\n\n  // RETIRED: 'INVALID_TTML': 2006,\n\n  /**\n   * MP4 segment does not contain TTML.\n   */\n  'INVALID_MP4_TTML': 2007,\n\n  /**\n   * MP4 segment does not contain VTT.\n   */\n  'INVALID_MP4_VTT': 2008,\n\n  /**\n   * When examining media in advance, we were unable to extract the cue time.\n   * This should only be possible with HLS, where we do not have explicit\n   * segment start times.\n   * <br> error.data[0] is the underlying exception or Error object.\n   */\n  'UNABLE_TO_EXTRACT_CUE_START_TIME': 2009,\n\n\n  /**\n   * Some component tried to read past the end of a buffer.  The segment index,\n   * init segment, or PSSH may be malformed.\n   */\n  'BUFFER_READ_OUT_OF_BOUNDS': 3000,\n\n  /**\n   * Some component tried to parse an integer that was too large to fit in a\n   * JavaScript number without rounding error.  JavaScript can only natively\n   * represent integers up to 53 bits.\n   */\n  'JS_INTEGER_OVERFLOW': 3001,\n\n  /**\n   * The EBML parser used to parse the WebM container encountered an integer,\n   * ID, or other field larger than the maximum supported by the parser.\n   */\n  'EBML_OVERFLOW': 3002,\n\n  /**\n   * The EBML parser used to parse the WebM container encountered a floating-\n   * point field of a size not supported by the parser.\n   */\n  'EBML_BAD_FLOATING_POINT_SIZE': 3003,\n\n  /**\n   * The MP4 SIDX parser found the wrong box type.\n   * Either the segment index range is incorrect or the data is corrupt.\n   */\n  'MP4_SIDX_WRONG_BOX_TYPE': 3004,\n\n  /**\n   * The MP4 SIDX parser encountered an invalid timescale.\n   * The segment index data may be corrupt.\n   */\n  'MP4_SIDX_INVALID_TIMESCALE': 3005,\n\n  /** The MP4 SIDX parser encountered a type of SIDX that is not supported. */\n  'MP4_SIDX_TYPE_NOT_SUPPORTED': 3006,\n\n  /**\n   * The WebM Cues parser was unable to locate the Cues element.\n   * The segment index data may be corrupt.\n   */\n  'WEBM_CUES_ELEMENT_MISSING': 3007,\n\n  /**\n   * The WebM header parser was unable to locate the Ebml element.\n   * The init segment data may be corrupt.\n   */\n  'WEBM_EBML_HEADER_ELEMENT_MISSING': 3008,\n\n  /**\n   * The WebM header parser was unable to locate the Segment element.\n   * The init segment data may be corrupt.\n   */\n  'WEBM_SEGMENT_ELEMENT_MISSING': 3009,\n\n  /**\n   * The WebM header parser was unable to locate the Info element.\n   * The init segment data may be corrupt.\n   */\n  'WEBM_INFO_ELEMENT_MISSING': 3010,\n\n  /**\n   * The WebM header parser was unable to locate the Duration element.\n   * The init segment data may be corrupt or may have been incorrectly encoded.\n   * Shaka requires a duration in WebM DASH content.\n   */\n  'WEBM_DURATION_ELEMENT_MISSING': 3011,\n\n  /**\n   * The WebM Cues parser was unable to locate the Cue Track Positions element.\n   * The segment index data may be corrupt.\n   */\n  'WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING': 3012,\n\n  /**\n   * The WebM Cues parser was unable to locate the Cue Time element.\n   * The segment index data may be corrupt.\n   */\n  'WEBM_CUE_TIME_ELEMENT_MISSING': 3013,\n\n  /**\n   * A MediaSource operation failed.\n   * <br> error.data[0] is a MediaError code from the video element.\n   */\n  'MEDIA_SOURCE_OPERATION_FAILED': 3014,\n\n  /**\n   * A MediaSource operation threw an exception.\n   * <br> error.data[0] is the exception that was thrown.\n   */\n  'MEDIA_SOURCE_OPERATION_THREW': 3015,\n\n  /**\n   * The video element reported an error.\n   * <br> error.data[0] is a MediaError code from the video element.\n   * <br> On Edge & IE, error.data[1] is a Microsoft extended error code in hex.\n   * <br> On Chrome, error.data[2] is a string with details on the error.\n   */\n  'VIDEO_ERROR': 3016,\n\n  /**\n   * A MediaSource operation threw QuotaExceededError and recovery failed. The\n   * content cannot be played correctly because the segments are too large for\n   * the browser/platform. This may occur when attempting to play very high\n   * quality, very high bitrate content on low-end devices.\n   * <br> error.data[0] is the type of content which caused the error.\n   */\n  'QUOTA_EXCEEDED_ERROR': 3017,\n\n  /**\n   * Mux.js did not invoke the callback signifying successful transmuxing.\n   */\n  'TRANSMUXING_FAILED': 3018,\n\n\n  /**\n   * The Player was unable to guess the manifest type based on file extension\n   * or MIME type.  To fix, try one of the following:\n   * <br><ul>\n   *   <li>Rename the manifest so that the URI ends in a well-known extension.\n   *   <li>Configure the server to send a recognizable Content-Type header.\n   *   <li>Configure the server to accept a HEAD request for the manifest.\n   * </ul>\n   * <br> error.data[0] is the manifest URI.\n   */\n  'UNABLE_TO_GUESS_MANIFEST_TYPE': 4000,\n\n  /** The DASH Manifest contained invalid XML markup. */\n  'DASH_INVALID_XML': 4001,\n\n  /**\n   * The DASH Manifest contained a Representation with insufficient segment\n   * information.\n   */\n  'DASH_NO_SEGMENT_INFO': 4002,\n\n  /** The DASH Manifest contained an AdaptationSet with no Representations. */\n  'DASH_EMPTY_ADAPTATION_SET': 4003,\n\n  /** The DASH Manifest contained an Period with no AdaptationSets. */\n  'DASH_EMPTY_PERIOD': 4004,\n\n  /**\n   * The DASH Manifest does not specify an init segment with a WebM container.\n   */\n  'DASH_WEBM_MISSING_INIT': 4005,\n\n  /** The DASH Manifest contained an unsupported container format. */\n  'DASH_UNSUPPORTED_CONTAINER': 4006,\n\n  /** The embedded PSSH data has invalid encoding. */\n  'DASH_PSSH_BAD_ENCODING': 4007,\n\n  /**\n   * There is an AdaptationSet whose Representations do not have any common\n   * key-systems.\n   */\n  'DASH_NO_COMMON_KEY_SYSTEM': 4008,\n\n  /** Having multiple key IDs per Representation is not supported. */\n  'DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED': 4009,\n\n  /** The DASH Manifest specifies conflicting key IDs. */\n  'DASH_CONFLICTING_KEY_IDS': 4010,\n\n  /**\n   * The manifest contains a period with no playable streams.\n   * Either the period was originally empty, or the streams within cannot be\n   * played on this browser or platform.\n   */\n  'UNPLAYABLE_PERIOD': 4011,\n\n  /**\n   * There exist some streams that could be decoded, but restrictions imposed\n   * by the application or the key system prevent us from playing.  This may\n   * happen under the following conditions:\n   * <ul>\n   *   <li>The application has given restrictions to the Player that restrict\n   *       at least one content type completely (e.g. no playable audio).\n   *   <li>The manifest specifies different keys than were given to us from the\n   *       license server.\n   *   <li>The key system has imposed output restrictions that cannot be met\n   *       (such as HDCP) and there are no unrestricted alternatives.\n   * </ul>\n   * <br> error.data[0] is a {@link shaka.extern.RestrictionInfo} object\n   * describing the kinds of restrictions that caused this error.\n   */\n  'RESTRICTIONS_CANNOT_BE_MET': 4012,\n\n  // RETIRED: 'INTERNAL_ERROR_KEY_STATUS': 4013,\n\n  /**\n   * No valid periods were found in the manifest.  Please check that your\n   * manifest is correct and free of typos.\n   */\n  'NO_PERIODS': 4014,\n\n  /**\n   * HLS playlist doesn't start with a mandory #EXTM3U tag.\n   */\n  'HLS_PLAYLIST_HEADER_MISSING': 4015,\n\n  /**\n   * HLS tag has an invalid name that doesn't start with '#EXT'\n   * <br> error.data[0] is the invalid tag.\n   */\n  'INVALID_HLS_TAG': 4016,\n\n  /**\n   * HLS playlist has both Master and Media/Segment tags.\n   */\n  'HLS_INVALID_PLAYLIST_HIERARCHY': 4017,\n\n  /**\n   * A Representation has an id that is the same as another Representation in\n   * the same Period.  This makes manifest updates impossible since we cannot\n   * map the updated Representation to the old one.\n   */\n  'DASH_DUPLICATE_REPRESENTATION_ID': 4018,\n\n  // RETIRED: 'HLS_MEDIA_INIT_SECTION_INFO_MISSING': 4019,\n\n  /**\n   * HLS manifest has several #EXT-X-MAP tags. We can only\n   * support one at the moment.\n   */\n  'HLS_MULTIPLE_MEDIA_INIT_SECTIONS_FOUND': 4020,\n\n  /**\n   * HLS parser was unable to guess mime type of a stream.\n   * <br> error.data[0] is the stream file's extension.\n   */\n  'HLS_COULD_NOT_GUESS_MIME_TYPE': 4021,\n\n  /**\n   * No Master Playlist has been provided. Master playlist provides\n   * vital information about the streams (like codecs) that is\n   * required for MediaSource. We don't support directly providing\n   * a Media Playlist.\n   */\n  'HLS_MASTER_PLAYLIST_NOT_PROVIDED': 4022,\n\n  /**\n   * One of the required attributes was not provided, so the\n   * HLS manifest is invalid.\n   * <br> error.data[0] is the missing attribute's name.\n   */\n  'HLS_REQUIRED_ATTRIBUTE_MISSING': 4023,\n\n  /**\n   * One of the required tags was not provided, so the\n   * HLS manifest is invalid.\n   * <br> error.data[0] is the missing tag's name.\n   */\n  'HLS_REQUIRED_TAG_MISSING': 4024,\n\n  /**\n   * The HLS parser was unable to guess codecs of a stream.\n   * <br> error.data[0] is the list of all codecs for the variant.\n   */\n  'HLS_COULD_NOT_GUESS_CODECS': 4025,\n\n  /**\n   * The HLS parser has encountered encrypted content with unsupported\n   * KEYFORMAT attributes.\n   */\n  'HLS_KEYFORMATS_NOT_SUPPORTED': 4026,\n\n  /**\n   * The manifest parser only supports xlink links with xlink:actuate=\"onLoad\".\n   */\n  'DASH_UNSUPPORTED_XLINK_ACTUATE': 4027,\n\n  /**\n   * The manifest parser has hit its depth limit on xlink link chains.\n   */\n  'DASH_XLINK_DEPTH_LIMIT': 4028,\n\n  // RETIRED: 'HLS_LIVE_CONTENT_NOT_SUPPORTED': 4029,\n\n  /**\n   * The HLS parser was unable to parse segment start time from the media.\n   */\n  'HLS_COULD_NOT_PARSE_SEGMENT_START_TIME': 4030,\n\n  // RETIRED: 'HLS_MEDIA_SEQUENCE_REQUIRED_IN_LIVE_STREAMS': 4031,\n\n  /**\n   * The content container or codecs are not supported by this browser. For\n   * example, this could happen if the content is WebM, but your browser does\n   * not support the WebM container, or if the content uses HEVC, but your\n   * browser does not support the HEVC codec.  This can also occur for\n   * multicodec or multicontainer manifests if none of the codecs or containers\n   * are supported by the browser.\n   *\n   * To see what your browser supports, you can check the JSON data dumped by\n   * http://support.shaka-player-demo.appspot.com/\n   */\n  'CONTENT_UNSUPPORTED_BY_BROWSER': 4032,\n\n  /**\n   * External text tracks cannot be added to live streams.\n   */\n  'CANNOT_ADD_EXTERNAL_TEXT_TO_LIVE_STREAM': 4033,\n\n  /**\n   * We do not support AES-128 encryption with HLS yet.\n   */\n  'HLS_AES_128_ENCRYPTION_NOT_SUPPORTED': 4034,\n\n  // RETIRED: 'INCONSISTENT_BUFFER_STATE': 5000,\n  // RETIRED: 'INVALID_SEGMENT_INDEX': 5001,\n  // RETIRED: 'SEGMENT_DOES_NOT_EXIST': 5002,\n  // RETIRED: 'CANNOT_SATISFY_BYTE_LIMIT': 5003,\n  // RETIRED: 'BAD_SEGMENT': 5004,\n\n  /**\n   * The StreamingEngine called onChooseStreams() but the callback receiver\n   * did not return the correct number or type of Streams.\n   *\n   * This can happen when there is multi-Period content where one Period is\n   * video+audio and another is video-only or audio-only.  We don't support this\n   * case because it is incompatible with MSE.  When the browser reaches the\n   * transition, it will pause, waiting for the audio stream.\n   */\n  'INVALID_STREAMS_CHOSEN': 5005,\n\n\n  /**\n   * The manifest indicated protected content, but the manifest parser was\n   * unable to determine what key systems should be used.\n   */\n  'NO_RECOGNIZED_KEY_SYSTEMS': 6000,\n\n  /**\n   * None of the requested key system configurations are available.  This may\n   * happen under the following conditions:\n   * <ul>\n   *   <li> The key system is not supported.\n   *   <li> The key system does not support the features requested (e.g.\n   *        persistent state).\n   *   <li> A user prompt was shown and the user denied access.\n   *   <li> The key system is not available from unsecure contexts. (i.e.\n            requires HTTPS) See https://bit.ly/2K9X1nY\n   * </ul>\n   */\n  'REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE': 6001,\n\n  /**\n   * The browser found one of the requested key systems, but it failed to\n   * create an instance of the CDM for some unknown reason.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'FAILED_TO_CREATE_CDM': 6002,\n\n  /**\n   * The browser found one of the requested key systems and created an instance\n   * of the CDM, but it failed to attach the CDM to the video for some unknown\n   * reason.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'FAILED_TO_ATTACH_TO_VIDEO': 6003,\n\n  /**\n   * The CDM rejected the server certificate supplied by the application.\n   * The certificate may be malformed or in an unsupported format.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'INVALID_SERVER_CERTIFICATE': 6004,\n\n  /**\n   * The CDM refused to create a session for some unknown reason.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'FAILED_TO_CREATE_SESSION': 6005,\n\n  /**\n   * The CDM was unable to generate a license request for the init data it was\n   * given.  The init data may be malformed or in an unsupported format.\n   * <br> error.data[0] is an error message string from the browser.\n   * <br> error.data[1] is the error object from the browser.\n   * <br> error.data[2] is a string with the extended error code, if available.\n   */\n  'FAILED_TO_GENERATE_LICENSE_REQUEST': 6006,\n\n  /**\n   * The license request failed.  This could be a timeout, a network failure, or\n   * a rejection by the server.\n   * <br> error.data[0] is a shaka.util.Error from the networking engine.\n   */\n  'LICENSE_REQUEST_FAILED': 6007,\n\n  /**\n   * The license response was rejected by the CDM.  The server's response may be\n   * invalid or malformed for this CDM.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'LICENSE_RESPONSE_REJECTED': 6008,\n\n  // RETIRED: 'NO_LICENSE_SERVER_SPECIFIED': 6009,\n\n  /**\n   * The manifest does not specify any DRM info, but the content is encrypted.\n   * Either the manifest or the manifest parser are broken.\n   */\n  'ENCRYPTED_CONTENT_WITHOUT_DRM_INFO': 6010,\n\n  // RETIRED: 'WRONG_KEYS': 6011,\n\n  /**\n   * No license server was given for the key system signaled by the manifest.\n   * A license server URI is required for every key system.\n   * <br> error.data[0] is the key system identifier.\n   */\n  'NO_LICENSE_SERVER_GIVEN': 6012,\n\n  /**\n   * A required offline session was removed.  The content is not playable.\n   */\n  'OFFLINE_SESSION_REMOVED': 6013,\n\n  /**\n   * The license has expired.  This is triggered when all keys in the key\n   * status map have a status of 'expired'.\n   */\n  'EXPIRED': 6014,\n\n\n  /**\n   * The call to Player.load() was interrupted by a call to Player.unload()\n   * or another call to Player.load().\n   */\n  'LOAD_INTERRUPTED': 7000,\n\n  /**\n   * An internal error which indicates that an operation was aborted.  This\n   * should not be seen by applications.\n   */\n  'OPERATION_ABORTED': 7001,\n\n  /**\n   * The call to Player.load() failed because the Player does not have a video\n   * element.  The video element must either be provided to the constructor or\n   * to Player.attach() before Player.load() is called.\n   */\n  'NO_VIDEO_ELEMENT': 7002,\n\n\n  /**\n   * The Cast API is unavailable.  This may be because of one of the following:\n   *  1. The browser may not have Cast support\n   *  2. The browser may be missing a necessary Cast extension\n   *  3. The Cast sender library may not be loaded in your app\n   */\n  'CAST_API_UNAVAILABLE': 8000,\n\n  /**\n   * No cast receivers are available at this time.\n   */\n  'NO_CAST_RECEIVERS': 8001,\n\n  /**\n   * The library is already casting.\n   */\n  'ALREADY_CASTING': 8002,\n\n  /**\n   * A Cast SDK error that we did not explicitly plan for has occurred.\n   * Check data[0] and refer to the Cast SDK documentation for details.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'UNEXPECTED_CAST_ERROR': 8003,\n\n  /**\n   * The cast operation was canceled by the user.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'CAST_CANCELED_BY_USER': 8004,\n\n  /**\n   * The cast connection timed out.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'CAST_CONNECTION_TIMED_OUT': 8005,\n\n  /**\n   * The requested receiver app ID does not exist or is unavailable.\n   * Check the requested app ID for typos.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'CAST_RECEIVER_APP_UNAVAILABLE': 8006,\n\n\n  /**\n   * No receiver app id has been provided, making casting impossible.\n   */\n  'CAST_RECEIVER_APP_ID_MISSING': 8007,\n\n\n  /**\n   * Offline storage is not supported on this browser; it is required for\n   * offline support.\n   */\n  'STORAGE_NOT_SUPPORTED': 9000,\n\n  /**\n   * An unknown error occurred in the IndexedDB.\n   * <br> On Firefox, one common source for UnknownError calls is reverting\n   * Firefox to an old version. This makes the IndexedDB storage inaccessible\n   * for older versions. The only way to fix this is to delete the storage\n   * data in your profile. See https://mzl.la/2yCGWCm\n   * <br> error.data[0] is the error object.\n   */\n  'INDEXED_DB_ERROR': 9001,\n\n  /**\n   * The storage operation was aborted.  Deprecated in favor of more general\n   * OPERATION_ABORTED.\n   */\n  'DEPRECATED_OPERATION_ABORTED': 9002,\n\n  /**\n   * The specified item was not found in the IndexedDB.\n   * <br> error.data[0] is the offline URI.\n   */\n  'REQUESTED_ITEM_NOT_FOUND': 9003,\n\n  /**\n   * A network request was made with a malformed offline URI.\n   * <br> error.data[0] is the URI.\n   */\n  'MALFORMED_OFFLINE_URI': 9004,\n\n  /**\n   * The specified content is live or in-progress.\n   * Live and in-progress streams cannot be stored offline.\n   * <br> error.data[0] is the URI.\n   */\n  'CANNOT_STORE_LIVE_OFFLINE': 9005,\n\n  /**\n   * There is already a store operation in-progress. Wait until it completes\n   * before starting another.\n   */\n  'STORE_ALREADY_IN_PROGRESS': 9006,\n\n  /**\n   * The specified manifest is encrypted but does not specify any init data.\n   * Without init data specified in the manifest, the content will not be\n   * playable offline.\n   * <br> error.data[0] is the URI.\n   */\n  'NO_INIT_DATA_FOR_OFFLINE': 9007,\n\n  /**\n   * shaka.offline.Storage was constructed with a Player proxy instead of a\n   * local player instance.  To fix this, use Player directly with Storage\n   * instead of the results of CastProxy.prototype.getPlayer().\n   */\n  'LOCAL_PLAYER_INSTANCE_REQUIRED': 9008,\n\n  // RETIRED/MOVED TO 4000's: 'CONTENT_UNSUPPORTED_BY_BROWSER': 9009,\n\n  // RETIRED: 'UNSUPPORTED_UPGRADE_REQUEST': 9010,\n\n  /**\n   * The storage cell does not allow new operations that require new keys.\n   */\n  'NEW_KEY_OPERATION_NOT_SUPPORTED': 9011,\n\n  /**\n   * A key was not found in a storage cell.\n   */\n  'KEY_NOT_FOUND': 9012,\n\n  /**\n   * A storage cell was not found.\n   */\n  'MISSING_STORAGE_CELL': 9013,\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.PublicPromise');\n\n\n/**\n * A utility to create Promises with convenient public resolve and reject\n * methods.\n *\n * @constructor\n * @struct\n * @extends {Promise.<T>}\n * @return {Promise.<T>}\n * @template T\n */\nshaka.util.PublicPromise = function() {\n  let resolvePromise;\n  let rejectPromise;\n\n  // Promise.call causes an error.  It seems that inheriting from a native\n  // Promise is not permitted by JavaScript interpreters.\n\n  // The work-around is to construct a Promise object, modify it to look like\n  // the compiler's picture of PublicPromise, then return it.  The caller of\n  // new PublicPromise will receive |promise| instead of |this|, and the\n  // compiler will be aware of the additional properties |resolve| and\n  // |reject|.\n\n  const promise = new Promise(function(resolve, reject) {\n    resolvePromise = resolve;\n    rejectPromise = reject;\n  });\n\n  // Now cast the Promise object to our subclass PublicPromise so that the\n  // compiler will permit us to attach resolve() and reject() to it.\n  const publicPromise = /** @type {shaka.util.PublicPromise} */(promise);\n  publicPromise.resolve = resolvePromise;\n  publicPromise.reject = rejectPromise;\n\n  return publicPromise;\n};\n\n\n/** @param {T=} value */\nshaka.util.PublicPromise.prototype.resolve = function(value) {};\n\n\n/** @param {*=} reason */\nshaka.util.PublicPromise.prototype.reject = function(reason) {};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.AbortableOperation');\n\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.PublicPromise');\n\n/**\n * A utility to wrap abortable operations.  Note that these are not cancelable.\n * Cancelation implies undoing what has been done so far, whereas aborting only\n * means that futher work is stopped.\n *\n * @implements {shaka.extern.IAbortableOperation.<T>}\n * @template T\n * @export\n */\nshaka.util.AbortableOperation = class {\n  /**\n   * @param {!Promise.<T>} promise\n   *   A Promise which represents the underlying operation.  It is resolved when\n   *   the operation is complete, and rejected if the operation fails or is\n   *   aborted.  Aborted operations should be rejected with a shaka.util.Error\n   *   object using the error code OPERATION_ABORTED.\n   * @param {function():!Promise} onAbort\n   *   Will be called by this object to abort the underlying operation.\n   *   This is not cancelation, and will not necessarily result in any work\n   *   being undone.  abort() should return a Promise which is resolved when the\n   *   underlying operation has been aborted.  The returned Promise should never\n   *   be rejected.\n   */\n  constructor(promise, onAbort) {\n    /** @const {!Promise.<T>} */\n    this.promise = promise;\n\n    /** @private {function():!Promise} */\n    this.onAbort_ = onAbort;\n\n    /** @private {boolean} */\n    this.aborted_ = false;\n  }\n\n  /**\n   * @param {!shaka.util.Error} error\n   * @return {!shaka.util.AbortableOperation} An operation which has already\n   *   failed with the error given by the caller.\n   * @export\n   */\n  static failed(error) {\n    return new shaka.util.AbortableOperation(\n        Promise.reject(error),\n        () => Promise.resolve());\n  }\n\n  /**\n   * @return {!shaka.util.AbortableOperation} An operation which has already\n   *   failed with the error OPERATION_ABORTED.\n   * @export\n   */\n  static aborted() {\n    const p = Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.OPERATION_ABORTED));\n    // Silence uncaught rejection errors, which may otherwise occur any place\n    // we don't explicitly handle aborted operations.\n    p.catch(() => {});\n    return new shaka.util.AbortableOperation(p, () => Promise.resolve());\n  }\n\n  /**\n   * @param {U} value\n   * @return {!shaka.util.AbortableOperation.<U>} An operation which has already\n   *   completed with the given value.\n   * @template U\n   * @export\n   */\n  static completed(value) {\n    return new shaka.util.AbortableOperation(\n        Promise.resolve(value),\n        () => Promise.resolve());\n  }\n\n  /**\n   * @param {!Promise.<U>} promise\n   * @return {!shaka.util.AbortableOperation.<U>} An operation which cannot be\n   *   aborted.  It will be completed when the given Promise is resolved, or\n   *   will be failed when the given Promise is rejected.\n   * @template U\n   * @export\n   */\n  static notAbortable(promise) {\n    return new shaka.util.AbortableOperation(\n        promise,\n        // abort() here will return a Promise which is resolved when the input\n        // promise either resolves or fails.\n        () => promise.catch(() => {}));\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  abort() {\n    this.aborted_ = true;\n    return this.onAbort_();\n  }\n\n  /**\n   * @param {!Array.<!shaka.util.AbortableOperation>} operations\n   * @return {!shaka.util.AbortableOperation} An operation which is resolved\n   *   when all operations are successful and fails when any operation fails.\n   *   For this operation, abort() aborts all given operations.\n   * @export\n   */\n  static all(operations) {\n    return new shaka.util.AbortableOperation(\n        Promise.all(operations.map((op) => op.promise)),\n        () => Promise.all(operations.map((op) => op.abort())));\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  finally(onFinal) {\n    this.promise.then((value) => onFinal(true), (e) => onFinal(false));\n    return this;\n  }\n\n  /**\n   * @param {(undefined|\n   *          function(T):U|\n   *          function(T):!Promise.<U>|\n   *          function(T):!shaka.util.AbortableOperation.<U>)} onSuccess\n   *   A callback to be invoked after this operation is complete, to chain to\n   *   another operation.  The callback can return a plain value, a Promise to\n   *   an asynchronous value, or another AbortableOperation.\n   * @param {function(*)=} onError\n   *   An optional callback to be invoked if this operation fails, to perform\n   *   some cleanup or error handling.  Analogous to the second parameter of\n   *   Promise.prototype.then.\n   * @return {!shaka.util.AbortableOperation.<U>} An operation which is resolved\n   *   when this operation and the operation started by the callback are both\n   *   complete.\n   * @template U\n   * @export\n   */\n  chain(onSuccess, onError) {\n    let newPromise = new shaka.util.PublicPromise();\n\n    // If called before \"this\" completes, just abort \"this\".\n    let abort = () => {\n      newPromise.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.OPERATION_ABORTED));\n      return this.abort();\n    };\n\n    this.promise.then((value) => {\n      if (this.aborted_) {\n        // If \"this\" is not abortable(), or if abort() is called after \"this\"\n        // is complete but before the next stage in the chain begins, we should\n        // stop right away.\n        newPromise.reject(new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.PLAYER,\n            shaka.util.Error.Code.OPERATION_ABORTED));\n        return;\n      }\n\n      if (!onSuccess) {\n        // No callback?  Pass the success along.\n        newPromise.resolve(value);\n        return;\n      }\n\n      // Call the success callback, interpret the return value,\n      // set the Promise state, and get the next abort function.\n      abort = shaka.util.AbortableOperation.wrapChainCallback_(\n          onSuccess, value, newPromise);\n    }, (e) => {\n      // \"This\" failed or was aborted.\n\n      if (!onError) {\n        // No callback?  Pass the failure along.\n        newPromise.reject(e);\n        return;\n      }\n\n      // Call the error callback, interpret the return value,\n      // set the Promise state, and get the next abort function.\n      abort = shaka.util.AbortableOperation.wrapChainCallback_(\n          onError, e, newPromise);\n    });\n\n    return new shaka.util.AbortableOperation(\n        newPromise,\n        // By creating a closure around abort(), we can update the value of\n        // abort() at various stages.\n        () => abort());\n  }\n\n  /**\n   * @param {(function(T):U|\n   *          function(T):!Promise.<U>|\n   *          function(T):!shaka.util.AbortableOperation.<U>|\n   *          function(*))} callback\n   *   A callback to be invoked with the given value.\n   * @param {T} value\n   * @param {!shaka.util.PublicPromise} newPromise The promise for the next\n   *   stage in the chain.\n   * @return {function():!Promise} The next abort() function for the chain.\n   * @private\n   * @template T, U\n   */\n  static wrapChainCallback_(callback, value, newPromise) {\n    try {\n      let ret = callback(value);\n\n      if (ret && ret.promise && ret.abort) {\n        // This is an abortable operation, with its own abort() method.\n        // After this point, abort() should abort the operation from the\n        // callback, and the new promise should be tied to the promise\n        // from the callback's operation.\n        newPromise.resolve(ret.promise);\n        // This used to say \"return ret.abort;\", but it caused subtle issues by\n        // unbinding part of the abort chain.  There is now a test to ensure\n        // that we don't call abort with the wrong \"this\".\n        return () => ret.abort();\n      } else {\n        // This is a Promise or a plain value, and this step cannot be aborted.\n        newPromise.resolve(ret);\n        // Abort is complete when the returned value/Promise is resolved or\n        // fails, but never fails itself nor returns a value.\n        return () => Promise.resolve(ret).then(() => {}).catch(() => {});\n      }\n    } catch (exception) {\n      // The callback threw an exception or error.  Reject the new Promise and\n      // resolve any future abort call right away.\n      newPromise.reject(exception);\n      return () => Promise.resolve();\n    }\n  }\n};\n\n/**\n * @const {!Promise.<T>}\n * @exportInterface\n */\nshaka.util.AbortableOperation.prototype.promise;\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.FakeEvent');\n\n\n/**\n * Create an Event work-alike object based on the provided dictionary.\n * The event should contain all of the same properties from the dict.\n *\n * @param {string} type\n * @param {Object=} dict\n * @constructor\n * @extends {Event}\n */\nshaka.util.FakeEvent = function(type, dict = {}) {\n  // Take properties from dict if present.\n  for (let key in dict) {\n    this[key] = dict[key];\n  }\n\n\n  // The properties below cannot be set by the dict.  They are all provided for\n  // compatibility with native events.\n\n  /** @const {boolean} */\n  this.bubbles = false;\n\n  /** @type {boolean} */\n  this.cancelable = false;\n\n  /** @type {boolean} */\n  this.defaultPrevented = false;\n\n  /**\n   * According to MDN, Chrome uses high-res timers instead of epoch time.\n   * Follow suit so that timeStamps on FakeEvents use the same base as\n   * on native Events.\n   * @const {number}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Event/timeStamp\n   */\n  this.timeStamp = window.performance && window.performance.now ?\n      window.performance.now() : Date.now();\n\n  /** @const {string} */\n  this.type = type;\n\n  /** @const {boolean} */\n  this.isTrusted = false;\n\n  /** @type {EventTarget} */\n  this.currentTarget = null;\n\n  /** @type {EventTarget} */\n  this.target = null;\n\n\n  /**\n   * Non-standard property read by FakeEventTarget to stop processing listeners.\n   * @type {boolean}\n   */\n  this.stopped = false;\n};\n\n\n/**\n * Prevents the default action of the event.  Has no effect if the event isn't\n * cancellable.\n * @override\n */\nshaka.util.FakeEvent.prototype.preventDefault = function() {\n  if (this.cancelable) {\n    this.defaultPrevented = true;\n  }\n};\n\n\n/**\n * Stops processing event listeners for this event.  Provided for compatibility\n * with native Events.\n * @override\n */\nshaka.util.FakeEvent.prototype.stopImmediatePropagation = function() {\n  this.stopped = true;\n};\n\n\n/**\n * Does nothing, since FakeEvents do not bubble.  Provided for compatibility\n * with native Events.\n * @override\n */\nshaka.util.FakeEvent.prototype.stopPropagation = function() {};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.MultiMap');\n\n\n/**\n * A simple multimap template.\n * @constructor\n * @struct\n * @template T\n */\nshaka.util.MultiMap = function() {\n  /** @private {!Object.<string, !Array.<T>>} */\n  this.map_ = {};\n};\n\n\n/**\n * Add a key, value pair to the map.\n * @param {string} key\n * @param {T} value\n */\nshaka.util.MultiMap.prototype.push = function(key, value) {\n  if (this.map_.hasOwnProperty(key)) {\n    this.map_[key].push(value);\n  } else {\n    this.map_[key] = [value];\n  }\n};\n\n\n/**\n * Get a list of values by key.\n * @param {string} key\n * @return {Array.<T>} or null if no such key exists.\n */\nshaka.util.MultiMap.prototype.get = function(key) {\n  let list = this.map_[key];\n  // slice() clones the list so that it and the map can each be modified\n  // without affecting the other.\n  return list ? list.slice() : null;\n};\n\n\n/**\n * Get a list of all values.\n * @return {!Array.<T>}\n */\nshaka.util.MultiMap.prototype.getAll = function() {\n  let list = [];\n  for (let key in this.map_) {\n    list.push.apply(list, this.map_[key]);\n  }\n  return list;\n};\n\n\n/**\n * Remove a specific value, if it exists.\n * @param {string} key\n * @param {T} value\n */\nshaka.util.MultiMap.prototype.remove = function(key, value) {\n  let list = this.map_[key];\n  if (!list) return;\n  for (let i = 0; i < list.length; ++i) {\n    if (list[i] == value) {\n      list.splice(i, 1);\n      --i;\n    }\n  }\n};\n\n\n/**\n * Clear all keys and values from the multimap.\n */\nshaka.util.MultiMap.prototype.clear = function() {\n  this.map_ = {};\n};\n\n\n/**\n * @param {function(string, !Array.<T>)} callback\n */\nshaka.util.MultiMap.prototype.forEach = function(callback) {\n  for (let key in this.map_) {\n    callback(key, this.map_[key]);\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.FakeEventTarget');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.MultiMap');\n\n\n/**\n * A work-alike for EventTarget.  Only DOM elements may be true EventTargets,\n * but this can be used as a base class to provide event dispatch to non-DOM\n * classes.  Only FakeEvents should be dispatched.\n *\n * @struct\n * @constructor\n * @implements {EventTarget}\n * @exportInterface\n */\nshaka.util.FakeEventTarget = function() {\n  /**\n   * @private {!shaka.util.MultiMap.<shaka.util.FakeEventTarget.ListenerType>}\n   */\n  this.listeners_ = new shaka.util.MultiMap();\n\n  /**\n   * The target of all dispatched events.  Defaults to |this|.\n   * @type {EventTarget}\n   */\n  this.dispatchTarget = this;\n};\n\n\n/**\n * These are the listener types defined in the closure extern for EventTarget.\n * @typedef {EventListener|function(!Event):*}\n * @exportInterface\n */\nshaka.util.FakeEventTarget.ListenerType;\n\n\n/**\n * Add an event listener to this object.\n *\n * @param {string} type The event type to listen for.\n * @param {shaka.util.FakeEventTarget.ListenerType} listener The callback or\n *   listener object to invoke.\n * @param {(!AddEventListenerOptions|boolean)=} options Ignored.\n * @override\n * @exportInterface\n */\nshaka.util.FakeEventTarget.prototype.addEventListener =\n    function(type, listener, options) {\n  this.listeners_.push(type, listener);\n};\n\n\n/**\n * Remove an event listener from this object.\n *\n * @param {string} type The event type for which you wish to remove a listener.\n * @param {shaka.util.FakeEventTarget.ListenerType} listener The callback or\n *   listener object to remove.\n * @param {(EventListenerOptions|boolean)=} options Ignored.\n * @override\n * @exportInterface\n */\nshaka.util.FakeEventTarget.prototype.removeEventListener =\n    function(type, listener, options) {\n  this.listeners_.remove(type, listener);\n};\n\n\n/**\n * Dispatch an event from this object.\n *\n * @param {!Event} event The event to be dispatched from this object.\n * @return {boolean} True if the default action was prevented.\n * @override\n * @exportInterface\n */\nshaka.util.FakeEventTarget.prototype.dispatchEvent = function(event) {\n  // In many browsers, it is complex to overwrite properties of actual Events.\n  // Here we expect only to dispatch FakeEvents, which are simpler.\n  goog.asserts.assert(event instanceof shaka.util.FakeEvent,\n                      'FakeEventTarget can only dispatch FakeEvents!');\n\n  const listeners = this.listeners_.get(event.type) || [];\n\n  // Execute this event on listeners until the event has been stopped or we\n  // run out of listeners.\n  for (let i = 0; i < listeners.length; ++i) {\n    // Do this every time, since events can be re-dispatched from handlers.\n    event.target = this.dispatchTarget;\n    event.currentTarget = this.dispatchTarget;\n\n    let listener = listeners[i];\n    try {\n      // Check for the |handleEvent| member to test if this is a\n      // |EventListener| instance or a basic function.\n      if (listener.handleEvent) {\n        listener.handleEvent(event);\n      } else {\n        listener.call(this, event);\n      }\n    } catch (exception) {\n      // Exceptions during event handlers should not affect the caller,\n      // but should appear on the console as uncaught, according to MDN:\n      // https://mzl.la/2JXgwRo\n      shaka.log.error('Uncaught exception in event handler', exception,\n          exception ? exception.message : null,\n          exception ? exception.stack : null);\n    }\n\n    if (event.stopped) {\n      break;\n    }\n  }\n\n  return event.defaultPrevented;\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.ObjectUtils');\n\n\nshaka.util.ObjectUtils = class {\n /**\n  * Performs a deep clone of the given simple object.  This does not copy\n  * prototypes, custom properties (e.g. read-only), or multiple references to\n  * the same object.  If the caller needs these fields, it will need to set them\n  * after this returns.\n  *\n  * @template T\n  * @param {T} arg\n  * @return {T}\n  */\n  static cloneObject(arg) {\n    let seenObjects = new Set();\n    // This recursively clones the value |val|, using the captured variable\n    // |seenObjects| to track the objects we have already cloned.\n    let clone = function(val) {\n      switch (typeof val) {\n        case 'undefined':\n        case 'boolean':\n        case 'number':\n        case 'string':\n        case 'symbol':\n        case 'function':\n          return val;\n        case 'object':\n        default: {\n          // typeof null === 'object'\n          if (!val) return val;\n\n          // This covers Uint8Array and friends, even without a TypedArray\n          // base-class constructor.\n          const isTypedArray =\n              val.buffer && val.buffer.constructor == ArrayBuffer;\n          if (isTypedArray) {\n            return val;\n          }\n\n          if (seenObjects.has(val)) {\n            return null;\n          }\n\n          const isArray = val.constructor == Array;\n          if (val.constructor != Object && !isArray) {\n            return null;\n          }\n\n          seenObjects.add(val);\n          let ret = isArray ? [] : {};\n          // Note |name| will equal a number for arrays.\n          for (let name in val) {\n            ret[name] = clone(val[name]);\n          }\n\n          // Length is a non-enumerable property, but we should copy it over in\n          // case it is not the default.\n          if (isArray) {\n            ret.length = val.length;\n          }\n          return ret;\n        }\n      }\n    };\n    return clone(arg);\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.ArrayUtils');\n\n\n/**\n * @namespace shaka.util.ArrayUtils\n * @summary Array utility functions.\n */\n\n\n/**\n * Returns whether the two values contain the same value.  This correctly\n * handles comparisons involving NaN.\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n * @template T\n */\nshaka.util.ArrayUtils.defaultEquals = function(a, b) {\n  // NaN !== NaN, so we need to special case it.\n  if (typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b)) {\n    return true;\n  }\n  return a === b;\n};\n\n\n/**\n * Remove given element from array (assumes no duplicates).\n * @param {!Array.<T>} array\n * @param {T} element\n * @template T\n */\nshaka.util.ArrayUtils.remove = function(array, element) {\n  let index = array.indexOf(element);\n  if (index > -1) {\n    array.splice(index, 1);\n  }\n};\n\n\n/**\n * Count the number of items in the list that pass the check function.\n * @param {!Array.<T>} array\n * @param {function(T):boolean} check\n * @return {number}\n * @template T\n */\nshaka.util.ArrayUtils.count = function(array, check) {\n  let count = 0;\n\n  array.forEach(function(element) {\n    count += check(element) ? 1 : 0;\n  });\n\n  return count;\n};\n\n\n/**\n * Determines if the given arrays contain the same elements.\n *\n * @param {!Array.<T>} a\n * @param {!Array.<T>} b\n * @param {function(T, T):boolean=} compareFn\n * @return {boolean}\n * @template T\n */\nshaka.util.ArrayUtils.hasSameElements = function(a, b, compareFn) {\n  if (!compareFn) {\n    compareFn = shaka.util.ArrayUtils.defaultEquals;\n  }\n  if (a.length != b.length) {\n    return false;\n  }\n\n  let copy = b.slice();\n  for (const item of a) {\n    const idx = copy.findIndex((other) => compareFn(item, other));\n    if (idx == -1) {\n      return false;\n    }\n    // Since order doesn't matter, just swap the last element with this one and\n    // then drop the last element.\n    copy[idx] = copy[copy.length - 1];\n    copy.pop();\n  }\n\n  return copy.length == 0;\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.OperationManager');\n\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.IDestroyable');\n\n/**\n * A utility for cleaning up AbortableOperations, to help simplify common\n * patterns and reduce code duplication.\n *\n * @implements {shaka.util.IDestroyable}\n */\nshaka.util.OperationManager = class {\n  constructor() {\n    /** @private {!Array.<!shaka.extern.IAbortableOperation>} */\n    this.operations_ = [];\n  }\n\n  /**\n   * Manage an operation.  This means aborting it on destroy() and removing it\n   * from the management set when it complete.\n   *\n   * @param {!shaka.extern.IAbortableOperation} operation\n   */\n  manage(operation) {\n    this.operations_.push(operation.finally(() => {\n      shaka.util.ArrayUtils.remove(this.operations_, operation);\n    }));\n  }\n\n  /** @override */\n  destroy() {\n    let cleanup = [];\n    this.operations_.forEach((op) => {\n      // Catch and ignore any failures.  This silences error logs in the\n      // JavaScript console about uncaught Promise failures.\n      op.promise.catch(() => {});\n\n      // Now abort the operation.\n      cleanup.push(op.abort());\n    });\n\n    this.operations_ = [];\n    return Promise.all(cleanup);\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.net.NetworkingEngine');\ngoog.provide('shaka.net.NetworkingEngine.PendingRequest');\n\ngoog.require('goog.Uri');\ngoog.require('goog.asserts');\ngoog.require('shaka.net.Backoff');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.ObjectUtils');\ngoog.require('shaka.util.OperationManager');\n\n\n/**\n * @event shaka.net.NetworkingEngine.RetryEvent\n * @description Fired when the networking engine receives a recoverable error\n *   and retries.\n * @property {string} type\n *   'retry'\n * @property {?shaka.util.Error} error\n *   The error that caused the retry. If it was a non-Shaka error, this is set\n *   to null.\n * @exportDoc\n */\n\n\n/**\n * NetworkingEngine wraps all networking operations.  This accepts plugins that\n * handle the actual request.  A plugin is registered using registerScheme.\n * Each scheme has at most one plugin to handle the request.\n *\n * @param {function(number, number)=} onProgressUpdated Called when a progress\n *   event is triggered. Passed the duration, in milliseconds, that the request\n *   took, and the number of bytes transferred.\n *\n * @struct\n * @constructor\n * @implements {shaka.util.IDestroyable}\n * @extends {shaka.util.FakeEventTarget}\n * @export\n */\nshaka.net.NetworkingEngine = function(onProgressUpdated) {\n  shaka.util.FakeEventTarget.call(this);\n\n  /** @private {boolean} */\n  this.destroyed_ = false;\n\n  /** @private {!shaka.util.OperationManager} */\n  this.operationManager_ = new shaka.util.OperationManager();\n\n  /** @private {!Set.<shaka.extern.RequestFilter>} */\n  this.requestFilters_ = new Set();\n\n  /** @private {!Set.<shaka.extern.ResponseFilter>} */\n  this.responseFilters_ = new Set();\n\n  /** @private {?function(number, number)} */\n  this.onProgressUpdated_ = onProgressUpdated || null;\n};\n\ngoog.inherits(shaka.net.NetworkingEngine, shaka.util.FakeEventTarget);\n\n\n/**\n * Request types.  Allows a filter to decide which requests to read/alter.\n *\n * @enum {number}\n * @export\n */\nshaka.net.NetworkingEngine.RequestType = {\n  'MANIFEST': 0,\n  'SEGMENT': 1,\n  'LICENSE': 2,\n  'APP': 3,\n  'TIMING': 4,\n};\n\n\n/**\n * Priority level for network scheme plugins.\n * If multiple plugins are provided for the same scheme, only the\n * highest-priority one is used.\n *\n * @enum {number}\n * @export\n */\nshaka.net.NetworkingEngine.PluginPriority = {\n  'FALLBACK': 1,\n  'PREFERRED': 2,\n  'APPLICATION': 3,\n};\n\n\n/**\n * @typedef {{\n *   plugin: shaka.extern.SchemePlugin,\n *   priority: number\n * }}\n * @property {shaka.extern.SchemePlugin} plugin\n *   The associated plugin.\n * @property {number} priority\n *   The plugin's priority.\n */\nshaka.net.NetworkingEngine.SchemeObject;\n\n\n/**\n * Contains the scheme plugins.\n *\n * @private {!Object.<string, shaka.net.NetworkingEngine.SchemeObject>}\n */\nshaka.net.NetworkingEngine.schemes_ = {};\n\n/**\n * @typedef {{\n *   response: shaka.extern.Response,\n *   gotProgress: boolean\n * }}\n *\n * @description\n * Defines a response wrapper object, including the response object and whether\n * progress event is fired by the scheme plugin.\n *\n * @property {shaka.extern.Response} response\n * @property {boolean} gotProgress\n * @private\n */\nshaka.net.NetworkingEngine.ResponseAndGotProgress;\n\n\n/**\n * Registers a scheme plugin.  This plugin will handle all requests with the\n * given scheme.  If a plugin with the same scheme already exists, it is\n * replaced, unless the existing plugin is of higher priority.\n * If no priority is provided, this defaults to the highest priority of\n * APPLICATION.\n *\n * @param {string} scheme\n * @param {shaka.extern.SchemePlugin} plugin\n * @param {number=} priority\n * @export\n */\nshaka.net.NetworkingEngine.registerScheme =\n    function(scheme, plugin, priority) {\n  goog.asserts.assert(priority == undefined || priority > 0,\n      'explicit priority must be > 0');\n  priority =\n      priority || shaka.net.NetworkingEngine.PluginPriority.APPLICATION;\n  let existing = shaka.net.NetworkingEngine.schemes_[scheme];\n  if (!existing || priority >= existing.priority) {\n    shaka.net.NetworkingEngine.schemes_[scheme] = {\n      priority: priority,\n      plugin: plugin,\n    };\n  }\n};\n\n\n/**\n * Removes a scheme plugin.\n *\n * @param {string} scheme\n * @export\n */\nshaka.net.NetworkingEngine.unregisterScheme = function(scheme) {\n  delete shaka.net.NetworkingEngine.schemes_[scheme];\n};\n\n\n/**\n * Registers a new request filter.  All filters are applied in the order they\n * are registered.\n *\n * @param {shaka.extern.RequestFilter} filter\n * @export\n */\nshaka.net.NetworkingEngine.prototype.registerRequestFilter = function(filter) {\n  this.requestFilters_.add(filter);\n};\n\n\n/**\n * Removes a request filter.\n *\n * @param {shaka.extern.RequestFilter} filter\n * @export\n */\nshaka.net.NetworkingEngine.prototype.unregisterRequestFilter =\n    function(filter) {\n  this.requestFilters_.delete(filter);\n};\n\n\n/**\n * Clears all request filters.\n *\n * @export\n */\nshaka.net.NetworkingEngine.prototype.clearAllRequestFilters = function() {\n  this.requestFilters_.clear();\n};\n\n\n/**\n * Registers a new response filter.  All filters are applied in the order they\n * are registered.\n *\n * @param {shaka.extern.ResponseFilter} filter\n * @export\n */\nshaka.net.NetworkingEngine.prototype.registerResponseFilter = function(filter) {\n  this.responseFilters_.add(filter);\n};\n\n\n/**\n * Removes a response filter.\n *\n * @param {shaka.extern.ResponseFilter} filter\n * @export\n */\nshaka.net.NetworkingEngine.prototype.unregisterResponseFilter =\n    function(filter) {\n  this.responseFilters_.delete(filter);\n};\n\n\n/**\n * Clears all response filters.\n *\n * @export\n */\nshaka.net.NetworkingEngine.prototype.clearAllResponseFilters = function() {\n  this.responseFilters_.clear();\n};\n\n\n/**\n * Gets a copy of the default retry parameters.\n *\n * @return {shaka.extern.RetryParameters}\n *\n * NOTE: The implementation moved to shaka.net.Backoff to avoid a circular\n * dependency between the two classes.\n */\nshaka.net.NetworkingEngine.defaultRetryParameters =\n    shaka.net.Backoff.defaultRetryParameters;\n\n\n/**\n * Makes a simple network request for the given URIs.\n *\n * @param {!Array.<string>} uris\n * @param {shaka.extern.RetryParameters} retryParams\n * @return {shaka.extern.Request}\n */\nshaka.net.NetworkingEngine.makeRequest = function(uris, retryParams) {\n  return {\n    uris: uris,\n    method: 'GET',\n    body: null,\n    headers: {},\n    allowCrossSiteCredentials: false,\n    retryParameters: retryParams,\n    licenseRequestType: null,\n  };\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.net.NetworkingEngine.prototype.destroy = function() {\n  this.destroyed_ = true;\n  this.requestFilters_.clear();\n  this.responseFilters_.clear();\n  return this.operationManager_.destroy();\n};\n\n\n/**\n * Makes a network request and returns the resulting data.\n *\n * @param {shaka.net.NetworkingEngine.RequestType} type\n * @param {shaka.extern.Request} request\n * @return {!shaka.net.NetworkingEngine.PendingRequest}\n * @export\n */\nshaka.net.NetworkingEngine.prototype.request = function(type, request) {\n  const ObjectUtils = shaka.util.ObjectUtils;\n  const numBytesRemainingObj =\n      new shaka.net.NetworkingEngine.NumBytesRemainingClass();\n\n  // Reject all requests made after destroy is called.\n  if (this.destroyed_) {\n    const p = Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.OPERATION_ABORTED));\n    // Silence uncaught rejection errors, which may otherwise occur any place\n    // we don't explicitly handle aborted operations.\n    p.catch(() => {});\n    return new shaka.net.NetworkingEngine.PendingRequest(\n        p, () => Promise.resolve(), numBytesRemainingObj);\n  }\n\n  goog.asserts.assert(request.uris && request.uris.length,\n                      'Request without URIs!');\n\n  // If a request comes from outside the library, some parameters may be left\n  // undefined.  To make it easier for application developers, we will fill them\n  // in with defaults if necessary.\n  //\n  // We clone retryParameters and uris so that if a filter modifies the request,\n  // it doesn't contaminate future requests.\n  request.method = request.method || 'GET';\n  request.headers = request.headers || {};\n  request.retryParameters = request.retryParameters ?\n      ObjectUtils.cloneObject(request.retryParameters) :\n      shaka.net.NetworkingEngine.defaultRetryParameters();\n  request.uris = ObjectUtils.cloneObject(request.uris);\n\n  // Apply the registered filters to the request.\n  let requestFilterOperation = this.filterRequest_(type, request);\n  let requestOperation = requestFilterOperation.chain(\n      () => this.makeRequestWithRetry_(type, request, numBytesRemainingObj));\n  let responseFilterOperation = requestOperation.chain(\n      (responseAndGotProgress) =>\n          this.filterResponse_(type, responseAndGotProgress));\n\n  // Keep track of time spent in filters.\n  let requestFilterStartTime = Date.now();\n  let requestFilterMs = 0;\n  requestFilterOperation.promise.then(() => {\n    requestFilterMs = Date.now() - requestFilterStartTime;\n  }, () => {});  // Silence errors in this fork of the Promise chain.\n\n  let responseFilterStartTime = 0;\n  requestOperation.promise.then(() => {\n    responseFilterStartTime = Date.now();\n  }, () => {});  // Silence errors in this fork of the Promise chain.\n\n  const operation = responseFilterOperation.chain((responseAndGotProgress) => {\n    const responseFilterMs = Date.now() - responseFilterStartTime;\n    const response = responseAndGotProgress.response;\n    response.timeMs += requestFilterMs;\n    response.timeMs += responseFilterMs;\n    if (!responseAndGotProgress.gotProgress &&\n        this.onProgressUpdated_ &&\n        !response.fromCache &&\n        type == shaka.net.NetworkingEngine.RequestType.SEGMENT) {\n      this.onProgressUpdated_(response.timeMs, response.data.byteLength);\n    }\n    return response;\n  }, (e) => {\n    // Any error thrown from elsewhere should be recategorized as CRITICAL here.\n    // This is because by the time it gets here, we've exhausted retries.\n    if (e) {\n      goog.asserts.assert(e instanceof shaka.util.Error, 'Wrong error type');\n      e.severity = shaka.util.Error.Severity.CRITICAL;\n    }\n\n    throw e;\n  });\n\n  // Return the pending request, which carries the response operation, and the\n  // number of bytes remaining to be downloaded, updated by the progress events.\n  // Add the operation to the manager for later cleanup.\n  const pendingRequest =\n      new shaka.net.NetworkingEngine.PendingRequest(operation.promise,\n      operation.onAbort_, numBytesRemainingObj);\n  this.operationManager_.manage(pendingRequest);\n  return pendingRequest;\n};\n\n\n/**\n * @param {shaka.net.NetworkingEngine.RequestType} type\n * @param {shaka.extern.Request} request\n * @return {!shaka.extern.IAbortableOperation.<undefined>}\n * @private\n */\nshaka.net.NetworkingEngine.prototype.filterRequest_ = function(type, request) {\n  let filterOperation = shaka.util.AbortableOperation.completed(undefined);\n\n  for (const requestFilter of this.requestFilters_) {\n    // Request filters are run sequentially.\n    filterOperation =\n        filterOperation.chain(() => requestFilter(type, request));\n  }\n\n  // Catch any errors thrown by request filters, and substitute\n  // them with a Shaka-native error.\n  return filterOperation.chain(undefined, (e) => {\n    if (e && e.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n      // Don't change anything if the operation was aborted.\n      throw e;\n    }\n\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.NETWORK,\n        shaka.util.Error.Code.REQUEST_FILTER_ERROR, e);\n  });\n};\n\n\n/**\n * @param {shaka.net.NetworkingEngine.RequestType} type\n * @param {shaka.extern.Request} request\n * @param {shaka.net.NetworkingEngine.NumBytesRemainingClass}\n *            numBytesRemainingObj\n * @return {!shaka.extern.IAbortableOperation.<\n *            shaka.net.NetworkingEngine.ResponseAndGotProgress>}\n * @private\n */\nshaka.net.NetworkingEngine.prototype.makeRequestWithRetry_ =\n    function(type, request, numBytesRemainingObj) {\n  let backoff = new shaka.net.Backoff(\n      request.retryParameters, /* autoReset */ false);\n  let index = 0;\n  return this.send_(type, request, backoff, index, /* lastError */ null,\n                    numBytesRemainingObj);\n};\n\n\n/**\n * Sends the given request to the correct plugin and retry using Backoff.\n *\n * @param {shaka.net.NetworkingEngine.RequestType} type\n * @param {shaka.extern.Request} request\n * @param {!shaka.net.Backoff} backoff\n * @param {number} index\n * @param {?shaka.util.Error} lastError\n * @param {shaka.net.NetworkingEngine.NumBytesRemainingClass}\n *     numBytesRemainingObj\n * @return {!shaka.extern.IAbortableOperation.<\n *               shaka.net.NetworkingEngine.ResponseAndGotProgress>}\n * @private\n */\nshaka.net.NetworkingEngine.prototype.send_ = function(\n    type, request, backoff, index, lastError, numBytesRemainingObj) {\n  let uri = new goog.Uri(request.uris[index]);\n  let scheme = uri.getScheme();\n  // Whether it got a progress event.\n  let gotProgress = false;\n  if (!scheme) {\n    // If there is no scheme, infer one from the location.\n    scheme = shaka.net.NetworkingEngine.getLocationProtocol_();\n    goog.asserts.assert(scheme[scheme.length - 1] == ':',\n                        'location.protocol expected to end with a colon!');\n    // Drop the colon.\n    scheme = scheme.slice(0, -1);\n\n    // Override the original URI to make the scheme explicit.\n    uri.setScheme(scheme);\n    request.uris[index] = uri.toString();\n  }\n\n  let object = shaka.net.NetworkingEngine.schemes_[scheme];\n  let plugin = object ? object.plugin : null;\n  if (!plugin) {\n    return shaka.util.AbortableOperation.failed(\n        new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.UNSUPPORTED_SCHEME,\n            uri));\n  }\n\n\n  // Every attempt must have an associated backoff.attempt() call so that the\n  // accounting is correct.\n  let backoffOperation =\n      shaka.util.AbortableOperation.notAbortable(backoff.attempt());\n\n  let startTimeMs;\n  let sendOperation = backoffOperation.chain(() => {\n    if (this.destroyed_) {\n      return shaka.util.AbortableOperation.aborted();\n    }\n\n    startTimeMs = Date.now();\n    const segment = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n    return plugin(request.uris[index],\n         request,\n         type,\n         // The following function is passed to plugin.\n         (time, bytes, numBytesRemaining) => {\n           if (this.onProgressUpdated_ && type == segment) {\n             this.onProgressUpdated_(time, bytes);\n             gotProgress = true;\n             numBytesRemainingObj.setBytes(numBytesRemaining);\n           }\n        });\n  }).chain((response) => {\n    if (response.timeMs == undefined) {\n      response.timeMs = Date.now() - startTimeMs;\n    }\n    let responseAndGotProgress = {\n      response: response,\n      gotProgress: gotProgress,\n    };\n\n    return responseAndGotProgress;\n  }, (error) => {\n    if (error && error.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n      // Don't change anything if the operation was aborted.\n      throw error;\n    }\n\n    if (this.destroyed_) {\n      return shaka.util.AbortableOperation.aborted();\n    }\n\n    if (error && error.severity == shaka.util.Error.Severity.RECOVERABLE) {\n      // Don't pass in a non-shaka error, even if one is somehow thrown;\n      // instead, call the listener with a null error.\n      const errorOrNull = error instanceof shaka.util.Error ? error : null;\n      let event = new shaka.util.FakeEvent('retry', {'error': errorOrNull});\n      this.dispatchEvent(event);\n\n      // Move to the next URI.\n      index = (index + 1) % request.uris.length;\n      const shakaError = /** @type {shaka.util.Error} */(error);\n      return this.send_(type, request, backoff, index, shakaError,\n                        numBytesRemainingObj);\n    }\n\n    // The error was not recoverable, so do not try again.\n    // Rethrow the error so the Promise chain stays rejected.\n    throw error || lastError;\n  });\n\n  return sendOperation;\n};\n\n\n/**\n * @param {shaka.net.NetworkingEngine.RequestType} type\n * @param {shaka.net.NetworkingEngine.ResponseAndGotProgress}\n *        responseAndGotProgress\n * @return {!shaka.extern.IAbortableOperation.<\n *               shaka.net.NetworkingEngine.ResponseAndGotProgress>}\n * @private\n */\nshaka.net.NetworkingEngine.prototype.filterResponse_ =\n    function(type, responseAndGotProgress) {\n  let filterOperation = shaka.util.AbortableOperation.completed(undefined);\n  for (const responseFilter of this.responseFilters_) {\n    // Response filters are run sequentially.\n    filterOperation = filterOperation.chain(\n      responseFilter.bind(null, type, responseAndGotProgress.response));\n  }\n  // If successful, return the filtered response with whether it got progress.\n  return filterOperation.chain(() => {\n    return responseAndGotProgress;\n  }, (e) => {\n    // Catch any errors thrown by request filters, and substitute\n    // them with a Shaka-native error.\n\n    if (e && e.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n      // Don't change anything if the operation was aborted.\n      throw e;\n    }\n\n    // The error is assumed to be critical if the original wasn't a Shaka error.\n    let severity = shaka.util.Error.Severity.CRITICAL;\n    if (e instanceof shaka.util.Error) {\n      severity = e.severity;\n    }\n\n    throw new shaka.util.Error(\n        severity,\n        shaka.util.Error.Category.NETWORK,\n        shaka.util.Error.Code.RESPONSE_FILTER_ERROR, e);\n  });\n};\n\n\n/**\n * This is here only for testability.  We can't mock location in our tests on\n * all browsers, so instead we mock this.\n *\n * @return {string} The value of location.protocol.\n * @private\n */\nshaka.net.NetworkingEngine.getLocationProtocol_ = function() {\n  return location.protocol;\n};\n\n/**\n * A wrapper class for the number of bytes remaining to be downloaded for the\n * request.\n * Instead of using PendingRequest directly, this class is needed to be sent to\n * plugin as a parameter, and a Promise is returned, before PendingRequest is\n * created.\n *\n * @export\n */\nshaka.net.NetworkingEngine.NumBytesRemainingClass = class {\n  /**\n   * Constructor\n   */\n  constructor() {\n    /** @private {number} */\n    this.bytesToLoad_ = 0;\n  }\n\n  /**\n   * @param {number} bytesToLoad\n   */\n  setBytes(bytesToLoad) {\n    this.bytesToLoad_ = bytesToLoad;\n  }\n\n  /**\n   * @return {number}\n   */\n  getBytes() {\n    return this.bytesToLoad_;\n  }\n};\n\n/**\n * A pending network request. This can track the current progress of the\n * download, and allows the request to be aborted if the network is slow.\n *\n * @implements {shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n * @extends {shaka.util.AbortableOperation}\n * @export\n */\nshaka.net.NetworkingEngine.PendingRequest =\n    class extends shaka.util.AbortableOperation {\n  /**\n   * @param {!Promise} promise\n   *   A Promise which represents the underlying operation.  It is resolved when\n   *   the operation is complete, and rejected if the operation fails or is\n   *   aborted.  Aborted operations should be rejected with a shaka.util.Error\n   *   object using the error code OPERATION_ABORTED.\n   * @param {function():!Promise} onAbort\n   *   Will be called by this object to abort the underlying operation.\n   *   This is not cancelation, and will not necessarily result in any work\n   *   being undone.  abort() should return a Promise which is resolved when the\n   *   underlying operation has been aborted.  The returned Promise should never\n   *   be rejected.\n   * @param {shaka.net.NetworkingEngine.NumBytesRemainingClass}\n   *   numBytesRemainingObj\n   */\n  constructor(promise, onAbort, numBytesRemainingObj) {\n    super(promise, onAbort);\n\n    /** @private {shaka.net.NetworkingEngine.NumBytesRemainingClass} */\n    this.bytesRemaining_ = numBytesRemainingObj;\n  }\n\n /**\n  * @return {number}\n  */\n  getBytesRemaining() {\n    return this.bytesRemaining_.getBytes();\n  }\n};\n",null,"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.IReleasable');\n\n\n/**\n * An interface to standardize how objects release internal references\n * synchronously. If an object needs to asynchronously release references, then\n * it should use 'shaka.util.IDestroyable'.\n *\n * @interface\n * @export\n */\nshaka.util.IReleasable = class {\n  /**\n   * Request that this object release all internal references.\n   *\n   * @exportInterface\n   */\n  release() {}\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.EventManager');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.MultiMap');\n\n\n/**\n * @summary\n * An EventManager maintains a collection of \"event\n * bindings\" between event targets and event listeners.\n *\n * @implements {shaka.util.IReleasable}\n * @export\n */\nshaka.util.EventManager = class {\n  constructor() {\n    /**\n     * Maps an event type to an array of event bindings.\n     * @private {shaka.util.MultiMap.<!shaka.util.EventManager.Binding_>}\n     */\n    this.bindingMap_ = new shaka.util.MultiMap();\n  }\n\n\n  /**\n   * Detaches all event listeners.\n   * @override\n   * @export\n   */\n  release() {\n    this.removeAll();\n    this.bindingMap_ = null;\n  }\n\n\n  /**\n   * Attaches an event listener to an event target.\n   * @param {EventTarget} target The event target.\n   * @param {string} type The event type.\n   * @param {shaka.util.EventManager.ListenerType} listener The event listener.\n   * @param {(boolean|!AddEventListenerOptions)=} options An object that\n   *    specifies characteristics about the event listener.\n   *    The passive option, if true, indicates that this function will never\n   *    call preventDefault(), which improves scrolling performance.\n   * @export\n   */\n  listen(target, type, listener, options) {\n    if (!this.bindingMap_) {\n      return;\n    }\n\n    const binding =\n        new shaka.util.EventManager.Binding_(target, type, listener, options);\n    this.bindingMap_.push(type, binding);\n  }\n\n\n  /**\n   * Attaches an event listener to an event target.  The listener will be\n   * removed when the first instance of the event is fired.\n   * @param {EventTarget} target The event target.\n   * @param {string} type The event type.\n   * @param {shaka.util.EventManager.ListenerType} listener The event listener.\n   * @param {(boolean|!AddEventListenerOptions)=} options An object that\n   *    specifies characteristics about the event listener.\n   *    The passive option, if true, indicates that this function will never\n   *    call preventDefault(), which improves scrolling performance.\n   * @export\n   */\n  listenOnce(target, type, listener, options) {\n    // Install a shim listener that will stop listening after the first event.\n    const shim = (event) => {\n      // Stop listening to this event.\n      this.unlisten(target, type, shim);\n      // Call the original listener.\n      listener(event);\n    };\n    this.listen(target, type, shim, options);\n  }\n\n\n  /**\n   * Detaches an event listener from an event target.\n   * @param {EventTarget} target The event target.\n   * @param {string} type The event type.\n   * @param {shaka.util.EventManager.ListenerType=} listener The event listener.\n   * @export\n   */\n  unlisten(target, type, listener) {\n    if (!this.bindingMap_) {\n      return;\n    }\n\n    const list = this.bindingMap_.get(type) || [];\n\n    for (const binding of list) {\n      if (binding.target == target) {\n        if (listener == binding.listener || !listener) {\n          binding.unlisten();\n          this.bindingMap_.remove(type, binding);\n        }\n      }\n    }\n  }\n\n\n  /**\n   * Detaches all event listeners from all targets.\n   * @export\n   */\n  removeAll() {\n    if (!this.bindingMap_) {\n      return;\n    }\n\n    const list = this.bindingMap_.getAll();\n\n    for (const binding of list) {\n      binding.unlisten();\n    }\n\n    this.bindingMap_.clear();\n  }\n};\n\n\n/**\n * @typedef {function(!Event)}\n * @export\n */\nshaka.util.EventManager.ListenerType;\n\n\n/**\n * Creates a new Binding_ and attaches the event listener to the event target.\n *\n * @private\n */\nshaka.util.EventManager.Binding_ = class {\n  /**\n   * @param {EventTarget} target The event target.\n   * @param {string} type The event type.\n   * @param {shaka.util.EventManager.ListenerType} listener The event listener.\n   * @param {(boolean|!AddEventListenerOptions)=} options An object that\n   *    specifies characteristics about the event listener.\n   *    The passive option, if true, indicates that this function will never\n   *    call preventDefault(), which improves scrolling performance.\n   */\n  constructor(target, type, listener, options) {\n    /** @type {EventTarget} */\n    this.target = target;\n\n    /** @type {string} */\n    this.type = type;\n\n    /** @type {?shaka.util.EventManager.ListenerType} */\n    this.listener = listener;\n\n    /** @type {(boolean|!AddEventListenerOptions)} */\n    this.options =\n        shaka.util.EventManager.Binding_.convertOptions_(target, options);\n\n    this.target.addEventListener(type, listener, this.options);\n  }\n\n\n  /**\n   * Detaches the event listener from the event target. This does nothing if\n   * the event listener is already detached.\n   * @export\n   */\n  unlisten() {\n    goog.asserts.assert(this.target, 'Missing target');\n    this.target.removeEventListener(this.type, this.listener, this.options);\n\n    this.target = null;\n    this.listener = null;\n    this.options = false;\n  }\n\n  /**\n   * Converts the provided options value into a value accepted by the browser.\n   * Some browsers (e.g. IE11 and Tizen) don't support passing options as an\n   * object.  So this detects this case and converts it.\n   *\n   * @param {EventTarget} target\n   * @param {(boolean|!AddEventListenerOptions)=} value\n   * @return {(boolean|!AddEventListenerOptions)}\n   * @private\n   */\n  static convertOptions_(target, value) {\n    if (value == undefined) {\n      return false;\n    } else if (typeof value == 'boolean') {\n      return value;\n    } else {\n      // Ignore the 'passive' option since it is just an optimization and\n      // doesn't affect behavior.  Assert there aren't any other settings to\n      // ensure we don't have different behavior on different browsers by\n      // ignoring an important option.\n      const ignored = new Set(['passive', 'capture']);\n      const keys = Object.keys(value).filter((k) => !ignored.has(k));\n      goog.asserts.assert(\n          keys.length == 0,\n          'Unsupported flag(s) to addEventListener: ' + keys.join(','));\n\n      const supports =\n          shaka.util.EventManager.Binding_.doesSupportObject_(target);\n      if (supports) {\n        return value;\n      } else {\n        return value['capture'] || false;\n      }\n    }\n  }\n\n  /**\n   * Checks whether the browser supports passing objects as the third argument\n   * to addEventListener.  This caches the result value in a static field to\n   * avoid a bunch of checks.\n   *\n   * @param {EventTarget} target\n   * @return {boolean}\n   * @private\n   */\n  static doesSupportObject_(target) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n    let supports = shaka.util.EventManager.Binding_.supportsObject_;\n    if (supports == undefined) {\n      supports = false;\n      try {\n        const options = {};\n        // This defines a getter that will set this variable if called.  So if\n        // the browser gets this property, it supports using an object.  If the\n        // browser doesn't get these fields, it won't support objects.\n        const prop = {\n          get: () => {\n            supports = true;\n            return false;\n          },\n        };\n        Object.defineProperty(options, 'passive', prop);\n        Object.defineProperty(options, 'capture', prop);\n\n        const call = () => {};\n        target.addEventListener('test', call, options);\n        target.removeEventListener('test', call, options);\n      } catch (e) {\n        supports = false;\n      }\n      shaka.util.EventManager.Binding_.supportsObject_ = supports;\n    }\n    return supports || false;  // \"false\" fallback needed for compiler.\n  }\n};\n\n/** @private {(boolean|undefined)} */\nshaka.util.EventManager.Binding_.supportsObject_ = undefined;\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.Iterables');\n\n\n/**\n * Recreations of Array-like functions so that they work on any iterable\n * type.\n * @final\n */\nshaka.util.Iterables = class {\n  /**\n   * @param {!Iterable.<FROM>} iterable\n   * @param {function(FROM):TO} mapping\n   * @return {!Iterable.<TO>}\n   * @template FROM,TO\n   */\n  static map(iterable, mapping) {\n    const array = [];\n    for (const x of iterable) { array.push(mapping(x)); }\n    return array;\n  }\n\n  /**\n   * @param {!Iterable.<T>} iterable\n   * @param {function(T):boolean} test\n   * @return {boolean}\n   * @template T\n   */\n  static every(iterable, test) {\n    for (const x of iterable) {\n      if (!test(x)) { return false; }\n    }\n    return true;\n  }\n\n  /**\n   * @param {!Iterable.<T>} iterable\n   * @param {function(T):boolean} test\n   * @return {boolean}\n   * @template T\n   */\n  static some(iterable, test) {\n    for (const x of iterable) {\n      if (test(x)) { return true; }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate over an iterable object and return only the items that |filter|\n   * returns true for.\n   *\n   * @param {!Iterable.<T>} iterable\n   * @param {function(T):boolean} filter\n   * @return {!Array.<T>}\n   * @template T\n   */\n  static filter(iterable, filter) {\n    const out = [];\n    for (const x of iterable) {\n      if (filter(x)) { out.push(x); }\n    }\n    return out;\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.MapUtils');\n\n\n/**\n * @namespace shaka.util.MapUtils\n * @summary A set of map/object utility functions.\n */\n\n\n/**\n * @param {!Object.<KEY, VALUE>} object\n * @return {!Map.<KEY, VALUE>}\n * @template KEY,VALUE\n */\nshaka.util.MapUtils.asMap = function(object) {\n  const map = new Map();\n  Object.keys(object).forEach((key) => {\n    map.set(key, object[key]);\n  });\n\n  return map;\n};\n\n\n/**\n * @param {!Map.<KEY, VALUE>} map\n * @return {!Object.<KEY, VALUE>}\n * @template KEY,VALUE\n */\nshaka.util.MapUtils.asObject = function(map) {\n  const obj = {};\n  map.forEach((value, key) => {\n    obj[key] = value;\n  });\n\n  return obj;\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.MimeUtils');\n\n\n/**\n * @summary A set of utility functions for dealing with MIME types.\n */\nshaka.util.MimeUtils = class {\n  /**\n   * Takes a MIME type and optional codecs string and produces the full MIME\n   * type.\n   *\n   * @param {string} mimeType\n   * @param {string=} codecs\n   * @return {string}\n   */\n  static getFullType(mimeType, codecs) {\n    let fullMimeType = mimeType;\n    if (codecs) {\n      fullMimeType += '; codecs=\"' + codecs + '\"';\n    }\n    return fullMimeType;\n  }\n\n  /**\n   * Takes a Stream object and produces an extended MIME type with information\n   * beyond the container and codec type, when available.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {string}\n   */\n  static getExtendedType(stream) {\n    const components = [stream.mimeType];\n\n    const extendedMimeParams = shaka.util.MimeUtils.EXTENDED_MIME_PARAMETERS_;\n    extendedMimeParams.forEach((mimeKey, streamKey) => {\n      const value = stream[streamKey];\n      if (value) {\n        components.push(mimeKey + '=\"' + value + '\"');\n      }\n    });\n\n    return components.join(';');\n  }\n\n  /**\n   * Split a list of codecs encoded in a string into a list of codecs.\n   * @param {string} codecs\n   * @return {!Array.<string>}\n   */\n  static splitCodecs(codecs) {\n    return codecs.split(',');\n  }\n\n  /**\n   * Get the base codec from a codec string.\n   *\n   * @param {string} codecString\n   * @return {string}\n   */\n  static getCodecBase(codecString) {\n    const parts = shaka.util.MimeUtils.getCodecParts_(codecString);\n    return parts[0];\n  }\n\n  /**\n   * Get the base and profile of a codec string. Where [0] will be the codec\n   * base and [1] will be the profile.\n   * @param {string} codecString\n   * @return {!Array.<string>}\n   * @private\n   */\n  static getCodecParts_(codecString) {\n    const parts = codecString.split('.');\n\n    const base = parts[0];\n\n    parts.pop();\n    const profile = parts.join('.');\n\n    // Make sure that we always return a \"base\" and \"profile\".\n    return [base, profile];\n  }\n};\n\n\n/**\n * A map from Stream object keys to MIME type parameters.  These should be\n * ignored by platforms that do not recognize them.\n *\n * This initial set of parameters are all recognized by Chromecast.\n *\n * @const {!Map.<string, string>}\n * @private\n */\nshaka.util.MimeUtils.EXTENDED_MIME_PARAMETERS_ = new Map()\n  .set('codecs', 'codecs')\n  .set('frameRate', 'framerate')  // Ours is camelCase, theirs is lowercase.\n  .set('bandwidth', 'bitrate')  // They are in the same units: bits/sec.\n  .set('width', 'width')\n  .set('height', 'height')\n  .set('channelsCount', 'channels');\n\n\n/**\n * A mimetype created for CEA closed captions.\n * @const {string}\n */\nshaka.util.MimeUtils.CLOSED_CAPTION_MIMETYPE = 'application/cea-608';\n\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.Platform');\n\ngoog.require('shaka.util.Timer');\n\n\n/**\n * A wrapper for platform-specific functions.\n *\n * @final\n */\nshaka.util.Platform = class {\n  /**\n   * Check if the current platform supports media source. We assume that if\n   * the current platform supports media source, then we can use media source\n   * as per its design.\n   *\n   * @return {boolean}\n   */\n  static supportsMediaSource() {\n    // Browsers that lack a media source implementation will have no reference\n    // to |window.MediaSource|. Platforms that we see having problematic media\n    // source implementations will have this reference removed via a polyfill.\n    if (!window.MediaSource) {\n      return false;\n    }\n\n    // Some very old MediaSource implementations didn't have isTypeSupported.\n    if (!MediaSource.isTypeSupported) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns true if the media type is supported natively by the platform.\n   *\n   * @param {string} mimeType\n   * @return {boolean}\n   */\n  static supportsMediaType(mimeType) {\n    const video = shaka.util.Platform.anyMediaElement_();\n    return video.canPlayType(mimeType) != '';\n  }\n\n  /**\n   * Check if the current platform is MS Edge.\n   *\n   * @return {boolean}\n   */\n  static isEdge() {\n    return shaka.util.Platform.userAgentContains_('Edge/');\n  }\n\n  /**\n   * Check if the current platform is MS IE.\n   *\n   * @return {boolean}\n   */\n  static isIE() {\n    return shaka.util.Platform.userAgentContains_('Trident/');\n  }\n\n  /**\n   * Check if the current platform is a Tizen TV.\n   *\n   * @return {boolean}\n   */\n  static isTizen() {\n    return shaka.util.Platform.userAgentContains_('Tizen');\n  }\n\n  /**\n   * Check if the current platform is a Tizen 3 TV.\n   *\n   * @return {boolean}\n   */\n  static isTizen3() {\n    return shaka.util.Platform.userAgentContains_('Tizen 3');\n  }\n\n  /**\n   * Check if the current platform is a WebOS.\n   *\n   * @return {boolean}\n   */\n  static isWebOS() {\n    return shaka.util.Platform.userAgentContains_('Web0S');\n  }\n\n  /**\n   * Check if the current platform is a Google Chromecast.\n   *\n   * @return {boolean}\n   */\n  static isChromecast() {\n    return shaka.util.Platform.userAgentContains_('CrKey');\n  }\n\n  /**\n   * Check if the current platform is Google Chrome.\n   *\n   * @return {boolean}\n   */\n  static isChrome() {\n    // The Edge user agent will also contain the \"Chrome\" keyword, so we need\n    // to make sure this is not Edge.\n    return shaka.util.Platform.userAgentContains_('Chrome') &&\n           !shaka.util.Platform.isEdge();\n  }\n\n  /**\n   * Check if the current platform is an Apple device (iOS, desktop Safari, etc)\n   *\n   * @return {boolean}\n   */\n  static isApple() {\n    return !!navigator.vendor && navigator.vendor.includes('Apple');\n  }\n\n  /**\n   * Guesses if the platform is a mobile one (iOS or Android).\n   *\n   * @return {boolean}\n   */\n  static isMobile() {\n    return /(?:iPhone|iPad|iPod|Android)/.test(navigator.userAgent);\n  }\n\n  /**\n   * Check if the user agent contains a key. This is the best way we know of\n   * right now to detect platforms. If there is a better way, please send a\n   * PR.\n   *\n   * @param {string} key\n   * @return {boolean}\n   * @private\n   */\n  static userAgentContains_(key) {\n    const userAgent = navigator.userAgent || '';\n    return userAgent.includes(key);\n  }\n\n  /**\n   * For canPlayType queries, we just need any instance.\n   *\n   * First, use a cached element from a previous query.\n   * Second, search the page for one.\n   * Third, create a temporary one.\n   *\n   * Cached elements expire in one second so that they can be GC'd or removed.\n   *\n   * @return {!HTMLMediaElement}\n   */\n  static anyMediaElement_() {\n    const Platform = shaka.util.Platform;\n    if (Platform.cachedMediaElement_) {\n      return Platform.cachedMediaElement_;\n    }\n\n    if (!Platform.cacheExpirationTimer_) {\n      Platform.cacheExpirationTimer_ = new shaka.util.Timer(() => {\n        Platform.cachedMediaElement_ = null;\n      });\n    }\n\n    Platform.cachedMediaElement_ = /** @type {HTMLMediaElement} */(\n        document.querySelector('video') || document.querySelector('audio'));\n\n    if (!Platform.cachedMediaElement_) {\n      Platform.cachedMediaElement_ = /** @type {!HTMLMediaElement} */(\n          document.createElement('video'));\n    }\n\n    Platform.cacheExpirationTimer_.tickAfter(/* seconds= */ 1);\n    return Platform.cachedMediaElement_;\n  }\n};\n\n/** @private {shaka.util.Timer} */\nshaka.util.Platform.cacheExpirationTimer_ = null;\n\n/** @private {HTMLMediaElement} */\nshaka.util.Platform.cachedMediaElement_ = null;\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.StringUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\n\n\n/**\n * @namespace shaka.util.StringUtils\n * @summary A set of string utility functions.\n * @exportDoc\n */\n\n\n/**\n * Creates a string from the given buffer as UTF-8 encoding.\n *\n * @param {?BufferSource} data\n * @return {string}\n * @throws {shaka.util.Error}\n * @export\n */\nshaka.util.StringUtils.fromUTF8 = function(data) {\n  if (!data) return '';\n\n  let uint8 = new Uint8Array(data);\n  // If present, strip off the UTF-8 BOM.\n  if (uint8[0] == 0xef && uint8[1] == 0xbb && uint8[2] == 0xbf) {\n    uint8 = uint8.subarray(3);\n  }\n\n  // http://stackoverflow.com/a/13691499\n  let utf8 = shaka.util.StringUtils.fromCharCode(uint8);\n  // This converts each character in the string to an escape sequence.  If the\n  // character is in the ASCII range, it is not converted; otherwise it is\n  // converted to a URI escape sequence.\n  // Example: '\\x67\\x35\\xe3\\x82\\xac' -> 'g#%E3%82%AC'\n  let escaped = escape(utf8);\n  // Decode the escaped sequence.  This will interpret UTF-8 sequences into the\n  // correct character.\n  // Example: 'g#%E3%82%AC' -> 'g#'\n  try {\n    return decodeURIComponent(escaped);\n  } catch (e) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL, shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.BAD_ENCODING);\n  }\n};\n\n\n/**\n * Creates a string from the given buffer as UTF-16 encoding.\n *\n * @param {?BufferSource} data\n * @param {boolean} littleEndian true to read little endian, false to read big.\n * @param {boolean=} noThrow true to avoid throwing in cases where we may\n *     expect invalid input.  If noThrow is true and the data has an odd length,\n *     it will be truncated.\n * @return {string}\n * @throws {shaka.util.Error}\n * @export\n */\nshaka.util.StringUtils.fromUTF16 = function(data, littleEndian, noThrow) {\n  if (!data) return '';\n\n  if (!noThrow && data.byteLength % 2 != 0) {\n    shaka.log.error('Data has an incorrect length, must be even.');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL, shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.BAD_ENCODING);\n  }\n\n  /** @type {ArrayBuffer} */\n  let buffer;\n  if (data instanceof ArrayBuffer) {\n    buffer = data;\n  } else {\n    // Have to create a new buffer because the argument may be a smaller\n    // view on a larger ArrayBuffer.  We cannot use an ArrayBufferView in\n    // a DataView.\n    let temp = new Uint8Array(data.byteLength);\n    temp.set(new Uint8Array(data));\n    buffer = temp.buffer;\n  }\n\n  // Use a DataView to ensure correct endianness.\n  let length = Math.floor(data.byteLength / 2);\n  let arr = new Uint16Array(length);\n  let dataView = new DataView(buffer);\n  for (let i = 0; i < length; i++) {\n    arr[i] = dataView.getUint16(i * 2, littleEndian);\n  }\n  return shaka.util.StringUtils.fromCharCode(arr);\n};\n\n\n/**\n * Creates a string from the given buffer, auto-detecting the encoding that is\n * being used.  If it cannot detect the encoding, it will throw an exception.\n *\n * @param {?BufferSource} data\n * @return {string}\n * @throws {shaka.util.Error}\n * @export\n */\nshaka.util.StringUtils.fromBytesAutoDetect = function(data) {\n  const StringUtils = shaka.util.StringUtils;\n\n  let uint8 = new Uint8Array(data);\n  if (uint8[0] == 0xef && uint8[1] == 0xbb && uint8[2] == 0xbf) {\n    return StringUtils.fromUTF8(uint8);\n  } else if (uint8[0] == 0xfe && uint8[1] == 0xff) {\n    return StringUtils.fromUTF16(uint8.subarray(2), false /* littleEndian */);\n  } else if (uint8[0] == 0xff && uint8[1] == 0xfe) {\n    return StringUtils.fromUTF16(uint8.subarray(2), true /* littleEndian */);\n  }\n\n  let isAscii = (function(arr, i) {\n    // arr[i] >= ' ' && arr[i] <= '~';\n    return arr.byteLength <= i || (arr[i] >= 0x20 && arr[i] <= 0x7e);\n  }.bind(null, uint8));\n\n  shaka.log.debug('Unable to find byte-order-mark, making an educated guess.');\n  if (uint8[0] == 0 && uint8[2] == 0) {\n    return StringUtils.fromUTF16(data, false /* littleEndian */);\n  } else if (uint8[1] == 0 && uint8[3] == 0) {\n    return StringUtils.fromUTF16(data, true /* littleEndian */);\n  } else if (isAscii(0) && isAscii(1) && isAscii(2) && isAscii(3)) {\n    return StringUtils.fromUTF8(data);\n  }\n\n  throw new shaka.util.Error(\n      shaka.util.Error.Severity.CRITICAL,\n      shaka.util.Error.Category.TEXT,\n      shaka.util.Error.Code.UNABLE_TO_DETECT_ENCODING);\n};\n\n\n/**\n * Creates a ArrayBuffer from the given string, converting to UTF-8 encoding.\n *\n * @param {string} str\n * @return {!ArrayBuffer}\n * @export\n */\nshaka.util.StringUtils.toUTF8 = function(str) {\n  // http://stackoverflow.com/a/13691499\n  // Converts the given string to a URI encoded string.  If a character falls\n  // in the ASCII range, it is not converted; otherwise it will be converted to\n  // a series of URI escape sequences according to UTF-8.\n  // Example: 'g#' -> 'g#%E3%82%AC'\n  let encoded = encodeURIComponent(str);\n  // Convert each escape sequence individually into a character.  Each escape\n  // sequence is interpreted as a code-point, so if an escape sequence happens\n  // to be part of a multi-byte sequence, each byte will be converted to a\n  // single character.\n  // Example: 'g#%E3%82%AC' -> '\\x67\\x35\\xe3\\x82\\xac'\n  let utf8 = unescape(encoded);\n\n  let result = new Uint8Array(utf8.length);\n  for (let i = 0; i < utf8.length; ++i) {\n    result[i] = utf8.charCodeAt(i);\n  }\n  return result.buffer;\n};\n\n\n/**\n * Creates a ArrayBuffer from the given string, converting to UTF-16 encoding.\n *\n * @param {string} str\n * @param {boolean} littleEndian\n * @return {!ArrayBuffer}\n * @export\n */\nshaka.util.StringUtils.toUTF16 = function(str, littleEndian) {\n  const result = new Uint8Array(str.length * 2);\n  const view = new DataView(result.buffer);\n  for (let i = 0; i < str.length; ++i) {\n    const value = str.charCodeAt(i);\n    view.setUint16(/* position= */ i * 2, value, littleEndian);\n  }\n  return result.buffer;\n};\n\n\n/**\n * Creates a new string from the given array of char codes.\n *\n * Using String.fromCharCode.apply is risky because you can trigger stack errors\n * on very large arrays.  This breaks up the array into several pieces to avoid\n * this.\n *\n * @param {!TypedArray} array\n * @return {string}\n */\nshaka.util.StringUtils.fromCharCode = function(array) {\n  // Check the browser for what chunk sizes it supports.  Cache the result\n  // in an impl method to avoid checking several times.\n  if (!shaka.util.StringUtils.fromCharCodeImpl_) {\n    const supportsChunkSize = (size) => {\n      try {\n        const buffer = new Uint8Array(size);\n        // The compiler will complain about suspicious value if this isn't\n        // stored in a variable and used.\n        const foo = String.fromCharCode(...buffer);\n        goog.asserts.assert(foo, 'Should get value');\n        return true;\n      } catch (error) {\n        return false;\n      }\n    };\n\n    // Different browsers support different chunk sizes; find out the largest\n    // this browser supports so we can use larger chunks on supported browsers\n    // but still support lower-end devices that require small chunks.\n    // 64k is supported on all major desktop browsers.\n    for (let size = 64 * 1024; size > 0; size /= 2) {\n      if (supportsChunkSize(size)) {\n        shaka.util.StringUtils.fromCharCodeImpl_ = (buffer) => {\n          let ret = '';\n          for (let i = 0; i < buffer.length; i += size) {\n            const subArray = buffer.subarray(i, i + size);\n            ret += String.fromCharCode(...subArray);\n          }\n          return ret;\n        };\n        break;\n      }\n    }\n  }\n\n  goog.asserts.assert(\n      shaka.util.StringUtils.fromCharCodeImpl_,\n      'Unable to create a fromCharCode method');\n  return shaka.util.StringUtils.fromCharCodeImpl_(array);\n};\n\n\n/** @private {?function(!TypedArray):string} */\nshaka.util.StringUtils.fromCharCodeImpl_ = null;\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.Uint8ArrayUtils');\n\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * @namespace shaka.util.Uint8ArrayUtils\n * @summary A set of Uint8Array utility functions.\n * @exportDoc\n */\n\n\n/**\n * Convert a Uint8Array to a base64 string.  The output will always use the\n * alternate encoding/alphabet also known as \"base64url\".\n * @param {!Uint8Array} arr\n * @param {boolean=} padding If true, pad the output with equals signs.\n *   Defaults to true.\n * @return {string}\n * @export\n */\nshaka.util.Uint8ArrayUtils.toBase64 = function(arr, padding) {\n  // btoa expects a \"raw string\" where each character is interpreted as a byte.\n  let bytes = shaka.util.StringUtils.fromCharCode(arr);\n  padding = (padding == undefined) ? true : padding;\n  let base64 = window.btoa(bytes).replace(/\\+/g, '-').replace(/\\//g, '_');\n  return padding ? base64 : base64.replace(/=*$/, '');\n};\n\n\n/**\n * Convert a base64 string to a Uint8Array.  Accepts either the standard\n * alphabet or the alternate \"base64url\" alphabet.\n * @param {string} str\n * @return {!Uint8Array}\n * @export\n */\nshaka.util.Uint8ArrayUtils.fromBase64 = function(str) {\n  // atob creates a \"raw string\" where each character is interpreted as a byte.\n  let bytes = window.atob(str.replace(/-/g, '+').replace(/_/g, '/'));\n  let result = new Uint8Array(bytes.length);\n  for (let i = 0; i < bytes.length; ++i) {\n    result[i] = bytes.charCodeAt(i);\n  }\n  return result;\n};\n\n\n/**\n * Convert a hex string to a Uint8Array.\n * @param {string} str\n * @return {!Uint8Array}\n * @export\n */\nshaka.util.Uint8ArrayUtils.fromHex = function(str) {\n  let arr = new Uint8Array(str.length / 2);\n  for (let i = 0; i < str.length; i += 2) {\n    arr[i / 2] = window.parseInt(str.substr(i, 2), 16);\n  }\n  return arr;\n};\n\n\n/**\n * Convert a Uint8Array to a hex string.\n * @param {!Uint8Array} arr\n * @return {string}\n * @export\n */\nshaka.util.Uint8ArrayUtils.toHex = function(arr) {\n  let hex = '';\n  for (let i = 0; i < arr.length; ++i) {\n    let value = arr[i].toString(16);\n    if (value.length == 1) value = '0' + value;\n    hex += value;\n  }\n  return hex;\n};\n\n\n/**\n * Compare two Uint8Arrays for equality.\n * @param {Uint8Array} arr1\n * @param {Uint8Array} arr2\n * @return {boolean}\n * @export\n */\nshaka.util.Uint8ArrayUtils.equal = function(arr1, arr2) {\n  if (!arr1 && !arr2) return true;\n  if (!arr1 || !arr2) return false;\n  if (arr1.length != arr2.length) return false;\n  for (let i = 0; i < arr1.length; ++i) {\n    if (arr1[i] != arr2[i]) return false;\n  }\n  return true;\n};\n\n\n/**\n * Concatenate Uint8Arrays.\n * @param {...!Uint8Array} varArgs\n * @return {!Uint8Array}\n * @export\n */\nshaka.util.Uint8ArrayUtils.concat = function(...varArgs) {\n  let totalLength = 0;\n  for (let i = 0; i < varArgs.length; ++i) {\n    totalLength += varArgs[i].length;\n  }\n\n  let result = new Uint8Array(totalLength);\n  let offset = 0;\n  for (let i = 0; i < varArgs.length; ++i) {\n    result.set(varArgs[i], offset);\n    offset += varArgs[i].length;\n  }\n  return result;\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.DrmEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.MapUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Timer');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @param {shaka.media.DrmEngine.PlayerInterface} playerInterface\n *\n * @constructor\n * @struct\n * @implements {shaka.util.IDestroyable}\n */\nshaka.media.DrmEngine = function(playerInterface) {\n  /** @private {?shaka.media.DrmEngine.PlayerInterface} */\n  this.playerInterface_ = playerInterface;\n\n  /** @private {!Set.<string>} */\n  this.supportedTypes_ = new Set();\n\n  /** @private {MediaKeys} */\n  this.mediaKeys_ = null;\n\n  /** @private {HTMLMediaElement} */\n  this.video_ = null;\n\n  /** @private {boolean} */\n  this.initialized_ = false;\n\n  /** @private {?shaka.extern.DrmInfo} */\n  this.currentDrmInfo_ = null;\n\n  /** @private {shaka.util.EventManager} */\n  this.eventManager_ = new shaka.util.EventManager();\n\n  /**\n   * @private {!Map.<MediaKeySession,\n   *           shaka.media.DrmEngine.SessionMetaData>}\n   */\n  this.activeSessions_ = new Map();\n\n  /** @private {!Array.<string>} */\n  this.offlineSessionIds_ = [];\n\n  /** @private {!shaka.util.PublicPromise} */\n  this.allSessionsLoaded_ = new shaka.util.PublicPromise();\n\n  /** @private {?shaka.extern.DrmConfiguration} */\n  this.config_ = null;\n\n  /** @private {?function(!shaka.util.Error)} */\n  this.onError_ = (err) => {\n    this.allSessionsLoaded_.reject(err);\n    playerInterface.onError(err);\n  };\n\n  /**\n   * The most recent key status information we have.\n   * We may not have announced this information to the outside world yet,\n   * which we delay to batch up changes and avoid spurious \"missing key\" errors.\n   * @private {!Map.<string, string>}\n   */\n  this.keyStatusByKeyId_ = new Map();\n\n  /**\n   * The key statuses most recently announced to other classes.\n   * We may have more up-to-date information being collected in\n   * this.keyStatusByKeyId_, which has not been batched up and released yet.\n   * @private {!Map.<string, string>}\n   */\n  this.announcedKeyStatusByKeyId_ = new Map();\n\n  /** @private {shaka.util.Timer} */\n  this.keyStatusTimer_ =\n      new shaka.util.Timer(() => this.processKeyStatusChanges_());\n\n  /**\n   * A flag to signal when have started destroying ourselves. This will:\n   *  1. Stop later calls to |destroy| from trying to destroy the already\n   *     destroyed (or currently destroying) DrmEngine.\n   *  2. Stop in-progress async operations from continuing.\n   *\n   * @private {boolean}\n   */\n  this.isDestroying_ = false;\n\n  /**\n   * A promise that will only resolve once we have finished destroying\n   * ourselves, this is used to ensure that subsequent calls to |destroy| don't\n   * resolve before the first call to |destroy|.\n   *\n   * @private {!shaka.util.PublicPromise}\n   */\n  this.finishedDestroyingPromise_ = new shaka.util.PublicPromise();\n\n  /** @private {boolean} */\n  this.usePersistentLicenses_ = false;\n\n  /** @private {!Array.<!MediaKeyMessageEvent>} */\n  this.mediaKeyMessageEvents_ = [];\n\n  /** @private {boolean} */\n  this.initialRequestsSent_ = false;\n\n  /** @private {?shaka.util.Timer} */\n  this.expirationTimer_ = new shaka.util.Timer(() => {\n    this.pollExpiration_();\n  }).tickEvery(/* seconds= */ 1);\n\n  // Add a catch to the Promise to avoid console logs about uncaught errors.\n  const noop = () => {};\n  this.allSessionsLoaded_.catch(noop);\n};\n\n\n/**\n * @typedef {{\n *   loaded: boolean,\n *   initData: Uint8Array,\n *   oldExpiration: number,\n *   updatePromise: shaka.util.PublicPromise\n * }}\n *\n * @description A record to track sessions and suppress duplicate init data.\n * @property {boolean} loaded\n *   True once the key status has been updated (to a non-pending state).  This\n *   does not mean the session is 'usable'.\n * @property {Uint8Array} initData\n *   The init data used to create the session.\n * @property {!MediaKeySession} session\n *   The session object.\n * @property {number} oldExpiration\n *   The expiration of the session on the last check.  This is used to fire\n *   an event when it changes.\n * @property {shaka.util.PublicPromise} updatePromise\n *   An optional Promise that will be resolved/rejected on the next update()\n *   call.  This is used to track the 'license-release' message when calling\n *   remove().\n */\nshaka.media.DrmEngine.SessionMetaData;\n\n\n/**\n * @typedef {{\n *   netEngine: !shaka.net.NetworkingEngine,\n *   onError: function(!shaka.util.Error),\n *   onKeyStatus: function(!Object.<string,string>),\n *   onExpirationUpdated: function(string,number),\n *   onEvent: function(!Event)\n * }}\n *\n * @property {shaka.net.NetworkingEngine} netEngine\n *   The NetworkingEngine instance to use.  The caller retains ownership.\n * @property {function(!shaka.util.Error)} onError\n *   Called when an error occurs.  If the error is recoverable (see\n *   {@link shaka.util.Error}) then the caller may invoke either\n *   StreamingEngine.switch*() or StreamingEngine.seeked() to attempt recovery.\n * @property {function(!Object.<string,string>)} onKeyStatus\n *   Called when key status changes.  The argument is a map of hex key IDs to\n *   statuses.\n * @property {function(string,number)} onExpirationUpdated\n *   Called when the session expiration value changes.\n * @property {function(!Event)} onEvent\n *   Called when an event occurs that should be sent to the app.\n */\nshaka.media.DrmEngine.PlayerInterface;\n\n\n/** @override */\nshaka.media.DrmEngine.prototype.destroy = async function() {\n  // If we have started destroying ourselves, wait for the common \"I am finished\n  // being destroyed\" promise to be resolved.\n  if (this.isDestroying_) {\n   await this.finishedDestroyingPromise_;\n  } else {\n    this.isDestroying_ = true;\n    await this.destroyNow_();\n    this.finishedDestroyingPromise_.resolve();\n  }\n};\n\n\n/**\n * Destroy this instance of DrmEngine. This assumes that all other checks about\n * \"if it should\" have passed.\n *\n * @private\n */\nshaka.media.DrmEngine.prototype.destroyNow_ = async function() {\n  // |eventManager_| should only be |null| after we call |destroy|. Destroy it\n  // first so that we will stop responding to events.\n  this.eventManager_.release();\n  this.eventManager_ = null;\n\n  // Since we are destroying ourselves, we don't want to react to the \"all\n  // sessions loaded\" event.\n  this.allSessionsLoaded_.reject();\n\n  // Stop all timers. This will ensure that they do not start any new work while\n  // we are destroying ourselves.\n  this.expirationTimer_.stop();\n  this.expirationTimer_ = null;\n\n  this.keyStatusTimer_.stop();\n  this.keyStatusTimer_ = null;\n\n  // Close all open sessions.\n  const openSessions = Array.from(this.activeSessions_.keys());\n  this.activeSessions_.clear();\n\n  // Close all sessions before we remove media keys from the video element.\n  await Promise.all(openSessions.map((session) => {\n    return Promise.resolve().then(async () => {\n      shaka.log.v1('Closing session', session.sessionId);\n\n      try {\n        await shaka.media.DrmEngine.closeSession_(session);\n      } catch (error) {\n        // Ignore errors when closing the sessions. Closing a session that\n        // generated no key requests will throw an error.\n      }\n    });\n  }));\n\n  // |video_| will be |null| if we never attached to a video element.\n  if (this.video_) {\n    goog.asserts.assert(!this.video_.src, 'video src must be removed first!');\n\n    try {\n      await this.video_.setMediaKeys(null);\n    } catch (error) {\n      // Ignore any failures while removing media keys from the video element.\n    }\n\n    this.video_ = null;\n  }\n\n  // Break references to everything else we hold internally.\n  this.currentDrmInfo_ = null;\n  this.supportedTypes_.clear();\n  this.mediaKeys_ = null;\n  this.offlineSessionIds_ = [];\n  this.config_ = null;\n  this.onError_ = null;\n  this.playerInterface_ = null;\n};\n\n\n/**\n * Called by the Player to provide an updated configuration any time it changes.\n * Must be called at least once before init().\n *\n * @param {shaka.extern.DrmConfiguration} config\n */\nshaka.media.DrmEngine.prototype.configure = function(config) {\n  this.config_ = config;\n};\n\n\n/**\n * Initialize the drm engine for storing and deleting stored content.\n *\n * @param {!Array.<shaka.extern.Variant>} variants\n *    The variants that are going to be stored.\n * @param {boolean} usePersistentLicenses\n *    Whether or not persistent licenses should be requested and stored for\n *    |manifest|.\n * @return {!Promise}\n */\nshaka.media.DrmEngine.prototype.initForStorage = function(\n    variants, usePersistentLicenses) {\n  // There are two cases for this call:\n  //  1. We are about to store a manifest - in that case, there are no offline\n  //     sessions and therefore no offline session ids.\n  //  2. We are about to remove the offline sessions for this manifest - in\n  //     that case, we don't need to know about them right now either as\n  //     we will be told which ones to remove later.\n  this.offlineSessionIds_ = [];\n\n  // What we really need to know is whether or not they are expecting to use\n  // persistent licenses.\n  this.usePersistentLicenses_ = usePersistentLicenses;\n\n  return this.init_(variants);\n};\n\n\n/**\n * Initialize the drm engine for playback operations.\n *\n * @param {!Array.<shaka.extern.Variant>} variants\n *    The variants that we want to support playing.\n * @param {!Array.<string>} offlineSessionIds\n * @return {!Promise}\n */\nshaka.media.DrmEngine.prototype.initForPlayback = function(\n    variants, offlineSessionIds) {\n  this.offlineSessionIds_ = offlineSessionIds;\n  this.usePersistentLicenses_ = offlineSessionIds.length > 0;\n\n  return this.init_(variants);\n};\n\n\n/**\n * Initializes the drm engine for removing persistent sessions.  Only the\n * removeSession(s) methods will work correctly, creating new sessions may not\n * work as desired.\n *\n * @param {string} keySystem\n * @param {string} licenseServerUri\n * @param {Uint8Array} serverCertificate\n * @param {!Array.<MediaKeySystemMediaCapability>} audioCapabilities\n * @param {!Array.<MediaKeySystemMediaCapability>} videoCapabilities\n * @return {!Promise}\n */\nshaka.media.DrmEngine.prototype.initForRemoval = function(\n    keySystem, licenseServerUri, serverCertificate,\n    audioCapabilities, videoCapabilities) {\n  /** @type {!Map.<string, MediaKeySystemConfiguration>} */\n  const configsByKeySystem = new Map();\n  configsByKeySystem.set(keySystem, {\n    audioCapabilities: audioCapabilities,\n    videoCapabilities: videoCapabilities,\n    distinctiveIdentifier: 'optional',\n    persistentState: 'required',\n    sessionTypes: ['persistent-license'],\n    label: keySystem,\n    drmInfos: [{\n      keySystem: keySystem,\n      licenseServerUri: licenseServerUri,\n      distinctiveIdentifierRequired: false,\n      persistentStateRequired: true,\n      audioRobustness: '',  // Not required by queryMediaKeys_\n      videoRobustness: '',  // Same\n      serverCertificate: serverCertificate,\n      initData: null,\n      keyIds: null,\n    }],  // Tracked by us, ignored by EME.\n  });\n\n  return this.queryMediaKeys_(configsByKeySystem);\n};\n\n\n/**\n * Negotiate for a key system and set up MediaKeys.\n * This will assume that both |usePersistentLicences_| and |offlineSessionIds_|\n * have been properly set.\n *\n * @param {!Array.<shaka.extern.Variant>} variants\n *    The variants that we expect to operate with during the drm engine's\n *    lifespan of the drm engine.\n * @return {!Promise} Resolved if/when a key system has been chosen.\n * @private\n */\nshaka.media.DrmEngine.prototype.init_ = function(variants) {\n  goog.asserts.assert(this.config_,\n      'DrmEngine configure() must be called before init()!');\n\n  const hadDrmInfo = variants.some((v) => v.drmInfos.length > 0);\n\n  // When preparing to play live streams, it is possible that we won't know\n  // about some upcoming encrypted content. If we initialize the drm engine\n  // with no key systems, we won't be able to play when the encrypted content\n  // comes.\n  //\n  // To avoid this, we will set the drm engine up to work with as many key\n  // systems as possible so that we will be ready.\n  if (!hadDrmInfo) {\n    const servers = shaka.util.MapUtils.asMap(this.config_.servers);\n    shaka.media.DrmEngine.replaceDrmInfo_(variants, servers);\n  }\n\n  // ClearKey config overrides the manifest DrmInfo if present. The variants\n  // are modified so that filtering in Player still works.\n  /** @type {?shaka.extern.DrmInfo} */\n  const clearKeyDrmInfo = this.configureClearKey_();\n  if (clearKeyDrmInfo) {\n    for (const variant of variants) {\n      variant.drmInfos = [clearKeyDrmInfo];\n    }\n  }\n\n  // Make sure all the drm infos are valid and filled in correctly.\n  for (const variant of variants) {\n    for (const info of variant.drmInfos) {\n      shaka.media.DrmEngine.fillInDrmInfoDefaults_(\n          info,\n          shaka.util.MapUtils.asMap(this.config_.servers),\n          shaka.util.MapUtils.asMap(this.config_.advanced || {}));\n    }\n  }\n\n  /** @type {!Map.<string, MediaKeySystemConfiguration>} */\n  const configsByKeySystem = this.prepareMediaKeyConfigsForVariants_(variants);\n\n  // TODO(vaage): Find an explanation for the difference between this\n  //  \"unencrypted\" form and the \"no drm info unencrypted form\" and express\n  //  that difference here.\n  if (!configsByKeySystem.size) {\n    // Unencrypted.\n    this.initialized_ = true;\n    return Promise.resolve();\n  }\n\n  const p = this.queryMediaKeys_(configsByKeySystem);\n\n  // TODO(vaage): Look into the assertion below. If we do not have any drm info,\n  //  we create drm info so that content can play if it has drm info later.\n  //  However it is okay if we fail to initialize? If we fail to initialize, it\n  //  means we won't be able to play the later-encrypted content, which is no\n  //  okay.\n\n  // If the content did not originally have any drm info, then it doesn't matter\n  // if we fail to initialize the drm engine, because we won't need it anyway.\n  return hadDrmInfo ?\n         p :\n         p.catch(() => {});\n};\n\n\n/**\n * Attach MediaKeys to the video element and start processing events.\n * @param {HTMLMediaElement} video\n * @return {!Promise}\n */\nshaka.media.DrmEngine.prototype.attach = function(video) {\n  if (!this.mediaKeys_) {\n    // Unencrypted, or so we think.  We listen for encrypted events in order to\n    // warn when the stream is encrypted, even though the manifest does not know\n    // it.\n    // Don't complain about this twice, so just listenOnce().\n    // FIXME: This is ineffective when a prefixed event is translated by our\n    // polyfills, since those events are only caught and translated by a\n    // MediaKeys instance.  With clear content and no polyfilled MediaKeys\n    // instance attached, you'll never see the 'encrypted' event on those\n    // platforms (IE 11 & Safari).\n    this.eventManager_.listenOnce(video, 'encrypted', (event) => {\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.ENCRYPTED_CONTENT_WITHOUT_DRM_INFO));\n    });\n    return Promise.resolve();\n  }\n\n  this.video_ = video;\n\n  this.eventManager_.listenOnce(this.video_, 'play', () => this.onPlay_());\n\n  let setMediaKeys = this.video_.setMediaKeys(this.mediaKeys_);\n  setMediaKeys = setMediaKeys.catch(function(exception) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.FAILED_TO_ATTACH_TO_VIDEO,\n        exception.message));\n  });\n\n  let setServerCertificate = this.setServerCertificate();\n\n  return Promise.all([setMediaKeys, setServerCertificate]).then(() => {\n    if (this.isDestroying_) { return Promise.reject(); }\n\n    this.createOrLoad();\n    if (!this.currentDrmInfo_.initData.length &&\n        !this.offlineSessionIds_.length) {\n      // Explicit init data for any one stream or an offline session is\n      // sufficient to suppress 'encrypted' events for all streams.\n      const cb = (e) =>\n          this.newInitData(e.initDataType, new Uint8Array(e.initData));\n      this.eventManager_.listen(this.video_, 'encrypted', cb);\n    }\n  }).catch((error) => {\n    if (this.isDestroying_) { return; }\n    return Promise.reject(error);\n  });\n};\n\n\n/**\n * Sets the server certificate based on the current DrmInfo.\n *\n * @return {!Promise}\n */\nshaka.media.DrmEngine.prototype.setServerCertificate = async function() {\n  goog.asserts.assert(this.initialized_,\n    'Must call init() before setServerCertificate');\n\n  if (this.mediaKeys_ &&\n      this.currentDrmInfo_ &&\n      this.currentDrmInfo_.serverCertificate &&\n      this.currentDrmInfo_.serverCertificate.length) {\n    try {\n      const supported = await this.mediaKeys_.setServerCertificate(\n          this.currentDrmInfo_.serverCertificate);\n      if (!supported) {\n        shaka.log.warning('Server certificates are not supported by the key' +\n                          ' system.  The server certificate has been ignored.');\n      }\n    } catch (exception) {\n      return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.INVALID_SERVER_CERTIFICATE,\n        exception.message));\n    }\n  }\n};\n\n\n/**\n * Remove an offline session and delete it's data. This can only be called\n * after a successful call to |init|. This will wait until the 'license-release'\n * message is handled. The returned Promise will be rejected if there is an\n * error releasing the license.\n *\n * @param {string} sessionId\n * @return {!Promise}\n */\nshaka.media.DrmEngine.prototype.removeSession = async function(sessionId) {\n  goog.asserts.assert(this.mediaKeys_, 'Must call init() before removeSession');\n\n  const session = await this.loadOfflineSession_(sessionId);\n\n  // This will be null on error, such as session not found.\n  if (!session) {\n    shaka.log.v2('Ignoring attempt to remove missing session', sessionId);\n    return;\n  }\n\n  // TODO: Consider adding a timeout to get the 'message' event.\n  // Note that the 'message' event will get raised after the remove()\n  // promise resolves.\n  const tasks = [];\n\n  const found = this.activeSessions_.get(session);\n  if (found) {\n    // This will force us to wait until the 'license-release' message has been\n    // handled.\n    found.updatePromise = new shaka.util.PublicPromise();\n    tasks.push(found.updatePromise);\n  }\n\n  shaka.log.v2('Attempting to remove session', sessionId);\n  tasks.push(session.remove());\n\n  await Promise.all(tasks);\n};\n\n/**\n * Creates the sessions for the init data and waits for them to become ready.\n *\n * @return {!Promise}\n */\nshaka.media.DrmEngine.prototype.createOrLoad = function() {\n  // Create temp sessions.\n  let initDatas = this.currentDrmInfo_ ? this.currentDrmInfo_.initData : [];\n  initDatas.forEach((initDataOverride) => {\n    return this.createTemporarySession_(initDataOverride.initDataType,\n                                        initDataOverride.initData);\n  });\n\n  // Load each session.\n  this.offlineSessionIds_.forEach((sessionId) => {\n    return this.loadOfflineSession_(sessionId);\n  });\n\n  // If we have no sessions, we need to resolve the promise right now or else\n  // it will never get resolved.\n  if (!initDatas.length && !this.offlineSessionIds_.length) {\n    this.allSessionsLoaded_.resolve();\n  }\n\n  return this.allSessionsLoaded_;\n};\n\n\n/**\n * Called when new initialization data is encountered.  If this data hasn't\n * been seen yet, this will create a new session for it.\n *\n * @param {string} initDataType\n * @param {!Uint8Array} initData\n */\nshaka.media.DrmEngine.prototype.newInitData = function(initDataType, initData) {\n  // Aliases:\n  const Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n\n  // Suppress duplicate init data.\n  // Note that some init data are extremely large and can't portably be used as\n  // keys in a dictionary.\n  const metadatas = this.activeSessions_.values();\n  for (const metadata of metadatas) {\n    if (Uint8ArrayUtils.equal(initData, metadata.initData)) {\n      shaka.log.debug('Ignoring duplicate init data.');\n      return;\n    }\n  }\n\n  this.createTemporarySession_(initDataType, initData);\n};\n\n\n/** @return {boolean} */\nshaka.media.DrmEngine.prototype.initialized = function() {\n  return this.initialized_;\n};\n\n\n/** @return {string} */\nshaka.media.DrmEngine.prototype.keySystem = function() {\n  return this.currentDrmInfo_ ? this.currentDrmInfo_.keySystem : '';\n};\n\n\n/**\n * Check if DrmEngine (as initialized) will likely be able to support the given\n * content type.\n *\n * @param {string} contentType\n * @return {boolean}\n */\nshaka.media.DrmEngine.prototype.willSupport = function(contentType) {\n  // Edge 14 does not report correct capabilities.  It will only report the\n  // first MIME type even if the others are supported.  To work around this,\n  // we say that Edge supports everything.\n  //\n  // See: https://bit.ly/2IcEgv0 and Issue #1495\n  if (shaka.util.Platform.isEdge()) {\n    return true;\n  }\n\n  return this.supportedTypes_.has(contentType);\n};\n\n\n/**\n * Returns the ID of the sessions currently active.\n *\n * @return {!Array.<string>}\n */\nshaka.media.DrmEngine.prototype.getSessionIds = function() {\n  const sessions = this.activeSessions_.keys();\n  const ids = shaka.util.Iterables.map(sessions, (s) => s.sessionId);\n\n  // TODO: Make |getSessionIds| return |Iterable| instead of |Array|.\n  return Array.from(ids);\n};\n\n\n/**\n * Returns the next expiration time, or Infinity.\n * @return {number}\n */\nshaka.media.DrmEngine.prototype.getExpiration = function() {\n  // This will equal Infinity if there are no entries.\n  let min = Infinity;\n\n  const sessions = this.activeSessions_.keys();\n  for (const session of sessions) {\n    if (!isNaN(session.expiration)) {\n      min = Math.min(min, session.expiration);\n    }\n  }\n\n  return min;\n};\n\n\n/**\n * Returns the DrmInfo that was used to initialize the current key system.\n *\n * @return {?shaka.extern.DrmInfo}\n */\nshaka.media.DrmEngine.prototype.getDrmInfo = function() {\n  return this.currentDrmInfo_;\n};\n\n\n/**\n * Returns the current key statuses.\n *\n * @return {!Object.<string, string>}\n */\nshaka.media.DrmEngine.prototype.getKeyStatuses = function() {\n  return shaka.util.MapUtils.asObject(this.announcedKeyStatusByKeyId_);\n};\n\n\n/**\n * @param {!Array.<shaka.extern.Variant>} variants\n * @see https://bit.ly/EmeConfig for MediaKeySystemConfiguration spec\n * @return {!Map.<string, MediaKeySystemConfiguration>}\n * @private\n */\nshaka.media.DrmEngine.prototype.prepareMediaKeyConfigsForVariants_ = function(\n    variants) {\n  // Get all the drm info so that we can avoid using nested loops when we just\n  // need the drm info.\n  const allDrmInfo = new Set();\n  for (const variant of variants) {\n    for (const info of variant.drmInfos) {\n      allDrmInfo.add(info);\n    }\n  }\n\n  // Make sure all the drm infos are valid and filled in correctly.\n  for (const info of allDrmInfo) {\n    shaka.media.DrmEngine.fillInDrmInfoDefaults_(\n        info,\n        shaka.util.MapUtils.asMap(this.config_.servers),\n        shaka.util.MapUtils.asMap(this.config_.advanced || {}));\n  }\n\n  const persistentState =\n      this.usePersistentLicenses_ ? 'required' : 'optional';\n  const sessionTypes =\n      this.usePersistentLicenses_ ? ['persistent-license'] : ['temporary'];\n\n  const configs = new Map();\n\n  // Create a config entry for each key system.\n  for (const info of allDrmInfo) {\n    const config = {\n      // Ignore initDataTypes.\n      audioCapabilities: [],\n      videoCapabilities: [],\n      distinctiveIdentifier: 'optional',\n      persistentState: persistentState,\n      sessionTypes: sessionTypes,\n      label: info.keySystem,\n      drmInfos: [],  // Tracked by us, ignored by EME.\n    };\n\n    // Multiple calls to |set| will still respect the insertion order of the\n    // first call to |set| for a given key.\n    configs.set(info.keySystem, config);\n  }\n\n  // Connect each key system with each stream using it.\n  for (const variant of variants) {\n    /** @type {?shaka.extern.Stream} */\n    const audio = variant.audio;\n    /** @type {?shaka.extern.Stream} */\n    const video = variant.video;\n\n    /** @type {string} */\n    const audioMimeType =\n        audio ?\n        shaka.util.MimeUtils.getFullType(audio.mimeType, audio.codecs) :\n        '';\n    /** @type {string} */\n    const videoMimeType =\n        video ?\n        shaka.util.MimeUtils.getFullType(video.mimeType, video.codecs) :\n        '';\n\n    // Add the last bit of information to each config;\n    for (const info of variant.drmInfos) {\n      const config = configs.get(info.keySystem);\n      goog.asserts.assert(\n          config,\n          'Any missing configs should have be filled in before.');\n\n      config.drmInfos.push(info);\n\n      if (info.distinctiveIdentifierRequired) {\n        config.distinctiveIdentifier = 'required';\n      }\n\n      if (info.persistentStateRequired) {\n        config.persistentState = 'required';\n      }\n\n      if (audio) {\n        /** @type {MediaKeySystemMediaCapability} */\n        const capability = {\n          robustness: info.audioRobustness || '',\n          contentType: audioMimeType,\n        };\n\n        config.audioCapabilities.push(capability);\n      }\n\n      if (video) {\n        /** @type {MediaKeySystemMediaCapability} */\n        const capability = {\n          robustness: info.videoRobustness || '',\n          contentType: videoMimeType,\n        };\n\n        config.videoCapabilities.push(capability);\n      }\n    }\n  }\n\n  return configs;\n};\n\n\n/**\n * @param {!Map.<string, MediaKeySystemConfiguration>} configsByKeySystem\n *   A dictionary of configs, indexed by key system, with an iteration order\n *   (insertion order) that reflects the preference for the application.\n * @return {!Promise} Resolved if/when a key system has been chosen.\n * @private\n */\nshaka.media.DrmEngine.prototype.queryMediaKeys_ = function(configsByKeySystem) {\n  if (configsByKeySystem.size == 1 && configsByKeySystem.has('')) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.NO_RECOGNIZED_KEY_SYSTEMS));\n  }\n\n  // If there are no tracks of a type, these should be not present.\n  // Otherwise the query will fail.\n  for (const config of configsByKeySystem.values()) {\n    if (config.audioCapabilities.length == 0) {\n      delete config.audioCapabilities;\n    }\n    if (config.videoCapabilities.length == 0) {\n      delete config.videoCapabilities;\n    }\n  }\n\n  // Wait to reject this initial Promise until we have built the entire chain.\n  let instigator = new shaka.util.PublicPromise();\n  let p = instigator;\n\n  // Try key systems with configured license servers first.  We only have to try\n  // key systems without configured license servers for diagnostic reasons, so\n  // that we can differentiate between \"none of these key systems are available\"\n  // and \"some are available, but you did not configure them properly.\"  The\n  // former takes precedence.\n  [true, false].forEach(function(shouldHaveLicenseServer) {\n    configsByKeySystem.forEach((config, keySystem) => {\n      let hasLicenseServer = config.drmInfos.some(function(info) {\n        return !!info.licenseServerUri;\n      });\n      if (hasLicenseServer != shouldHaveLicenseServer) return;\n\n      p = p.catch(function() {\n        if (this.isDestroying_) { return; }\n        return navigator.requestMediaKeySystemAccess(keySystem, [config]);\n      }.bind(this));\n    });\n  }.bind(this));\n\n  p = p.catch(() => {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE));\n  });\n\n  p = p.then(function(mediaKeySystemAccess) {\n    if (this.isDestroying_) { return Promise.reject(); }\n\n    // Get the set of supported content types from the audio and video\n    // capabilities. Avoid duplicates so that it is easier to read what is\n    // supported.\n    this.supportedTypes_.clear();\n\n    // Store the capabilities of the key system.\n    const realConfig = mediaKeySystemAccess.getConfiguration();\n    const audioCaps = realConfig.audioCapabilities || [];\n    const videoCaps = realConfig.videoCapabilities || [];\n\n    for (const cap of audioCaps) {\n      this.supportedTypes_.add(cap.contentType);\n    }\n\n    for (const cap of videoCaps) {\n      this.supportedTypes_.add(cap.contentType);\n    }\n\n    goog.asserts.assert(this.supportedTypes_.size,\n                        'We should get at least one supported MIME type');\n\n    this.currentDrmInfo_ = shaka.media.DrmEngine.createDrmInfoFor_(\n        mediaKeySystemAccess.keySystem,\n        configsByKeySystem.get(mediaKeySystemAccess.keySystem));\n\n    if (!this.currentDrmInfo_.licenseServerUri) {\n      return Promise.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.NO_LICENSE_SERVER_GIVEN,\n          this.currentDrmInfo_.keySystem));\n    }\n\n    return mediaKeySystemAccess.createMediaKeys();\n  }.bind(this)).then(function(mediaKeys) {\n    if (this.isDestroying_) { return Promise.reject(); }\n    shaka.log.info('Created MediaKeys object for key system',\n                   this.currentDrmInfo_.keySystem);\n\n    this.mediaKeys_ = mediaKeys;\n    this.initialized_ = true;\n  }.bind(this)).catch(function(exception) {\n    if (this.isDestroying_) { return; }\n\n    // Don't rewrap a shaka.util.Error from earlier in the chain:\n    this.currentDrmInfo_ = null;\n    this.supportedTypes_.clear();\n    if (exception instanceof shaka.util.Error) {\n      return Promise.reject(exception);\n    }\n\n    // We failed to create MediaKeys.  This generally shouldn't happen.\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.FAILED_TO_CREATE_CDM,\n        exception.message));\n  }.bind(this));\n\n  instigator.reject();\n  return p;\n};\n\n\n/**\n * Create a DrmInfo using configured clear keys.\n * The server URI will be a data URI which decodes to a clearkey license.\n * @return {?shaka.extern.DrmInfo} or null if clear keys are not configured.\n * @private\n * @see https://bit.ly/2K8gOnv for the spec on the clearkey license format.\n */\nshaka.media.DrmEngine.prototype.configureClearKey_ = function() {\n  const clearKeys = shaka.util.MapUtils.asMap(this.config_.clearKeys);\n  if (clearKeys.size == 0) { return null; }\n\n  const StringUtils = shaka.util.StringUtils;\n  const Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n  let keys = [];\n  let keyIds = [];\n\n  clearKeys.forEach((keyHex, keyIdHex) => {\n    let keyId = Uint8ArrayUtils.fromHex(keyIdHex);\n    let key = Uint8ArrayUtils.fromHex(keyHex);\n    let keyObj = {\n      kty: 'oct',\n      kid: Uint8ArrayUtils.toBase64(keyId, false),\n      k: Uint8ArrayUtils.toBase64(key, false),\n    };\n\n    keys.push(keyObj);\n    keyIds.push(keyObj.kid);\n  });\n\n  let jwkSet = {keys: keys};\n  let license = JSON.stringify(jwkSet);\n\n  // Use the keyids init data since is suggested by EME.\n  // Suggestion: https://bit.ly/2JYcNTu\n  // Format: https://www.w3.org/TR/eme-initdata-keyids/\n  let initDataStr = JSON.stringify({'kids': keyIds});\n  let initData = new Uint8Array(StringUtils.toUTF8(initDataStr));\n  let initDatas = [{initData: initData, initDataType: 'keyids'}];\n\n  return {\n    keySystem: 'org.w3.clearkey',\n    licenseServerUri: 'data:application/json;base64,' + window.btoa(license),\n    distinctiveIdentifierRequired: false,\n    persistentStateRequired: false,\n    audioRobustness: '',\n    videoRobustness: '',\n    serverCertificate: null,\n    initData: initDatas,\n    keyIds: [],\n  };\n};\n\n\n/**\n * @param {string} sessionId\n * @return {!Promise.<MediaKeySession>}\n * @private\n */\nshaka.media.DrmEngine.prototype.loadOfflineSession_ = function(sessionId) {\n  let session;\n  try {\n    shaka.log.v1('Attempting to load an offline session', sessionId);\n    session = this.mediaKeys_.createSession('persistent-license');\n  } catch (exception) {\n    let error = new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.FAILED_TO_CREATE_SESSION,\n        exception.message);\n    this.onError_(error);\n    return Promise.reject(error);\n  }\n\n  this.eventManager_.listen(session, 'message',\n      /** @type {shaka.util.EventManager.ListenerType} */(\n          this.onSessionMessage_.bind(this)));\n  this.eventManager_.listen(session, 'keystatuseschange',\n      this.onKeyStatusesChange_.bind(this));\n\n  const metadata = {\n    initData: null,\n    loaded: false,\n    oldExpiration: Infinity,\n    updatePromise: null,\n  };\n  this.activeSessions_.set(session, metadata);\n\n  return session.load(sessionId).then(function(present) {\n    if (this.isDestroying_) { return Promise.reject(); }\n    shaka.log.v2('Loaded offline session', sessionId, present);\n\n    if (!present) {\n      this.activeSessions_.delete(session);\n\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.OFFLINE_SESSION_REMOVED));\n      return;\n    }\n\n    // TODO: We should get a key status change event.  Remove once Chrome CDM\n    // is fixed.\n    metadata.loaded = true;\n    if (this.areAllSessionsLoaded_()) {\n      this.allSessionsLoaded_.resolve();\n    }\n\n    return session;\n  }.bind(this), function(error) {\n    if (this.isDestroying_) { return; }\n\n    this.activeSessions_.delete(session);\n\n    this.onError_(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.FAILED_TO_CREATE_SESSION,\n        error.message));\n  }.bind(this));\n};\n\n\n/**\n * @param {string} initDataType\n * @param {!Uint8Array} initData\n * @private\n */\nshaka.media.DrmEngine.prototype.createTemporarySession_ =\n    function(initDataType, initData) {\n  let session;\n  try {\n    if (this.usePersistentLicenses_) {\n      shaka.log.v1('Creating new persistent session');\n      session = this.mediaKeys_.createSession('persistent-license');\n    } else {\n      shaka.log.v1('Creating new temporary session');\n      session = this.mediaKeys_.createSession();\n    }\n  } catch (exception) {\n    this.onError_(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.FAILED_TO_CREATE_SESSION,\n        exception.message));\n    return;\n  }\n\n  this.eventManager_.listen(session, 'message',\n      /** @type {shaka.util.EventManager.ListenerType} */(\n          this.onSessionMessage_.bind(this)));\n  this.eventManager_.listen(session, 'keystatuseschange',\n      this.onKeyStatusesChange_.bind(this));\n\n  const metadata = {\n    initData: initData,\n    loaded: false,\n    oldExpiration: Infinity,\n    updatePromise: null,\n  };\n  this.activeSessions_.set(session, metadata);\n\n  session.generateRequest(initDataType, initData.buffer).catch((error) => {\n    if (this.isDestroying_) { return; }\n\n    this.activeSessions_.delete(session);\n\n    let extended;\n    if (error.errorCode && error.errorCode.systemCode) {\n      extended = error.errorCode.systemCode;\n      if (extended < 0) {\n        extended += Math.pow(2, 32);\n      }\n      extended = '0x' + extended.toString(16);\n    }\n\n    this.onError_(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.FAILED_TO_GENERATE_LICENSE_REQUEST,\n        error.message, error, extended));\n  });\n};\n\n\n/**\n * @param {!MediaKeyMessageEvent} event\n * @private\n */\nshaka.media.DrmEngine.prototype.onSessionMessage_ = function(event) {\n  if (this.delayLicenseRequest_()) {\n    this.mediaKeyMessageEvents_.push(event);\n  } else {\n    this.sendLicenseRequest_(event);\n  }\n};\n\n\n/**\n * @return {boolean}\n * @private\n */\nshaka.media.DrmEngine.prototype.delayLicenseRequest_ = function() {\n  return (this.config_.delayLicenseRequestUntilPlayed &&\n          this.video_.paused && !this.initialRequestsSent_);\n};\n\n\n/**\n * Sends a license request.\n * @param {!MediaKeyMessageEvent} event\n * @private\n */\nshaka.media.DrmEngine.prototype.sendLicenseRequest_ = function(event) {\n  /** @type {!MediaKeySession} */\n  let session = event.target;\n  shaka.log.v2('Sending license request for session', session.sessionId);\n\n  const metadata = this.activeSessions_.get(session);\n\n  let url = this.currentDrmInfo_.licenseServerUri;\n  const advancedConfig = this.config_.advanced[this.currentDrmInfo_.keySystem];\n  if (event.messageType == 'individualization-request' && advancedConfig &&\n      advancedConfig.individualizationServer) {\n    url = advancedConfig.individualizationServer;\n  }\n\n  const requestType = shaka.net.NetworkingEngine.RequestType.LICENSE;\n  let request = shaka.net.NetworkingEngine.makeRequest(\n      [url], this.config_.retryParameters);\n  request.body = event.message;\n  request.method = 'POST';\n  request.licenseRequestType = event.messageType;\n  // NOTE: allowCrossSiteCredentials can be set in a request filter.\n\n  if (this.currentDrmInfo_.keySystem == 'com.microsoft.playready' ||\n      this.currentDrmInfo_.keySystem == 'com.chromecast.playready') {\n    this.unpackPlayReadyRequest_(request);\n  }\n  if (this.currentDrmInfo_.keySystem.startsWith('com.apple.fps')) {\n    this.formatFairPlayRequest_(request);\n  }\n\n  this.playerInterface_.netEngine.request(requestType, request).promise\n      .then(function(response) {\n        if (this.isDestroying_) { return Promise.reject(); }\n\n        if (this.currentDrmInfo_.keySystem.startsWith('com.apple.fps')) {\n          this.parseFairPlayResponse_(response);\n        }\n\n        // Request succeeded, now pass the response to the CDM.\n        return session.update(response.data).then(function() {\n          let event = new shaka.util.FakeEvent('drmsessionupdate');\n          this.playerInterface_.onEvent(event);\n\n          if (metadata) {\n            if (metadata.updatePromise) {\n              metadata.updatePromise.resolve();\n            }\n            // In case there are no key statuses, consider this session loaded\n            // after a reasonable timeout.  It should definitely not take 5\n            // seconds to process a license.\n            const timer = new shaka.util.Timer(() => {\n              metadata.loaded = true;\n              if (this.areAllSessionsLoaded_()) {\n                this.allSessionsLoaded_.resolve();\n              }\n            });\n\n            timer.tickAfter(\n                /* seconds= */ shaka.media.DrmEngine.SESSION_LOAD_TIMEOUT_);\n          }\n        }.bind(this));\n      }.bind(this), function(error) {\n        // Ignore destruction errors\n        if (this.isDestroying_) { return; }\n\n        // Request failed!\n        goog.asserts.assert(error instanceof shaka.util.Error,\n                            'Wrong NetworkingEngine error type!');\n        let shakaErr = new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.LICENSE_REQUEST_FAILED,\n            error);\n        this.onError_(shakaErr);\n        if (metadata && metadata.updatePromise) {\n          metadata.updatePromise.reject(shakaErr);\n        }\n      }.bind(this)).catch(function(error) {\n        // Ignore destruction errors\n        if (this.isDestroying_) { return; }\n\n        // Session update failed!\n        let shakaErr = new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.LICENSE_RESPONSE_REJECTED,\n            error.message);\n        this.onError_(shakaErr);\n        if (metadata && metadata.updatePromise) {\n          metadata.updatePromise.reject(shakaErr);\n        }\n      }.bind(this));\n};\n\n\n/**\n * Unpacks PlayReady license requests.  Modifies the request object.\n * @param {shaka.extern.Request} request\n * @private\n */\nshaka.media.DrmEngine.prototype.unpackPlayReadyRequest_ = function(request) {\n  // On IE and Edge, the raw license message is UTF-16-encoded XML.  We need to\n  // unpack the Challenge element (base64-encoded string containing the actual\n  // license request) and any HttpHeader elements (sent as request headers).\n\n  // Example XML:\n\n  // <PlayReadyKeyMessage type=\"LicenseAcquisition\">\n  //   <LicenseAcquisition Version=\"1\">\n  //     <Challenge encoding=\"base64encoded\">{Base64Data}</Challenge>\n  //     <HttpHeaders>\n  //       <HttpHeader>\n  //         <name>Content-Type</name>\n  //         <value>text/xml; charset=utf-8</value>\n  //       </HttpHeader>\n  //       <HttpHeader>\n  //         <name>SOAPAction</name>\n  //         <value>http://schemas.microsoft.com/DRM/etc/etc</value>\n  //       </HttpHeader>\n  //     </HttpHeaders>\n  //   </LicenseAcquisition>\n  // </PlayReadyKeyMessage>\n\n  let xml = shaka.util.StringUtils.fromUTF16(\n      request.body, true /* littleEndian */, true /* noThrow */);\n  if (!xml.includes('PlayReadyKeyMessage')) {\n    // This does not appear to be a wrapped message as on IE and Edge.  Some\n    // clients do not need this unwrapping, so we will assume this is one of\n    // them.  Note that \"xml\" at this point probably looks like random garbage,\n    // since we interpreted UTF-8 as UTF-16.\n    shaka.log.debug('PlayReady request is already unwrapped.');\n    request.headers['Content-Type'] = 'text/xml; charset=utf-8';\n    return;\n  }\n  shaka.log.debug('Unwrapping PlayReady request.');\n  let dom = new DOMParser().parseFromString(xml, 'application/xml');\n\n  // Set request headers.\n  let headers = dom.getElementsByTagName('HttpHeader');\n  for (let i = 0; i < headers.length; ++i) {\n    let name = headers[i].querySelector('name');\n    let value = headers[i].querySelector('value');\n    goog.asserts.assert(name && value, 'Malformed PlayReady headers!');\n    request.headers[name.textContent] = value.textContent;\n  }\n\n  // Unpack the base64-encoded challenge.\n  let challenge = dom.querySelector('Challenge');\n  goog.asserts.assert(challenge, 'Malformed PlayReady challenge!');\n  goog.asserts.assert(challenge.getAttribute('encoding') == 'base64encoded',\n                      'Unexpected PlayReady challenge encoding!');\n  request.body =\n      shaka.util.Uint8ArrayUtils.fromBase64(challenge.textContent).buffer;\n};\n\n\n/**\n * Formats FairPlay license requests.  Modifies the request object.\n *\n * @param {shaka.extern.Request} request\n * @private\n */\nshaka.media.DrmEngine.prototype.formatFairPlayRequest_ = function(request) {\n  // The standard format for FairPlay seems to be to place the request into a\n  // POST parameter (spc=).\n  const originalPayload = new Uint8Array(request.body);\n  const base64Payload = shaka.util.Uint8ArrayUtils.toBase64(originalPayload);\n  const params = 'spc=' + base64Payload;\n  request.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n  request.body = shaka.util.StringUtils.toUTF8(params);\n};\n\n\n/**\n * Parse FairPlay license response format.  Modifies the response object.\n * This will run after any response filters, so application-specific formats\n * can still be handled by the app.\n *\n * @param {shaka.extern.Response} response\n * @private\n */\nshaka.media.DrmEngine.prototype.parseFairPlayResponse_ = function(response) {\n  // In Apple's docs, responses can be of the form:\n  //   '\\n<ckc>base64encoded</ckc>\\n' or 'base64encoded'\n  // We have also seen responses in JSON format from some of our partners.\n  // In all of these text-based formats, the CKC data is base64-encoded.\n\n  // This handles all of the above.  Other formats should be handled via\n  // application-level response filters.\n\n  let responseText;\n  try {\n    // Convert it to text for further processing.\n    responseText = shaka.util.StringUtils.fromUTF8(response.data);\n  } catch (error) {\n    // Assume it's not a text format of any kind and leave it alone.\n    return;\n  }\n\n  // Trim whitespace.\n  responseText = responseText.trim();\n\n  // Look for <ckc> wrapper and remove it.\n  if (responseText.substr(0, 5) === '<ckc>' &&\n      responseText.substr(-6) === '</ckc>') {\n    responseText = responseText.slice(5, -6);\n  }\n\n  // Look for a JSON wrapper and remove it.\n  try {\n    const responseObject = JSON.parse(responseText);\n    responseText = responseObject['ckc'];\n  } catch (error) {\n    // It wasn't JSON.  Fall through with other transformations.\n  }\n\n  // Decode the base64-encoded data into the format the browser expects.\n  // It's not clear why FairPlay license servers don't just serve this directly.\n  response.data = shaka.util.Uint8ArrayUtils.fromBase64(responseText).buffer;\n};\n\n\n/**\n * @param {!Event} event\n * @private\n * @suppress {invalidCasts} to swap keyId and status\n */\nshaka.media.DrmEngine.prototype.onKeyStatusesChange_ = function(event) {\n  const session = /** @type {!MediaKeySession} */(event.target);\n  shaka.log.v2('Key status changed for session', session.sessionId);\n\n  const found = this.activeSessions_.get(session);\n  let keyStatusMap = session.keyStatuses;\n  let hasExpiredKeys = false;\n\n  keyStatusMap.forEach(function(status, keyId) {\n    // The spec has changed a few times on the exact order of arguments here.\n    // As of 2016-06-30, Edge has the order reversed compared to the current\n    // EME spec.  Given the back and forth in the spec, it may not be the only\n    // one.  Try to detect this and compensate:\n    if (typeof keyId == 'string') {\n      let tmp = keyId;\n      keyId = /** @type {ArrayBuffer} */(status);\n      status = /** @type {string} */(tmp);\n    }\n\n    // Microsoft's implementation in Edge seems to present key IDs as\n    // little-endian UUIDs, rather than big-endian or just plain array of bytes.\n    // standard: 6e 5a 1d 26 - 27 57 - 47 d7 - 80 46 ea a5 d1 d3 4b 5a\n    // on Edge:  26 1d 5a 6e - 57 27 - d7 47 - 80 46 ea a5 d1 d3 4b 5a\n    // Bug filed: https://bit.ly/2thuzXu\n\n    // NOTE that we skip this if byteLength != 16.  This is used for the IE11\n    // and Edge 12 EME polyfill, which uses single-byte dummy key IDs.\n    // However, unlike Edge and Chromecast, Tizen doesn't have this problem.\n    if (this.currentDrmInfo_.keySystem == 'com.microsoft.playready' &&\n        keyId.byteLength == 16 &&\n        !shaka.util.Platform.isTizen()) {\n      // Read out some fields in little-endian:\n      let dataView = new DataView(keyId);\n      let part0 = dataView.getUint32(0, true /* LE */);\n      let part1 = dataView.getUint16(4, true /* LE */);\n      let part2 = dataView.getUint16(6, true /* LE */);\n      // Write it back in big-endian:\n      dataView.setUint32(0, part0, false /* BE */);\n      dataView.setUint16(4, part1, false /* BE */);\n      dataView.setUint16(6, part2, false /* BE */);\n    }\n\n    // Microsoft's implementation in IE11 seems to never set key status to\n    // 'usable'.  It is stuck forever at 'status-pending'.  In spite of this,\n    // the keys do seem to be usable and content plays correctly.\n    // Bug filed: https://bit.ly/2tpIU3n\n    // Microsoft has fixed the issue on Edge, but it remains in IE.\n    if (this.currentDrmInfo_.keySystem == 'com.microsoft.playready' &&\n        status == 'status-pending') {\n      status = 'usable';\n    }\n\n    if (status != 'status-pending') {\n      found.loaded = true;\n    }\n\n    if (!found) {\n      // We can get a key status changed for a closed session after it has been\n      // removed from |activeSessions_|.  If it is closed, none of its keys\n      // should be usable.\n      goog.asserts.assert(\n          status != 'usable', 'Usable keys found in closed session');\n    }\n\n    if (status == 'expired') {\n      hasExpiredKeys = true;\n    }\n\n    let keyIdHex = shaka.util.Uint8ArrayUtils.toHex(new Uint8Array(keyId));\n\n    this.keyStatusByKeyId_.set(keyIdHex, status);\n  }.bind(this));\n\n  // If the session has expired, close it.\n  // Some CDMs do not have sub-second time resolution, so the key status may\n  // fire with hundreds of milliseconds left until the stated expiration time.\n  let msUntilExpiration = session.expiration - Date.now();\n  if (msUntilExpiration < 0 || (hasExpiredKeys && msUntilExpiration < 1000)) {\n    // If this is part of a remove(), we don't want to close the session until\n    // the update is complete.  Otherwise, we will orphan the session.\n    if (found && !found.updatePromise) {\n      shaka.log.debug('Session has expired', session.sessionId);\n      this.activeSessions_.delete(session);\n      session.close().catch(() => {});  // Silence uncaught rejection errors\n    }\n  }\n\n  if (!this.areAllSessionsLoaded_()) {\n    // Don't announce key statuses or resolve the \"all loaded\" promise until\n    // everything is loaded.\n    return;\n  }\n\n  this.allSessionsLoaded_.resolve();\n\n  // Batch up key status changes before checking them or notifying Player.\n  // This handles cases where the statuses of multiple sessions are set\n  // simultaneously by the browser before dispatching key status changes for\n  // each of them.  By batching these up, we only send one status change event\n  // and at most one EXPIRED error on expiration.\n  this.keyStatusTimer_.tickAfter(\n      /* seconds= */ shaka.media.DrmEngine.KEY_STATUS_BATCH_TIME_);\n};\n\n\n/**\n * @private\n */\nshaka.media.DrmEngine.prototype.processKeyStatusChanges_ = function() {\n  const privateMap = this.keyStatusByKeyId_;\n  const publicMap = this.announcedKeyStatusByKeyId_;\n\n  // Copy the latest key statuses into the publicly-accessible map.\n  publicMap.clear();\n  privateMap.forEach((status, keyId) => publicMap.set(keyId, status));\n\n  // If all keys are expired, fire an error. |every| is always true for an empty\n  // array but we shouldn't fire an error for a lack of key status info.\n  const statuses = Array.from(publicMap.values());\n  const allExpired = statuses.length &&\n                     statuses.every((status) => status == 'expired');\n\n  if (allExpired) {\n    this.onError_(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.EXPIRED));\n  }\n\n  this.playerInterface_.onKeyStatus(shaka.util.MapUtils.asObject(publicMap));\n};\n\n\n/**\n * Returns true if the browser has recent EME APIs.\n *\n * @return {boolean}\n */\nshaka.media.DrmEngine.isBrowserSupported = function() {\n  let basic =\n      !!window.MediaKeys &&\n      !!window.navigator &&\n      !!window.navigator.requestMediaKeySystemAccess &&\n      !!window.MediaKeySystemAccess &&\n      !!window.MediaKeySystemAccess.prototype.getConfiguration;\n\n  return basic;\n};\n\n\n/**\n * Returns a Promise to a map of EME support for well-known key systems.\n *\n * @return {!Promise.<!Object.<string, ?shaka.extern.DrmSupportType>>}\n */\nshaka.media.DrmEngine.probeSupport = function() {\n  goog.asserts.assert(shaka.media.DrmEngine.isBrowserSupported(),\n                      'Must have basic EME support');\n\n  let testKeySystems = [\n    'org.w3.clearkey',\n    'com.widevine.alpha',\n    'com.microsoft.playready',\n    'com.apple.fps.3_0',\n    'com.apple.fps.2_0',\n    'com.apple.fps.1_0',\n    'com.apple.fps',\n    'com.adobe.primetime',\n  ];\n\n  let basicVideoCapabilities = [\n    {contentType: 'video/mp4; codecs=\"avc1.42E01E\"'},\n    {contentType: 'video/webm; codecs=\"vp8\"'},\n  ];\n\n  let basicConfig = {\n    videoCapabilities: basicVideoCapabilities,\n  };\n  let offlineConfig = {\n    videoCapabilities: basicVideoCapabilities,\n    persistentState: 'required',\n    sessionTypes: ['persistent-license'],\n  };\n\n  // Try the offline config first, then fall back to the basic config.\n  const configs = [offlineConfig, basicConfig];\n\n  /** @type {!Map.<string, ?shaka.extern.DrmSupportType>} */\n  const support = new Map();\n\n  const testSystem = async (keySystem) => {\n    try {\n      const access = await navigator.requestMediaKeySystemAccess(\n          keySystem, configs);\n\n      // Edge doesn't return supported session types, but current versions\n      // do not support persistent-license.  If sessionTypes is missing,\n      // assume no support for persistent-license.\n      // TODO: Polyfill Edge to return known supported session types.\n      // Edge bug: https://bit.ly/2IeKzho\n      let sessionTypes = access.getConfiguration().sessionTypes;\n      let persistentState = sessionTypes ?\n          sessionTypes.includes('persistent-license') : false;\n\n      // Tizen 3.0 doesn't support persistent licenses, but reports that it\n      // does.  It doesn't fail until you call update() with a license\n      // response, which is way too late.\n      // This is a work-around for #894.\n      if (shaka.util.Platform.isTizen3()) {\n        persistentState = false;\n      }\n\n      support.set(keySystem, {persistentState: persistentState});\n      await access.createMediaKeys();\n    } catch (e) {\n      // Either the request failed or createMediaKeys failed.\n      // Either way, write null to the support object.\n      support.set(keySystem, null);\n    }\n  };\n\n  // Test each key system.\n  const tests = testKeySystems.map((keySystem) => testSystem(keySystem));\n  return Promise.all(tests).then(() => shaka.util.MapUtils.asObject(support));\n};\n\n\n/**\n * @private\n */\nshaka.media.DrmEngine.prototype.onPlay_ = function() {\n  for (let i = 0; i < this.mediaKeyMessageEvents_.length; i++) {\n    this.sendLicenseRequest_(this.mediaKeyMessageEvents_[i]);\n  }\n\n  this.initialRequestsSent_ = true;\n  this.mediaKeyMessageEvents_ = [];\n};\n\n\n/**\n * Check if a variant is likely to be supported by DrmEngine. This will err on\n * the side of being too accepting and may not reject a variant that it will\n * later fail to play.\n *\n * @param {!shaka.extern.Variant} variant\n * @return {boolean}\n **/\nshaka.media.DrmEngine.prototype.supportsVariant = function(variant) {\n  /** @type {?shaka.extern.Stream} */\n  const audio = variant.audio;\n  /** @type {?shaka.extern.Stream} */\n  const video = variant.video;\n\n  if (audio && audio.encrypted) {\n    const audioContentType = shaka.util.MimeUtils.getFullType(\n        audio.mimeType, audio.codecs);\n\n    if (!this.willSupport(audioContentType)) { return false; }\n  }\n\n  if (video && video.encrypted) {\n    const videoContentType = shaka.util.MimeUtils.getFullType(\n        video.mimeType, video.codecs);\n\n    if (!this.willSupport(videoContentType)) { return false; }\n  }\n\n  const keySystem = this.keySystem();\n  return variant.drmInfos.length == 0 ||\n      variant.drmInfos.some((drmInfo) => drmInfo.keySystem == keySystem);\n};\n\n\n/**\n * Checks if two DrmInfos can be decrypted using the same key system.\n * Clear content is considered compatible with every key system.\n *\n * @param {!Array.<!shaka.extern.DrmInfo>} drms1\n * @param {!Array.<!shaka.extern.DrmInfo>} drms2\n * @return {boolean}\n */\nshaka.media.DrmEngine.areDrmCompatible = function(drms1, drms2) {\n  if (!drms1.length || !drms2.length) return true;\n\n  return shaka.media.DrmEngine.getCommonDrmInfos(\n      drms1, drms2).length > 0;\n};\n\n\n/**\n * Returns an array of drm infos that are present in both input arrays.\n * If one of the arrays is empty, returns the other one since clear\n * content is considered compatible with every drm info.\n *\n * @param {!Array.<!shaka.extern.DrmInfo>} drms1\n * @param {!Array.<!shaka.extern.DrmInfo>} drms2\n * @return {!Array.<!shaka.extern.DrmInfo>}\n */\nshaka.media.DrmEngine.getCommonDrmInfos = function(drms1, drms2) {\n  if (!drms1.length) return drms2;\n  if (!drms2.length) return drms1;\n\n  let commonDrms = [];\n\n  for (let i = 0; i < drms1.length; i++) {\n    for (let j = 0; j < drms2.length; j++) {\n      // This method is only called to compare drmInfos of a video and an audio\n      // adaptations, so we shouldn't have to worry about checking robustness.\n      if (drms1[i].keySystem == drms2[j].keySystem) {\n        let drm1 = drms1[i];\n        let drm2 = drms2[j];\n        let initData = [];\n        initData = initData.concat(drm1.initData || []);\n        initData = initData.concat(drm2.initData || []);\n        let keyIds = [];\n        keyIds = keyIds.concat(drm1.keyIds);\n        keyIds = keyIds.concat(drm2.keyIds);\n        let mergedDrm = {\n          keySystem: drm1.keySystem,\n          licenseServerUri: drm1.licenseServerUri || drm2.licenseServerUri,\n          distinctiveIdentifierRequired: drm1.distinctiveIdentifierRequired ||\n              drm2.distinctiveIdentifierRequired,\n          persistentStateRequired: drm1.persistentStateRequired ||\n              drm2.persistentStateRequired,\n          videoRobustness: drm1.videoRobustness || drm2.videoRobustness,\n          audioRobustness: drm1.audioRobustness || drm2.audioRobustness,\n          serverCertificate: drm1.serverCertificate || drm2.serverCertificate,\n          initData: initData,\n          keyIds: keyIds,\n        };\n        commonDrms.push(mergedDrm);\n        break;\n      }\n    }\n  }\n\n  return commonDrms;\n};\n\n\n/**\n * Called in an interval timer to poll the expiration times of the sessions.  We\n * don't get an event from EME when the expiration updates, so we poll it so we\n * can fire an event when it happens.\n * @private\n */\nshaka.media.DrmEngine.prototype.pollExpiration_ = function() {\n  this.activeSessions_.forEach((metadata, session) => {\n    let oldTime = metadata.oldExpiration;\n    let newTime = session.expiration;\n    if (isNaN(newTime)) {\n      newTime = Infinity;\n    }\n\n    if (newTime != oldTime) {\n      this.playerInterface_.onExpirationUpdated(session.sessionId, newTime);\n      metadata.oldExpiration = newTime;\n    }\n  });\n};\n\n\n/**\n * @return {boolean}\n * @private\n */\nshaka.media.DrmEngine.prototype.areAllSessionsLoaded_ = function() {\n  const metadatas = this.activeSessions_.values();\n  return shaka.util.Iterables.every(metadatas, (data) => data.loaded);\n};\n\n\n/**\n * Replace the drm info used in each variant in |variants| to reflect each\n * key service in |keySystems|.\n *\n * @param {!Array.<shaka.extern.Variant>} variants\n * @param {!Map.<string, string>} keySystems\n * @private\n */\nshaka.media.DrmEngine.replaceDrmInfo_ = function(variants, keySystems) {\n  const drmInfos = [];\n\n  keySystems.forEach((uri, keySystem) => {\n    drmInfos.push({\n      keySystem: keySystem,\n      licenseServerUri: uri,\n      distinctiveIdentifierRequired: false,\n      persistentStateRequired: false,\n      audioRobustness: '',\n      videoRobustness: '',\n      serverCertificate: null,\n      initData: [],\n      keyIds: [],\n    });\n  });\n\n  for (const variant of variants) {\n    variant.drmInfos = drmInfos;\n  }\n};\n\n\n/**\n * Creates a DrmInfo object describing the settings used to initialize the\n * engine.\n *\n * @param {string} keySystem\n * @param {MediaKeySystemConfiguration} config\n * @return {shaka.extern.DrmInfo}\n *\n * @private\n */\nshaka.media.DrmEngine.createDrmInfoFor_ = function(keySystem, config) {\n  /** @type {!Array.<string>} */\n  let licenseServers = [];\n\n  /** @type {!Array.<!Uint8Array>} */\n  let serverCerts = [];\n\n  /** @type {!Array.<!shaka.extern.InitDataOverride>} */\n  let initDatas = [];\n\n  /** @type {!Array.<string>} */\n  let keyIds = [];\n\n  shaka.media.DrmEngine.processDrmInfos_(\n      config.drmInfos, licenseServers, serverCerts, initDatas, keyIds);\n\n  if (serverCerts.length > 1) {\n    shaka.log.warning('Multiple unique server certificates found! ' +\n                      'Only the first will be used.');\n  }\n\n  if (licenseServers.length > 1) {\n    shaka.log.warning('Multiple unique license server URIs found! ' +\n                      'Only the first will be used.');\n  }\n\n  // TODO: This only works when all DrmInfo have the same robustness.\n  let audioRobustness =\n      config.audioCapabilities ? config.audioCapabilities[0].robustness : '';\n  let videoRobustness =\n      config.videoCapabilities ? config.videoCapabilities[0].robustness : '';\n\n  return {\n    keySystem: keySystem,\n    licenseServerUri: licenseServers[0],\n    distinctiveIdentifierRequired: (config.distinctiveIdentifier == 'required'),\n    persistentStateRequired: (config.persistentState == 'required'),\n    audioRobustness: audioRobustness,\n    videoRobustness: videoRobustness,\n    serverCertificate: serverCerts[0],\n    initData: initDatas,\n    keyIds: keyIds,\n  };\n};\n\n\n/**\n * Extract license server, server cert, and init data from |drmInfos|, taking\n * care to eliminate duplicates.\n *\n * @param {!Array.<shaka.extern.DrmInfo>} drmInfos\n * @param {!Array.<string>} licenseServers\n * @param {!Array.<!Uint8Array>} serverCerts\n * @param {!Array.<!shaka.extern.InitDataOverride>} initDatas\n * @param {!Array.<string>} keyIds\n * @private\n */\nshaka.media.DrmEngine.processDrmInfos_ =\n    function(drmInfos, licenseServers, serverCerts, initDatas, keyIds) {\n  /** @type {function(shaka.extern.InitDataOverride,\n   *                  shaka.extern.InitDataOverride):boolean} */\n  let initDataOverrideEqual = (a, b) => {\n    if (a.keyId && a.keyId == b.keyId) {\n      // Two initDatas with the same keyId are considered to be the same,\n      // unless that \"same keyId\" is null.\n      return true;\n    }\n    return a.initDataType == b.initDataType &&\n           shaka.util.Uint8ArrayUtils.equal(a.initData, b.initData);\n  };\n\n  drmInfos.forEach((drmInfo) => {\n    // Aliases:\n    const Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n\n    // Build an array of unique license servers.\n    if (!licenseServers.includes(drmInfo.licenseServerUri)) {\n      licenseServers.push(drmInfo.licenseServerUri);\n    }\n\n    // Build an array of unique server certs.\n    if (drmInfo.serverCertificate) {\n      const found = serverCerts.some(\n          (cert) => Uint8ArrayUtils.equal(cert, drmInfo.serverCertificate));\n      if (!found) {\n        serverCerts.push(drmInfo.serverCertificate);\n      }\n    }\n\n    // Build an array of unique init datas.\n    if (drmInfo.initData) {\n      drmInfo.initData.forEach((initDataOverride) => {\n        const found = initDatas.some(\n            (initData) => initDataOverrideEqual(initData, initDataOverride));\n        if (!found) {\n          initDatas.push(initDataOverride);\n        }\n      });\n    }\n\n    if (drmInfo.keyIds) {\n      for (let i = 0; i < drmInfo.keyIds.length; ++i) {\n        if (!keyIds.includes(drmInfo.keyIds[i])) {\n          keyIds.push(drmInfo.keyIds[i]);\n        }\n      }\n    }\n  });\n};\n\n\n/**\n * Use |servers| and |advancedConfigs| to fill in missing values in drmInfo that\n * the parser left blank. Before working with any drmInfo, it should be passed\n * through here as it is uncommon for drmInfo to be complete when fetched\n * from a manifest because most manifest formats do not have the required\n * information.\n *\n * @param {shaka.extern.DrmInfo} drmInfo\n * @param {!Map.<string, string>} servers\n * @param {!Map.<string, shaka.extern.AdvancedDrmConfiguration>} advancedConfigs\n * @private\n */\nshaka.media.DrmEngine.fillInDrmInfoDefaults_ = function(\n    drmInfo, servers, advancedConfigs) {\n  if (!drmInfo.keySystem) {\n    // This is a placeholder from the manifest parser for an unrecognized key\n    // system.  Skip this entry, to avoid logging nonsensical errors.\n    return;\n  }\n\n  // The order of preference for drmInfo:\n  // 1. Clear Key config, used for debugging, should override everything else.\n  //    (The application can still specify a clearkey license server.)\n  // 2. Application-configured servers, if any are present, should override\n  //    anything from the manifest.  Nuance: if key system A is in the manifest\n  //    and key system B is in the player config, only B will be used, not A.\n  // 3. Manifest-provided license servers are only used if nothing else is\n  //    specified.\n  // This is important because it allows the application a clear way to indicate\n  // which DRM systems should be used on platforms with multiple DRM systems.\n  // The only way to get license servers from the manifest is not to specify any\n  // in your player config.\n\n  if (drmInfo.keySystem == 'org.w3.clearkey' && drmInfo.licenseServerUri) {\n    // Preference 1: Clear Key with pre-configured keys will have a data URI\n    // assigned as its license server.  Don't change anything.\n    return;\n  } else if (servers.size) {\n    // Preference 2: If anything is configured at the application level,\n    // override whatever was in the manifest.\n    const server = servers.get(drmInfo.keySystem) || '';\n    drmInfo.licenseServerUri = server;\n  } else {\n    // Preference 3: Keep whatever we had in drmInfo.licenseServerUri, which\n    // comes from the manifest.\n  }\n\n  if (!drmInfo.keyIds) {\n    drmInfo.keyIds = [];\n  }\n\n  const advancedConfig = advancedConfigs.get(drmInfo.keySystem);\n  if (advancedConfig) {\n    if (!drmInfo.distinctiveIdentifierRequired) {\n      drmInfo.distinctiveIdentifierRequired =\n          advancedConfig.distinctiveIdentifierRequired;\n    }\n\n    if (!drmInfo.persistentStateRequired) {\n      drmInfo.persistentStateRequired = advancedConfig.persistentStateRequired;\n    }\n\n    if (!drmInfo.videoRobustness) {\n      drmInfo.videoRobustness = advancedConfig.videoRobustness;\n    }\n\n    if (!drmInfo.audioRobustness) {\n      drmInfo.audioRobustness = advancedConfig.audioRobustness;\n    }\n\n    if (!drmInfo.serverCertificate) {\n      drmInfo.serverCertificate = advancedConfig.serverCertificate;\n    }\n  }\n\n  // Chromecast has a variant of PlayReady that uses a different key\n  // system ID.  Since manifest parsers convert the standard PlayReady\n  // UUID to the standard PlayReady key system ID, here we will switch\n  // to the Chromecast version if we are running on that platform.\n  // Note that this must come after fillInDrmInfoDefaults_, since the\n  // player config uses the standard PlayReady ID for license server\n  // configuration.\n  if (window.cast && window.cast.__platform__) {\n    if (drmInfo.keySystem == 'com.microsoft.playready') {\n      drmInfo.keySystem = 'com.chromecast.playready';\n    }\n  }\n};\n\n\n/**\n * Close a drm session while accounting for a bug in Chrome. Sometimes the\n * Promise returned by close() never resolves.\n *\n * See issue #1093 and https://crbug.com/690583.\n *\n * @param {!MediaKeySession} session\n * @return {!Promise}\n * @private\n */\nshaka.media.DrmEngine.closeSession_ = async function(session) {\n  const DrmEngine = shaka.media.DrmEngine;\n\n  const timeout = new Promise((resolve) => {\n    const timer = new shaka.util.Timer(resolve);\n    timer.tickAfter(DrmEngine.CLOSE_TIMEOUT_);\n  });\n\n  /** @type {boolean} */\n  const wasSessionClosed = await Promise.race([\n      session.close().then(() => true),\n      timeout.then(() => false),\n  ]);\n\n  if (!wasSessionClosed) {\n    shaka.log.warning('Timeout waiting for session close');\n  }\n};\n\n\n/**\n * The amount of time, in seconds, we wait to consider a session closed.\n * This allows us to work around Chrome bug https://crbug.com/690583.\n * @private {number}\n */\nshaka.media.DrmEngine.CLOSE_TIMEOUT_ = 1;\n\n/**\n * The amount of time, in seconds, we wait to consider session loaded even if no\n * key status information is available.  This allows us to support browsers/CDMs\n * without key statuses.\n * @private {number}\n */\nshaka.media.DrmEngine.SESSION_LOAD_TIMEOUT_ = 5;\n\n/**\n * The amount of time, in seconds, we wait to batch up rapid key status changes.\n * This allows us to avoid multiple expiration events in most cases.\n * @private {number}\n */\nshaka.media.DrmEngine.KEY_STATUS_BATCH_TIME_ = 0.5;\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.IClosedCaptionParser');\ngoog.provide('shaka.media.MuxJSClosedCaptionParser');\ngoog.provide('shaka.media.NoopCaptionParser');\n\n\n/**\n * The IClosedCaptionParser defines the interface to provide all operations for\n * parsing the closed captions embedded in Dash videos streams.\n * @interface\n */\nshaka.media.IClosedCaptionParser = class {\n  /**\n   * Initialize the caption parser. This should be called only once.\n   * @param {!ArrayBuffer} data\n   */\n  init(data) {}\n\n  /**\n   * Parses embedded CEA closed captions and interacts with the underlying\n   * CaptionStream, and calls the callback function when there are closed\n   * captions.\n   *\n   * @param {!ArrayBuffer} data\n   * @param {function(Array.<muxjs.mp4.ClosedCaption>)} onCaptions\n   *         A callback function to handle the closed captions from parsed data.\n   */\n  parseFrom(data, onCaptions) {}\n\n  /**\n   * Resets the CaptionStream.\n   */\n  reset() {}\n};\n\n\n/**\n * Closed Caption Parser provides all operations for parsing the closed captions\n * embedded in Dash videos streams.\n *\n * @implements {shaka.media.IClosedCaptionParser}\n * @final\n */\nshaka.media.MuxJSClosedCaptionParser = class {\n  constructor() {\n    /** @private {muxjs.mp4.CaptionParser} */\n    this.muxCaptionParser_ = new muxjs.mp4.CaptionParser();\n\n    /** @private {!Array.<number>} */\n    this.videoTrackIds_ = [];\n\n    /**\n     * Timescales from the init segments, used for mux.js CaptionParser.\n     * @private {!Object.<number, number>}\n     */\n    this.timescales_ = {};\n  }\n\n  /**\n   * @override\n   */\n  init(data) {\n    const probe = muxjs.mp4.probe;\n    // Caption parser for Dash\n    const initBytes = new Uint8Array(data);\n    this.videoTrackIds_ = probe.videoTrackIds(initBytes);\n    this.timescales_ = probe.timescale(initBytes);\n    this.muxCaptionParser_.init();\n  }\n\n  /**\n   * @override\n   */\n  parseFrom(data, onCaptions) {\n    const segmentBytes = new Uint8Array(data);\n    const dashParsed = this.muxCaptionParser_.parse(\n          segmentBytes, this.videoTrackIds_, this.timescales_);\n    if (dashParsed && dashParsed.captions) {\n      onCaptions(dashParsed.captions);\n    }\n    // ParsedCaptions is used by mux.js to store the captions parsed so far.\n    // It should be reset every time some data is parsed, so as to store new\n    // data.\n    this.muxCaptionParser_.clearParsedCaptions();\n  }\n\n  /**\n   * @override\n   */\n  reset() {\n    this.muxCaptionParser_.resetCaptionStream();\n  }\n\n  /**\n   * Check if the MuxJS closed caption parser is supported on this platform.\n   *\n   * @return {boolean}\n   */\n  static isSupported() {\n    return !!window.muxjs;\n  }\n};\n\n/**\n * Noop Caption Parser creates an empty caption parser object when mux.js is not\n * available.\n *\n * @implements {shaka.media.IClosedCaptionParser}\n * @final\n */\nshaka.media.NoopCaptionParser = class {\n  constructor() {}\n\n  /**\n   * @override\n   */\n  init(data) {}\n\n  /**\n   * @override\n   */\n  parseFrom(data, onCaptions) {}\n\n  /**\n   * @override\n   */\n  reset() {}\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.TimeRangesUtils');\n\ngoog.require('shaka.util.Platform');\n\n\n/**\n * @namespace shaka.media.TimeRangesUtils\n * @summary A set of utility functions for dealing with TimeRanges objects.\n */\n\n\n/**\n * Gets the first timestamp in the buffer.\n *\n * @param {TimeRanges} b\n * @return {?number} The first buffered timestamp, in seconds, if |buffered|\n *   is non-empty; otherwise, return null.\n */\nshaka.media.TimeRangesUtils.bufferStart = function(b) {\n  if (!b) return null;\n  // Workaround Safari bug: https://bit.ly/2trx6O8\n  if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) return null;\n  // Workaround Edge bug: https://bit.ly/2JYLPeB\n  if (b.length == 1 && b.start(0) < 0) return 0;\n  return b.length ? b.start(0) : null;\n};\n\n\n/**\n * Gets the last timestamp in the buffer.\n *\n * @param {TimeRanges} b\n * @return {?number} The last buffered timestamp, in seconds, if |buffered|\n *   is non-empty; otherwise, return null.\n */\nshaka.media.TimeRangesUtils.bufferEnd = function(b) {\n  if (!b) return null;\n  // Workaround Safari bug: https://bit.ly/2trx6O8\n  if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) return null;\n  return b.length ? b.end(b.length - 1) : null;\n};\n\n\n/**\n * Determines if the given time is inside a buffered range.  This includes gaps,\n * meaning that if the playhead is in a gap, it is considered buffered. If there\n * is a small gap between the playhead and buffer start, consider it as\n * buffered.\n *\n * @param {TimeRanges} b\n * @param {number} time Playhead time\n * @param {number=} smallGapLimit Set in configuration\n * @return {boolean}\n */\nshaka.media.TimeRangesUtils.isBuffered = function(b, time, smallGapLimit = 0) {\n  if (!b || !b.length) return false;\n  // Workaround Safari bug: https://bit.ly/2trx6O8\n  if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) return false;\n\n  if (time > b.end(b.length - 1)) {\n    return false;\n  }\n  // Push the time forward by the gap limit so that it is more likely to be in\n  // the range.\n  return (time + smallGapLimit >= b.start(0));\n};\n\n\n/**\n * Computes how far ahead of the given timestamp is buffered.  To provide smooth\n * playback while jumping gaps, we don't include the gaps when calculating this.\n * This only includes the amount of content that is buffered.\n *\n * @param {TimeRanges} b\n * @param {number} time\n * @return {number} The number of seconds buffered, in seconds, ahead of the\n *   given time.\n */\nshaka.media.TimeRangesUtils.bufferedAheadOf = function(b, time) {\n  if (!b || !b.length) return 0;\n  // Workaround Safari bug: https://bit.ly/2trx6O8\n  if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) return 0;\n\n  // NOTE: On IE11, buffered ranges may show appended data before the associated\n  // append operation is complete.\n\n  // We calculate the buffered amount by ONLY accounting for the content\n  // buffered (i.e. we ignore the times of the gaps).  We also buffer through\n  // all gaps.\n  // Therefore, we start at the end and add up all buffers until |time|.\n  let result = 0;\n  for (let i = b.length - 1; i >= 0 && b.end(i) > time; --i) {\n    result += b.end(i) - Math.max(b.start(i), time);\n  }\n\n  return result;\n};\n\n\n/**\n * Determines if the given time is inside a gap between buffered ranges.  If it\n * is, this returns the index of the buffer that is *ahead* of the gap.\n *\n * @param {TimeRanges} b\n * @param {number} time\n * @return {?number} The index of the buffer after the gap, or null if not in a\n *   gap.\n */\nshaka.media.TimeRangesUtils.getGapIndex = function(b, time) {\n  const Platform = shaka.util.Platform;\n\n  if (!b || !b.length) return null;\n  // Workaround Safari bug: https://bit.ly/2trx6O8\n  if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) return null;\n\n  // Some browsers will stop earlier than others before a gap (e.g. IE/Edge\n  // stops 0.5 seconds before a gap). So for some browsers we need to use a\n  // larger threshold. See: https://bit.ly/2K5xmJO\n  const useLargeThreshold = Platform.isEdge() ||\n                            Platform.isIE() ||\n                            Platform.isTizen() ||\n                            Platform.isChromecast();\n\n  const threshold = useLargeThreshold ? 0.5 : 0.1;\n\n  for (let i = 0; i < b.length; i++) {\n    if (b.start(i) > time && (i == 0 || b.end(i - 1) - time <= threshold)) {\n      return i;\n    }\n  }\n\n  return null;\n};\n\n\n/**\n * @param {TimeRanges} b\n * @return {!Array.<shaka.extern.BufferedRange>}\n */\nshaka.media.TimeRangesUtils.getBufferedInfo = function(b) {\n  if (!b) return [];\n  let ret = [];\n  for (let i = 0; i < b.length; i++) {\n    ret.push({start: b.start(i), end: b.end(i)});\n  }\n  return ret;\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.Functional');\n\n\n/**\n * @namespace shaka.util.Functional\n * @summary A set of functional utility functions.\n */\n\n\n/**\n * Creates a promise chain that calls the given callback for each element in\n * the array in a catch of a promise.\n *\n * e.g.:\n * Promise.reject().catch(callback(array[0])).catch(callback(array[1]));\n *\n * @param {!Array.<ELEM>} array\n * @param {function(ELEM):!Promise.<RESULT>} callback\n * @return {!Promise.<RESULT>}\n * @template ELEM,RESULT\n */\nshaka.util.Functional.createFallbackPromiseChain = function(array, callback) {\n  return array.reduce(function(callback, promise, elem) {\n    return promise.catch(callback.bind(null, elem));\n  }.bind(null, callback), Promise.reject());\n};\n\n\n/**\n * Returns the first array concatenated to the second; used to collapse an\n * array of arrays into a single array.\n *\n * @param {!Array.<T>} all\n * @param {!Array.<T>} part\n * @return {!Array.<T>}\n * @template T\n */\nshaka.util.Functional.collapseArrays = function(all, part) {\n  return all.concat(part);\n};\n\n\n/**\n * A no-op function.  Useful in promise chains.\n */\nshaka.util.Functional.noop = function() {};\n\n\n/**\n * Returns if the given value is not null; useful for filtering out null values.\n *\n * @param {T} value\n * @return {boolean}\n * @template T\n */\nshaka.util.Functional.isNotNull = function(value) {\n  return value != null;\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.ManifestParserUtils');\n\ngoog.require('goog.Uri');\ngoog.require('shaka.util.Functional');\n\n\n/**\n * @namespace shaka.util.ManifestParserUtils\n * @summary Utility functions for manifest parsing.\n */\n\n\n/**\n * Resolves an array of relative URIs to the given base URIs. This will result\n * in M*N number of URIs.\n *\n * @param {!Array.<string>} baseUris\n * @param {!Array.<string>} relativeUris\n * @return {!Array.<string>}\n */\nshaka.util.ManifestParserUtils.resolveUris = function(baseUris, relativeUris) {\n  const Functional = shaka.util.Functional;\n  if (relativeUris.length == 0) {\n    return baseUris;\n  }\n\n  let relativeAsGoog =\n      relativeUris.map(function(uri) { return new goog.Uri(uri); });\n  // Resolve each URI relative to each base URI, creating an Array of Arrays.\n  // Then flatten the Arrays into a single Array.\n  return baseUris.map(function(uri) { return new goog.Uri(uri); })\n    .map(function(base) { return relativeAsGoog.map(base.resolve.bind(base)); })\n    .reduce(Functional.collapseArrays, [])\n    .map(function(uri) { return uri.toString(); });\n};\n\n\n/**\n * Creates a DrmInfo object from the given info.\n *\n * @param {string} keySystem\n * @param {Array.<shaka.extern.InitDataOverride>} initData\n * @return {shaka.extern.DrmInfo}\n */\nshaka.util.ManifestParserUtils.createDrmInfo = function(keySystem, initData) {\n  return {\n    keySystem: keySystem,\n    licenseServerUri: '',\n    distinctiveIdentifierRequired: false,\n    persistentStateRequired: false,\n    audioRobustness: '',\n    videoRobustness: '',\n    serverCertificate: null,\n    initData: initData || [],\n    keyIds: [],\n  };\n};\n\n\n/**\n * @enum {string}\n */\nshaka.util.ManifestParserUtils.ContentType = {\n  VIDEO: 'video',\n  AUDIO: 'audio',\n  TEXT: 'text',\n  APPLICATION: 'application',\n};\n\n\n/**\n * @enum {string}\n */\nshaka.util.ManifestParserUtils.TextStreamKind = {\n  SUBTITLE: 'subtitle',\n  CLOSED_CAPTION: 'caption',\n};\n\n\n/**\n * Specifies how tolerant the player is of inaccurate segment start times and\n * end times within a manifest. For example, gaps or overlaps between segments\n * in a SegmentTimeline which are greater than or equal to this value will\n * result in a warning message.\n *\n * @const {number}\n */\nshaka.util.ManifestParserUtils.GAP_OVERLAP_TOLERANCE_SECONDS = 1 / 15;\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.Transmuxer');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * Transmuxer provides all operations for transmuxing from Transport\n * Stream to MP4.\n *\n * @struct\n * @constructor\n * @implements {shaka.util.IDestroyable}\n */\nshaka.media.Transmuxer = function() {\n  /** @private {muxjs.mp4.Transmuxer} */\n  this.muxTransmuxer_ = new muxjs.mp4.Transmuxer({\n    'keepOriginalTimestamps': true,\n  });\n\n  /** @private {shaka.util.PublicPromise} */\n  this.transmuxPromise_ = null;\n\n  /** @private {!Array.<!Uint8Array>} */\n  this.transmuxedData_ = [];\n\n  /** @private {!Array.<muxjs.mp4.ClosedCaption>} */\n  this.captions_ = [];\n\n  /** @private {boolean} */\n  this.isTransmuxing_ = false;\n\n  this.muxTransmuxer_.on('data', this.onTransmuxed_.bind(this));\n\n  this.muxTransmuxer_.on('done', this.onTransmuxDone_.bind(this));\n};\n\n\n/**\n * @override\n */\nshaka.media.Transmuxer.prototype.destroy = function() {\n  this.muxTransmuxer_.dispose();\n  this.muxTransmuxer_ = null;\n  return Promise.resolve();\n};\n\n\n/**\n * Check if the content type is Transport Stream, and if muxjs is loaded.\n * @param {string} mimeType\n * @param {string=} contentType\n * @return {boolean}\n */\nshaka.media.Transmuxer.isSupported = function(mimeType, contentType) {\n  if (!window.muxjs || !shaka.media.Transmuxer.isTsContainer(mimeType)) {\n    return false;\n  }\n  let convertTsCodecs = shaka.media.Transmuxer.convertTsCodecs;\n  if (contentType) {\n    return MediaSource.isTypeSupported(convertTsCodecs(contentType, mimeType));\n  }\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  return MediaSource.isTypeSupported(\n             convertTsCodecs(ContentType.AUDIO, mimeType)) ||\n      MediaSource.isTypeSupported(convertTsCodecs(ContentType.VIDEO, mimeType));\n};\n\n\n/**\n * Check if the mimetype contains 'mp2t'.\n * @param {string} mimeType\n * @return {boolean}\n */\nshaka.media.Transmuxer.isTsContainer = function(mimeType) {\n  return mimeType.toLowerCase().split(';')[0].split('/')[1] == 'mp2t';\n};\n\n\n/**\n * For transport stream, convert its codecs to MP4 codecs.\n * @param {string} contentType\n * @param {string} tsMimeType\n * @return {string}\n */\nshaka.media.Transmuxer.convertTsCodecs = function(contentType, tsMimeType) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  let mp4MimeType = tsMimeType.replace(/mp2t/i, 'mp4');\n  if (contentType == ContentType.AUDIO) {\n    mp4MimeType = mp4MimeType.replace('video', 'audio');\n  }\n\n  // Handle legacy AVC1 codec strings (pre-RFC 6381).\n  // Look for \"avc1.<profile>.<level>\", where profile is:\n  //   66 (baseline => 0x42)\n  //   77 (main => 0x4d)\n  //   100 (high => 0x64)\n  // Reference: https://bit.ly/2K9JI3x\n  let match = /avc1\\.(66|77|100)\\.(\\d+)/.exec(mp4MimeType);\n  if (match) {\n    let newCodecString = 'avc1.';\n\n    let profile = match[1];\n    if (profile == '66') {\n      newCodecString += '4200';\n    } else if (profile == '77') {\n      newCodecString += '4d00';\n    } else {\n      goog.asserts.assert(profile == '100',\n                          'Legacy avc1 parsing code out of sync with regex!');\n      newCodecString += '6400';\n    }\n\n    // Convert the level to hex and append to the codec string.\n    let level = Number(match[2]);\n    goog.asserts.assert(level < 256,\n                        'Invalid legacy avc1 level number!');\n    newCodecString += (level >> 4).toString(16);\n    newCodecString += (level & 0xf).toString(16);\n\n    mp4MimeType = mp4MimeType.replace(match[0], newCodecString);\n  }\n\n  return mp4MimeType;\n};\n\n\n/**\n * Transmux from Transport stream to MP4, using the mux.js library.\n * @param {!ArrayBuffer} data\n * @return {!Promise.<{data: !Uint8Array,\n *                     captions: !Array.<!muxjs.mp4.ClosedCaption>}>}\n */\nshaka.media.Transmuxer.prototype.transmux = function(data) {\n  goog.asserts.assert(!this.isTransmuxing_,\n      'No transmuxing should be in progress.');\n  this.isTransmuxing_ = true;\n  this.transmuxPromise_ = new shaka.util.PublicPromise();\n  this.transmuxedData_ = [];\n  this.captions_ = [];\n\n  let dataArray = new Uint8Array(data);\n  this.muxTransmuxer_.push(dataArray);\n  this.muxTransmuxer_.flush();\n\n  // Workaround for https://bit.ly/Shaka1449 mux.js not\n  // emitting 'data' and 'done' events.\n  // mux.js code is synchronous, so if onTransmuxDone_ has\n  // not been called by now, it's not going to be.\n  // Treat it as a transmuxing failure and reject the promise.\n  if (this.isTransmuxing_) {\n    this.transmuxPromise_.reject(new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MEDIA,\n            shaka.util.Error.Code.TRANSMUXING_FAILED));\n  }\n  return this.transmuxPromise_;\n};\n\n\n/**\n * Handles the 'data' event of the transmuxer.\n * Extracts the cues from the transmuxed segment, and adds them to an array.\n * Stores the transmuxed data in another array, to pass it back to\n * MediaSourceEngine, and append to the source buffer.\n *\n * @param {muxjs.mp4.Transmuxer.Segment} segment\n * @private\n */\nshaka.media.Transmuxer.prototype.onTransmuxed_ = function(segment) {\n  this.captions_ = segment.captions;\n  let segmentWithInit = new Uint8Array(segment.data.byteLength +\n      segment.initSegment.byteLength);\n  segmentWithInit.set(segment.initSegment, 0);\n  segmentWithInit.set(segment.data, segment.initSegment.byteLength);\n  this.transmuxedData_.push(segmentWithInit);\n};\n\n\n/**\n * Handles the 'done' event of the transmuxer.\n * Resolves the transmux Promise, and returns the transmuxed data.\n * @private\n */\nshaka.media.Transmuxer.prototype.onTransmuxDone_ = function() {\n  let output = {\n    data: shaka.util.Uint8ArrayUtils.concat.apply(null, this.transmuxedData_),\n    captions: this.captions_,\n  };\n\n  this.transmuxPromise_.resolve(output);\n  this.isTransmuxing_ = false;\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.text.Cue');\ngoog.provide('shaka.text.CueRegion');\n\n/**\n * Creates a Cue object.\n *\n * @param {number} startTime\n * @param {number} endTime\n * @param {string} payload\n *\n * @implements {shaka.extern.Cue}\n * @constructor\n * @struct\n * @export\n */\nshaka.text.Cue = function(startTime, endTime, payload) {\n  const Cue = shaka.text.Cue;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.startTime = startTime;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.direction = Cue.direction.HORIZONTAL_LEFT_TO_RIGHT;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.endTime = endTime;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.payload = payload;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.region = new shaka.text.CueRegion();\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.position = null;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.positionAlign = Cue.positionAlign.AUTO;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.size = 100;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.textAlign = Cue.textAlign.CENTER;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.writingMode = Cue.writingMode.HORIZONTAL_TOP_TO_BOTTOM;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.lineInterpretation = Cue.lineInterpretation.LINE_NUMBER;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.line = null;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.lineHeight = '';\n\n  /**\n   * Line Alignment is set to start by default.\n   * @override\n   * @exportInterface\n   */\n  this.lineAlign = Cue.lineAlign.START;\n\n  /**\n   * Set the captions at the bottom of the text container by default.\n   * @override\n   * @exportInterface\n   */\n  this.displayAlign = Cue.displayAlign.AFTER;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.color = '';\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.backgroundColor = '';\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.backgroundImage = '';\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.fontSize = '';\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.fontWeight = Cue.fontWeight.NORMAL;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.fontStyle = Cue.fontStyle.NORMAL;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.fontFamily = '';\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.textDecoration = [];\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.wrapLine = true;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.id = '';\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.positionAlign = {\n  'LEFT': 'line-left',\n  'RIGHT': 'line-right',\n  'CENTER': 'center',\n  'AUTO': 'auto',\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.textAlign = {\n  'LEFT': 'left',\n  'RIGHT': 'right',\n  'CENTER': 'center',\n  'START': 'start',\n  'END': 'end',\n};\n\n\n/**\n * Vertical alignments of the cues within their extents.\n * 'BEFORE' means displaying at the top of the captions container box, 'CENTER'\n *  means in the middle, 'BOTTOM' means at the bottom.\n * @enum {string}\n * @export\n */\nshaka.text.Cue.displayAlign = {\n  'BEFORE': 'before',\n  'CENTER': 'center',\n  'AFTER': 'after',\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.direction = {\n  'HORIZONTAL_LEFT_TO_RIGHT': 'ltr',\n  'HORIZONTAL_RIGHT_TO_LEFT': 'rtl',\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.writingMode = {\n  'HORIZONTAL_TOP_TO_BOTTOM': 'horizontal-tb',\n  'VERTICAL_LEFT_TO_RIGHT': 'vertical-lr',\n  'VERTICAL_RIGHT_TO_LEFT': 'vertical-rl',\n};\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.text.Cue.lineInterpretation = {\n  'LINE_NUMBER': 0,\n  'PERCENTAGE': 1,\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.lineAlign = {\n  'CENTER': 'center',\n  'START': 'start',\n  'END': 'end',\n};\n\n\n/**\n * In CSS font weight can be a number, where 400 is normal and 700 is bold.\n * Use these values for the enum for consistency.\n * @enum {number}\n * @export\n */\nshaka.text.Cue.fontWeight = {\n  'NORMAL': 400,\n  'BOLD': 700,\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.fontStyle = {\n  'NORMAL': 'normal',\n  'ITALIC': 'italic',\n  'OBLIQUE': 'oblique',\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.textDecoration = {\n  'UNDERLINE': 'underline',\n  'LINE_THROUGH': 'lineThrough',\n  'OVERLINE': 'overline',\n};\n\n\n/**\n * Creates a CueRegion object.\n *\n * @implements {shaka.extern.CueRegion}\n * @constructor\n * @struct\n * @export\n */\nshaka.text.CueRegion = function() {\n  const CueRegion = shaka.text.CueRegion;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.id = '';\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.viewportAnchorX = 0;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.viewportAnchorY = 0;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.regionAnchorX = 0;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.regionAnchorY = 0;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.width = 100;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.height = 100;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.heightUnits = CueRegion.units.PERCENTAGE;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.widthUnits = CueRegion.units.PERCENTAGE;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.viewportAnchorUnits = CueRegion.units.PERCENTAGE;\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  this.scroll = CueRegion.scrollMode.NONE;\n};\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.text.CueRegion.units = {\n  'PX': 0,\n  'PERCENTAGE': 1,\n  'LINES': 2,\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.CueRegion.scrollMode = {\n  'NONE': '',\n  'UP': 'up',\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.text.TextEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.MimeUtils');\n\n\n/**\n * Manages text parsers and cues.\n *\n * @param {shaka.extern.TextDisplayer} displayer\n * @struct\n * @constructor\n * @implements {shaka.util.IDestroyable}\n */\nshaka.text.TextEngine = function(displayer) {\n  /** @private {shaka.extern.TextParser} */\n  this.parser_ = null;\n\n  /** @private {shaka.extern.TextDisplayer} */\n  this.displayer_ = displayer;\n\n  /** @private {number} */\n  this.timestampOffset_ = 0;\n\n  /** @private {number} */\n  this.appendWindowStart_ = 0;\n\n  /** @private {number} */\n  this.appendWindowEnd_ = Infinity;\n\n  /** @private {?number} */\n  this.bufferStart_ = null;\n\n  /** @private {?number} */\n  this.bufferEnd_ = null;\n\n  /** @private {string} */\n  this.selectedClosedCaptionId_ = '';\n\n  /**\n   * The closed captions map stores the CEA closed captions by closed captions\n   * id and start and end time.\n   * It's used as the buffer of closed caption text streams, to show captions\n   * when we start displaying captions or switch caption tracks, we need to be\n   * able to get the cues for the other language and display them without\n   * re-fetching the video segments they were embedded in.\n   * Structure of closed caption map:\n   * closed caption id -> {start and end time -> cues}\n   * @private {!Map.<string, !Map.<string, !Array.<shaka.text.Cue>>>} */\n  this.closedCaptionsMap_ = new Map();\n};\n\n\n/** @private {!Object.<string, !shaka.extern.TextParserPlugin>} */\nshaka.text.TextEngine.parserMap_ = {};\n\n\n/**\n * @param {string} mimeType\n * @param {!shaka.extern.TextParserPlugin} plugin\n * @export\n */\nshaka.text.TextEngine.registerParser = function(mimeType, plugin) {\n  shaka.text.TextEngine.parserMap_[mimeType] = plugin;\n};\n\n\n/**\n * @param {string} mimeType\n * @export\n */\nshaka.text.TextEngine.unregisterParser = function(mimeType) {\n  delete shaka.text.TextEngine.parserMap_[mimeType];\n};\n\n\n/**\n * @param {string} mimeType\n * @return {boolean}\n */\nshaka.text.TextEngine.isTypeSupported = function(mimeType) {\n  if (shaka.text.TextEngine.parserMap_[mimeType]) {\n    // An actual parser is available.\n    return true;\n  }\n  if (window.muxjs &&\n      mimeType == shaka.util.MimeUtils.CLOSED_CAPTION_MIMETYPE) {\n    // Will be handled by mux.js.\n    return true;\n  }\n  return false;\n};\n\n\n/** @override */\nshaka.text.TextEngine.prototype.destroy = function() {\n  this.parser_ = null;\n  this.displayer_ = null;\n  this.closedCaptionsMap_.clear();\n\n  return Promise.resolve();\n};\n\n\n/**\n * @param {!shaka.extern.TextDisplayer} displayer\n */\nshaka.text.TextEngine.prototype.setDisplayer = function(displayer) {\n  this.displayer_ = displayer;\n};\n\n\n/**\n * Initialize the parser.  This can be called multiple times, but must be called\n * at least once before appendBuffer.\n *\n * @param {string} mimeType\n */\nshaka.text.TextEngine.prototype.initParser = function(mimeType) {\n  // No parser for CEA, which is extracted from video and side-loaded\n  // into TextEngine and TextDisplayer.\n  if (mimeType == shaka.util.MimeUtils.CLOSED_CAPTION_MIMETYPE) {\n    return;\n  }\n\n  let Factory = shaka.text.TextEngine.parserMap_[mimeType];\n  goog.asserts.assert(\n      Factory,\n      'Text type negotiation should have happened already');\n  this.parser_ = new Factory();\n};\n\n\n/**\n * Parse the start time from the text media segment, if possible.\n *\n * @param {!ArrayBuffer} buffer\n * @return {number}\n * @throws {shaka.util.Error} on failure\n */\nshaka.text.TextEngine.prototype.getStartTime = function(buffer) {\n  goog.asserts.assert(this.parser_, 'The parser should already be initialized');\n\n  /** @type {shaka.extern.TextParser.TimeContext} **/\n  let time = {\n    periodStart: 0,\n    segmentStart: null,\n    segmentEnd: 0,\n  };\n\n  // Parse the buffer and extract the first cue start time.\n  try {\n    let allCues = this.parser_.parseMedia(new Uint8Array(buffer), time);\n    return allCues[0].startTime;\n  } catch (exception) {\n    // This could be a failure from the parser itself (init segment required)\n    // or an exception from allCues.length being zero.\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.UNABLE_TO_EXTRACT_CUE_START_TIME,\n        exception);\n  }\n};\n\n\n/**\n * @param {!ArrayBuffer} buffer\n * @param {?number} startTime relative to the start of the presentation\n * @param {?number} endTime relative to the start of the presentation\n * @return {!Promise}\n */\nshaka.text.TextEngine.prototype.appendBuffer =\n    function(buffer, startTime, endTime) {\n  goog.asserts.assert(this.parser_, 'The parser should already be initialized');\n\n  // Start the operation asynchronously to avoid blocking the caller.\n  return Promise.resolve().then(function() {\n    // Check that TextEngine hasn't been destroyed.\n    if (!this.parser_ || !this.displayer_) return;\n\n    if (startTime == null || endTime == null) {\n      this.parser_.parseInit(new Uint8Array(buffer));\n      return;\n    }\n\n    /** @type {shaka.extern.TextParser.TimeContext} **/\n    let time = {\n      periodStart: this.timestampOffset_,\n      segmentStart: startTime,\n      segmentEnd: endTime,\n    };\n\n    // Parse the buffer and add the new cues.\n    let allCues = this.parser_.parseMedia(new Uint8Array(buffer), time);\n    let cuesToAppend = allCues.filter(function(cue) {\n      return cue.startTime >= this.appendWindowStart_ &&\n             cue.startTime < this.appendWindowEnd_;\n    }.bind(this));\n\n    this.displayer_.append(cuesToAppend);\n\n    // NOTE: We update the buffered range from the start and end times passed\n    // down from the segment reference, not with the start and end times of the\n    // parsed cues.  This is important because some segments may contain no\n    // cues, but we must still consider those ranges buffered.\n    if (this.bufferStart_ == null) {\n      this.bufferStart_ = Math.max(startTime, this.appendWindowStart_);\n    } else {\n      // We already had something in buffer, and we assume we are extending the\n      // range from the end.\n      goog.asserts.assert(this.bufferEnd_ != null,\n                          'There should already be a buffered range end.');\n      goog.asserts.assert((startTime - this.bufferEnd_) <= 1,\n                          'There should not be a gap in text references >1s');\n    }\n    this.bufferEnd_ = Math.min(endTime, this.appendWindowEnd_);\n  }.bind(this));\n};\n\n\n/**\n * @param {number} startTime relative to the start of the presentation\n * @param {number} endTime relative to the start of the presentation\n * @return {!Promise}\n */\nshaka.text.TextEngine.prototype.remove = function(startTime, endTime) {\n  // Start the operation asynchronously to avoid blocking the caller.\n  return Promise.resolve().then(function() {\n    if (this.displayer_ && this.displayer_.remove(startTime, endTime)) {\n      if (this.bufferStart_ == null) {\n        goog.asserts.assert(this.bufferEnd_ == null,\n                            'end must be null if startTime is null');\n      } else {\n        goog.asserts.assert(this.bufferEnd_ != null,\n                            'end must be non-null if startTime is non-null');\n\n        // Update buffered range.\n        if (endTime <= this.bufferStart_ || startTime >= this.bufferEnd_) {\n          // No intersection.  Nothing was removed.\n        } else if (startTime <= this.bufferStart_ &&\n                   endTime >= this.bufferEnd_) {\n          // We wiped out everything.\n          this.bufferStart_ = this.bufferEnd_ = null;\n        } else if (startTime <= this.bufferStart_ &&\n                   endTime < this.bufferEnd_) {\n          // We removed from the beginning of the range.\n          this.bufferStart_ = endTime;\n        } else if (startTime > this.bufferStart_ &&\n                   endTime >= this.bufferEnd_) {\n          // We removed from the end of the range.\n          this.bufferEnd_ = startTime;\n        } else {\n          // We removed from the middle?  StreamingEngine isn't supposed to.\n          goog.asserts.assert(\n              false, 'removal from the middle is not supported by TextEngine');\n        }\n      }\n    }\n  }.bind(this));\n};\n\n\n/** @param {number} timestampOffset */\nshaka.text.TextEngine.prototype.setTimestampOffset =\n    function(timestampOffset) {\n  this.timestampOffset_ = timestampOffset;\n};\n\n\n/**\n * @param {number} appendWindowStart\n * @param {number} appendWindowEnd\n */\nshaka.text.TextEngine.prototype.setAppendWindow =\n    function(appendWindowStart, appendWindowEnd) {\n  this.appendWindowStart_ = appendWindowStart;\n  this.appendWindowEnd_ = appendWindowEnd;\n};\n\n\n/**\n * @return {?number} Time in seconds of the beginning of the buffered range,\n *   or null if nothing is buffered.\n */\nshaka.text.TextEngine.prototype.bufferStart = function() {\n  return this.bufferStart_;\n};\n\n\n/**\n * @return {?number} Time in seconds of the end of the buffered range,\n *   or null if nothing is buffered.\n */\nshaka.text.TextEngine.prototype.bufferEnd = function() {\n  return this.bufferEnd_;\n};\n\n\n/**\n * @param {number} t A timestamp\n * @return {boolean}\n */\nshaka.text.TextEngine.prototype.isBuffered = function(t) {\n  if (this.bufferStart_ == null || this.bufferEnd_ == null) {\n    return false;\n  }\n  return t >= this.bufferStart_ && t < this.bufferEnd_;\n};\n\n\n/**\n * @param {number} t A timestamp\n * @return {number} Number of seconds ahead of 't' we have buffered\n */\nshaka.text.TextEngine.prototype.bufferedAheadOf = function(t) {\n  if (this.bufferEnd_ == null || this.bufferEnd_ < t) return 0;\n\n  goog.asserts.assert(\n      this.bufferStart_ != null, 'start should not be null if end is not null');\n\n  return this.bufferEnd_ - Math.max(t, this.bufferStart_);\n};\n\n\n/**\n * Append cues to text displayer.\n *\n * @param {!Array.<!shaka.text.Cue>} cues\n * @export\n */\nshaka.text.TextEngine.prototype.appendCues = function(cues) {\n  this.displayer_.append(cues);\n};\n\n\n/**\n * Set the selected closed captions id.\n * Append the cues stored in the closed captions map until buffer end time.\n * This is to fill the gap between buffered and unbuffered captions, and to\n * avoid duplicates that would be caused by any future video segments parsed for\n * captions.\n *\n * @param {string} id\n * @param {number} bufferEndTime Load any stored cues up to this time.\n * @export\n */\nshaka.text.TextEngine.prototype.setSelectedClosedCaptionId =\n    function(id, bufferEndTime) {\n  this.selectedClosedCaptionId_ = id;\n\n  const captionsMap = this.closedCaptionsMap_.get(id);\n  if (captionsMap) {\n    for (const startAndEndTime of captionsMap.keys()) {\n      /** @type {Array.<!shaka.text.Cue>} */\n      let cues = captionsMap.get(startAndEndTime);\n      if (cues) {\n        cues = cues.filter((c) => c.endTime <= bufferEndTime);\n        this.displayer_.append(cues);\n      }\n    }\n  }\n};\n\n\n/**\n * Store the closed captions in the text engine, and append the cues to the text\n * displayer.  This is a side-channel used for embedded text only.\n *\n * @param {!Array.<muxjs.mp4.ClosedCaption>} closedCaptions\n * @param {?number} startTime relative to the start of the presentation\n * @param {?number} endTime relative to the start of the presentation\n * @param {number} videoTimestampOffset the timestamp offset of the video\n *   stream in which these captions were embedded\n */\nshaka.text.TextEngine.prototype.storeAndAppendClosedCaptions = function(\n    closedCaptions, startTime, endTime, videoTimestampOffset) {\n  const startAndEndTime = startTime + ' ' + endTime;\n  const captionsMap = new Map();\n\n  for (const caption of closedCaptions) {\n    const id = caption.stream;\n    if (!captionsMap.has(id)) {\n      captionsMap.set(id, new Map());\n    }\n    if (!captionsMap.get(id).has(startAndEndTime)) {\n      captionsMap.get(id).set(startAndEndTime, []);\n    }\n\n    // Adjust CEA captions with respect to the timestamp offset of the video\n    // stream in which they were embedded.\n    caption.startTime += videoTimestampOffset;\n    caption.endTime += videoTimestampOffset;\n\n    const keepThisCue =\n        caption.startTime >= this.appendWindowStart_ &&\n        caption.startTime < this.appendWindowEnd_;\n    if (!keepThisCue) {\n      continue;\n    }\n    /** @type {!shaka.text.Cue} */\n    const cue = new shaka.text.Cue(\n        caption.startTime, caption.endTime, caption.text);\n    captionsMap.get(id).get(startAndEndTime).push(cue);\n    if (id == this.selectedClosedCaptionId_) {\n      this.displayer_.append([cue]);\n    }\n  }\n\n  for (const id of captionsMap.keys()) {\n    if (!this.closedCaptionsMap_.has(id)) {\n      this.closedCaptionsMap_.set(id, new Map());\n    }\n    for (const startAndEndTime of captionsMap.get(id).keys()) {\n      const cues = captionsMap.get(id).get(startAndEndTime);\n      this.closedCaptionsMap_.get(id).set(startAndEndTime, cues);\n    }\n  }\n\n  if (this.bufferStart_ == null) {\n    this.bufferStart_ = Math.max(startTime, this.appendWindowStart_);\n  } else {\n    this.bufferStart_ = Math.min(\n        this.bufferStart_, Math.max(startTime, this.appendWindowStart_));\n  }\n\n  this.bufferEnd_ = Math.max(\n      this.bufferEnd_, Math.min(endTime, this.appendWindowEnd_));\n};\n\n\n/**\n * Get the number of closed caption channels.\n *\n * This function is for TESTING ONLY. DO NOT USE in the library.\n *\n * @return {number}\n */\nshaka.text.TextEngine.prototype.getNumberOfClosedCaptionChannels = function() {\n  return this.closedCaptionsMap_.size;\n};\n\n/**\n * Get the number of closed caption cues for a given channel. If there is\n * no channel for the given channel id, this will return 0.\n *\n * This function is for TESTING ONLY. DO NOT USE in the library.\n *\n * @param {string} channelId\n * @return {number}\n */\nshaka.text.TextEngine.prototype.getNumberOfClosedCaptionsInChannel =\n    function(channelId) {\n  const channel = this.closedCaptionsMap_.get(channelId);\n  return channel ? channel.size : 0;\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.MediaSourceEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.IClosedCaptionParser');\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.media.Transmuxer');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * MediaSourceEngine wraps all operations on MediaSource and SourceBuffers.\n * All asynchronous operations return a Promise, and all operations are\n * internally synchronized and serialized as needed.  Operations that can\n * be done in parallel will be done in parallel.\n *\n * @param {HTMLMediaElement} video The video element, whose source is tied to\n *   MediaSource during the lifetime of the MediaSourceEngine.\n * @param {!shaka.media.IClosedCaptionParser} closedCaptionParser\n *    The closed caption parser that should be used to parser closed captions\n *    from the video stream. MediaSourceEngine takes ownership of the parser.\n *    When MediaSourceEngine is destroyed, it will destroy the parser.\n * @param {!shaka.extern.TextDisplayer} textDisplayer\n *    The text displayer that will be used with the text engine.\n *    MediaSourceEngine takes ownership of the displayer. When MediaSourceEngine\n *    is destroyed, it will destroy the displayer.\n * @struct\n * @constructor\n * @implements {shaka.util.IDestroyable}\n */\nshaka.media.MediaSourceEngine = function(\n    video, closedCaptionParser, textDisplayer) {\n  /** @private {HTMLMediaElement} */\n  this.video_ = video;\n\n  /** @private {shaka.extern.TextDisplayer} */\n  this.textDisplayer_ = textDisplayer;\n\n  /** @private {!Object.<shaka.util.ManifestParserUtils.ContentType,\n                         SourceBuffer>} */\n  this.sourceBuffers_ = {};\n\n  /** @private {shaka.text.TextEngine} */\n  this.textEngine_ = null;\n\n  /**\n   * @private {!Object.<string,\n   *                    !Array.<shaka.media.MediaSourceEngine.Operation>>}\n   */\n  this.queues_ = {};\n\n  /** @private {shaka.util.EventManager} */\n  this.eventManager_ = new shaka.util.EventManager();\n\n  /** @private {boolean} */\n  this.destroyed_ = false;\n\n  /** @private {!Object.<string, !shaka.media.Transmuxer>} */\n  this.transmuxers_ = {};\n\n  /** @private {shaka.media.IClosedCaptionParser} */\n  this.captionParser_ = closedCaptionParser;\n\n  /** @private {!shaka.util.PublicPromise} */\n  this.mediaSourceOpen_ = new shaka.util.PublicPromise();\n\n  /** @private {MediaSource} */\n  this.mediaSource_ = this.createMediaSource(this.mediaSourceOpen_);\n};\n\n\n/**\n * Internal reference to window.URL.createObjectURL function to avoid\n * compatibility issues with other libraries and frameworks such as React\n * Native. For use in unit tests only, not meant for external use.\n *\n * @type {function(?):string}\n */\nshaka.media.MediaSourceEngine.createObjectURL = window.URL.createObjectURL;\n\n\n/**\n * Create a MediaSource object, attach it to the video element, and return it.\n * Resolves the given promise when the MediaSource is ready.\n *\n * Replaced by unit tests.\n *\n * @param {!shaka.util.PublicPromise} p\n * @return {!MediaSource}\n */\nshaka.media.MediaSourceEngine.prototype.createMediaSource = function(p) {\n  let mediaSource = new MediaSource();\n\n  // Set up MediaSource on the video element.\n  this.eventManager_.listenOnce(mediaSource, 'sourceopen', p.resolve);\n  this.video_.src = shaka.media.MediaSourceEngine.createObjectURL(mediaSource);\n\n  return mediaSource;\n};\n\n\n/**\n * @typedef {{\n *   start: function(),\n *   p: !shaka.util.PublicPromise\n * }}\n *\n * @summary An operation in queue.\n * @property {function()} start\n *   The function which starts the operation.\n * @property {!shaka.util.PublicPromise} p\n *   The PublicPromise which is associated with this operation.\n */\nshaka.media.MediaSourceEngine.Operation;\n\n\n/**\n * Checks if a certain type is supported.\n *\n * @param {shaka.extern.Stream} stream\n * @return {boolean}\n */\nshaka.media.MediaSourceEngine.isStreamSupported = function(stream) {\n  let fullMimeType = shaka.util.MimeUtils.getFullType(\n      stream.mimeType, stream.codecs);\n  let extendedMimeType = shaka.util.MimeUtils.getExtendedType(stream);\n  return shaka.text.TextEngine.isTypeSupported(fullMimeType) ||\n      MediaSource.isTypeSupported(extendedMimeType) ||\n      shaka.media.Transmuxer.isSupported(fullMimeType, stream.type);\n};\n\n\n/**\n * Returns a map of MediaSource support for well-known types.\n *\n * @return {!Object.<string, boolean>}\n */\nshaka.media.MediaSourceEngine.probeSupport = function() {\n  const testMimeTypes = [\n    // MP4 types\n    'video/mp4; codecs=\"avc1.42E01E\"',\n    'video/mp4; codecs=\"avc3.42E01E\"',\n    'video/mp4; codecs=\"hev1.1.6.L93.90\"',\n    'video/mp4; codecs=\"hvc1.1.6.L93.90\"',\n    'video/mp4; codecs=\"hev1.2.4.L153.B0\"; eotf=\"smpte2084\"',  // HDR HEVC\n    'video/mp4; codecs=\"hvc1.2.4.L153.B0\"; eotf=\"smpte2084\"',  // HDR HEVC\n    'video/mp4; codecs=\"vp9\"',\n    'video/mp4; codecs=\"vp09.00.10.08\"',\n    'audio/mp4; codecs=\"mp4a.40.2\"',\n    'audio/mp4; codecs=\"ac-3\"',\n    'audio/mp4; codecs=\"ec-3\"',\n    'audio/mp4; codecs=\"opus\"',\n    'audio/mp4; codecs=\"flac\"',\n    // WebM types\n    'video/webm; codecs=\"vp8\"',\n    'video/webm; codecs=\"vp9\"',\n    'video/webm; codecs=\"vp09.00.10.08\"',\n    'audio/webm; codecs=\"vorbis\"',\n    'audio/webm; codecs=\"opus\"',\n    // MPEG2 TS types (video/ is also used for audio: https://bit.ly/TsMse)\n    'video/mp2t; codecs=\"avc1.42E01E\"',\n    'video/mp2t; codecs=\"avc3.42E01E\"',\n    'video/mp2t; codecs=\"hvc1.1.6.L93.90\"',\n    'video/mp2t; codecs=\"mp4a.40.2\"',\n    'video/mp2t; codecs=\"ac-3\"',\n    'video/mp2t; codecs=\"ec-3\"',\n    // WebVTT types\n    'text/vtt',\n    'application/mp4; codecs=\"wvtt\"',\n    // TTML types\n    'application/ttml+xml',\n    'application/mp4; codecs=\"stpp\"',\n  ];\n\n  let support = {};\n  for (let type of testMimeTypes) {\n    if (shaka.util.Platform.supportsMediaSource()) {\n      // Our TextEngine is only effective for MSE platforms at the moment.\n      if (shaka.text.TextEngine.isTypeSupported(type)) {\n        support[type] = true;\n      } else {\n        support[type] = MediaSource.isTypeSupported(type) ||\n                        shaka.media.Transmuxer.isSupported(type);\n      }\n    } else {\n      support[type] = shaka.util.Platform.supportsMediaType(type);\n    }\n\n    const basicType = type.split(';')[0];\n    support[basicType] = support[basicType] || support[type];\n  }\n\n  return support;\n};\n\n\n/** @override */\nshaka.media.MediaSourceEngine.prototype.destroy = function() {\n  const Functional = shaka.util.Functional;\n  this.destroyed_ = true;\n\n  let cleanup = [];\n\n  for (let contentType in this.queues_) {\n    // Make a local copy of the queue and the first item.\n    let q = this.queues_[contentType];\n    let inProgress = q[0];\n\n    // Drop everything else out of the original queue.\n    this.queues_[contentType] = q.slice(0, 1);\n\n    // We will wait for this item to complete/fail.\n    if (inProgress) {\n      cleanup.push(inProgress.p.catch(Functional.noop));\n    }\n\n    // The rest will be rejected silently if possible.\n    for (let i = 1; i < q.length; ++i) {\n      q[i].p.reject();\n    }\n  }\n\n  if (this.textEngine_) {\n    cleanup.push(this.textEngine_.destroy());\n  }\n  if (this.textDisplayer_) {\n    cleanup.push(this.textDisplayer_.destroy());\n  }\n\n  for (let contentType in this.transmuxers_) {\n    cleanup.push(this.transmuxers_[contentType].destroy());\n  }\n\n  return Promise.all(cleanup).then(() => {\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    if (this.video_) {\n      // \"unload\" the video element.\n      this.video_.removeAttribute('src');\n      this.video_.load();\n      this.video_ = null;\n    }\n\n    this.mediaSource_ = null;\n    this.textEngine_ = null;\n    this.textDisplayer_ = null;\n    this.sourceBuffers_ = {};\n    this.transmuxers_ = {};\n    this.captionParser_ = null;\n    if (goog.DEBUG) {\n      for (let contentType in this.queues_) {\n        goog.asserts.assert(\n            this.queues_[contentType].length == 0,\n            contentType + ' queue should be empty after destroy!');\n      }\n    }\n    this.queues_ = {};\n  });\n};\n\n\n/**\n * @return {!Promise} Resolved when MediaSource is open and attached to the\n *   media element.  This process is actually initiated by the constructor.\n */\nshaka.media.MediaSourceEngine.prototype.open = function() {\n  return this.mediaSourceOpen_;\n};\n\n\n/**\n * Initialize MediaSourceEngine.\n *\n * Note that it is not valid to call this multiple times, except to add or\n * reinitialize text streams.\n *\n * @param {!Map.<shaka.util.ManifestParserUtils.ContentType,\n *               shaka.extern.Stream>} streamsByType\n *   A map of content types to streams.  All streams must be supported according\n *   to MediaSourceEngine.isStreamSupported.\n * @param {boolean} forceTransmuxTS\n *   If true, this will transmux TS content even if it is natively supported.\n *\n * @return {!Promise}\n *\n * @throws InvalidAccessError if blank MIME types are given\n * @throws NotSupportedError if unsupported MIME types are given\n * @throws QuotaExceededError if the browser can't support that many buffers\n */\nshaka.media.MediaSourceEngine.prototype.init = async function(\n    streamsByType, forceTransmuxTS) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  await this.mediaSourceOpen_;\n\n  streamsByType.forEach((stream, contentType) => {\n    goog.asserts.assert(\n        shaka.media.MediaSourceEngine.isStreamSupported(stream),\n        'Type negotiation should happen before MediaSourceEngine.init!');\n\n    let mimeType = shaka.util.MimeUtils.getFullType(\n        stream.mimeType, stream.codecs);\n    if (contentType == ContentType.TEXT) {\n      this.reinitText(mimeType);\n    } else {\n      if ((forceTransmuxTS || !MediaSource.isTypeSupported(mimeType)) &&\n          shaka.media.Transmuxer.isSupported(mimeType, contentType)) {\n        this.transmuxers_[contentType] = new shaka.media.Transmuxer();\n        mimeType =\n            shaka.media.Transmuxer.convertTsCodecs(contentType, mimeType);\n      }\n      let sourceBuffer = this.mediaSource_.addSourceBuffer(mimeType);\n      this.eventManager_.listen(\n          sourceBuffer, 'error',\n          this.onError_.bind(this, contentType));\n      this.eventManager_.listen(\n          sourceBuffer, 'updateend',\n          this.onUpdateEnd_.bind(this, contentType));\n      this.sourceBuffers_[contentType] = sourceBuffer;\n      this.queues_[contentType] = [];\n    }\n  });\n};\n\n\n/**\n * Reinitialize the TextEngine for a new text type.\n * @param {string} mimeType\n */\nshaka.media.MediaSourceEngine.prototype.reinitText = function(mimeType) {\n  if (!this.textEngine_) {\n    this.textEngine_ = new shaka.text.TextEngine(this.textDisplayer_);\n  }\n  this.textEngine_.initParser(mimeType);\n};\n\n\n/**\n * @return {boolean} True if the MediaSource is in an \"ended\" state, or if the\n *   object has been destroyed.\n */\nshaka.media.MediaSourceEngine.prototype.ended = function() {\n  return this.mediaSource_ ? this.mediaSource_.readyState == 'ended' : true;\n};\n\n\n/**\n * Gets the first timestamp in buffer for the given content type.\n *\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @return {?number} The timestamp in seconds, or null if nothing is buffered.\n */\nshaka.media.MediaSourceEngine.prototype.bufferStart = function(contentType) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  if (contentType == ContentType.TEXT) {\n    return this.textEngine_.bufferStart();\n  }\n  return shaka.media.TimeRangesUtils.bufferStart(\n      this.getBuffered_(contentType));\n};\n\n\n/**\n * Gets the last timestamp in buffer for the given content type.\n *\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @return {?number} The timestamp in seconds, or null if nothing is buffered.\n */\nshaka.media.MediaSourceEngine.prototype.bufferEnd = function(contentType) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  if (contentType == ContentType.TEXT) {\n    return this.textEngine_.bufferEnd();\n  }\n  return shaka.media.TimeRangesUtils.bufferEnd(this.getBuffered_(contentType));\n};\n\n\n/**\n * Determines if the given time is inside the buffered range of the given\n * content type.\n *\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @param {number} time Playhead time\n * @param {number=} smallGapLimit\n * @return {boolean}\n */\nshaka.media.MediaSourceEngine.prototype.isBuffered = function(\n    contentType, time, smallGapLimit) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  if (contentType == ContentType.TEXT) {\n    return this.textEngine_.isBuffered(time);\n  } else {\n    let buffered = this.getBuffered_(contentType);\n    return shaka.media.TimeRangesUtils.isBuffered(\n               buffered, time, smallGapLimit);\n  }\n};\n\n\n/**\n * Computes how far ahead of the given timestamp is buffered for the given\n * content type.\n *\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @param {number} time\n * @return {number} The amount of time buffered ahead in seconds.\n */\nshaka.media.MediaSourceEngine.prototype.bufferedAheadOf =\n    function(contentType, time) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  if (contentType == ContentType.TEXT) {\n    return this.textEngine_.bufferedAheadOf(time);\n  } else {\n    let buffered = this.getBuffered_(contentType);\n    return shaka.media.TimeRangesUtils.bufferedAheadOf(buffered, time);\n  }\n};\n\n\n/**\n * Fill in the given buffered info object with the buffered info that media\n * source knows about.\n *\n * @param {shaka.extern.BufferedInfo} info\n */\nshaka.media.MediaSourceEngine.prototype.getBufferedInfo = function(info) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  const getBufferedInfo = shaka.media.TimeRangesUtils.getBufferedInfo;\n  info.total = getBufferedInfo(this.video_.buffered);\n  info.audio = getBufferedInfo(this.getBuffered_(ContentType.AUDIO));\n  info.video = getBufferedInfo(this.getBuffered_(ContentType.VIDEO));\n  info.text = [];\n\n  if (this.textEngine_) {\n    const start = this.textEngine_.bufferStart();\n    const end = this.textEngine_.bufferEnd();\n\n    if (start != null && end != null) {\n      info.text.push({start: start, end: end});\n    }\n  }\n};\n\n\n/**\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @return {TimeRanges} The buffered ranges for the given content type, or\n *   null if the buffered ranges could not be obtained.\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.getBuffered_ = function(contentType) {\n  try {\n    return this.sourceBuffers_[contentType].buffered;\n  } catch (exception) {\n    if (contentType in this.sourceBuffers_) {\n      // Note: previous MediaSource errors may cause access to |buffered| to\n      // throw.\n      shaka.log.error('failed to get buffered range for ' + contentType,\n                      exception);\n    }\n    return null;\n  }\n};\n\n\n/**\n * Enqueue an operation to append data to the SourceBuffer.\n * Start and end times are needed for TextEngine, but not for MediaSource.\n * Start and end times may be null for initialization segments; if present they\n * are relative to the presentation timeline.\n *\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @param {!ArrayBuffer} data\n * @param {?number} startTime relative to the start of the presentation\n * @param {?number} endTime relative to the start of the presentation\n * @param {?boolean} hasClosedCaptions True if the buffer contains CEA closed\n * captions\n * @return {!Promise}\n */\nshaka.media.MediaSourceEngine.prototype.appendBuffer =\n    function(contentType, data, startTime, endTime, hasClosedCaptions) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  if (contentType == ContentType.TEXT) {\n    return this.textEngine_.appendBuffer(data, startTime, endTime);\n  } else if (this.transmuxers_[contentType]) {\n    return this.transmuxers_[contentType].transmux(data).then(\n        function(transmuxedData) {\n          // For HLS CEA-608/708 CLOSED-CAPTIONS, text data is embedded in the\n          // video stream, so textEngine may not have been initialized.\n          if (!this.textEngine_) {\n            this.reinitText('text/vtt');\n          }\n          // This doesn't work for native TS support (ex. Edge/Chromecast),\n          // since no transmuxing is needed for native TS.\n          if (transmuxedData.captions) {\n            const videoOffset =\n                this.sourceBuffers_[ContentType.VIDEO].timestampOffset;\n            this.textEngine_.storeAndAppendClosedCaptions(\n                transmuxedData.captions, startTime, endTime, videoOffset);\n          }\n          return this.enqueueOperation_(contentType,\n              this.append_.bind(this, contentType, transmuxedData.data.buffer));\n        }.bind(this));\n  } else if (hasClosedCaptions && window.muxjs) {\n    if (!this.textEngine_) {\n      this.reinitText('text/vtt');\n    }\n    // If it is the init segment for closed captions, initialize the closed\n    // caption parser.\n    if (startTime == null && endTime == null) {\n      this.captionParser_.init(data);\n    } else {\n      this.captionParser_.parseFrom(data, (captions) => {\n        if (captions.length) {\n          const videoOffset =\n              this.sourceBuffers_[ContentType.VIDEO].timestampOffset;\n          this.textEngine_.storeAndAppendClosedCaptions(\n              captions, startTime, endTime, videoOffset);\n        }\n      });\n    }\n    return this.enqueueOperation_(\n        contentType,\n        this.append_.bind(this, contentType, data));\n  } else {\n    return this.enqueueOperation_(\n        contentType,\n        this.append_.bind(this, contentType, data));\n  }\n};\n\n\n/**\n * Set the selected closed captions Id and language.\n *\n * @param {string} id\n */\nshaka.media.MediaSourceEngine.prototype.setSelectedClosedCaptionId =\n    function(id) {\n  const VIDEO = shaka.util.ManifestParserUtils.ContentType.VIDEO;\n  const videoBufferEndTime = this.bufferEnd(VIDEO) || 0;\n  this.textEngine_.setSelectedClosedCaptionId(id, videoBufferEndTime);\n};\n\n\n/**\n * Enqueue an operation to remove data from the SourceBuffer.\n *\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @param {number} startTime relative to the start of the presentation\n * @param {number} endTime relative to the start of the presentation\n * @return {!Promise}\n */\nshaka.media.MediaSourceEngine.prototype.remove =\n    function(contentType, startTime, endTime) {\n  // On IE11, this operation would be permitted, but would have no effect!\n  // See https://github.com/google/shaka-player/issues/251\n  goog.asserts.assert(endTime < Number.MAX_VALUE,\n      'remove() with MAX_VALUE or Infinity is not IE-compatible!');\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  if (contentType == ContentType.TEXT) {\n    return this.textEngine_.remove(startTime, endTime);\n  }\n  return this.enqueueOperation_(\n      contentType,\n      this.remove_.bind(this, contentType, startTime, endTime));\n};\n\n\n/**\n * Enqueue an operation to clear the SourceBuffer.\n *\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @return {!Promise}\n */\nshaka.media.MediaSourceEngine.prototype.clear = function(contentType) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  if (contentType == ContentType.TEXT) {\n    if (!this.textEngine_) {\n      return Promise.resolve();\n    }\n\n    // CaptionParser tracks the latest timestamp and uses this to filter\n    // for duplicate captions.  We do this ourselves, so we must reset\n    // the CaptionParser when we seek.  The best indicator of an\n    // unbuffered seek in MediaSourceEngine is clear().  This causes a\n    // small glitch when we change languages (which also calls clear()),\n    // where the first caption in the new language may be missing.\n    // TODO: Ask mux.js for a switch to remove this timestamp-tracking\n    // feature so that we can do away with these hacks.\n    this.captionParser_.reset();\n\n    return this.textEngine_.remove(0, Infinity);\n  }\n  // Note that not all platforms allow clearing to Infinity.\n  return this.enqueueOperation_(\n      contentType,\n      this.remove_.bind(this, contentType, 0, this.mediaSource_.duration));\n};\n\n\n/**\n * Enqueue an operation to flush the SourceBuffer.\n * This is a workaround for what we believe is a Chromecast bug.\n *\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @return {!Promise}\n */\nshaka.media.MediaSourceEngine.prototype.flush = function(contentType) {\n  // Flush the pipeline.  Necessary on Chromecast, even though we have removed\n  // everything.\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  if (contentType == ContentType.TEXT) {\n    // Nothing to flush for text.\n    return Promise.resolve();\n  }\n  return this.enqueueOperation_(\n      contentType,\n      this.flush_.bind(this, contentType));\n};\n\n\n/**\n * Sets the timestamp offset and append window end for the given content type.\n *\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @param {number} timestampOffset The timestamp offset.  Segments which start\n *   at time t will be inserted at time t + timestampOffset instead.  This\n *   value does not affect segments which have already been inserted.\n * @param {number} appendWindowStart The timestamp to set the append window\n *   start to.  For future appends, frames/samples with timestamps less than\n *   this value will be dropped.\n * @param {number} appendWindowEnd The timestamp to set the append window end\n *   to.  For future appends, frames/samples with timestamps greater than this\n *   value will be dropped.\n * @return {!Promise}\n */\nshaka.media.MediaSourceEngine.prototype.setStreamProperties = function(\n    contentType, timestampOffset, appendWindowStart, appendWindowEnd) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  if (contentType == ContentType.TEXT) {\n    this.textEngine_.setTimestampOffset(timestampOffset);\n    this.textEngine_.setAppendWindow(appendWindowStart, appendWindowEnd);\n    return Promise.resolve();\n  }\n\n  return Promise.all([\n    // Queue an abort() to help MSE splice together overlapping segments.\n    // We set appendWindowEnd when we change periods in DASH content, and the\n    // period transition may result in overlap.\n    //\n    // An abort() also helps with MPEG2-TS.  When we append a TS segment, we\n    // always enter a PARSING_MEDIA_SEGMENT state and we can't change the\n    // timestamp offset.  By calling abort(), we reset the state so we can\n    // set it.\n    this.enqueueOperation_(\n        contentType,\n        this.abort_.bind(this, contentType)),\n    this.enqueueOperation_(\n        contentType,\n        this.setTimestampOffset_.bind(this, contentType, timestampOffset)),\n    this.enqueueOperation_(\n        contentType,\n        this.setAppendWindow_.bind(\n            this, contentType, appendWindowStart, appendWindowEnd)),\n  ]);\n};\n\n\n/**\n * @param {string=} reason Valid reasons are 'network' and 'decode'.\n * @return {!Promise}\n * @see http://w3c.github.io/media-source/#idl-def-EndOfStreamError\n */\nshaka.media.MediaSourceEngine.prototype.endOfStream = function(reason) {\n  return this.enqueueBlockingOperation_(function() {\n    // Chrome won't let us pass undefined, but it will let us omit the\n    // argument.  Firefox does not have this problem.\n    // TODO: File a bug about this.\n    if (reason) {\n      this.mediaSource_.endOfStream(reason);\n    } else {\n      this.mediaSource_.endOfStream();\n    }\n  }.bind(this));\n};\n\n\n/**\n * We only support increasing duration at this time.  Decreasing duration\n * causes the MSE removal algorithm to run, which results in an 'updateend'\n * event.  Supporting this scenario would be complicated, and is not currently\n * needed.\n *\n * @param {number} duration\n * @return {!Promise}\n */\nshaka.media.MediaSourceEngine.prototype.setDuration = function(duration) {\n  goog.asserts.assert(\n      isNaN(this.mediaSource_.duration) ||\n          this.mediaSource_.duration <= duration,\n      'duration cannot decrease: ' + this.mediaSource_.duration + ' -> ' +\n          duration);\n  return this.enqueueBlockingOperation_(function() {\n    this.mediaSource_.duration = duration;\n  }.bind(this));\n};\n\n\n/**\n * Get the current MediaSource duration.\n *\n * @return {number}\n */\nshaka.media.MediaSourceEngine.prototype.getDuration = function() {\n  return this.mediaSource_.duration;\n};\n\n\n/**\n * Append data to the SourceBuffer.\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @param {!ArrayBuffer} data\n * @throws QuotaExceededError if the browser's buffer is full\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.append_ =\n    function(contentType, data) {\n  // This will trigger an 'updateend' event.\n  this.sourceBuffers_[contentType].appendBuffer(data);\n};\n\n\n/**\n * Remove data from the SourceBuffer.\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @param {number} startTime relative to the start of the presentation\n * @param {number} endTime relative to the start of the presentation\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.remove_ =\n    function(contentType, startTime, endTime) {\n  if (endTime <= startTime) {\n    // Ignore removal of inverted or empty ranges.\n    // Fake 'updateend' event to resolve the operation.\n    this.onUpdateEnd_(contentType);\n    return;\n  }\n\n  // This will trigger an 'updateend' event.\n  this.sourceBuffers_[contentType].remove(startTime, endTime);\n};\n\n\n/**\n * Call abort() on the SourceBuffer.\n * This resets MSE's last_decode_timestamp on all track buffers, which should\n * trigger the splicing logic for overlapping segments.\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.abort_ = function(contentType) {\n  // Save the append window, which is reset on abort().\n  let appendWindowStart = this.sourceBuffers_[contentType].appendWindowStart;\n  let appendWindowEnd = this.sourceBuffers_[contentType].appendWindowEnd;\n\n  // This will not trigger an 'updateend' event, since nothing is happening.\n  // This is only to reset MSE internals, not to abort an actual operation.\n  this.sourceBuffers_[contentType].abort();\n\n  // Restore the append window.\n  this.sourceBuffers_[contentType].appendWindowStart = appendWindowStart;\n  this.sourceBuffers_[contentType].appendWindowEnd = appendWindowEnd;\n\n  // Fake an 'updateend' event to resolve the operation.\n  this.onUpdateEnd_(contentType);\n};\n\n\n/**\n * Nudge the playhead to force the media pipeline to be flushed.\n * This seems to be necessary on Chromecast to get new content to replace old\n * content.\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.flush_ = function(contentType) {\n  // Never use flush_ if there's data.  It causes a hiccup in playback.\n  goog.asserts.assert(\n      this.video_.buffered.length == 0,\n      'MediaSourceEngine.flush_ should only be used after clearing all data!');\n\n  // Seeking forces the pipeline to be flushed.\n  this.video_.currentTime -= 0.001;\n\n  // Fake an 'updateend' event to resolve the operation.\n  this.onUpdateEnd_(contentType);\n};\n\n\n/**\n * Set the SourceBuffer's timestamp offset.\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @param {number} timestampOffset\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.setTimestampOffset_ =\n    function(contentType, timestampOffset) {\n  // Work around for https://github.com/google/shaka-player/issues/1281:\n  // TODO(https://bit.ly/2ttKiBU): follow up when this is fixed in Edge\n  if (timestampOffset < 0) {\n    // Try to prevent rounding errors in Edge from removing the first keyframe.\n    timestampOffset += 0.001;\n  }\n\n  this.sourceBuffers_[contentType].timestampOffset = timestampOffset;\n\n  // Fake an 'updateend' event to resolve the operation.\n  this.onUpdateEnd_(contentType);\n};\n\n\n/**\n * Set the SourceBuffer's append window end.\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @param {number} appendWindowStart\n * @param {number} appendWindowEnd\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.setAppendWindow_ =\n    function(contentType, appendWindowStart, appendWindowEnd) {\n  // You can't set start > end, so first set start to 0, then set the new end,\n  // then set the new start.  That way, there are no intermediate states which\n  // are invalid.\n  this.sourceBuffers_[contentType].appendWindowStart = 0;\n  this.sourceBuffers_[contentType].appendWindowEnd = appendWindowEnd;\n  this.sourceBuffers_[contentType].appendWindowStart = appendWindowStart;\n\n  // Fake an 'updateend' event to resolve the operation.\n  this.onUpdateEnd_(contentType);\n};\n\n\n/**\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @param {!Event} event\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.onError_ =\n    function(contentType, event) {\n  let operation = this.queues_[contentType][0];\n  goog.asserts.assert(operation, 'Spurious error event!');\n  goog.asserts.assert(!this.sourceBuffers_[contentType].updating,\n                      'SourceBuffer should not be updating on error!');\n  let code = this.video_.error ? this.video_.error.code : 0;\n  operation.p.reject(new shaka.util.Error(\n      shaka.util.Error.Severity.CRITICAL,\n      shaka.util.Error.Category.MEDIA,\n      shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_FAILED,\n      code));\n  // Do not pop from queue.  An 'updateend' event will fire next, and to avoid\n  // synchronizing these two event handlers, we will allow that one to pop from\n  // the queue as normal.  Note that because the operation has already been\n  // rejected, the call to resolve() in the 'updateend' handler will have no\n  // effect.\n};\n\n\n/**\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.onUpdateEnd_ = function(contentType) {\n  let operation = this.queues_[contentType][0];\n  goog.asserts.assert(operation, 'Spurious updateend event!');\n  if (!operation) return;\n  goog.asserts.assert(!this.sourceBuffers_[contentType].updating,\n                      'SourceBuffer should not be updating on updateend!');\n  operation.p.resolve();\n  this.popFromQueue_(contentType);\n};\n\n\n/**\n * Enqueue an operation and start it if appropriate.\n *\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @param {function()} start\n * @return {!Promise}\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.enqueueOperation_ =\n    function(contentType, start) {\n  if (this.destroyed_) return Promise.reject();\n\n  let operation = {\n    start: start,\n    p: new shaka.util.PublicPromise(),\n  };\n  this.queues_[contentType].push(operation);\n\n  if (this.queues_[contentType].length == 1) {\n    try {\n      operation.start();\n    } catch (exception) {\n      if (exception.name == 'QuotaExceededError') {\n        operation.p.reject(new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MEDIA,\n            shaka.util.Error.Code.QUOTA_EXCEEDED_ERROR,\n            contentType));\n      } else {\n        operation.p.reject(new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MEDIA,\n            shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_THREW,\n            exception));\n      }\n      this.popFromQueue_(contentType);\n    }\n  }\n  return operation.p;\n};\n\n\n/**\n * Enqueue an operation which must block all other operations on all\n * SourceBuffers.\n *\n * @param {function()} run\n * @return {!Promise}\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.enqueueBlockingOperation_ =\n    function(run) {\n  if (this.destroyed_) return Promise.reject();\n\n  let allWaiters = [];\n\n  // Enqueue a 'wait' operation onto each queue.\n  // This operation signals its readiness when it starts.\n  // When all wait operations are ready, the real operation takes place.\n  for (let contentType in this.sourceBuffers_) {\n    let ready = new shaka.util.PublicPromise();\n    let operation = {\n      start: function(ready) { ready.resolve(); }.bind(null, ready),\n      p: ready,\n    };\n\n    this.queues_[contentType].push(operation);\n    allWaiters.push(ready);\n\n    if (this.queues_[contentType].length == 1) {\n      operation.start();\n    }\n  }\n\n  // Return a Promise to the real operation, which waits to begin until there\n  // are no other in-progress operations on any SourceBuffers.\n  return Promise.all(allWaiters).then(function() {\n    if (goog.DEBUG) {\n      // If we did it correctly, nothing is updating.\n      for (let contentType in this.sourceBuffers_) {\n        goog.asserts.assert(\n            this.sourceBuffers_[contentType].updating == false,\n            'SourceBuffers should not be updating after a blocking op!');\n      }\n    }\n\n    let ret;\n    // Run the real operation, which is synchronous.\n    try {\n      run();\n    } catch (exception) {\n      ret = Promise.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_THREW,\n          exception));\n    }\n\n    // Unblock the queues.\n    for (let contentType in this.sourceBuffers_) {\n      this.popFromQueue_(contentType);\n    }\n\n    return ret;\n  }.bind(this), function(error) {\n    // One of the waiters failed, which means we've been destroyed.\n    goog.asserts.assert(this.destroyed_, 'Should be destroyed by now');\n    // We haven't popped from the queue.  Canceled waiters have been removed by\n    // destroy.  What's left now should just be resolved waiters.  In uncompiled\n    // mode, we will maintain good hygiene and make sure the assert at the end\n    // of destroy passes.  In compiled mode, the queues are wiped in destroy.\n    if (goog.DEBUG) {\n      for (let contentType in this.sourceBuffers_) {\n        if (this.queues_[contentType].length) {\n          goog.asserts.assert(\n              this.queues_[contentType].length == 1,\n              'Should be at most one item in queue!');\n          goog.asserts.assert(\n              allWaiters.includes(this.queues_[contentType][0].p),\n              'The item in queue should be one of our waiters!');\n          this.queues_[contentType].shift();\n        }\n      }\n    }\n    throw error;\n  }.bind(this));\n};\n\n\n/**\n * Pop from the front of the queue and start a new operation.\n * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.popFromQueue_ = function(contentType) {\n  // Remove the in-progress operation, which is now complete.\n  this.queues_[contentType].shift();\n  // Retrieve the next operation, if any, from the queue and start it.\n  let next = this.queues_[contentType][0];\n  if (next) {\n    try {\n      next.start();\n    } catch (exception) {\n      next.p.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_THREW,\n          exception));\n      this.popFromQueue_(contentType);\n    }\n  }\n};\n\n\n/**\n * @return {!shaka.extern.TextDisplayer}\n */\nshaka.media.MediaSourceEngine.prototype.getTextDisplayer = function() {\n  goog.asserts.assert(\n      this.textDisplayer_,\n      'TextDisplayer should only be null when this is destroyed');\n\n  return this.textDisplayer_;\n};\n\n/**\n * @param {!shaka.extern.TextDisplayer} textDisplayer\n */\nshaka.media.MediaSourceEngine.prototype.setTextDisplayer =\n    function(textDisplayer) {\n      const oldTextDisplayer = this.textDisplayer_;\n      this.textDisplayer_ = textDisplayer;\n      if (oldTextDisplayer) {\n        textDisplayer.setTextVisibility(oldTextDisplayer.isTextVisible());\n        oldTextDisplayer.destroy();\n      }\n      if (this.textEngine_) {\n        this.textEngine_.setDisplayer(textDisplayer);\n      }\n    };\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.LanguageUtils');\n\ngoog.require('goog.asserts');\n\n\n/**\n * @summary A set of language utility functions.\n * @final\n */\nshaka.util.LanguageUtils = class {\n  /**\n   * Check if |locale1| and |locale2| are locale-compatible.\n   *\n   * Locale-compatible is defined as all components in each locale match. Since\n   * we only respect the language and region components, we only check that\n   * the language and region components match.\n   *\n   * Examples:\n   *  Locale A | Locale B | Locale Compatible\n   *  ---------------------------------------\n   *  en-US    | en-US    | true\n   *  en       | en-US    | false\n   *  en-US    | en-CA    | false\n   *\n   * @param {string} locale1\n   * @param {string} locale2\n   * @return {boolean}\n   */\n  static areLocaleCompatible(locale1, locale2) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Even through they SHOULD already be normalized, let's just be safe and\n    // do it again.\n    locale1 = LanguageUtils.normalize(locale1);\n    locale2 = LanguageUtils.normalize(locale2);\n\n    return locale1 == locale2;\n  }\n\n  /**\n   * Check if |locale1| and |locale2| are language-compatible.\n   *\n   * Language compatible is when the language component of each locale matches.\n   * This means that no matter what region they have (or don't have) as long as\n   * the language components match, they are language-compatible.\n   *\n   * Examples:\n   *  Locale A | Locale B | Language-Compatible\n   *  -----------------------------------------\n   *  en-US    | en-US    | true\n   *  en-US    | en       | true\n   *  en-US    | en-CA    | true\n   *  en-CA    | fr-CA    | false\n   *\n   * @param {string} locale1\n   * @param {string} locale2\n   * @return {boolean}\n   */\n  static areLanguageCompatible(locale1, locale2) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Even through they SHOULD already be normalized, let's just be safe and\n    // do it again.\n    locale1 = LanguageUtils.normalize(locale1);\n    locale2 = LanguageUtils.normalize(locale2);\n\n    // Get all components. This should only be language and region\n    // since we do not support dialect.\n    /** @type {!Array.<string>} */\n    const locale1Components = LanguageUtils.disassembleLocale_(locale1);\n    /** @type {!Array.<string>} */\n    const locale2Components = LanguageUtils.disassembleLocale_(locale2);\n\n    // We are language compatible if we have the same language.\n    return locale1Components[0] == locale2Components[0];\n  }\n\n  /**\n   * Check if |possibleParent| is the parent locale of |possibleChild|. Because\n   * we do not support dialects, the parent-child relationship is a lot simpler.\n   * In a parent child relationship:\n   *    - The parent and child have the same language-component\n   *    - The parent has no region-component\n   *    - The child has a region-component\n   *\n   * Example:\n   *  Locale A | Locale B | Is A The parent of B?\n   *  --------------------------------------------\n   *  en-US    | en-US    | no\n   *  en-US    | en       | no\n   *  en       | en-US    | yes\n   *  en       | en       | no\n   *  en       | fr       | no\n   *\n   * @param {string} possibleParent\n   * @param {string} possibleChild\n   * @return {boolean}\n   */\n  static isParentOf(possibleParent, possibleChild) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Even through they SHOULD already be normalized, let's just be safe and\n    // do it again.\n    possibleParent = LanguageUtils.normalize(possibleParent);\n    possibleChild = LanguageUtils.normalize(possibleChild);\n\n    // Get all components. This should only be language and region\n    // since we do not support dialect.\n    /** @type {!Array.<string>} */\n    const possibleParentComponents =\n        LanguageUtils.disassembleLocale_(possibleParent);\n    /** @type {!Array.<string>} */\n    const possibleChildComponents =\n        LanguageUtils.disassembleLocale_(possibleChild);\n\n    return possibleParentComponents[0] == possibleChildComponents[0] &&\n           possibleParentComponents.length == 1 &&\n           possibleChildComponents.length == 2;\n  }\n\n  /**\n   * Check if |localeA| shares the same parent with |localeB|. Since we don't\n   * support dialect, we will only look at language and region. For two locales\n   * to be siblings:\n   *    - Both must have language-components\n   *    - Both must have region-components\n   *    - Both must have the same language-component\n   *\n   * Example:\n   *  Locale A | Locale B | Siblings?\n   *  --------------------------------------------\n   *  en-US    | en-US    | yes\n   *  en-US    | en-CA    | yes\n   *  en-US    | en       | no\n   *  en       | en-US    | no\n   *  en       | en       | no\n   *  en       | fr       | no\n   *\n   * @param {string} localeA\n   * @param {string} localeB\n   * @return {boolean}\n   */\n  static isSiblingOf(localeA, localeB) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Even through they SHOULD already be normalized, let's just be safe and\n    // do it again.\n    localeA = LanguageUtils.normalize(localeA);\n    localeB = LanguageUtils.normalize(localeB);\n\n    // Get all components. This should only be language and region\n    // since we do not support dialect.\n    /** @type {!Array.<string>} */\n    const localeAComponents = LanguageUtils.disassembleLocale_(localeA);\n    /** @type {!Array.<string>} */\n    const localeBComponents = LanguageUtils.disassembleLocale_(localeB);\n\n    return localeAComponents.length == 2 &&\n           localeBComponents.length == 2 &&\n           localeAComponents[0] == localeBComponents[0];\n  }\n\n  /**\n   * Normalize a locale. This will take a locale and canonicalize it to a state\n   * that we are prepared to work with.\n   *\n   * We only support with:\n   *   - language\n   *   - language-REGION\n   *\n   * If given a dialect, we will discard it. We will convert any 3-character\n   * codes to 2-character codes. We will force language codes to lowercase and\n   * region codes to uppercase.\n   *\n   * @param {string} locale\n   * @return {string}\n   */\n  static normalize(locale) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    const components = locale.split('-');\n\n    // We are only going to use the language and the region. If there was\n    // a dialect or anything else, we are throwing it a way.\n    let language = components[0] || '';\n    let region = components[1] || '';\n\n    // Convert the language to lower case. It is standard for the language code\n    // to be in lower case, but it will also make the map look-up easier.\n    language = language.toLowerCase();\n    language = LanguageUtils.isoMap_.get(language) || language;\n\n    // Convert the region to upper case. It is standard for the region to be in\n    // upper case. If there is no upper code, then it will be an empty string\n    // and this will be a no-op.\n    region = region.toUpperCase();\n\n    return region ?\n           language + '-' + region :\n           language;\n  }\n\n  /**\n   * Check if two language codes are siblings. Language codes are siblings if\n   * they share the same base language while neither one is the base language.\n   *\n   * For example, \"en-US\" and \"en-CA\" are siblings but \"en-US\" and \"en\" are not\n   * siblings.\n   *\n   * @param {string} a\n   * @param {string} b\n   * @return {boolean}\n   */\n  static areSiblings(a, b) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    const baseA = LanguageUtils.getBase(a);\n    const baseB = LanguageUtils.getBase(b);\n\n    return a != baseA && b != baseB && baseA == baseB;\n  }\n\n  /**\n   * Get the normalized base language for a language code.\n   *\n   * @param {string} lang\n   * @return {string}\n   */\n  static getBase(lang) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    const splitAt = lang.indexOf('-');\n    let major;\n\n    if (splitAt >= 0) {\n      major = lang.substring(0, splitAt);\n    } else {\n      major = lang;\n    }\n\n    // Convert the major code to lower case. It is standard for the major code\n    // to be in lower case, but it will also make the map look-up easier.\n    major = major.toLowerCase();\n    major = LanguageUtils.isoMap_.get(major) || major;\n\n    return major;\n  }\n\n  /**\n   * Get the normalized language of the given text stream. Will return 'und' if\n   * a language is not found on the text stream.\n   *\n   * This should always be used to get the language from a text stream.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {string}\n   */\n  static getLocaleForText(stream) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    goog.asserts.assert(\n        stream.type == ContentType.TEXT,\n        'Can only get language from text streams');\n\n    const language = stream.language || 'und';\n    return LanguageUtils.normalize(language);\n  }\n\n  /**\n   * Get the normalized locale for the given variant. This will look through\n   * the variant to find the locale that represents the content in the variant.\n   * This will return 'und' if no language can be found.\n   *\n   * This should always be used to get the locale from a variant.\n   *\n   * @param {shaka.extern.Variant} variant\n   * @return {string}\n   */\n  static getLocaleForVariant(variant) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Our preference order is:\n    //  1. Variant\n    //  2. Audio Stream\n    //  3. Video Stream\n    //\n    // We are going to consider all falsy strings to be invalid locales, this\n    // will include empty strings.\n    if (variant.language) {\n      return LanguageUtils.normalize(variant.language);\n    }\n\n    if (variant.audio && variant.audio.language) {\n      return LanguageUtils.normalize(variant.audio.language);\n    }\n\n    if (variant.video && variant.video.language) {\n      return LanguageUtils.normalize(variant.video.language);\n    }\n\n    // No language was found, but we still want to return a valid string.\n    return 'und';\n  }\n\n  /**\n   * Find the locale in |searchSpace| that comes closest to |target|. If no\n   * locale is found to be close to |target|, then |null| will be returned.\n   *\n   * @param {string} target\n   * @param {!Iterable.<string>} searchSpace\n   * @return {?string}\n   */\n  static findClosestLocale(target, searchSpace) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    /** @type {string} */\n    const safeTarget = LanguageUtils.normalize(target);\n    /** @type {!Set.<string>} */\n    const safeSearchSpace = new Set();\n    for (const option of searchSpace) {\n      safeSearchSpace.add(LanguageUtils.normalize(option));\n    }\n\n    // Preference 1 - The option is an exact match. For example, \"en-US\" is an\n    //    exact match of \"en-US\". So if there is an option that is an exact\n    //    match, it would be the best match possible.\n    for (const option of safeSearchSpace) {\n      if (option == safeTarget) {\n        return option;\n      }\n    }\n\n    // Preference 2 - The option is the parent of the target. For example,\n    //    \"en\" is the parent of \"en-US\". So if there is an option with\n    //    \"en\", it should be good enough when our preference is \"en-US\".\n    for (const option of safeSearchSpace) {\n      if (LanguageUtils.isParentOf(option, safeTarget)) {\n        return option;\n      }\n    }\n\n    // Preference 3 - The option is a sibling of the target. For example,\n    //    \"en-US\" is a sibling of \"en-CA\". So if there is an option with\n    //    \"en_CA\", it should be good enough when our preference is \"en-US\".\n    for (const option of safeSearchSpace) {\n      if (LanguageUtils.isSiblingOf(option, safeTarget)) {\n        return option;\n      }\n    }\n\n    // Preference 4 - The option is a child of the target. For example,\n    //    \"en-US\" is the child of \"en\". SO it there is an option with\n    //    \"en-US\", it should be good enough when our preference is \"en\".\n    for (const option of safeSearchSpace) {\n      if (LanguageUtils.isParentOf(safeTarget, option)) {\n        return option;\n      }\n    }\n\n    // Failed to find anything.\n    return null;\n  }\n\n  /**\n   * Take a locale string and break it into its component. Check that each\n   * component matches what we would expect internally for locales. This\n   * should ONLY be used to verify locales that have been normalized.\n   *\n   * @param {string} locale\n   * @return {!Array.<string>}\n   * @private\n   */\n  static disassembleLocale_(locale) {\n    const components = locale.split('-');\n\n    goog.asserts.assert(\n        components.length <= 2,\n        [\n          'Locales should not have more than 2 components. ',\n          locale,\n          ' has too many components.',\n        ].join());\n\n    return components;\n  }\n};\n\n\n/**\n * A map from 3-letter language codes (ISO 639-2) to 2-letter language codes\n * (ISO 639-1) for all languages which have both in the registry.\n *\n * @const {!Map.<string, string>}\n * @private\n */\nshaka.util.LanguageUtils.isoMap_ = new Map([\n  ['aar', 'aa'], ['abk', 'ab'], ['afr', 'af'], ['aka', 'ak'], ['alb', 'sq'],\n  ['amh', 'am'], ['ara', 'ar'], ['arg', 'an'], ['arm', 'hy'], ['asm', 'as'],\n  ['ava', 'av'], ['ave', 'ae'], ['aym', 'ay'], ['aze', 'az'], ['bak', 'ba'],\n  ['bam', 'bm'], ['baq', 'eu'], ['bel', 'be'], ['ben', 'bn'], ['bih', 'bh'],\n  ['bis', 'bi'], ['bod', 'bo'], ['bos', 'bs'], ['bre', 'br'], ['bul', 'bg'],\n  ['bur', 'my'], ['cat', 'ca'], ['ces', 'cs'], ['cha', 'ch'], ['che', 'ce'],\n  ['chi', 'zh'], ['chu', 'cu'], ['chv', 'cv'], ['cor', 'kw'], ['cos', 'co'],\n  ['cre', 'cr'], ['cym', 'cy'], ['cze', 'cs'], ['dan', 'da'], ['deu', 'de'],\n  ['div', 'dv'], ['dut', 'nl'], ['dzo', 'dz'], ['ell', 'el'], ['eng', 'en'],\n  ['epo', 'eo'], ['est', 'et'], ['eus', 'eu'], ['ewe', 'ee'], ['fao', 'fo'],\n  ['fas', 'fa'], ['fij', 'fj'], ['fin', 'fi'], ['fra', 'fr'], ['fre', 'fr'],\n  ['fry', 'fy'], ['ful', 'ff'], ['geo', 'ka'], ['ger', 'de'], ['gla', 'gd'],\n  ['gle', 'ga'], ['glg', 'gl'], ['glv', 'gv'], ['gre', 'el'], ['grn', 'gn'],\n  ['guj', 'gu'], ['hat', 'ht'], ['hau', 'ha'], ['heb', 'he'], ['her', 'hz'],\n  ['hin', 'hi'], ['hmo', 'ho'], ['hrv', 'hr'], ['hun', 'hu'], ['hye', 'hy'],\n  ['ibo', 'ig'], ['ice', 'is'], ['ido', 'io'], ['iii', 'ii'], ['iku', 'iu'],\n  ['ile', 'ie'], ['ina', 'ia'], ['ind', 'id'], ['ipk', 'ik'], ['isl', 'is'],\n  ['ita', 'it'], ['jav', 'jv'], ['jpn', 'ja'], ['kal', 'kl'], ['kan', 'kn'],\n  ['kas', 'ks'], ['kat', 'ka'], ['kau', 'kr'], ['kaz', 'kk'], ['khm', 'km'],\n  ['kik', 'ki'], ['kin', 'rw'], ['kir', 'ky'], ['kom', 'kv'], ['kon', 'kg'],\n  ['kor', 'ko'], ['kua', 'kj'], ['kur', 'ku'], ['lao', 'lo'], ['lat', 'la'],\n  ['lav', 'lv'], ['lim', 'li'], ['lin', 'ln'], ['lit', 'lt'], ['ltz', 'lb'],\n  ['lub', 'lu'], ['lug', 'lg'], ['mac', 'mk'], ['mah', 'mh'], ['mal', 'ml'],\n  ['mao', 'mi'], ['mar', 'mr'], ['may', 'ms'], ['mkd', 'mk'], ['mlg', 'mg'],\n  ['mlt', 'mt'], ['mon', 'mn'], ['mri', 'mi'], ['msa', 'ms'], ['mya', 'my'],\n  ['nau', 'na'], ['nav', 'nv'], ['nbl', 'nr'], ['nde', 'nd'], ['ndo', 'ng'],\n  ['nep', 'ne'], ['nld', 'nl'], ['nno', 'nn'], ['nob', 'nb'], ['nor', 'no'],\n  ['nya', 'ny'], ['oci', 'oc'], ['oji', 'oj'], ['ori', 'or'], ['orm', 'om'],\n  ['oss', 'os'], ['pan', 'pa'], ['per', 'fa'], ['pli', 'pi'], ['pol', 'pl'],\n  ['por', 'pt'], ['pus', 'ps'], ['que', 'qu'], ['roh', 'rm'], ['ron', 'ro'],\n  ['rum', 'ro'], ['run', 'rn'], ['rus', 'ru'], ['sag', 'sg'], ['san', 'sa'],\n  ['sin', 'si'], ['slk', 'sk'], ['slo', 'sk'], ['slv', 'sl'], ['sme', 'se'],\n  ['smo', 'sm'], ['sna', 'sn'], ['snd', 'sd'], ['som', 'so'], ['sot', 'st'],\n  ['spa', 'es'], ['sqi', 'sq'], ['srd', 'sc'], ['srp', 'sr'], ['ssw', 'ss'],\n  ['sun', 'su'], ['swa', 'sw'], ['swe', 'sv'], ['tah', 'ty'], ['tam', 'ta'],\n  ['tat', 'tt'], ['tel', 'te'], ['tgk', 'tg'], ['tgl', 'tl'], ['tha', 'th'],\n  ['tib', 'bo'], ['tir', 'ti'], ['ton', 'to'], ['tsn', 'tn'], ['tso', 'ts'],\n  ['tuk', 'tk'], ['tur', 'tr'], ['twi', 'tw'], ['uig', 'ug'], ['ukr', 'uk'],\n  ['urd', 'ur'], ['uzb', 'uz'], ['ven', 've'], ['vie', 'vi'], ['vol', 'vo'],\n  ['wel', 'cy'], ['wln', 'wa'], ['wol', 'wo'], ['xho', 'xh'], ['yid', 'yi'],\n  ['yor', 'yo'], ['zha', 'za'], ['zho', 'zh'], ['zul', 'zu'],\n]);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.StreamUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.MediaSourceEngine');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\n\n\n/**\n * @namespace shaka.util.StreamUtils\n * @summary A set of utility functions for dealing with Streams and Manifests.\n */\n\n\n/**\n * @param {shaka.extern.Variant} variant\n * @param {shaka.extern.Restrictions} restrictions\n *   Configured restrictions from the user.\n * @param {{width: number, height: number}} maxHwRes\n *   The maximum resolution the hardware can handle.\n *   This is applied separately from user restrictions because the setting\n *   should not be easily replaced by the user's configuration.\n * @return {boolean}\n */\nshaka.util.StreamUtils.meetsRestrictions = function(\n    variant, restrictions, maxHwRes) {\n  /** @type {function(number, number, number):boolean} */\n  const inRange = (x, min, max) => {\n    return x >= min && x <= max;\n  };\n\n  const video = variant.video;\n\n  // |video.width| and |video.height| can be undefined, which breaks\n  // the math, so make sure they are there first.\n  if (video && video.width && video.height) {\n    if (!inRange(video.width,\n                 restrictions.minWidth,\n                 Math.min(restrictions.maxWidth, maxHwRes.width))) {\n      return false;\n    }\n\n    if (!inRange(video.height,\n                 restrictions.minHeight,\n                 Math.min(restrictions.maxHeight, maxHwRes.height))) {\n      return false;\n    }\n\n    if (!inRange(video.width * video.height,\n                 restrictions.minPixels,\n                 restrictions.maxPixels)) {\n      return false;\n    }\n  }\n\n  if (!inRange(variant.bandwidth,\n               restrictions.minBandwidth,\n               restrictions.maxBandwidth)) {\n    return false;\n  }\n\n  return true;\n};\n\n\n/**\n * @param {!Array.<shaka.extern.Variant>} variants\n * @param {shaka.extern.Restrictions} restrictions\n * @param {{width: number, height: number}} maxHwRes\n * @return {boolean} Whether the tracks changed.\n */\nshaka.util.StreamUtils.applyRestrictions =\n    function(variants, restrictions, maxHwRes) {\n  let tracksChanged = false;\n\n  variants.forEach((variant) => {\n    let originalAllowed = variant.allowedByApplication;\n    variant.allowedByApplication = shaka.util.StreamUtils.meetsRestrictions(\n        variant, restrictions, maxHwRes);\n\n    if (originalAllowed != variant.allowedByApplication) {\n      tracksChanged = true;\n    }\n  });\n\n  return tracksChanged;\n};\n\n\n/**\n * Alters the given Period to filter out any unplayable streams.\n *\n * @param {shaka.media.DrmEngine} drmEngine\n * @param {?shaka.extern.Stream} activeAudio\n * @param {?shaka.extern.Stream} activeVideo\n * @param {shaka.extern.Period} period\n */\nshaka.util.StreamUtils.filterNewPeriod = function(\n    drmEngine, activeAudio, activeVideo, period) {\n  const StreamUtils = shaka.util.StreamUtils;\n\n  if (activeAudio) {\n    goog.asserts.assert(StreamUtils.isAudio(activeAudio),\n                        'Audio streams must have the audio type.');\n  }\n\n  if (activeVideo) {\n    goog.asserts.assert(StreamUtils.isVideo(activeVideo),\n                        'Video streams must have the video type.');\n  }\n\n  // Filter variants.\n  period.variants = period.variants.filter((variant) => {\n    if (drmEngine && drmEngine.initialized()) {\n      if (!drmEngine.supportsVariant(variant)) {\n        shaka.log.debug('Dropping variant - not compatible with key system',\n                        variant);\n        return false;\n      }\n    }\n\n    const audio = variant.audio;\n    const video = variant.video;\n\n    if (audio && !shaka.media.MediaSourceEngine.isStreamSupported(audio)) {\n      shaka.log.debug('Dropping variant - audio not compatible with platform',\n                      StreamUtils.getStreamSummaryString_(audio));\n      return false;\n    }\n\n    if (video && !shaka.media.MediaSourceEngine.isStreamSupported(video)) {\n      shaka.log.debug('Dropping variant - video not compatible with platform',\n                      StreamUtils.getStreamSummaryString_(video));\n      return false;\n    }\n\n    if (audio && activeAudio) {\n      if (!StreamUtils.areStreamsCompatible_(audio, activeAudio)) {\n        shaka.log.debug('Droping variant - not compatible with active audio',\n                        'active audio',\n                        StreamUtils.getStreamSummaryString_(activeAudio),\n                        'variant.audio',\n                        StreamUtils.getStreamSummaryString_(audio));\n        return false;\n      }\n    }\n\n    if (video && activeVideo) {\n      if (!StreamUtils.areStreamsCompatible_(video, activeVideo)) {\n        shaka.log.debug('Droping variant - not compatible with active video',\n                        'active video',\n                        StreamUtils.getStreamSummaryString_(activeVideo),\n                        'variant.video',\n                        StreamUtils.getStreamSummaryString_(video));\n        return false;\n      }\n    }\n\n    return true;\n  });\n\n  // Filter text streams.\n  period.textStreams = period.textStreams.filter(function(stream) {\n    let fullMimeType = shaka.util.MimeUtils.getFullType(\n        stream.mimeType, stream.codecs);\n    let keep = shaka.text.TextEngine.isTypeSupported(fullMimeType);\n\n    if (!keep) {\n      shaka.log.debug('Dropping text stream. Is not supported by the ' +\n                      'platform.', stream);\n    }\n\n    return keep;\n  });\n};\n\n\n/**\n * @param {shaka.extern.Stream} s0\n * @param {shaka.extern.Stream} s1\n * @return {boolean}\n * @private\n */\nshaka.util.StreamUtils.areStreamsCompatible_ = function(s0, s1) {\n  // Basic mime types and basic codecs need to match.\n  // For example, we can't adapt between WebM and MP4,\n  // nor can we adapt between mp4a.* to ec-3.\n  // We can switch between text types on the fly,\n  // so don't run this check on text.\n  if (s0.mimeType != s1.mimeType) {\n    return false;\n  }\n\n  if (s0.codecs.split('.')[0] != s1.codecs.split('.')[0]) {\n    return false;\n  }\n\n  return true;\n};\n\n\n/**\n * @param {shaka.extern.Variant} variant\n * @return {shaka.extern.Track}\n */\nshaka.util.StreamUtils.variantToTrack = function(variant) {\n  /** @type {?shaka.extern.Stream} */\n  let audio = variant.audio;\n  /** @type {?shaka.extern.Stream} */\n  let video = variant.video;\n\n  /** @type {?string} */\n  let audioCodec = audio ? audio.codecs : null;\n  /** @type {?string} */\n  let videoCodec = video ? video.codecs : null;\n\n  /** @type {!Array.<string>} */\n  let codecs = [];\n  if (videoCodec) codecs.push(videoCodec);\n  if (audioCodec) codecs.push(audioCodec);\n\n  /** @type {!Array.<string>} */\n  let mimeTypes = [];\n  if (video) mimeTypes.push(video.mimeType);\n  if (audio) mimeTypes.push(audio.mimeType);\n  /** @type {?string} */\n  let mimeType = mimeTypes[0] || null;\n\n  /** @type {!Array.<string>} */\n  let kinds = [];\n  if (audio) kinds.push(audio.kind);\n  if (video) kinds.push(video.kind);\n  /** @type {?string} */\n  let kind = kinds[0] || null;\n\n  /** @type {!Set.<string>} */\n  const roles = new Set();\n  if (audio) audio.roles.forEach((role) => roles.add(role));\n  if (video) video.roles.forEach((role) => roles.add(role));\n\n  /** @type {shaka.extern.Track} */\n  let track = {\n    id: variant.id,\n    active: false,\n    type: 'variant',\n    bandwidth: variant.bandwidth,\n    language: variant.language,\n    label: null,\n    kind: kind,\n    width: null,\n    height: null,\n    frameRate: null,\n    mimeType: mimeType,\n    codecs: codecs.join(', '),\n    audioCodec: audioCodec,\n    videoCodec: videoCodec,\n    primary: variant.primary,\n    roles: Array.from(roles),\n    audioRoles: null,\n    videoId: null,\n    audioId: null,\n    channelsCount: null,\n    audioBandwidth: null,\n    videoBandwidth: null,\n    originalVideoId: null,\n    originalAudioId: null,\n    originalTextId: null,\n  };\n\n  if (video) {\n    track.videoId = video.id;\n    track.originalVideoId = video.originalId;\n    track.width = video.width || null;\n    track.height = video.height || null;\n    track.frameRate = video.frameRate || null;\n    track.videoBandwidth = video.bandwidth || null;\n  }\n\n  if (audio) {\n    track.audioId = audio.id;\n    track.originalAudioId = audio.originalId;\n    track.channelsCount = audio.channelsCount;\n    track.audioBandwidth = audio.bandwidth || null;\n    track.label = audio.label;\n    track.audioRoles = audio.roles;\n  }\n\n  return track;\n};\n\n\n/**\n * @param {shaka.extern.Stream} stream\n * @return {shaka.extern.Track}\n */\nshaka.util.StreamUtils.textStreamToTrack = function(stream) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  /** @type {shaka.extern.Track} */\n  let track = {\n    id: stream.id,\n    active: false,\n    type: ContentType.TEXT,\n    bandwidth: 0,\n    language: stream.language,\n    label: stream.label,\n    kind: stream.kind || null,\n    width: null,\n    height: null,\n    frameRate: null,\n    mimeType: stream.mimeType,\n    codecs: stream.codecs || null,\n    audioCodec: null,\n    videoCodec: null,\n    primary: stream.primary,\n    roles: stream.roles,\n    audioRoles: null,\n    videoId: null,\n    audioId: null,\n    channelsCount: null,\n    audioBandwidth: null,\n    videoBandwidth: null,\n    originalVideoId: null,\n    originalAudioId: null,\n    originalTextId: stream.originalId,\n  };\n\n  return track;\n};\n\n\n/**\n * Generate and return an ID for this track, since the ID field is optional.\n *\n * @param {TextTrack|AudioTrack} html5Track\n * @return {number} The generated ID.\n */\nshaka.util.StreamUtils.html5TrackId = function(html5Track) {\n  if (!html5Track['__shaka_id']) {\n    html5Track['__shaka_id'] = shaka.util.StreamUtils.nextTrackId_++;\n  }\n  return html5Track['__shaka_id'];\n};\n\n\n/** @private {number} */\nshaka.util.StreamUtils.nextTrackId_ = 0;\n\n\n/**\n * @param {TextTrack} textTrack\n * @return {shaka.extern.Track}\n */\nshaka.util.StreamUtils.html5TextTrackToTrack = function(textTrack) {\n  const CLOSED_CAPTION_MIMETYPE = shaka.util.MimeUtils.CLOSED_CAPTION_MIMETYPE;\n  const StreamUtils = shaka.util.StreamUtils;\n\n  /** @type {shaka.extern.Track} */\n  const track = StreamUtils.html5TrackToGenericShakaTrack_(textTrack);\n  track.active = textTrack.mode != 'disabled';\n  track.type = 'text';\n  track.originalTextId = textTrack.id;\n  if (textTrack.kind == 'captions') {\n    track.mimeType = CLOSED_CAPTION_MIMETYPE;\n  }\n\n  return track;\n};\n\n\n/**\n * @param {AudioTrack} audioTrack\n * @return {shaka.extern.Track}\n */\nshaka.util.StreamUtils.html5AudioTrackToTrack = function(audioTrack) {\n  const StreamUtils = shaka.util.StreamUtils;\n\n  /** @type {shaka.extern.Track} */\n  const track = StreamUtils.html5TrackToGenericShakaTrack_(audioTrack);\n  track.active = audioTrack.enabled;\n  track.type = 'variant';\n  track.originalAudioId = audioTrack.id;\n\n  if (audioTrack.kind == 'main') {\n    track.primary = true;\n    track.roles = ['main'];\n    track.audioRoles = ['main'];\n  } else {\n    track.audioRoles = [];\n  }\n\n  return track;\n};\n\n\n/**\n * Creates a Track object with non-type specific fields filled out.  The caller\n * is responsible for completing the Track object with any type-specific\n * information (audio or text).\n *\n * @param {TextTrack|AudioTrack} html5Track\n * @return {shaka.extern.Track}\n * @private\n */\nshaka.util.StreamUtils.html5TrackToGenericShakaTrack_ = function(html5Track) {\n  /** @type {shaka.extern.Track} */\n  const track = {\n    id: shaka.util.StreamUtils.html5TrackId(html5Track),\n    active: false,\n    type: '',\n    bandwidth: 0,\n    language: shaka.util.LanguageUtils.normalize(html5Track.language),\n    label: html5Track.label,\n    kind: html5Track.kind,\n    width: null,\n    height: null,\n    frameRate: null,\n    mimeType: null,\n    codecs: null,\n    audioCodec: null,\n    videoCodec: null,\n    primary: false,\n    roles: [],\n    audioRoles: null,\n    videoId: null,\n    audioId: null,\n    channelsCount: null,\n    audioBandwidth: null,\n    videoBandwidth: null,\n    originalVideoId: null,\n    originalAudioId: null,\n    originalTextId: null,\n  };\n\n  return track;\n};\n\n\n/**\n * Determines if the given variant is playable.\n * @param {!shaka.extern.Variant} variant\n * @return {boolean}\n */\nshaka.util.StreamUtils.isPlayable = function(variant) {\n  return variant.allowedByApplication && variant.allowedByKeySystem;\n};\n\n\n/**\n * Filters out unplayable variants.\n * @param {!Array.<!shaka.extern.Variant>} variants\n * @return {!Array.<!shaka.extern.Variant>}\n */\nshaka.util.StreamUtils.getPlayableVariants = function(variants) {\n  return variants.filter(function(variant) {\n    return shaka.util.StreamUtils.isPlayable(variant);\n  });\n};\n\n\n/**\n * Filters variants according to the given audio channel count config.\n *\n * @param {!Array.<shaka.extern.Variant>} variants\n * @param {number} preferredAudioChannelCount\n * @return {!Array.<!shaka.extern.Variant>}\n */\nshaka.util.StreamUtils.filterVariantsByAudioChannelCount = function(\n    variants, preferredAudioChannelCount) {\n  // Group variants by their audio channel counts.\n  const variantsWithChannelCounts =\n      variants.filter((v) => v.audio && v.audio.channelsCount);\n\n  /** @type {!Map.<number, !Array.<shaka.extern.Variant>>} */\n  const variantsByChannelCount = new Map();\n  for (const variant of variantsWithChannelCounts) {\n    const count = variant.audio.channelsCount;\n    goog.asserts.assert(count != null, 'Must have count after filtering!');\n    if (!variantsByChannelCount.has(count)) {\n      variantsByChannelCount.set(count, []);\n    }\n    variantsByChannelCount.get(count).push(variant);\n  }\n\n  /** @type {!Array.<number>} */\n  const channelCounts = Array.from(variantsByChannelCount.keys());\n\n  // If no variant has audio channel count info, return the original variants.\n  if (channelCounts.length == 0) {\n    return variants;\n  }\n\n  // Choose the variants with the largest number of audio channels less than or\n  // equal to the configured number of audio channels.\n  const countLessThanOrEqualtoConfig =\n      channelCounts.filter((count) => count <= preferredAudioChannelCount);\n  if (countLessThanOrEqualtoConfig.length) {\n    return variantsByChannelCount.get(Math.max.apply(null,\n        countLessThanOrEqualtoConfig));\n  }\n\n  // If all variants have more audio channels than the config, choose the\n  // variants with the fewest audio channels.\n  return variantsByChannelCount.get(Math.min.apply(null, channelCounts));\n};\n\n/**\n * Chooses streams according to the given config.\n *\n * @param {!Array.<shaka.extern.Stream>} streams\n * @param {string} preferredLanguage\n * @param {string} preferredRole\n * @return {!Array.<!shaka.extern.Stream>}\n */\nshaka.util.StreamUtils.filterStreamsByLanguageAndRole = function(\n    streams, preferredLanguage, preferredRole) {\n  const LanguageUtils = shaka.util.LanguageUtils;\n\n  /** @type {!Array.<!shaka.extern.Stream>} */\n  let chosen = streams;\n\n  // Start with the set of primary streams.\n  /** @type {!Array.<!shaka.extern.Stream>} */\n  let primary = streams.filter(function(stream) {\n    return stream.primary;\n  });\n\n  if (primary.length) {\n    chosen = primary;\n  }\n\n  // Now reduce the set to one language.  This covers both arbitrary language\n  // choice and the reduction of the \"primary\" stream set to one language.\n  let firstLanguage = chosen.length ? chosen[0].language : '';\n  chosen = chosen.filter(function(stream) {\n    return stream.language == firstLanguage;\n  });\n\n  // Find the streams that best match our language preference. This will\n  // override previous selections.\n  if (preferredLanguage) {\n    const closestLocale = LanguageUtils.findClosestLocale(\n        LanguageUtils.normalize(preferredLanguage),\n        streams.map((stream) => stream.language));\n\n    // Only replace |chosen| if we found a locale that is close to our\n    // preference.\n    if (closestLocale) {\n      chosen = streams.filter((stream) => {\n        const locale = LanguageUtils.normalize(stream.language);\n        return locale == closestLocale;\n      });\n    }\n  }\n\n  // Now refine the choice based on role preference.\n  if (preferredRole) {\n    let roleMatches = shaka.util.StreamUtils.filterTextStreamsByRole_(\n        chosen, preferredRole);\n    if (roleMatches.length) {\n      return roleMatches;\n    } else {\n      shaka.log.warning('No exact match for the text role could be found.');\n    }\n  } else {\n    // Prefer text streams with no roles, if they exist.\n    let noRoleMatches = chosen.filter(function(stream) {\n      return stream.roles.length == 0;\n    });\n    if (noRoleMatches.length) {\n      return noRoleMatches;\n    }\n  }\n\n  // Either there was no role preference, or it could not be satisfied.\n  // Choose an arbitrary role, if there are any, and filter out any other roles.\n  // This ensures we never adapt between roles.\n\n  let allRoles = chosen.map(function(stream) {\n    return stream.roles;\n  }).reduce(shaka.util.Functional.collapseArrays, []);\n\n  if (!allRoles.length) {\n    return chosen;\n  }\n  return shaka.util.StreamUtils.filterTextStreamsByRole_(chosen, allRoles[0]);\n};\n\n\n/**\n * Filter text Streams by role.\n *\n * @param {!Array.<shaka.extern.Stream>} textStreams\n * @param {string} preferredRole\n * @return {!Array.<shaka.extern.Stream>}\n * @private\n */\nshaka.util.StreamUtils.filterTextStreamsByRole_ =\n    function(textStreams, preferredRole) {\n  return textStreams.filter(function(stream) {\n    return stream.roles.includes(preferredRole);\n  });\n};\n\n\n/**\n * Finds a Variant with given audio and video streams.\n * Returns null if no such Variant was found.\n *\n * @param {?shaka.extern.Stream} audio\n * @param {?shaka.extern.Stream} video\n * @param {!Array.<!shaka.extern.Variant>} variants\n * @return {?shaka.extern.Variant}\n */\nshaka.util.StreamUtils.getVariantByStreams = function(audio, video, variants) {\n  if (audio) {\n    goog.asserts.assert(\n        shaka.util.StreamUtils.isAudio(audio),\n        'Audio streams must have the audio type.');\n  }\n\n  if (video) {\n    goog.asserts.assert(\n        shaka.util.StreamUtils.isVideo(video),\n        'Video streams must have the video type.');\n  }\n\n  for (let i = 0; i < variants.length; i++) {\n    if (variants[i].audio == audio && variants[i].video == video) {\n      return variants[i];\n    }\n  }\n\n  return null;\n};\n\n\n/**\n * Checks if the given stream is an audio stream.\n *\n * @param {shaka.extern.Stream} stream\n * @return {boolean}\n */\nshaka.util.StreamUtils.isAudio = function(stream) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  return stream.type == ContentType.AUDIO;\n};\n\n\n/**\n * Checks if the given stream is a video stream.\n *\n * @param {shaka.extern.Stream} stream\n * @return {boolean}\n */\nshaka.util.StreamUtils.isVideo = function(stream) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  return stream.type == ContentType.VIDEO;\n};\n\n\n/**\n * Get all non-null streams in the variant as an array.\n *\n * @param {shaka.extern.Variant} variant\n * @return {!Array.<shaka.extern.Stream>}\n */\nshaka.util.StreamUtils.getVariantStreams = function(variant) {\n  const streams = [];\n\n  if (variant.audio) { streams.push(variant.audio); }\n  if (variant.video) { streams.push(variant.video); }\n\n  return streams;\n};\n\n\n/**\n * @param {shaka.extern.Stream} stream\n * @return {string}\n * @private\n */\nshaka.util.StreamUtils.getStreamSummaryString_ = function(stream) {\n  if (shaka.util.StreamUtils.isAudio(stream)) {\n    return 'type=audio' +\n           ' codecs=' + stream.codecs +\n           ' bandwidth='+ stream.bandwidth +\n           ' channelsCount=' + stream.channelsCount;\n  }\n\n  if (shaka.util.StreamUtils.isVideo(stream)) {\n    return 'type=video' +\n           ' codecs=' + stream.codecs +\n           ' bandwidth=' + stream.bandwidth +\n           ' frameRate=' + stream.frameRate +\n           ' width=' + stream.width +\n           ' height=' + stream.height;\n  }\n\n  return 'unexpected stream type';\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.abr.SimpleAbrManager');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.abr.EwmaBandwidthEstimator');\ngoog.require('shaka.log');\ngoog.require('shaka.util.StreamUtils');\n\n\n/**\n * <p>\n * This defines the default ABR manager for the Player.  An instance of this\n * class is used when no ABR manager is given.\n * </p>\n * <p>\n * The behavior of this class is to take throughput samples using\n * segmentDownloaded to estimate the current network bandwidth.  Then it will\n * use that to choose the streams that best fit the current bandwidth.  It will\n * always pick the highest bandwidth variant it thinks can be played.\n * </p>\n * <p>\n * After initial choices are made, this class will call switchCallback() when\n * there is a better choice.  switchCallback() will not be called more than once\n * per ({@link shaka.abr.SimpleAbrManager.SWITCH_INTERVAL_MS}).\n * </p>\n *\n * @constructor\n * @struct\n * @implements {shaka.extern.AbrManager}\n * @export\n */\nshaka.abr.SimpleAbrManager = function() {\n  /** @private {?shaka.extern.AbrManager.SwitchCallback} */\n  this.switch_ = null;\n\n  /** @private {boolean} */\n  this.enabled_ = false;\n\n  /** @private {shaka.abr.EwmaBandwidthEstimator} */\n  this.bandwidthEstimator_ = new shaka.abr.EwmaBandwidthEstimator();\n  // TODO: Consider using NetworkInformation's change event to throw out an old\n  // estimate based on changing network types, such as wifi => 3g.\n\n  /**\n   * A filtered list of Variants to choose from.\n   * @private {!Array.<!shaka.extern.Variant>}\n   */\n  this.variants_ = [];\n\n  /** @private {boolean} */\n  this.startupComplete_ = false;\n\n  /**\n   * The last wall-clock time, in milliseconds, when streams were chosen.\n   *\n   * @private {?number}\n   */\n  this.lastTimeChosenMs_ = null;\n\n  /** @private {?shaka.extern.AbrConfiguration} */\n  this.config_ = null;\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.abr.SimpleAbrManager.prototype.stop = function() {\n  this.switch_ = null;\n  this.enabled_ = false;\n  this.variants_ = [];\n  this.lastTimeChosenMs_ = null;\n\n  // Don't reset |startupComplete_|: if we've left the startup interval, we can\n  // start using bandwidth estimates right away after init() is called.\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.abr.SimpleAbrManager.prototype.init = function(switchCallback) {\n  this.switch_ = switchCallback;\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.abr.SimpleAbrManager.prototype.chooseVariant = function() {\n  const SimpleAbrManager = shaka.abr.SimpleAbrManager;\n\n  // Get sorted Variants.\n  let sortedVariants = SimpleAbrManager.filterAndSortVariants_(\n      this.config_.restrictions, this.variants_);\n  let currentBandwidth = this.bandwidthEstimator_.getBandwidthEstimate(\n      this.config_.defaultBandwidthEstimate);\n\n  if (this.variants_.length && !sortedVariants.length) {\n    // If we couldn't meet the ABR restrictions, we should still play something.\n    // These restrictions are not \"hard\" restrictions in the way that top-level\n    // or DRM-based restrictions are.  Sort the variants without restrictions\n    // and keep just the first (lowest-bandwidth) one.\n    shaka.log.warning('No variants met the ABR restrictions. ' +\n                      'Choosing a variant by lowest bandwidth.');\n    sortedVariants = SimpleAbrManager.filterAndSortVariants_(\n        /* restrictions */ null, this.variants_);\n    sortedVariants = [sortedVariants[0]];\n  }\n\n  // Start by assuming that we will use the first Stream.\n  let chosen = sortedVariants[0] || null;\n\n  for (let i = 0; i < sortedVariants.length; ++i) {\n    let variant = sortedVariants[i];\n    let nextVariant = sortedVariants[i + 1] || {bandwidth: Infinity};\n\n    let minBandwidth = variant.bandwidth /\n                       this.config_.bandwidthDowngradeTarget;\n    let maxBandwidth = nextVariant.bandwidth /\n                       this.config_.bandwidthUpgradeTarget;\n    shaka.log.v2('Bandwidth ranges:',\n                 (variant.bandwidth / 1e6).toFixed(3),\n                 (minBandwidth / 1e6).toFixed(3),\n                 (maxBandwidth / 1e6).toFixed(3));\n\n    if (currentBandwidth >= minBandwidth && currentBandwidth <= maxBandwidth) {\n      chosen = variant;\n    }\n  }\n\n  this.lastTimeChosenMs_ = Date.now();\n  return chosen;\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.abr.SimpleAbrManager.prototype.enable = function() {\n  this.enabled_ = true;\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.abr.SimpleAbrManager.prototype.disable = function() {\n  this.enabled_ = false;\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.abr.SimpleAbrManager.prototype.segmentDownloaded = function(\n    deltaTimeMs, numBytes) {\n  shaka.log.v2('Segment downloaded:',\n               'deltaTimeMs=' + deltaTimeMs,\n               'numBytes=' + numBytes,\n               'lastTimeChosenMs=' + this.lastTimeChosenMs_,\n               'enabled=' + this.enabled_);\n  goog.asserts.assert(deltaTimeMs >= 0, 'expected a non-negative duration');\n  this.bandwidthEstimator_.sample(deltaTimeMs, numBytes);\n\n  if ((this.lastTimeChosenMs_ != null) && this.enabled_) {\n    this.suggestStreams_();\n  }\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.abr.SimpleAbrManager.prototype.getBandwidthEstimate = function() {\n  return this.bandwidthEstimator_.getBandwidthEstimate(\n      this.config_.defaultBandwidthEstimate);\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.abr.SimpleAbrManager.prototype.setVariants = function(variants) {\n  this.variants_ = variants;\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.abr.SimpleAbrManager.prototype.configure = function(config) {\n  this.config_ = config;\n};\n\n\n/**\n * Calls switch_() with the variant chosen by chooseVariant().\n *\n * @private\n */\nshaka.abr.SimpleAbrManager.prototype.suggestStreams_ = function() {\n  shaka.log.v2('Suggesting Streams...');\n  goog.asserts.assert(this.lastTimeChosenMs_ != null,\n                      'lastTimeChosenMs_ should not be null');\n\n  if (!this.startupComplete_) {\n    // Check if we've got enough data yet.\n    if (!this.bandwidthEstimator_.hasGoodEstimate()) {\n      shaka.log.v2('Still waiting for a good estimate...');\n      return;\n    }\n    this.startupComplete_ = true;\n  } else {\n    // Check if we've left the switch interval.\n    let now = Date.now();\n    let delta = now - this.lastTimeChosenMs_;\n    if (delta < this.config_.switchInterval * 1000) {\n      shaka.log.v2('Still within switch interval...');\n      return;\n    }\n  }\n\n  let chosenVariant = this.chooseVariant();\n  let bandwidthEstimate = this.bandwidthEstimator_.getBandwidthEstimate(\n      this.config_.defaultBandwidthEstimate);\n  let currentBandwidthKbps = Math.round(bandwidthEstimate / 1000.0);\n\n  shaka.log.debug(\n      'Calling switch_(), bandwidth=' + currentBandwidthKbps + ' kbps');\n  // If any of these chosen streams are already chosen, Player will filter them\n  // out before passing the choices on to StreamingEngine.\n  this.switch_(chosenVariant);\n};\n\n\n/**\n * @param {?shaka.extern.Restrictions} restrictions\n * @param {!Array.<shaka.extern.Variant>} variants\n * @return {!Array.<shaka.extern.Variant>} variants filtered according to\n *   |restrictions| and sorted in ascending order of bandwidth.\n * @private\n */\nshaka.abr.SimpleAbrManager.filterAndSortVariants_ = function(\n    restrictions, variants) {\n  if (restrictions) {\n    variants = variants.filter((variant) => {\n      // This was already checked in another scope, but the compiler doesn't\n      // seem to understand that.\n      goog.asserts.assert(restrictions, 'Restrictions should exist!');\n\n      return shaka.util.StreamUtils.meetsRestrictions(\n          variant, restrictions,\n          /* maxHwRes */ {width: Infinity, height: Infinity});\n    });\n  }\n\n  return variants.sort((v1, v2) => {\n    return v1.bandwidth - v2.bandwidth;\n  });\n};\n\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.deprecate.Version');\n\n/**\n * A class that defines what a library version is within the deprecation\n * system. Within deprecation we only care about the major and minor versions.\n *\n * @final\n */\nshaka.deprecate.Version = class {\n  /**\n   * @param {number} major\n   * @param {number} minor\n   */\n  constructor(major, minor) {\n    this.major_ = major;\n    this.minor_ = minor;\n  }\n\n  /** @return {number} */\n  major() { return this.major_; }\n\n  /** @return {number} */\n  minor() { return this.minor_; }\n\n  /**\n   * Returns:\n   *  - positive if |this| > |other|\n   *  - zero if |this| == |other|\n   *  - negative if |this| < |other|\n   *\n   * @param {!shaka.deprecate.Version} other\n   * @return {number}\n   */\n  compareTo(other) {\n    const majorCheck = this.major_ - other.major_;\n    const minorCheck = this.minor_ - other.minor_;\n\n    return majorCheck || minorCheck;\n  }\n\n  /** @override */\n  toString() {\n    return 'v' + this.major_ + '.' + this.minor_;\n  }\n\n  /**\n   * Parse the major and minor values out of a version string that is assumed\n   * to follow the grammar: \"vMAJOR.MINOR.\". What comes after the last \".\" we\n   * will ignore.\n   *\n   * @param {string} versionString\n   * @return {!shaka.deprecate.Version}\n   */\n  static parse(versionString) {\n    // Make sure to drop the \"v\" from the front. We limit the number of splits\n    // to two as we don't care what happens after the minor version number.\n    // For example: 'a.b.c.d'.split('.', 2) == ['a', 'b']\n    const components = versionString.substring(1).split('.', /* limit= */ 2);\n\n    return new shaka.deprecate.Version(\n        Number(components[0]),\n        Number(components[1]));\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.Deprecate');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.deprecate.Enforcer');\ngoog.require('shaka.deprecate.Version');\n\n\n/**\n * |shaka.Deprecate| is the front-end of the deprecation system, allowing for\n * any part of the code to say that \"this block of code should be removed by\n * version X\".\n *\n * @final\n */\nshaka.Deprecate = class {\n  /**\n   * Initialize the system. This must happen before any calls to |enforce|. In\n   * our code base, |shaka.Player| will be the only one to call this (it has the\n   * version string).\n   *\n   * If the |Deprecate| called |Player.version| to initialize itself, it would\n   * mean that |Player| could not use |Deprecate| because it would create a\n   * circular dependency. To work around this, we provide this method so that\n   * |Player| can give us the version without us needing to know about |Player|.\n   *\n   * This will initialize the system to:\n   *  - print warning messages when the feature is scheduled to be removed in a\n   *    later version\n   *  - print errors and fail assertions when the feature should be removed now\n   *\n   * @param {string} versionString\n   */\n  static init(versionString) {\n    goog.asserts.assert(\n        shaka.Deprecate.enforcer_ == null,\n        'Deprecate.init should only be called once.');\n\n    shaka.Deprecate.enforcer_ = new shaka.deprecate.Enforcer(\n        shaka.deprecate.Version.parse(versionString),\n        shaka.Deprecate.onPending_,\n        shaka.Deprecate.onExpired_);\n  }\n\n  /**\n   * Ask the deprecation system to require this feature to be removed by the\n   * given version.\n   *\n   * @param {number} major\n   * @param {number} minor\n   * @param {string} name\n   * @param {string} description\n   */\n  static deprecateFeature(major, minor, name, description) {\n    const enforcer = shaka.Deprecate.enforcer_;\n    goog.asserts.assert(\n        enforcer,\n        'Missing deprecation enforcer. Was |init| called?');\n\n    const expiresAt = new shaka.deprecate.Version(major, minor);\n    enforcer.enforce(expiresAt, name, description);\n  }\n\n  /**\n   * @param {!shaka.deprecate.Version} libraryVersion\n   * @param {!shaka.deprecate.Version} featureVersion\n   * @param {string} name\n   * @param {string} description\n   * @private\n   */\n  static onPending_(libraryVersion, featureVersion, name, description) {\n    // If we were to pass each value to the log call, it would be printed as\n    // a comma-separated list. To make the print state appear more natural to\n    // the reader, create one string for the message.\n    shaka.log.alwaysWarn([\n      name,\n      'has been deprecated and will be removed in',\n      featureVersion,\n      '. We are currently at version',\n      libraryVersion,\n      '. Additional information:',\n      description,\n    ].join(' '));\n  }\n\n  /**\n   * @param {!shaka.deprecate.Version} libraryVersion\n   * @param {!shaka.deprecate.Version} featureVersion\n   * @param {string} name\n   * @param {string} description\n   * @private\n   */\n  static onExpired_(libraryVersion, featureVersion, name, description) {\n    // If we were to pass each value to the log call, it would be printed as\n    // a comma-separated list. To make the print state appear more natural to\n    // the reader, create one string for the message.\n    const errorMessage = [\n      name,\n      'has been deprecated and has been removed in',\n      featureVersion,\n      '. We are now at version',\n      libraryVersion,\n      '. Additional information:',\n      description,\n    ].join('');\n\n    shaka.log.alwaysError(errorMessage);\n    goog.asserts.assert(false, errorMessage);\n  }\n};\n\n/**\n * The global deprecation enforcer that will be set by the player (because the\n * player knows the version) when it calls |init|. This may appear a little\n * round-about to you, because it is. Since player uses |Deprecate|, it means\n * that |Deprecate| can't depend on Player directly.\n *\n * @private {shaka.deprecate.Enforcer}\n */\nshaka.Deprecate.enforcer_ = null;\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.cast.CastProxy');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Deprecate');\ngoog.require('shaka.cast.CastSender');\ngoog.require('shaka.cast.CastUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IDestroyable');\n\n\n/**\n * A proxy to switch between local and remote playback for Chromecast in a way\n * that is transparent to the app's controls.\n *\n * @constructor\n * @struct\n * @param {!HTMLMediaElement} video The local video element associated with the\n *   local Player instance.\n * @param {!shaka.Player} player A local Player instance.\n * @param {string} receiverAppId The ID of the cast receiver application.\n *   If blank, casting will not be available, but the proxy will still function\n *   otherwise.\n * @implements {shaka.util.IDestroyable}\n * @extends {shaka.util.FakeEventTarget}\n * @export\n */\nshaka.cast.CastProxy = function(video, player, receiverAppId) {\n  shaka.util.FakeEventTarget.call(this);\n\n  /** @private {HTMLMediaElement} */\n  this.localVideo_ = video;\n\n  /** @private {shaka.Player} */\n  this.localPlayer_ = player;\n\n  /** @private {Object} */\n  this.videoProxy_ = null;\n\n  /** @private {Object} */\n  this.playerProxy_ = null;\n\n  /** @private {shaka.util.FakeEventTarget} */\n  this.videoEventTarget_ = null;\n\n  /** @private {shaka.util.FakeEventTarget} */\n  this.playerEventTarget_ = null;\n\n  /** @private {shaka.util.EventManager} */\n  this.eventManager_ = null;\n\n  /** @private {string} */\n  this.receiverAppId_ = receiverAppId;\n\n  if (this.receiverAppId_) {\n    // TODO: This is temporary fix to get casting working.\n    // It masks the fact that we're at the moment unable to\n    // change the receiver id sucessfully.\n    // It relies on the assumption that changing one actual\n    // id to another is a very edgy use case (usually apps have\n    // only one receiver app).\n    // It unblocks casting in the world where UI can be configured,\n    // but it's hacky and must be changed to a permanent solution\n    // allowing to change Receiver App ID for reals.\n    /** @private {shaka.cast.CastSender} */\n    this.sender_ = new shaka.cast.CastSender(\n        receiverAppId,\n        () => this.onCastStatusChanged_(),\n        () => this.onFirstCastStateUpdate_(),\n        (targetName, event) => this.onRemoteEvent_(targetName, event),\n        () => this.onResumeLocal_(),\n        () => this.getInitState_());\n  }\n\n  this.init_();\n};\ngoog.inherits(shaka.cast.CastProxy, shaka.util.FakeEventTarget);\n\n\n/**\n * Destroys the proxy and the underlying local Player.\n *\n * @param {boolean=} forceDisconnect If true, force the receiver app to shut\n *   down by disconnecting.  Does nothing if not connected.\n * @override\n * @export\n */\nshaka.cast.CastProxy.prototype.destroy = function(forceDisconnect) {\n  if (forceDisconnect && this.sender_) {\n    this.sender_.forceDisconnect();\n  }\n\n  if (this.eventManager_) {\n    this.eventManager_.release();\n    this.eventManager_ = null;\n  }\n\n  const waitFor = [];\n  if (this.localPlayer_) {\n    waitFor.push(this.localPlayer_.destroy());\n    this.localPlayer_ = null;\n  }\n\n  if (this.sender_) {\n    waitFor.push(this.sender_.destroy());\n    this.sender_ = null;\n  }\n\n  this.localVideo_ = null;\n  this.videoProxy_ = null;\n  this.playerProxy_ = null;\n\n  return Promise.all(waitFor);\n};\n\n\n/**\n * @event shaka.cast.CastProxy.CastStatusChangedEvent\n * @description Fired when cast status changes.  The status change will be\n *   reflected in canCast() and isCasting().\n * @property {string} type\n *   'caststatuschanged'\n * @exportDoc\n */\n\n\n/**\n * Get a proxy for the video element that delegates to local and remote video\n * elements as appropriate.\n *\n * @suppress {invalidCasts} to cast proxy Objects to unrelated types\n * @return {!HTMLMediaElement}\n * @export\n */\nshaka.cast.CastProxy.prototype.getVideo = function() {\n  return /** @type {!HTMLMediaElement} */(this.videoProxy_);\n};\n\n\n/**\n * Get a proxy for the Player that delegates to local and remote Player objects\n * as appropriate.\n *\n * @suppress {invalidCasts} to cast proxy Objects to unrelated types\n * @return {!shaka.Player}\n * @export\n */\nshaka.cast.CastProxy.prototype.getPlayer = function() {\n  return /** @type {!shaka.Player} */(this.playerProxy_);\n};\n\n\n/**\n * @return {boolean} True if the cast API is available and there are receivers.\n * @export\n */\nshaka.cast.CastProxy.prototype.canCast = function() {\n  return this.sender_ ?\n      this.sender_.apiReady() && this.sender_.hasReceivers() :\n      false;\n};\n\n\n/**\n * @return {boolean} True if we are currently casting.\n * @export\n */\nshaka.cast.CastProxy.prototype.isCasting = function() {\n  return this.sender_ ? this.sender_.isCasting() : false;\n};\n\n\n/**\n * @return {string} The name of the Cast receiver device, if isCasting().\n * @export\n */\nshaka.cast.CastProxy.prototype.receiverName = function() {\n  return this.sender_ ? this.sender_.receiverName() : '';\n};\n\n\n/**\n * @return {!Promise} Resolved when connected to a receiver.  Rejected if the\n *   connection fails or is canceled by the user.\n * @export\n */\nshaka.cast.CastProxy.prototype.cast = function() {\n  if (!this.sender_) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.RECOVERABLE,\n        shaka.util.Error.Category.CAST,\n        shaka.util.Error.Code.CAST_RECEIVER_APP_ID_MISSING);\n  }\n\n  let initState = this.getInitState_();\n\n  // TODO: transfer manually-selected tracks?\n  // TODO: transfer side-loaded text tracks?\n\n  return this.sender_.cast(initState).then(function() {\n    if (!this.localPlayer_) {\n      // We've already been destroyed.\n      return;\n    }\n\n    // Unload the local manifest when casting succeeds.\n    return this.localPlayer_.unload();\n  }.bind(this));\n};\n\n\n/**\n * Set application-specific data.\n *\n * @param {Object} appData Application-specific data to relay to the receiver.\n * @export\n */\nshaka.cast.CastProxy.prototype.setAppData = function(appData) {\n  if (this.sender_) {\n    this.sender_.setAppData(appData);\n  }\n};\n\n\n/**\n * Show a dialog where user can choose to disconnect from the cast connection.\n * @export\n */\nshaka.cast.CastProxy.prototype.suggestDisconnect = function() {\n  if (this.sender_) {\n    this.sender_.showDisconnectDialog();\n  }\n};\n\n\n/**\n * @param {string} newAppId\n * @export\n */\nshaka.cast.CastProxy.prototype.changeReceiverId = async function(newAppId) {\n  if (newAppId == this.receiverAppId_) {\n    // Nothing to change\n    return;\n  }\n\n  this.receiverAppId_ = newAppId;\n\n  // TODO: This code doesn't work correctly at the moment. Changing\n  // one working receiver id to another needs to be figured out.\n  // Destroy the old sender\n  if (this.sender_) {\n    this.sender_.forceDisconnect();\n    await this.sender_.destroy();\n    this.sender_ = null;\n  }\n\n\n  // Create the new one\n  this.sender_ = new shaka.cast.CastSender(\n      newAppId,\n      () => this.onCastStatusChanged_(),\n      () => this.onFirstCastStateUpdate_(),\n      (targetName, event) => this.onRemoteEvent_(targetName, event),\n      () => this.onResumeLocal_(),\n      () => this.getInitState_());\n\n  this.sender_.init();\n};\n\n\n/**\n * Force the receiver app to shut down by disconnecting.\n * @export\n */\nshaka.cast.CastProxy.prototype.forceDisconnect = function() {\n  if (this.sender_) {\n    this.sender_.forceDisconnect();\n  }\n};\n\n\n/**\n * Initialize the Proxies and the Cast sender.\n * @private\n */\nshaka.cast.CastProxy.prototype.init_ = function() {\n  if (this.sender_) {\n    this.sender_.init();\n  }\n\n  this.eventManager_ = new shaka.util.EventManager();\n\n  shaka.cast.CastUtils.VideoEvents.forEach(function(name) {\n    this.eventManager_.listen(this.localVideo_, name,\n        this.videoProxyLocalEvent_.bind(this));\n  }.bind(this));\n\n  shaka.cast.CastUtils.PlayerEvents.forEach(function(name) {\n    this.eventManager_.listen(this.localPlayer_, name,\n        this.playerProxyLocalEvent_.bind(this));\n  }.bind(this));\n\n  // We would like to use Proxy here, but it is not supported on IE11 or Safari.\n  this.videoProxy_ = {};\n  for (let k in this.localVideo_) {\n    Object.defineProperty(this.videoProxy_, k, {\n      configurable: false,\n      enumerable: true,\n      get: this.videoProxyGet_.bind(this, k),\n      set: this.videoProxySet_.bind(this, k),\n    });\n  }\n\n  this.playerProxy_ = {};\n  for (let k in /** @type {Object} */(this.localPlayer_)) {\n    Object.defineProperty(this.playerProxy_, k, {\n      configurable: false,\n      enumerable: true,\n      get: this.playerProxyGet_.bind(this, k),\n    });\n  }\n\n  this.videoEventTarget_ = new shaka.util.FakeEventTarget();\n  this.videoEventTarget_.dispatchTarget =\n      /** @type {EventTarget} */(this.videoProxy_);\n\n  this.playerEventTarget_ = new shaka.util.FakeEventTarget();\n  this.playerEventTarget_.dispatchTarget =\n      /** @type {EventTarget} */(this.playerProxy_);\n};\n\n\n/**\n * @return {shaka.cast.CastUtils.InitStateType} initState Video and player state\n *   to be sent to the receiver.\n * @private\n */\nshaka.cast.CastProxy.prototype.getInitState_ = function() {\n  let initState = {\n    'video': {},\n    'player': {},\n    'playerAfterLoad': {},\n    'manifest': this.localPlayer_.getAssetUri(),\n    'startTime': null,\n  };\n\n  // Pause local playback before capturing state.\n  this.localVideo_.pause();\n\n  shaka.cast.CastUtils.VideoInitStateAttributes.forEach(function(name) {\n    initState['video'][name] = this.localVideo_[name];\n  }.bind(this));\n\n  // If the video is still playing, set the startTime.\n  // Has no effect if nothing is loaded.\n  if (!this.localVideo_.ended) {\n    initState['startTime'] = this.localVideo_.currentTime;\n  }\n\n  shaka.cast.CastUtils.PlayerInitState.forEach(function(pair) {\n    let getter = pair[0];\n    let setter = pair[1];\n    let value = /** @type {Object} */(this.localPlayer_)[getter]();\n\n    initState['player'][setter] = value;\n  }.bind(this));\n\n  shaka.cast.CastUtils.PlayerInitAfterLoadState.forEach(function(pair) {\n    let getter = pair[0];\n    let setter = pair[1];\n    let value = /** @type {Object} */(this.localPlayer_)[getter]();\n\n    initState['playerAfterLoad'][setter] = value;\n  }.bind(this));\n\n  return initState;\n};\n\n\n/**\n * Dispatch an event to notify the app that the status has changed.\n * @private\n */\nshaka.cast.CastProxy.prototype.onCastStatusChanged_ = function() {\n  let event = new shaka.util.FakeEvent('caststatuschanged');\n  this.dispatchEvent(event);\n};\n\n\n/**\n * Dispatch a synthetic play or pause event to ensure that the app correctly\n * knows that the player is playing, if joining an existing receiver.\n * @private\n */\nshaka.cast.CastProxy.prototype.onFirstCastStateUpdate_ = function() {\n  let type = this.videoProxy_.paused ? 'pause' : 'play';\n  let fakeEvent = new shaka.util.FakeEvent(type);\n  this.videoEventTarget_.dispatchEvent(fakeEvent);\n};\n\n\n/**\n * Transfer remote state back and resume local playback.\n * @private\n */\nshaka.cast.CastProxy.prototype.onResumeLocal_ = function() {\n  goog.asserts.assert(this.sender_,\n      'Cast sender should not be null!');\n\n  // Transfer back the player state.\n  shaka.cast.CastUtils.PlayerInitState.forEach(function(pair) {\n    let getter = pair[0];\n    let setter = pair[1];\n    let value = this.sender_.get('player', getter)();\n    /** @type {Object} */(this.localPlayer_)[setter](value);\n  }.bind(this));\n\n  // Get the most recent manifest URI and ended state.\n  let assetUri = this.sender_.get('player', 'getAssetUri')();\n  let ended = this.sender_.get('video', 'ended');\n\n  let manifestReady = Promise.resolve();\n  let autoplay = this.localVideo_.autoplay;\n\n  let startTime = null;\n\n  // If the video is still playing, set the startTime.\n  // Has no effect if nothing is loaded.\n  if (!ended) {\n    startTime = this.sender_.get('video', 'currentTime');\n  }\n\n  // Now load the manifest, if present.\n  if (assetUri) {\n    // Don't autoplay the content until we finish setting up initial state.\n    this.localVideo_.autoplay = false;\n    manifestReady = this.localPlayer_.load(assetUri, startTime);\n  }\n\n  // Get the video state into a temp variable since we will apply it async.\n  let videoState = {};\n  shaka.cast.CastUtils.VideoInitStateAttributes.forEach(function(name) {\n    videoState[name] = this.sender_.get('video', name);\n  }.bind(this));\n\n  // Finally, take on video state and player's \"after load\" state.\n  manifestReady.then(() => {\n    if (!this.localVideo_) {\n      // We've already been destroyed.\n      return;\n    }\n\n    shaka.cast.CastUtils.VideoInitStateAttributes.forEach(function(name) {\n      this.localVideo_[name] = videoState[name];\n    }.bind(this));\n\n    shaka.cast.CastUtils.PlayerInitAfterLoadState.forEach(function(pair) {\n      let getter = pair[0];\n      let setter = pair[1];\n      let value = this.sender_.get('player', getter)();\n      /** @type {Object} */(this.localPlayer_)[setter](value);\n    }.bind(this));\n\n    // Restore the original autoplay setting.\n    this.localVideo_.autoplay = autoplay;\n    if (assetUri) {\n      // Resume playback with transferred state.\n      this.localVideo_.play();\n    }\n  }, (error) => {\n    // Pass any errors through to the app.\n    goog.asserts.assert(error instanceof shaka.util.Error,\n                        'Wrong error type!');\n    let event = new shaka.util.FakeEvent('error', {'detail': error});\n    this.localPlayer_.dispatchEvent(event);\n  });\n};\n\n\n/**\n * @param {string} name\n * @return {?}\n * @private\n */\nshaka.cast.CastProxy.prototype.videoProxyGet_ = function(name) {\n  if (name == 'addEventListener') {\n    return this.videoEventTarget_.addEventListener.bind(\n        this.videoEventTarget_);\n  }\n  if (name == 'removeEventListener') {\n    return this.videoEventTarget_.removeEventListener.bind(\n        this.videoEventTarget_);\n  }\n\n  // If we are casting, but the first update has not come in yet, use local\n  // values, but not local methods.\n  if (this.sender_ && this.sender_.isCasting() &&\n      !this.sender_.hasRemoteProperties()) {\n    let value = this.localVideo_[name];\n    if (typeof value != 'function') {\n      return value;\n    }\n  }\n\n  // Use local values and methods if we are not casting.\n  if (!this.sender_ || !this.sender_.isCasting()) {\n    let value = this.localVideo_[name];\n    if (typeof value == 'function') {\n      value = value.bind(this.localVideo_);\n    }\n    return value;\n  }\n\n  return this.sender_.get('video', name);\n};\n\n\n/**\n * @param {string} name\n * @param {?} value\n * @private\n */\nshaka.cast.CastProxy.prototype.videoProxySet_ = function(name, value) {\n  if (!this.sender_ || !this.sender_.isCasting()) {\n    this.localVideo_[name] = value;\n    return;\n  }\n\n  this.sender_.set('video', name, value);\n};\n\n\n/**\n * @param {!Event} event\n * @private\n */\nshaka.cast.CastProxy.prototype.videoProxyLocalEvent_ = function(event) {\n  if (this.sender_ && this.sender_.isCasting()) {\n    // Ignore any unexpected local events while casting.  Events can still be\n    // fired by the local video and Player when we unload() after the Cast\n    // connection is complete.\n    return;\n  }\n\n  // Convert this real Event into a FakeEvent for dispatch from our\n  // FakeEventListener.\n  let fakeEvent = new shaka.util.FakeEvent(event.type, event);\n  this.videoEventTarget_.dispatchEvent(fakeEvent);\n};\n\n\n/**\n * @param {string} name\n * @return {?}\n * @private\n */\nshaka.cast.CastProxy.prototype.playerProxyGet_ = function(name) {\n  if (name == 'addEventListener') {\n    return this.playerEventTarget_.addEventListener.bind(\n        this.playerEventTarget_);\n  }\n  if (name == 'removeEventListener') {\n    return this.playerEventTarget_.removeEventListener.bind(\n        this.playerEventTarget_);\n  }\n\n  if (name == 'getMediaElement') {\n    return function() { return this.videoProxy_; }.bind(this);\n  }\n\n  if (name == 'getSharedConfiguration') {\n    shaka.log.warning(\n        'Can\\'t share configuration across a network. Returning copy.');\n    return this.sender_ ?\n           this.sender_.get('player', 'getConfiguration') :\n           this.localPlayer_.getConfiguration();\n  }\n\n  if (name == 'getNetworkingEngine') {\n    // Always returns a local instance, in case you need to make a request.\n    // Issues a warning, in case you think you are making a remote request\n    // or affecting remote filters.\n    if (this.sender_ && this.sender_.isCasting()) {\n      shaka.log.warning('NOTE: getNetworkingEngine() is always local!');\n    }\n    return this.localPlayer_.getNetworkingEngine.bind(this.localPlayer_);\n  }\n\n  if (this.sender_ && this.sender_.isCasting()) {\n    // These methods are unavailable or otherwise stubbed during casting.\n    if (name == 'getManifest' || name == 'drmInfo') {\n      return function() {\n        shaka.log.alwaysWarn(name + '() does not work while casting!');\n        return null;\n      };\n    }\n\n    if (name == 'getManifestUri') {\n      shaka.Deprecate.deprecateFeature(\n          2, 6,\n          'getManifestUri',\n          'Please use \"getAssetUri\" instead.');\n\n      return this.playerProxyGet_('getAssetUri');\n    }\n\n    if (name == 'attach' || name == 'detach') {\n      return function() {\n        shaka.log.alwaysWarn(name + '() does not work while casting!');\n        return Promise.resolve();\n      };\n    }\n  }  // if (this.sender_.isCasting())\n\n  // If we are casting, but the first update has not come in yet, use local\n  // getters, but not local methods.\n  if (this.sender_ && this.sender_.isCasting() &&\n      !this.sender_.hasRemoteProperties()) {\n    if (shaka.cast.CastUtils.PlayerGetterMethods[name]) {\n      let value = /** @type {Object} */(this.localPlayer_)[name];\n      goog.asserts.assert(typeof value == 'function', 'only methods on Player');\n      return value.bind(this.localPlayer_);\n    }\n  }\n\n  // Use local getters and methods if we are not casting.\n  if (!this.sender_ || !this.sender_.isCasting()) {\n    let value = /** @type {Object} */(this.localPlayer_)[name];\n    goog.asserts.assert(typeof value == 'function', 'only methods on Player');\n    return value.bind(this.localPlayer_);\n  }\n\n  return this.sender_.get('player', name);\n};\n\n\n/**\n * @param {!Event} event\n * @private\n */\nshaka.cast.CastProxy.prototype.playerProxyLocalEvent_ = function(event) {\n  if (this.sender_ && this.sender_.isCasting()) {\n    // Ignore any unexpected local events while casting.\n    return;\n  }\n\n  this.playerEventTarget_.dispatchEvent(event);\n};\n\n\n/**\n * @param {string} targetName\n * @param {!shaka.util.FakeEvent} event\n * @private\n */\nshaka.cast.CastProxy.prototype.onRemoteEvent_ = function(targetName, event) {\n  goog.asserts.assert(this.sender_ && this.sender_.isCasting(),\n                      'Should only receive remote events while casting');\n  if (!this.sender_.isCasting()) {\n    // Ignore any unexpected remote events.\n    return;\n  }\n\n  if (targetName == 'video') {\n    this.videoEventTarget_.dispatchEvent(event);\n  } else if (targetName == 'player') {\n    this.playerEventTarget_.dispatchEvent(event);\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.deprecate.Enforcer');\n\ngoog.require('shaka.deprecate.Version');\n\n\n/**\n * The enforcer's job is to call the correct callback when a feature will need\n * to be removed later or removed now.\n *\n * The \"what should be done\" is not part of the enforcer, that must be provided\n * to the enforcer when it is created. This separation was created so that\n * testing and production could be equal users of the enforcer.\n *\n * @final\n */\nshaka.deprecate.Enforcer = class {\n  /**\n   * @param {!shaka.deprecate.Version} libraryVersion\n   * @param {shaka.deprecate.Listener} onPending\n   * @param {shaka.deprecate.Listener} onExpired\n   */\n  constructor(libraryVersion, onPending, onExpired) {\n    /** @private {!shaka.deprecate.Version} */\n    this.libraryVersion_ = libraryVersion;\n\n    /** @private {shaka.deprecate.Listener} */\n    this.onPending_ = onPending;\n    /** @private {shaka.deprecate.Listener} */\n    this.onExpired_ = onExpired;\n  }\n\n  /**\n   * Tell the enforcer that a feature will expire on |expiredOn| and that it\n   * should notify the listeners if it is pending or expired.\n   *\n   * @param {!shaka.deprecate.Version} expiresOn\n   * @param {string} name\n   * @param {string} description\n   */\n  enforce(expiresOn, name, description) {\n    // If the expiration version is larger than the library version\n    // (compareTo > 0), it means the expiration is in the future, and is still\n    // pending.\n    const isPending = expiresOn.compareTo(this.libraryVersion_) > 0;\n\n    // Find the right callback (pending or expired) for this enforcement request\n    // call it to handle this features pending/expired removal.\n    const callback = isPending ? this.onPending_ : this.onExpired_;\n    callback(this.libraryVersion_, expiresOn, name, description);\n  }\n};\n\n/**\n * A callback for listening to deprecation events.\n *\n * Parameters:\n *  libraryVersion: !shaka.deprecate.Version\n *  featureVersion: !shaka.deprecate.Version\n *  name: string\n *  description: string\n *\n * libraryVersion: The current version of the library.\n * featureVersion: The version of the library when the feature should be\n *                 removed.\n * name: The name of the feature that will/should be removed.\n * description: A description of what is changing.\n *\n * @typedef {function(\n *    !shaka.deprecate.Version,\n *    !shaka.deprecate.Version,\n *    string,\n *    string)}\n */\nshaka.deprecate.Listener;\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.cast.CastUtils');\n\ngoog.require('shaka.util.FakeEvent');\n\n\n/**\n * @namespace shaka.cast.CastUtils\n * @summary A set of cast utility functions and variables shared between sender\n *   and receiver.\n */\n\n\n/**\n * HTMLMediaElement events that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoEvents = [\n  'ended',\n  'play',\n  'playing',\n  'pause',\n  'pausing',\n  'ratechange',\n  'seeked',\n  'seeking',\n  'timeupdate',\n  'volumechange',\n];\n\n\n/**\n * HTMLMediaElement attributes that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoAttributes = [\n  'buffered',\n  'currentTime',\n  'duration',\n  'ended',\n  'loop',\n  'muted',\n  'paused',\n  'playbackRate',\n  'seeking',\n  'videoHeight',\n  'videoWidth',\n  'volume',\n];\n\n\n/**\n * HTMLMediaElement attributes that are transferred when casting begins.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoInitStateAttributes = [\n  'loop',\n  'playbackRate',\n];\n\n\n/**\n * HTMLMediaElement methods with no return value that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoVoidMethods = [\n  'pause',\n  'play',\n];\n\n\n/**\n * Player events that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.PlayerEvents = [\n  'abrstatuschanged',\n  'adaptation',\n  'buffering',\n  'emsg',\n  'error',\n  'loading',\n  'streaming',\n  'texttrackvisibility',\n  'timelineregionadded',\n  'timelineregionenter',\n  'timelineregionexit',\n  'trackschanged',\n  'unloading',\n  'variantchanged',\n  'textchanged',\n];\n\n\n/**\n * Player getter methods that are proxied while casting.\n * The key is the method, the value is the frequency of updates.\n * Frequency 1 translates to every update; frequency 2 to every 2 updates, etc.\n * @const {!Object.<string, number>}\n */\nshaka.cast.CastUtils.PlayerGetterMethods = {\n  // NOTE: The 'drmInfo' property is not proxied, as it is very large.\n  'getAssetUri': 2,\n  'getAudioLanguages': 2,\n  'getAudioLanguagesAndRoles': 2,\n  'getBufferedInfo': 2,\n  // NOTE: The 'getSharedConfiguration' property is not proxied as it would\n  //       not be possible to share a reference.\n  'getConfiguration': 2,\n  'getExpiration': 2,\n  // NOTE: The 'getManifest' property is not proxied, as it is very large.\n  // TODO(vaage): Remove |getManifestUri| references in v2.6.\n  // NOTE: The 'getManifestUri' property is not proxied, as CastProxy has a\n  // handler for it.\n  // NOTE: The 'getManifestParserFactory' property is not proxied, as it would\n  // not serialize.\n  'getPlaybackRate': 2,\n  'getTextLanguages': 2,\n  'getTextLanguagesAndRoles': 2,\n  'getTextTracks': 2,\n  'getStats': 5,\n  'getVariantTracks': 2,\n  'isAudioOnly': 10,\n  'isBuffering': 1,\n  'isInProgress': 1,\n  'isLive': 10,\n  'isTextTrackVisible': 1,\n  'keySystem': 10,\n  'seekRange': 1,\n  'usingEmbeddedTextTrack': 2,\n  'getLoadMode': 10,\n};\n\n\n/**\n * Player getter methods that are proxied while casting, but only when casting\n * a livestream.\n * The key is the method, the value is the frequency of updates.\n * Frequency 1 translates to every update; frequency 2 to every 2 updates, etc.\n * @const {!Object.<string, number>}\n */\nshaka.cast.CastUtils.PlayerGetterMethodsThatRequireLive = {\n  'getPlayheadTimeAsDate': 1,\n  'getPresentationStartTimeAsDate': 20,\n};\n\n\n/**\n * Player getter and setter methods that are used to transfer state when casting\n * begins.\n * @const {!Array.<!Array.<string>>}\n */\nshaka.cast.CastUtils.PlayerInitState = [\n  ['getConfiguration', 'configure'],\n];\n\n\n/**\n * Player getter and setter methods that are used to transfer state after\n * load() is resolved.\n * @const {!Array.<!Array.<string>>}\n */\nshaka.cast.CastUtils.PlayerInitAfterLoadState = [\n  ['isTextTrackVisible', 'setTextTrackVisibility'],\n];\n\n\n/**\n * Player methods with no return value that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.PlayerVoidMethods = [\n  'addTextTrack',\n  'cancelTrickPlay',\n  'configure',\n  'resetConfiguration',\n  'retryStreaming',\n  'selectAudioLanguage',\n  'selectEmbeddedTextTrack',\n  'selectTextLanguage',\n  'selectTextTrack',\n  'selectVariantTrack',\n  'setTextTrackVisibility',\n  'trickPlay',\n];\n\n\n/**\n * Player methods returning a Promise that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.PlayerPromiseMethods = [\n  'attach',\n  'detach',\n  // The manifestFactory parameter of load is not supported.\n  'load',\n  'unload',\n];\n\n\n/**\n * @typedef {{\n *   video: Object,\n *   player: Object,\n *   manifest: ?string,\n *   startTime: ?number\n * }}\n * @property {Object} video\n *   Dictionary of video properties to be set.\n * @property {Object} player\n *   Dictionary of player setters to be called.\n * @property {?string} manifest\n *   The currently-selected manifest, if present.\n * @property {?number} startTime\n *   The playback start time, if currently playing.\n */\nshaka.cast.CastUtils.InitStateType;\n\n\n/**\n * The namespace for Shaka messages on the cast bus.\n * @const {string}\n */\nshaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE = 'urn:x-cast:com.google.shaka.v2';\n\n\n/**\n * The namespace for generic messages on the cast bus.\n * @const {string}\n */\nshaka.cast.CastUtils.GENERIC_MESSAGE_NAMESPACE =\n    'urn:x-cast:com.google.cast.media';\n\n\n/**\n * Serialize as JSON, but specially encode things JSON will not otherwise\n * represent.\n * @param {?} thing\n * @return {string}\n */\nshaka.cast.CastUtils.serialize = function(thing) {\n  return JSON.stringify(thing, function(key, value) {\n    if (typeof value == 'function') {\n      // Functions can't be (safely) serialized.\n      return undefined;\n    }\n\n    if (value instanceof Event || value instanceof shaka.util.FakeEvent) {\n      // Events don't serialize to JSON well because of the DOM objects\n      // and other complex objects they contain, so we strip these out.\n      // Note that using Object.keys or JSON.stringify directly on the event\n      // will not capture its properties.  We must use a for loop.\n      let simpleEvent = {};\n      for (let eventKey in value) {\n        let eventValue = value[eventKey];\n        if (eventValue && typeof eventValue == 'object') {\n          if (eventKey == 'detail') {\n            // Keep the detail value, because it contains important information\n            // for diagnosing errors.\n            simpleEvent[eventKey] = eventValue;\n          }\n          // Strip out non-null object types because they are complex and we\n          // don't need them.\n        } else if (eventKey in Event) {\n          // Strip out keys that are found on Event itself because they are\n          // class-level constants we don't need, like Event.MOUSEMOVE == 16.\n        } else {\n          simpleEvent[eventKey] = eventValue;\n        }\n      }\n      return simpleEvent;\n    }\n\n    if (value instanceof TimeRanges) {\n      // TimeRanges must be unpacked into plain data for serialization.\n      return shaka.cast.CastUtils.unpackTimeRanges_(value);\n    }\n\n    if (value instanceof Uint8Array) {\n      // Some of our code cares about Uint8Arrays actually being Uint8Arrays,\n      // so this gives them special treatment.\n      return shaka.cast.CastUtils.unpackUint8Array_(value);\n    }\n\n    if (typeof value == 'number') {\n      // NaN and infinity cannot be represented directly in JSON.\n      if (isNaN(value)) return 'NaN';\n      if (isFinite(value)) return value;\n      if (value < 0) return '-Infinity';\n      return 'Infinity';\n    }\n\n    return value;\n  });\n};\n\n\n/**\n * Deserialize JSON using our special encodings.\n * @param {string} str\n * @return {?}\n */\nshaka.cast.CastUtils.deserialize = function(str) {\n  return JSON.parse(str, function(key, value) {\n    if (value == 'NaN') {\n      return NaN;\n    } else if (value == '-Infinity') {\n      return -Infinity;\n    } else if (value == 'Infinity') {\n      return Infinity;\n    } else if (value && typeof value == 'object' &&\n               value['__type__'] == 'TimeRanges') {\n      // TimeRanges objects have been unpacked and sent as plain data.\n      // Simulate the original TimeRanges object.\n      return shaka.cast.CastUtils.simulateTimeRanges_(value);\n    } else if (value && typeof value == 'object' &&\n               value['__type__'] == 'Uint8Array') {\n      return shaka.cast.CastUtils.makeUint8Array_(value);\n    }\n    return value;\n  });\n};\n\n\n/**\n * @param {!TimeRanges} ranges\n * @return {Object}\n * @private\n */\nshaka.cast.CastUtils.unpackTimeRanges_ = function(ranges) {\n  let obj = {\n    '__type__': 'TimeRanges',  // a signal to deserialize\n    'length': ranges.length,\n    'start': [],\n    'end': [],\n  };\n\n  for (let i = 0; i < ranges.length; ++i) {\n    obj['start'].push(ranges.start(i));\n    obj['end'].push(ranges.end(i));\n  }\n\n  return obj;\n};\n\n\n/**\n * Creates a simulated TimeRanges object from data sent by the cast receiver.\n * @param {?} obj\n * @return {{\n *   length: number,\n *   start: function(number): number,\n *   end: function(number): number\n * }}\n * @private\n */\nshaka.cast.CastUtils.simulateTimeRanges_ = function(obj) {\n  return {\n    length: obj.length,\n    // NOTE: a more complete simulation would throw when |i| was out of range,\n    // but for simplicity we will assume a well-behaved application that uses\n    // length instead of catch to stop iterating.\n    start: function(i) { return obj.start[i]; },\n    end: function(i) { return obj.end[i]; },\n  };\n};\n\n\n/**\n * @param {!Uint8Array} array\n * @return {Object}\n * @private\n */\nshaka.cast.CastUtils.unpackUint8Array_ = function(array) {\n  return {\n    '__type__': 'Uint8Array',  // a signal to deserialize\n    'entries': Array.from(array),\n  };\n};\n\n\n/**\n * Creates a Uint8Array object from data sent by the cast receiver.\n * @param {?} obj\n * @return {Uint8Array}\n * @private\n */\nshaka.cast.CastUtils.makeUint8Array_ = function(obj) {\n  return new Uint8Array(obj['entries']);\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.cast.CastSender');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.cast.CastUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * @constructor\n * @struct\n * @param {string} receiverAppId The ID of the cast receiver application.\n * @param {function()} onStatusChanged A callback invoked when the cast status\n *   changes.\n * @param {function()} onFirstCastStateUpdate A callback invoked when an\n *   \"update\" event has been received for the first time.\n * @param {function(string, !shaka.util.FakeEvent)} onRemoteEvent A callback\n *   invoked with target name and event when a remote event is received.\n * @param {function()} onResumeLocal A callback invoked when the local player\n *   should resume playback.  Called before the cached remote state is wiped.\n * @param {function()} onInitStateRequired A callback to get local player's.\n *   state.  Invoked when casting is initiated from Chrome's cast button.\n * @implements {shaka.util.IDestroyable}\n */\nshaka.cast.CastSender =\n    function(receiverAppId, onStatusChanged, onFirstCastStateUpdate,\n             onRemoteEvent, onResumeLocal, onInitStateRequired) {\n  /** @private {string} */\n  this.receiverAppId_ = receiverAppId;\n\n  /** @private {shaka.util.Timer} */\n  this.statusChangeTimer_ = new shaka.util.Timer(onStatusChanged);\n\n  /** @private {?function()} */\n  this.onFirstCastStateUpdate_ = onFirstCastStateUpdate;\n\n  /** @private {boolean} */\n  this.hasJoinedExistingSession_ = false;\n\n  /** @private {?function(string, !shaka.util.FakeEvent)} */\n  this.onRemoteEvent_ = onRemoteEvent;\n\n  /** @private {?function()} */\n  this.onResumeLocal_ = onResumeLocal;\n\n  /** @private {?function()} */\n  this.onInitStateRequired_ = onInitStateRequired;\n\n  /** @private {boolean} */\n  this.apiReady_ = false;\n\n  /** @private {boolean} */\n  this.isCasting_ = false;\n\n  /** @private {string} */\n  this.receiverName_ = '';\n\n  /** @private {Object} */\n  this.appData_ = null;\n\n  /** @private {?function()} */\n  this.onConnectionStatusChangedBound_ =\n      this.onConnectionStatusChanged_.bind(this);\n\n  /** @private {?function(string, string)} */\n  this.onMessageReceivedBound_ = this.onMessageReceived_.bind(this);\n\n  /** @private {Object} */\n  this.cachedProperties_ = {\n    'video': {},\n    'player': {},\n  };\n\n  /** @private {number} */\n  this.nextAsyncCallId_ = 0;\n\n  /** @private {Object.<string, !shaka.util.PublicPromise>} */\n  this.asyncCallPromises_ = {};\n\n  /** @private {shaka.util.PublicPromise} */\n  this.castPromise_ = null;\n};\n\n\n/** @private {boolean} */\nshaka.cast.CastSender.hasReceivers_ = false;\n\n\n/** @private {chrome.cast.Session} */\nshaka.cast.CastSender.session_ = null;\n\n\n/** @override */\nshaka.cast.CastSender.prototype.destroy = function() {\n  this.rejectAllPromises_();\n  if (shaka.cast.CastSender.session_) {\n    this.removeListeners_();\n    // Don't leave the session, so that this session can be re-used later if\n    // necessary.\n  }\n\n  if (this.statusChangeTimer_) {\n    this.statusChangeTimer_.stop();\n    this.statusChangeTimer_ = null;\n  }\n\n  this.onRemoteEvent_ = null;\n  this.onResumeLocal_ = null;\n  this.apiReady_ = false;\n  this.isCasting_ = false;\n  this.appData_ = null;\n  this.cachedProperties_ = null;\n  this.asyncCallPromises_ = null;\n  this.castPromise_ = null;\n  this.onConnectionStatusChangedBound_ = null;\n  this.onMessageReceivedBound_ = null;\n\n  return Promise.resolve();\n};\n\n\n/**\n * @return {boolean} True if the cast API is available.\n */\nshaka.cast.CastSender.prototype.apiReady = function() {\n  return this.apiReady_;\n};\n\n\n/**\n * @return {boolean} True if there are receivers.\n */\nshaka.cast.CastSender.prototype.hasReceivers = function() {\n  return shaka.cast.CastSender.hasReceivers_;\n};\n\n\n/**\n * @return {boolean} True if we are currently casting.\n */\nshaka.cast.CastSender.prototype.isCasting = function() {\n  return this.isCasting_;\n};\n\n\n/**\n * @return {string} The name of the Cast receiver device, if isCasting().\n */\nshaka.cast.CastSender.prototype.receiverName = function() {\n  return this.receiverName_;\n};\n\n\n/**\n * @return {boolean} True if we have a cache of remote properties from the\n *   receiver.\n */\nshaka.cast.CastSender.prototype.hasRemoteProperties = function() {\n  return Object.keys(this.cachedProperties_['video']).length != 0;\n};\n\n\n/** Initialize the Cast API. */\nshaka.cast.CastSender.prototype.init = function() {\n  // Check for the cast extension.\n  if (!window.chrome || !chrome.cast || !chrome.cast.isAvailable) {\n    // Not available yet, so wait to be notified if/when it is available.\n    window.__onGCastApiAvailable = (function(loaded) {\n      if (loaded) {\n        this.init();\n      }\n    }).bind(this);\n    return;\n  }\n\n  // The API is now available.\n  delete window.__onGCastApiAvailable;\n  this.apiReady_ = true;\n  this.statusChangeTimer_.tickNow();\n\n  let sessionRequest = new chrome.cast.SessionRequest(this.receiverAppId_);\n  let apiConfig = new chrome.cast.ApiConfig(sessionRequest,\n      this.onExistingSessionJoined_.bind(this),\n      this.onReceiverStatusChanged_.bind(this),\n      'origin_scoped');\n\n  // TODO: Have never seen this fail.  When would it and how should we react?\n  chrome.cast.initialize(apiConfig,\n      function() { shaka.log.debug('CastSender: init'); },\n      function(error) { shaka.log.error('CastSender: init error', error); });\n  if (shaka.cast.CastSender.hasReceivers_) {\n    // Fire a fake cast status change, to simulate the update that\n    // would be fired normally.\n    // This is after a brief delay, to give users a chance to add event\n    // listeners.\n    this.statusChangeTimer_.tickAfter(/* seconds= */ 0.02);\n  }\n\n  let oldSession = shaka.cast.CastSender.session_;\n  if (oldSession && oldSession.status != chrome.cast.SessionStatus.STOPPED) {\n    // The old session still exists, so re-use it.\n    shaka.log.debug('CastSender: re-using existing connection');\n    this.onExistingSessionJoined_(oldSession);\n  } else {\n    // The session has been canceled in the meantime, so ignore it.\n    shaka.cast.CastSender.session_ = null;\n  }\n};\n\n\n/**\n * Set application-specific data.\n *\n * @param {Object} appData Application-specific data to relay to the receiver.\n */\nshaka.cast.CastSender.prototype.setAppData = function(appData) {\n  this.appData_ = appData;\n  if (this.isCasting_) {\n    this.sendMessage_({\n      'type': 'appData',\n      'appData': this.appData_,\n    });\n  }\n};\n\n\n/**\n * @param {shaka.cast.CastUtils.InitStateType} initState Video and player state\n *   to be sent to the receiver.\n * @return {!Promise} Resolved when connected to a receiver.  Rejected if the\n *   connection fails or is canceled by the user.\n */\nshaka.cast.CastSender.prototype.cast = function(initState) {\n  if (!this.apiReady_) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.RECOVERABLE,\n        shaka.util.Error.Category.CAST,\n        shaka.util.Error.Code.CAST_API_UNAVAILABLE));\n  }\n  if (!shaka.cast.CastSender.hasReceivers_) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.RECOVERABLE,\n        shaka.util.Error.Category.CAST,\n        shaka.util.Error.Code.NO_CAST_RECEIVERS));\n  }\n  if (this.isCasting_) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.RECOVERABLE,\n        shaka.util.Error.Category.CAST,\n        shaka.util.Error.Code.ALREADY_CASTING));\n  }\n\n  this.castPromise_ = new shaka.util.PublicPromise();\n  chrome.cast.requestSession(\n      this.onSessionInitiated_.bind(this, initState),\n      this.onConnectionError_.bind(this));\n  return this.castPromise_;\n};\n\n\n/**\n * Shows user a cast dialog where they can choose to stop\n * casting.  Relies on Chrome to perform disconnect if they do.\n * Doesn't do anything if not connected.\n */\nshaka.cast.CastSender.prototype.showDisconnectDialog = function() {\n  if (!this.isCasting_) {\n    return;\n  }\n  let initState = this.onInitStateRequired_();\n\n  chrome.cast.requestSession(\n      this.onSessionInitiated_.bind(this, initState),\n      this.onConnectionError_.bind(this));\n};\n\n\n/**\n * Forces the receiver app to shut down by disconnecting.  Does nothing if not\n * connected.\n */\nshaka.cast.CastSender.prototype.forceDisconnect = function() {\n  if (!this.isCasting_) {\n    return;\n  }\n\n  this.rejectAllPromises_();\n  if (shaka.cast.CastSender.session_) {\n    this.removeListeners_();\n    shaka.cast.CastSender.session_.stop(function() {}, function() {});\n    shaka.cast.CastSender.session_ = null;\n  }\n};\n\n\n/**\n * Getter for properties of remote objects.\n * @param {string} targetName\n * @param {string} property\n * @return {?}\n */\nshaka.cast.CastSender.prototype.get = function(targetName, property) {\n  goog.asserts.assert(targetName == 'video' || targetName == 'player',\n                      'Unexpected target name');\n  const CastUtils = shaka.cast.CastUtils;\n  if (targetName == 'video') {\n    if (CastUtils.VideoVoidMethods.includes(property)) {\n      return this.remoteCall_.bind(this, targetName, property);\n    }\n  } else if (targetName == 'player') {\n    if (CastUtils.PlayerGetterMethodsThatRequireLive[property]) {\n      let isLive = this.get('player', 'isLive')();\n      goog.asserts.assert(isLive,\n          property + ' should be called on a live stream!');\n      // If the property shouldn't exist, return a fake function so that the\n      // user doesn't call an undefined function and get a second error.\n      if (!isLive) {\n        return () => undefined;\n      }\n    }\n    if (CastUtils.PlayerVoidMethods.includes(property)) {\n      return this.remoteCall_.bind(this, targetName, property);\n    }\n    if (CastUtils.PlayerPromiseMethods.includes(property)) {\n      return this.remoteAsyncCall_.bind(this, targetName, property);\n    }\n    if (CastUtils.PlayerGetterMethods[property]) {\n      return this.propertyGetter_.bind(this, targetName, property);\n    }\n  }\n\n  return this.propertyGetter_(targetName, property);\n};\n\n\n/**\n * Setter for properties of remote objects.\n * @param {string} targetName\n * @param {string} property\n * @param {?} value\n */\nshaka.cast.CastSender.prototype.set = function(targetName, property, value) {\n  goog.asserts.assert(targetName == 'video' || targetName == 'player',\n                      'Unexpected target name');\n\n  this.cachedProperties_[targetName][property] = value;\n  this.sendMessage_({\n    'type': 'set',\n    'targetName': targetName,\n    'property': property,\n    'value': value,\n  });\n};\n\n\n/**\n * @param {shaka.cast.CastUtils.InitStateType} initState\n * @param {chrome.cast.Session} session\n * @private\n */\nshaka.cast.CastSender.prototype.onSessionInitiated_ =\n    function(initState, session) {\n  shaka.log.debug('CastSender: onSessionInitiated');\n  this.onSessionCreated_(session);\n\n  this.sendMessage_({\n    'type': 'init',\n    'initState': initState,\n    'appData': this.appData_,\n  });\n\n  this.castPromise_.resolve();\n};\n\n\n/**\n * @param {chrome.cast.Error} error\n * @private\n */\nshaka.cast.CastSender.prototype.onConnectionError_ = function(error) {\n  // Default error code:\n  let code = shaka.util.Error.Code.UNEXPECTED_CAST_ERROR;\n\n  switch (error.code) {\n    case 'cancel':\n      code = shaka.util.Error.Code.CAST_CANCELED_BY_USER;\n      break;\n    case 'timeout':\n      code = shaka.util.Error.Code.CAST_CONNECTION_TIMED_OUT;\n      break;\n    case 'receiver_unavailable':\n      code = shaka.util.Error.Code.CAST_RECEIVER_APP_UNAVAILABLE;\n      break;\n  }\n\n  this.castPromise_.reject(new shaka.util.Error(\n      shaka.util.Error.Severity.CRITICAL,\n      shaka.util.Error.Category.CAST,\n      code,\n      error));\n};\n\n\n/**\n * @param {string} targetName\n * @param {string} property\n * @return {?}\n * @private\n */\nshaka.cast.CastSender.prototype.propertyGetter_ =\n    function(targetName, property) {\n  goog.asserts.assert(targetName == 'video' || targetName == 'player',\n                      'Unexpected target name');\n  return this.cachedProperties_[targetName][property];\n};\n\n\n/**\n * @param {string} targetName\n * @param {string} methodName\n * @param {...*} varArgs\n * @private\n */\nshaka.cast.CastSender.prototype.remoteCall_ =\n    function(targetName, methodName, ...varArgs) {\n  goog.asserts.assert(targetName == 'video' || targetName == 'player',\n                      'Unexpected target name');\n  this.sendMessage_({\n    'type': 'call',\n    'targetName': targetName,\n    'methodName': methodName,\n    'args': varArgs,\n  });\n};\n\n\n/**\n * @param {string} targetName\n * @param {string} methodName\n * @param {...*} varArgs\n * @return {!Promise}\n * @private\n */\nshaka.cast.CastSender.prototype.remoteAsyncCall_ =\n    function(targetName, methodName, ...varArgs) {\n  goog.asserts.assert(targetName == 'video' || targetName == 'player',\n                      'Unexpected target name');\n\n  let p = new shaka.util.PublicPromise();\n  let id = this.nextAsyncCallId_.toString();\n  this.nextAsyncCallId_++;\n  this.asyncCallPromises_[id] = p;\n\n  this.sendMessage_({\n    'type': 'asyncCall',\n    'targetName': targetName,\n    'methodName': methodName,\n    'args': varArgs,\n    'id': id,\n  });\n  return p;\n};\n\n\n/**\n * @param {chrome.cast.Session} session\n * @private\n */\nshaka.cast.CastSender.prototype.onExistingSessionJoined_ = function(session) {\n  shaka.log.debug('CastSender: onExistingSessionJoined');\n\n  let initState = this.onInitStateRequired_();\n\n  this.castPromise_ = new shaka.util.PublicPromise();\n  this.hasJoinedExistingSession_ = true;\n\n  this.onSessionInitiated_(initState, session);\n};\n\n\n/**\n * @param {string} availability\n * @private\n */\nshaka.cast.CastSender.prototype.onReceiverStatusChanged_ =\n    function(availability) {\n  // The cast extension is telling us whether there are any cast receiver\n  // devices available.\n  shaka.log.debug('CastSender: receiver status', availability);\n  shaka.cast.CastSender.hasReceivers_ = availability == 'available';\n  this.statusChangeTimer_.tickNow();\n};\n\n\n/**\n * @param {chrome.cast.Session} session\n * @private\n */\nshaka.cast.CastSender.prototype.onSessionCreated_ = function(session) {\n  shaka.cast.CastSender.session_ = session;\n  session.addUpdateListener(this.onConnectionStatusChangedBound_);\n  session.addMessageListener(shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE,\n      this.onMessageReceivedBound_);\n  this.onConnectionStatusChanged_();\n};\n\n\n/**\n * @private\n */\nshaka.cast.CastSender.prototype.removeListeners_ = function() {\n  let session = shaka.cast.CastSender.session_;\n  session.removeUpdateListener(this.onConnectionStatusChangedBound_);\n  session.removeMessageListener(shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE,\n      this.onMessageReceivedBound_);\n};\n\n\n/**\n * @private\n */\nshaka.cast.CastSender.prototype.onConnectionStatusChanged_ = function() {\n  let connected = shaka.cast.CastSender.session_ ?\n      shaka.cast.CastSender.session_.status == 'connected' :\n      false;\n  shaka.log.debug('CastSender: connection status', connected);\n  if (this.isCasting_ && !connected) {\n    // Tell CastProxy to transfer state back to local player.\n    this.onResumeLocal_();\n\n    // Clear whatever we have cached.\n    for (let targetName in this.cachedProperties_) {\n      this.cachedProperties_[targetName] = {};\n    }\n\n    this.rejectAllPromises_();\n  }\n\n  this.isCasting_ = connected;\n  this.receiverName_ = connected ?\n      shaka.cast.CastSender.session_.receiver.friendlyName :\n      '';\n  this.statusChangeTimer_.tickNow();\n};\n\n\n/**\n * Reject any async call promises that are still pending.\n * @private\n */\nshaka.cast.CastSender.prototype.rejectAllPromises_ = function() {\n  for (let id in this.asyncCallPromises_) {\n    let p = this.asyncCallPromises_[id];\n    delete this.asyncCallPromises_[id];\n\n    // Reject pending async operations as if they were interrupted.\n    // At the moment, load() is the only async operation we are worried about.\n    p.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.RECOVERABLE,\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.LOAD_INTERRUPTED));\n  }\n};\n\n\n/**\n * @param {string} namespace\n * @param {string} serialized\n * @private\n */\nshaka.cast.CastSender.prototype.onMessageReceived_ =\n    function(namespace, serialized) {\n  // Since this method is in the compiled library, make sure all messages passed\n  // in here were created with quoted property names.\n\n  let message = shaka.cast.CastUtils.deserialize(serialized);\n  shaka.log.v2('CastSender: message', message);\n\n  switch (message['type']) {\n    case 'event': {\n      let targetName = message['targetName'];\n      let event = message['event'];\n      let fakeEvent = new shaka.util.FakeEvent(event['type'], event);\n      this.onRemoteEvent_(targetName, fakeEvent);\n      break;\n    }\n    case 'update': {\n      let update = message['update'];\n      for (let targetName in update) {\n        let target = this.cachedProperties_[targetName] || {};\n        for (let property in update[targetName]) {\n          target[property] = update[targetName][property];\n        }\n      }\n      if (this.hasJoinedExistingSession_) {\n        this.onFirstCastStateUpdate_();\n        this.hasJoinedExistingSession_ = false;\n      }\n      break;\n    }\n    case 'asyncComplete': {\n      let id = message['id'];\n      let error = message['error'];\n      let p = this.asyncCallPromises_[id];\n      delete this.asyncCallPromises_[id];\n\n      goog.asserts.assert(p, 'Unexpected async id');\n      if (!p) break;\n\n      if (error) {\n        // This is a hacky way to reconstruct the serialized error.\n        let reconstructedError = new shaka.util.Error(\n            error.severity, error.category, error.code);\n        for (let k in error) {\n          (/** @type {Object} */(reconstructedError))[k] = error[k];\n        }\n        p.reject(reconstructedError);\n      } else {\n        p.resolve();\n      }\n      break;\n    }\n  }\n};\n\n\n/**\n * @param {!Object} message\n * @private\n */\nshaka.cast.CastSender.prototype.sendMessage_ = function(message) {\n  // Since this method is in the compiled library, make sure all messages passed\n  // in here were created with quoted property names.\n\n  let serialized = shaka.cast.CastUtils.serialize(message);\n  // TODO: have never seen this fail.  When would it and how should we react?\n  let session = shaka.cast.CastSender.session_;\n  session.sendMessage(shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE,\n                      serialized,\n                      function() {},  // success callback\n                      shaka.log.error);  // error callback\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.cast.CastReceiver');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.cast.CastUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * A receiver to communicate between the Chromecast-hosted player and the\n * sender application.\n *\n * @constructor\n * @struct\n * @param {!HTMLMediaElement} video The local video element associated with the\n *   local Player instance.\n * @param {!shaka.Player} player A local Player instance.\n * @param {function(Object)=} appDataCallback A callback to handle\n *   application-specific data passed from the sender.  This can come either\n *   from a Shaka-based sender through CastProxy.setAppData, or from a\n *   sender using the customData field of the LOAD message of the standard\n *   Cast message namespace.  It can also be null if no such data is sent.\n  * @param {function(string):string=} contentIdCallback A callback to\n *   retrieve manifest URI from the provided content id.\n * @implements {shaka.util.IDestroyable}\n * @extends {shaka.util.FakeEventTarget}\n * @export\n */\nshaka.cast.CastReceiver =\n    function(video, player, appDataCallback, contentIdCallback) {\n  shaka.util.FakeEventTarget.call(this);\n\n  /** @private {HTMLMediaElement} */\n  this.video_ = video;\n\n  /** @private {shaka.Player} */\n  this.player_ = player;\n\n  /** @private {shaka.util.EventManager} */\n  this.eventManager_ = new shaka.util.EventManager();\n\n  /** @private {Object} */\n  this.targets_ = {\n    'video': video,\n    'player': player,\n  };\n\n  /** @private {?function(Object)} */\n  this.appDataCallback_ = appDataCallback || function() {};\n\n  /** @private {?function(string):string} */\n  this.contentIdCallback_ = contentIdCallback ||\n                            /** @param {string} contentId\n                                @return {string} */\n                            function(contentId) { return contentId; };\n\n  /** @private {boolean} */\n  this.isConnected_ = false;\n\n  /** @private {boolean} */\n  this.isIdle_ = true;\n\n  /** @private {number} */\n  this.updateNumber_ = 0;\n\n  /** @private {boolean} */\n  this.startUpdatingUpdateNumber_ = false;\n\n  /** @private {boolean} */\n  this.initialStatusUpdatePending_ = true;\n\n  /** @private {cast.receiver.CastMessageBus} */\n  this.shakaBus_ = null;\n\n  /** @private {cast.receiver.CastMessageBus} */\n  this.genericBus_ = null;\n\n  /** @private {shaka.util.Timer} */\n  this.pollTimer_ = new shaka.util.Timer(() => {\n    this.pollAttributes_();\n  });\n\n  this.init_();\n};\ngoog.inherits(shaka.cast.CastReceiver, shaka.util.FakeEventTarget);\n\n\n/**\n * @return {boolean} True if the cast API is available and there are receivers.\n * @export\n */\nshaka.cast.CastReceiver.prototype.isConnected = function() {\n  return this.isConnected_;\n};\n\n\n/**\n * @return {boolean} True if the receiver is not currently doing loading or\n *   playing anything.\n * @export\n */\nshaka.cast.CastReceiver.prototype.isIdle = function() {\n  return this.isIdle_;\n};\n\n\n/**\n * Destroys the underlying Player, then terminates the cast receiver app.\n *\n * @override\n * @export\n */\nshaka.cast.CastReceiver.prototype.destroy = async function() {\n  if (this.eventManager_) {\n    this.eventManager_.release();\n    this.eventManager_ = null;\n  }\n\n  const waitFor = [];\n  if (this.player_) {\n    waitFor.push(this.player_.destroy());\n    this.player_ = null;\n  }\n\n  if (this.pollTimer_) {\n    this.pollTimer_.stop();\n    this.pollTimer_ = null;\n  }\n\n  this.video_ = null;\n  this.targets_ = null;\n  this.appDataCallback_ = null;\n  this.isConnected_ = false;\n  this.isIdle_ = true;\n  this.shakaBus_ = null;\n  this.genericBus_ = null;\n\n  await Promise.all(waitFor);\n\n  const manager = cast.receiver.CastReceiverManager.getInstance();\n  manager.stop();\n};\n\n\n/** @private */\nshaka.cast.CastReceiver.prototype.init_ = function() {\n  let manager = cast.receiver.CastReceiverManager.getInstance();\n  manager.onSenderConnected = this.onSendersChanged_.bind(this);\n  manager.onSenderDisconnected = this.onSendersChanged_.bind(this);\n  manager.onSystemVolumeChanged = this.fakeVolumeChangeEvent_.bind(this);\n\n  this.genericBus_ = manager.getCastMessageBus(\n      shaka.cast.CastUtils.GENERIC_MESSAGE_NAMESPACE);\n  this.genericBus_.onMessage = this.onGenericMessage_.bind(this);\n\n  this.shakaBus_ = manager.getCastMessageBus(\n      shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE);\n  this.shakaBus_.onMessage = this.onShakaMessage_.bind(this);\n\n  if (goog.DEBUG) {\n    // Sometimes it is useful to load the receiver app in Chrome to work on the\n    // UI.  To avoid log spam caused by the SDK trying to connect to web sockets\n    // that don't exist, in uncompiled mode we check if the hosting browser is a\n    // Chromecast before starting the receiver manager.  We wouldn't do browser\n    // detection except for debugging, so only do this in uncompiled mode.\n    if (shaka.util.Platform.isChromecast()) {\n      manager.start();\n    }\n  } else {\n    manager.start();\n  }\n\n  shaka.cast.CastUtils.VideoEvents.forEach(function(name) {\n    this.eventManager_.listen(\n        this.video_, name, this.proxyEvent_.bind(this, 'video'));\n  }.bind(this));\n\n  shaka.cast.CastUtils.PlayerEvents.forEach(function(name) {\n    this.eventManager_.listen(\n        this.player_, name, this.proxyEvent_.bind(this, 'player'));\n  }.bind(this));\n\n  // In our tests, the original Chromecast seems to have trouble decoding above\n  // 1080p.  It would be a waste to select a higher res anyway, given that the\n  // device only outputs 1080p to begin with.\n\n  // Chromecast has an extension to query the device/display's resolution.\n  if (cast.__platform__ && cast.__platform__.canDisplayType(\n      'video/mp4; codecs=\"avc1.640028\"; width=3840; height=2160')) {\n    // The device and display can both do 4k.  Assume a 4k limit.\n    this.player_.setMaxHardwareResolution(3840, 2160);\n  } else {\n    // Chromecast has always been able to do 1080p.  Assume a 1080p limit.\n    this.player_.setMaxHardwareResolution(1920, 1080);\n  }\n\n  // Do not start excluding values from update messages until the video is\n  // fully loaded.\n  this.eventManager_.listen(this.video_, 'loadeddata', function() {\n    this.startUpdatingUpdateNumber_ = true;\n  }.bind(this));\n\n  // Maintain idle state.\n  this.eventManager_.listen(this.player_, 'loading', function() {\n    // No longer idle once loading.  This allows us to show the spinner during\n    // the initial buffering phase.\n    this.isIdle_ = false;\n    this.onCastStatusChanged_();\n  }.bind(this));\n  this.eventManager_.listen(this.video_, 'playing', function() {\n    // No longer idle once playing.  This allows us to replay a video without\n    // reloading.\n    this.isIdle_ = false;\n    this.onCastStatusChanged_();\n  }.bind(this));\n  this.eventManager_.listen(this.video_, 'pause', function() {\n    this.onCastStatusChanged_();\n  }.bind(this));\n  this.eventManager_.listen(this.player_, 'unloading', function() {\n    // Go idle when unloading content.\n    this.isIdle_ = true;\n    this.onCastStatusChanged_();\n  }.bind(this));\n  this.eventManager_.listen(this.video_, 'ended', function() {\n    // Go idle 5 seconds after 'ended', assuming we haven't started again or\n    // been destroyed.\n    const timer = new shaka.util.Timer(() => {\n      if (this.video_ && this.video_.ended) {\n        this.isIdle_ = true;\n        this.onCastStatusChanged_();\n      }\n    });\n\n    timer.tickAfter(/* seconds= */ 5);\n  }.bind(this));\n\n  // Do not start polling until after the sender's 'init' message is handled.\n};\n\n\n/** @private */\nshaka.cast.CastReceiver.prototype.onSendersChanged_ = function() {\n  // Reset update message frequency values, to make sure whomever joined\n  // will get a full update message.\n  this.updateNumber_ = 0;\n  // Don't reset startUpdatingUpdateNumber_, because this operation does not\n  // result in new data being loaded.\n  this.initialStatusUpdatePending_ = true;\n\n  let manager = cast.receiver.CastReceiverManager.getInstance();\n  this.isConnected_ = manager.getSenders().length != 0;\n  this.onCastStatusChanged_();\n};\n\n\n/**\n * Dispatch an event to notify the receiver app that the status has changed.\n * @private\n */\nshaka.cast.CastReceiver.prototype.onCastStatusChanged_ = function() {\n  // Do this asynchronously so that synchronous changes to idle state (such as\n  // Player calling unload() as part of load()) are coalesced before the event\n  // goes out.\n  Promise.resolve().then(function() {\n    if (!this.player_) {\n      // We've already been destroyed.\n      return;\n    }\n\n    let event = new shaka.util.FakeEvent('caststatuschanged');\n    this.dispatchEvent(event);\n    // Send a media status message, with a media info message if appropriate.\n    if (!this.maybeSendMediaInfoMessage_()) {\n      this.sendMediaStatus_(0);\n    }\n  }.bind(this));\n};\n\n\n/**\n * Take on initial state from the sender.\n * @param {shaka.cast.CastUtils.InitStateType} initState\n * @param {Object} appData\n * @private\n */\nshaka.cast.CastReceiver.prototype.initState_ = function(initState, appData) {\n  // Take on player state first.\n  for (let k in initState['player']) {\n    let v = initState['player'][k];\n    // All player state vars are setters to be called.\n    /** @type {Object} */(this.player_)[k](v);\n  }\n\n  // Now process custom app data, which may add additional player configs:\n  this.appDataCallback_(appData);\n\n  let manifestReady = Promise.resolve();\n  let autoplay = this.video_.autoplay;\n\n  // Now load the manifest, if present.\n  if (initState['manifest']) {\n    // Don't autoplay the content until we finish setting up initial state.\n    this.video_.autoplay = false;\n    manifestReady = this.player_.load(\n        initState['manifest'], initState['startTime']);\n  }\n\n  // Finally, take on video state and player's \"after load\" state.\n  manifestReady.then(() => {\n    if (!this.player_) {\n      // We've already been destroyed.\n      return;\n    }\n\n    for (let k in initState['video']) {\n      let v = initState['video'][k];\n      this.video_[k] = v;\n    }\n\n    for (let k in initState['playerAfterLoad']) {\n      let v = initState['playerAfterLoad'][k];\n      // All player state vars are setters to be called.\n      /** @type {Object} */(this.player_)[k](v);\n    }\n\n    // Restore original autoplay setting.\n    this.video_.autoplay = autoplay;\n    if (initState['manifest']) {\n      // Resume playback with transferred state.\n      this.video_.play();\n      // Notify generic controllers of the state change.\n      this.sendMediaStatus_(0);\n    }\n  }, (error) => {\n    // Pass any errors through to the app.\n    goog.asserts.assert(error instanceof shaka.util.Error,\n                        'Wrong error type!');\n    let event = new shaka.util.FakeEvent('error', {'detail': error});\n    this.player_.dispatchEvent(event);\n  });\n};\n\n\n/**\n * @param {string} targetName\n * @param {!Event} event\n * @private\n */\nshaka.cast.CastReceiver.prototype.proxyEvent_ = function(targetName, event) {\n  if (!this.player_) {\n    // The receiver is destroyed, so it should ignore further events.\n    return;\n  }\n\n  // Poll and send an update right before we send the event.  Some events\n  // indicate an attribute change, so that change should be visible when the\n  // event is handled.\n  this.pollAttributes_();\n\n  this.sendMessage_({\n    'type': 'event',\n    'targetName': targetName,\n    'event': event,\n  }, this.shakaBus_);\n};\n\n\n/** @private */\nshaka.cast.CastReceiver.prototype.pollAttributes_ = function() {\n  // The poll timer may have been pre-empted by an event (e.g. timeupdate).\n  // Calling |start| will cancel any pending calls and therefore will avoid us\n  // polling too often.\n  this.pollTimer_.tickAfter(/* seconds= */ 0.5);\n\n  let update = {\n    'video': {},\n    'player': {},\n  };\n\n  shaka.cast.CastUtils.VideoAttributes.forEach(function(name) {\n    update['video'][name] = this.video_[name];\n  }.bind(this));\n\n  // TODO: Instead of this variable frequency update system, instead cache the\n  // previous player state and only send over changed values, with complete\n  // updates every ~20 updates to account for dropped messages.\n\n  if (this.player_.isLive()) {\n    for (let name in shaka.cast.CastUtils.PlayerGetterMethodsThatRequireLive) {\n      let frequency =\n          shaka.cast.CastUtils.PlayerGetterMethodsThatRequireLive[name];\n      if (this.updateNumber_ % frequency == 0) {\n        update['player'][name] = /** @type {Object} */ (this.player_)[name]();\n      }\n    }\n  }\n  for (let name in shaka.cast.CastUtils.PlayerGetterMethods) {\n    let frequency = shaka.cast.CastUtils.PlayerGetterMethods[name];\n    if (this.updateNumber_ % frequency == 0) {\n      update['player'][name] = /** @type {Object} */ (this.player_)[name]();\n    }\n  }\n\n  // Volume attributes are tied to the system volume.\n  let manager = cast.receiver.CastReceiverManager.getInstance();\n  let systemVolume = manager.getSystemVolume();\n  if (systemVolume) {\n    update['video']['volume'] = systemVolume.level;\n    update['video']['muted'] = systemVolume.muted;\n  }\n\n  // Only start progressing the update number once data is loaded,\n  // just in case any of the \"rarely changing\" properties with less frequent\n  // update messages changes significantly during the loading process.\n  if (this.startUpdatingUpdateNumber_) {\n    this.updateNumber_ += 1;\n  }\n\n  this.sendMessage_({\n    'type': 'update',\n    'update': update,\n  }, this.shakaBus_);\n\n  this.maybeSendMediaInfoMessage_();\n};\n\n\n/**\n * Composes and sends a mediaStatus message if appropriate.\n * @return {boolean}\n * @private\n */\nshaka.cast.CastReceiver.prototype.maybeSendMediaInfoMessage_ = function() {\n  if (this.initialStatusUpdatePending_ &&\n      (this.video_.duration || this.player_.isLive())) {\n    // Send over a media status message to set the duration of the cast\n    // dialogue.\n    this.sendMediaInfoMessage_();\n    this.initialStatusUpdatePending_ = false;\n    return true;\n  }\n  return false;\n};\n\n\n/**\n * Composes and sends a mediaStatus message with a mediaInfo component.\n * @private\n */\nshaka.cast.CastReceiver.prototype.sendMediaInfoMessage_ = function() {\n  let media = {\n    'contentId': this.player_.getAssetUri(),\n    'streamType': this.player_.isLive() ? 'LIVE' : 'BUFFERED',\n    'duration': this.video_.duration,\n    // TODO: Is there a use case when this would be required?\n    // Sending an empty string for now since it's a mandatory\n    // field.\n    'contentType': '',\n  };\n  this.sendMediaStatus_(0, media);\n};\n\n\n/**\n * Dispatch a fake 'volumechange' event to mimic the video element, since volume\n * changes are routed to the system volume on the receiver.\n * @private\n */\nshaka.cast.CastReceiver.prototype.fakeVolumeChangeEvent_ = function() {\n  // Volume attributes are tied to the system volume.\n  let manager = cast.receiver.CastReceiverManager.getInstance();\n  let systemVolume = manager.getSystemVolume();\n  goog.asserts.assert(systemVolume, 'System volume should not be null!');\n\n  if (systemVolume) {\n    // Send an update message with just the latest volume level and muted state.\n    this.sendMessage_({\n      'type': 'update',\n      'update': {\n        'video': {\n          'volume': systemVolume.level,\n          'muted': systemVolume.muted,\n        },\n      },\n    }, this.shakaBus_);\n  }\n\n  // Send another message with a 'volumechange' event to update the sender's UI.\n  this.sendMessage_({\n    'type': 'event',\n    'targetName': 'video',\n    'event': {'type': 'volumechange'},\n  }, this.shakaBus_);\n};\n\n\n/**\n * Since this method is in the compiled library, make sure all messages are\n * read with quoted properties.\n * @param {!cast.receiver.CastMessageBus.Event} event\n * @private\n */\nshaka.cast.CastReceiver.prototype.onShakaMessage_ = function(event) {\n  let message = shaka.cast.CastUtils.deserialize(event.data);\n  shaka.log.debug('CastReceiver: message', message);\n\n  switch (message['type']) {\n    case 'init':\n      // Reset update message frequency values after initialization.\n      this.updateNumber_ = 0;\n      this.startUpdatingUpdateNumber_ = false;\n      this.initialStatusUpdatePending_ = true;\n\n      this.initState_(message['initState'], message['appData']);\n      // The sender is supposed to reflect the cast system volume after\n      // connecting.  Using fakeVolumeChangeEvent_() would create a race on the\n      // sender side, since it would have volume properties, but no others.\n      // This would lead to hasRemoteProperties() being true, even though a\n      // complete set had never been sent.\n      // Now that we have init state, this is a good time for the first update\n      // message anyway.\n      this.pollAttributes_();\n      break;\n    case 'appData':\n      this.appDataCallback_(message['appData']);\n      break;\n    case 'set': {\n      let targetName = message['targetName'];\n      let property = message['property'];\n      let value = message['value'];\n\n      if (targetName == 'video') {\n        // Volume attributes must be rerouted to the system.\n        let manager = cast.receiver.CastReceiverManager.getInstance();\n        if (property == 'volume') {\n          manager.setSystemVolumeLevel(value);\n          break;\n        } else if (property == 'muted') {\n          manager.setSystemVolumeMuted(value);\n          break;\n        }\n      }\n\n      this.targets_[targetName][property] = value;\n      break;\n    }\n    case 'call': {\n      let targetName = message['targetName'];\n      let methodName = message['methodName'];\n      let args = message['args'];\n      let target = this.targets_[targetName];\n      target[methodName].apply(target, args);\n      break;\n    }\n    case 'asyncCall': {\n      let targetName = message['targetName'];\n      let methodName = message['methodName'];\n      if (targetName == 'player' && methodName == 'load') {\n        // Reset update message frequency values after a load.\n        this.updateNumber_ = 0;\n        this.startUpdatingUpdateNumber_ = false;\n      }\n      let args = message['args'];\n      let id = message['id'];\n      let senderId = event.senderId;\n      let target = this.targets_[targetName];\n      let p = target[methodName].apply(target, args);\n      if (targetName == 'player' && methodName == 'load') {\n        // Wait until the manifest has actually loaded to send another media\n        // info message, so on a new load it doesn't send the old info over.\n        p = p.then(function() {\n          this.initialStatusUpdatePending_ = true;\n        }.bind(this));\n      }\n      // Replies must go back to the specific sender who initiated, so that we\n      // don't have to deal with conflicting IDs between senders.\n      p.then(this.sendAsyncComplete_.bind(this, senderId, id, /* error */ null),\n             this.sendAsyncComplete_.bind(this, senderId, id));\n      break;\n    }\n  }\n};\n\n\n/**\n * @param {!cast.receiver.CastMessageBus.Event} event\n * @private\n */\nshaka.cast.CastReceiver.prototype.onGenericMessage_ = function(event) {\n  let message = shaka.cast.CastUtils.deserialize(event.data);\n  shaka.log.debug('CastReceiver: message', message);\n  // TODO(ismena): error message on duplicate request id from the same sender\n  switch (message['type']) {\n    case 'PLAY':\n      this.video_.play();\n      // Notify generic controllers that the player state changed.\n      // requestId=0 (the parameter) means that the message was not\n      // triggered by a GET_STATUS request.\n      this.sendMediaStatus_(0);\n      break;\n    case 'PAUSE':\n      this.video_.pause();\n      this.sendMediaStatus_(0);\n      break;\n    case 'SEEK': {\n      let currentTime = message['currentTime'];\n      let resumeState = message['resumeState'];\n      if (currentTime != null) {\n        this.video_.currentTime = Number(currentTime);\n      }\n      if (resumeState && resumeState == 'PLAYBACK_START') {\n        this.video_.play();\n        this.sendMediaStatus_(0);\n      } else if (resumeState && resumeState == 'PLAYBACK_PAUSE') {\n        this.video_.pause();\n        this.sendMediaStatus_(0);\n      }\n      break;\n    }\n    case 'STOP':\n      this.player_.unload().then(function() {\n        if (!this.player_) {\n          // We've already been destroyed.\n          return;\n        }\n\n        this.sendMediaStatus_(0);\n      }.bind(this));\n      break;\n    case 'GET_STATUS':\n      // TODO(ismena): According to the SDK this is supposed to be a\n      // unicast message to the sender that requested the status,\n      // but it doesn't appear to be working.\n      // Look into what's going on there and change this to be a\n      // unicast.\n      this.sendMediaStatus_(Number(message['requestId']));\n      break;\n    case 'VOLUME': {\n      let volumeObject = message['volume'];\n      let level = volumeObject['level'];\n      let muted = volumeObject['muted'];\n      let oldVolumeLevel = this.video_.volume;\n      let oldVolumeMuted = this.video_.muted;\n      if (level != null) {\n        this.video_.volume = Number(level);\n      }\n      if (muted != null) {\n        this.video_.muted = muted;\n      }\n      // Notify generic controllers if the volume changed.\n      if (oldVolumeLevel != this.video_.volume ||\n          oldVolumeMuted != this.video_.muted) {\n        this.sendMediaStatus_(0);\n      }\n      break;\n    }\n    case 'LOAD': {\n      // Reset update message frequency values after a load.\n      this.updateNumber_ = 0;\n      this.startUpdatingUpdateNumber_ = false;\n      this.initialStatusUpdatePending_ = false; // This already sends an update.\n\n      let mediaInfo = message['media'];\n      let contentId = mediaInfo['contentId'];\n      let currentTime = message['currentTime'];\n      let assetUri = this.contentIdCallback_(contentId);\n      let autoplay = message['autoplay'] || true;\n      let customData = mediaInfo['customData'];\n\n      this.appDataCallback_(customData);\n\n      if (autoplay) {\n        this.video_.autoplay = true;\n      }\n      this.player_.load(assetUri, currentTime).then(function() {\n        if (!this.player_) {\n          // We've already been destroyed.\n          return;\n        }\n\n        // Notify generic controllers that the media has changed.\n        this.sendMediaInfoMessage_();\n      }.bind(this)).catch(function(error) {\n        // Load failed.  Dispatch the error message to the sender.\n        let type = 'LOAD_FAILED';\n        if (error.category == shaka.util.Error.Category.PLAYER &&\n            error.code == shaka.util.Error.Code.LOAD_INTERRUPTED) {\n          type = 'LOAD_CANCELLED';\n        }\n\n        this.sendMessage_({\n          'requestId': Number(message['requestId']),\n          'type': type,\n        }, this.genericBus_);\n      }.bind(this));\n      break;\n    }\n    default:\n      shaka.log.warning(\n          'Unrecognized message type from the generic Chromecast controller!',\n          message['type']);\n      // Dispatch an error to the sender.\n      this.sendMessage_({\n        'requestId': Number(message['requestId']),\n        'type': 'INVALID_REQUEST',\n        'reason': 'INVALID_COMMAND',\n      }, this.genericBus_);\n      break;\n  }\n};\n\n\n/**\n * Tell the sender that the async operation is complete.\n * @param {string} senderId\n * @param {string} id\n * @param {shaka.util.Error} error\n * @private\n */\nshaka.cast.CastReceiver.prototype.sendAsyncComplete_ =\n    function(senderId, id, error) {\n  if (!this.player_) {\n    // We've already been destroyed.\n    return;\n  }\n\n  this.sendMessage_({\n    'type': 'asyncComplete',\n    'id': id,\n    'error': error,\n  }, this.shakaBus_, senderId);\n};\n\n\n/**\n * Since this method is in the compiled library, make sure all messages passed\n * in here were created with quoted property names.\n * @param {!Object} message\n * @param {cast.receiver.CastMessageBus} bus\n * @param {string=} senderId\n * @private\n */\nshaka.cast.CastReceiver.prototype.sendMessage_ =\n    function(message, bus, senderId) {\n  // Cuts log spam when debugging the receiver UI in Chrome.\n  if (!this.isConnected_) return;\n\n  let serialized = shaka.cast.CastUtils.serialize(message);\n  if (senderId) {\n    bus.getCastChannel(senderId).send(serialized);\n  } else {\n    bus.broadcast(serialized);\n  }\n};\n\n\n/**\n * @return {string}\n * @private\n */\nshaka.cast.CastReceiver.prototype.getPlayState_ = function() {\n  let playState = shaka.cast.CastReceiver.PLAY_STATE;\n  if (this.isIdle_) {\n    return playState.IDLE;\n  } else if (this.player_.isBuffering()) {\n    return playState.BUFFERING;\n  } else if (this.video_.paused) {\n    return playState.PAUSED;\n  } else {\n    return playState.PLAYING;\n  }\n};\n\n\n/**\n * @param {number} requestId\n * @param {Object=} media\n * @private\n */\nshaka.cast.CastReceiver.prototype.sendMediaStatus_ =\n    function(requestId, media) {\n  let mediaStatus = {\n    // mediaSessionId is a unique ID for the playback of this specific session.\n    // It's used to identify a specific instance of a playback.\n    // We don't support multiple playbacks, so just return 0.\n    'mediaSessionId': 0,\n    'playbackRate': this.video_.playbackRate,\n    'playerState': this.getPlayState_(),\n    'currentTime': this.video_.currentTime,\n    // supportedMediaCommands is a sum of all the flags of commands that the\n    // player supports.\n    // The list of comands with respective flags is:\n    // 1 - Pause\n    // 2 - Seek\n    // 4 - Stream volume\n    // 8 - Stream mute\n    // 16 - Skip forward\n    // 32 - Skip backward\n    // We support pause, seek, volume and mute which gives a value of\n    // 1+2+4+8=15\n    'supportedMediaCommands': 15,\n    'volume': {\n      'level': this.video_.volume,\n      'muted': this.video_.muted,\n    },\n  };\n\n  if (media) {\n    mediaStatus['media'] = media;\n  }\n\n  let ret = {\n    'requestId': requestId,\n    'type': 'MEDIA_STATUS',\n    'status': [mediaStatus],\n  };\n\n  this.sendMessage_(ret, this.genericBus_);\n};\n\n\n/**\n * @enum {string}\n */\nshaka.cast.CastReceiver.PLAY_STATE = {\n  IDLE: 'IDLE',\n  PLAYING: 'PLAYING',\n  BUFFERING: 'BUFFERING',\n  PAUSED: 'PAUSED',\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.XmlUtils');\n\ngoog.require('shaka.log');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * @namespace shaka.util.XmlUtils\n * @summary A set of XML utility functions.\n */\n\n\n/**\n * Finds a child XML element.\n * @param {!Node} elem The parent XML element.\n * @param {string} name The child XML element's tag name.\n * @return {Element} The child XML element, or null if a child XML element does\n *   not exist with the given tag name OR if there exists more than one\n *   child XML element with the given tag name.\n */\nshaka.util.XmlUtils.findChild = function(elem, name) {\n  let children = shaka.util.XmlUtils.findChildren(elem, name);\n  if (children.length != 1) {\n    return null;\n  }\n  return children[0];\n};\n\n\n/**\n * Finds a namespace-qualified child XML element.\n * @param {!Node} elem The parent XML element.\n * @param {string} ns The child XML element's namespace URI.\n * @param {string} name The child XML element's local name.\n * @return {Element} The child XML element, or null if a child XML element does\n *   not exist with the given tag name OR if there exists more than one\n *   child XML element with the given tag name.\n */\nshaka.util.XmlUtils.findChildNS = function(elem, ns, name) {\n  let children = shaka.util.XmlUtils.findChildrenNS(elem, ns, name);\n  if (children.length != 1) {\n    return null;\n  }\n  return children[0];\n};\n\n\n/**\n * Finds child XML elements.\n * @param {!Node} elem The parent XML element.\n * @param {string} name The child XML element's tag name.\n * @return {!Array.<!Element>} The child XML elements.\n */\nshaka.util.XmlUtils.findChildren = function(elem, name) {\n  return Array.prototype.filter.call(elem.childNodes, function(child) {\n    return child instanceof Element && child.tagName == name;\n  });\n};\n\n\n/**\n * Finds namespace-qualified child XML elements.\n * @param {!Node} elem The parent XML element.\n * @param {string} ns The child XML element's namespace URI.\n * @param {string} name The child XML element's local name.\n * @return {!Array.<!Element>} The child XML elements.\n */\nshaka.util.XmlUtils.findChildrenNS = function(elem, ns, name) {\n  return Array.prototype.filter.call(elem.childNodes, function(child) {\n    return child instanceof Element && child.localName == name &&\n        child.namespaceURI == ns;\n  });\n};\n\n\n/**\n * Gets a namespace-qualified attribute.\n * @param {!Element} elem The element to get from.\n * @param {string} ns The namespace URI.\n * @param {string} name The local name of the attribute.\n * @return {?string} The attribute's value, or null if not present.\n */\nshaka.util.XmlUtils.getAttributeNS = function(elem, ns, name) {\n  // Some browsers return the empty string when the attribute is missing,\n  // so check if it exists first.  See: https://mzl.la/2L7F0UK\n  return elem.hasAttributeNS(ns, name) ? elem.getAttributeNS(ns, name) : null;\n};\n\n\n/**\n * Gets the text contents of a node.\n * @param {!Node} elem The XML element.\n * @return {?string} The text contents, or null if there are none.\n */\nshaka.util.XmlUtils.getContents = function(elem) {\n  let isText = (child) => {\n    return child.nodeType == Node.TEXT_NODE ||\n        child.nodeType == Node.CDATA_SECTION_NODE;\n  };\n  if (!Array.prototype.every.call(elem.childNodes, isText)) {\n    return null;\n  }\n\n  // Read merged text content from all text nodes.\n  return elem.textContent.trim();\n};\n\n\n/**\n * Parses an attribute by its name.\n * @param {!Element} elem The XML element.\n * @param {string} name The attribute name.\n * @param {function(string): (T|null)} parseFunction A function that parses\n *   the attribute.\n * @param {(T|null)=} defaultValue The attribute's default value, if not\n *   specified, the attibute's default value is null.\n * @return {(T|null)} The parsed attribute on success, or the attribute's\n *   default value if the attribute does not exist or could not be parsed.\n * @template T\n */\nshaka.util.XmlUtils.parseAttr = function(\n    elem, name, parseFunction, defaultValue = null) {\n  let parsedValue = null;\n\n  let value = elem.getAttribute(name);\n  if (value != null) {\n    parsedValue = parseFunction(value);\n  }\n  return parsedValue == null ? defaultValue : parsedValue;\n};\n\n\n/**\n * Parses an XML date string.\n * @param {string} dateString\n * @return {?number} The parsed date in seconds on success; otherwise, return\n *   null.\n */\nshaka.util.XmlUtils.parseDate = function(dateString) {\n  if (!dateString) {\n    return null;\n  }\n\n  // Times in the manifest should be in UTC.  If they don't specify a timezone,\n  // Date.parse() will use the local timezone instead of UTC.  So manually add\n  // the timezone if missing ('Z' indicates the UTC timezone).\n  // Format: YYYY-MM-DDThh:mm:ss.ssssss\n  if (/^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/.test(dateString)) {\n    dateString += 'Z';\n  }\n\n  let result = Date.parse(dateString);\n  return (!isNaN(result) ? Math.floor(result / 1000.0) : null);\n};\n\n\n/**\n * Parses an XML duration string.\n * Negative values are not supported. Years and months are treated as exactly\n * 365 and 30 days respectively.\n * @param {string} durationString The duration string, e.g., \"PT1H3M43.2S\",\n *   which means 1 hour, 3 minutes, and 43.2 seconds.\n * @return {?number} The parsed duration in seconds on success; otherwise,\n *   return null.\n * @see {@link http://www.datypic.com/sc/xsd/t-xsd_duration.html}\n */\nshaka.util.XmlUtils.parseDuration = function(durationString) {\n  if (!durationString) {\n    return null;\n  }\n\n  let re = '^P(?:([0-9]*)Y)?(?:([0-9]*)M)?(?:([0-9]*)D)?' +\n           '(?:T(?:([0-9]*)H)?(?:([0-9]*)M)?(?:([0-9.]*)S)?)?$';\n  let matches = new RegExp(re).exec(durationString);\n\n  if (!matches) {\n    shaka.log.warning('Invalid duration string:', durationString);\n    return null;\n  }\n\n  // Note: Number(null) == 0 but Number(undefined) == NaN.\n  let years = Number(matches[1] || null);\n  let months = Number(matches[2] || null);\n  let days = Number(matches[3] || null);\n  let hours = Number(matches[4] || null);\n  let minutes = Number(matches[5] || null);\n  let seconds = Number(matches[6] || null);\n\n  // Assume a year always has 365 days and a month always has 30 days.\n  let d = (60 * 60 * 24 * 365) * years +\n          (60 * 60 * 24 * 30) * months +\n          (60 * 60 * 24) * days +\n          (60 * 60) * hours +\n          60 * minutes +\n          seconds;\n  return isFinite(d) ? d : null;\n};\n\n\n/**\n * Parses a range string.\n * @param {string} rangeString The range string, e.g., \"101-9213\".\n * @return {?{start: number, end: number}} The parsed range on success;\n *   otherwise, return null.\n */\nshaka.util.XmlUtils.parseRange = function(rangeString) {\n  let matches = /([0-9]+)-([0-9]+)/.exec(rangeString);\n\n  if (!matches) {\n    return null;\n  }\n\n  let start = Number(matches[1]);\n  if (!isFinite(start)) {\n    return null;\n  }\n\n  let end = Number(matches[2]);\n  if (!isFinite(end)) {\n    return null;\n  }\n\n  return {start: start, end: end};\n};\n\n\n/**\n * Parses an integer.\n * @param {string} intString The integer string.\n * @return {?number} The parsed integer on success; otherwise, return null.\n */\nshaka.util.XmlUtils.parseInt = function(intString) {\n  let n = Number(intString);\n  return (n % 1 === 0) ? n : null;\n};\n\n\n/**\n * Parses a positive integer.\n * @param {string} intString The integer string.\n * @return {?number} The parsed positive integer on success; otherwise,\n *   return null.\n */\nshaka.util.XmlUtils.parsePositiveInt = function(intString) {\n  let n = Number(intString);\n  return (n % 1 === 0) && (n > 0) ? n : null;\n};\n\n\n/**\n * Parses a non-negative integer.\n * @param {string} intString The integer string.\n * @return {?number} The parsed non-negative integer on success; otherwise,\n *   return null.\n */\nshaka.util.XmlUtils.parseNonNegativeInt = function(intString) {\n  let n = Number(intString);\n  return (n % 1 === 0) && (n >= 0) ? n : null;\n};\n\n\n/**\n * Parses a floating point number.\n * @param {string} floatString The floating point number string.\n * @return {?number} The parsed floating point number on success; otherwise,\n *   return null. May return -Infinity or Infinity.\n */\nshaka.util.XmlUtils.parseFloat = function(floatString) {\n  let n = Number(floatString);\n  return !isNaN(n) ? n : null;\n};\n\n\n/**\n * Evaluate a division expressed as a string.\n * @param {string} exprString\n *   The expression to evaluate, e.g. \"200/2\". Can also be a single number.\n * @return {?number} The evaluated expression as floating point number on\n *   success; otherwise return null.\n */\nshaka.util.XmlUtils.evalDivision = function(exprString) {\n  let res;\n  let n;\n  if ((res = exprString.match(/^(\\d+)\\/(\\d+)$/))) {\n    n = Number(res[1]) / Number(res[2]);\n  } else {\n    n = Number(exprString);\n  }\n  return !isNaN(n) ? n : null;\n};\n\n\n/**\n * Parse a string and return the resulting root element if\n * it was valid XML.\n * @param {string} xmlString\n * @param {string} expectedRootElemName\n * @return {Element|undefined}\n */\nshaka.util.XmlUtils.parseXmlString = function(xmlString, expectedRootElemName) {\n  const parser = new DOMParser();\n  let rootElem;\n  let xml;\n  try {\n    xml = parser.parseFromString(xmlString, 'text/xml');\n  } catch (exception) {}\n  if (xml) {\n    // The top-level element in the loaded xml should have the\n    // same type as the element linking.\n    if (xml.documentElement.tagName == expectedRootElemName) {\n      rootElem = xml.documentElement;\n    }\n  }\n  if (rootElem && rootElem.getElementsByTagName('parsererror').length > 0) {\n    return null;\n  }  // It had a parser error in it.\n\n  return rootElem;\n};\n\n\n/**\n * Parse some UTF8 data and return the resulting root element if\n * it was valid XML.\n * @param {ArrayBuffer} data\n * @param {string} expectedRootElemName\n * @return {Element|undefined}\n */\nshaka.util.XmlUtils.parseXml = function(data, expectedRootElemName) {\n  try {\n    const string = shaka.util.StringUtils.fromUTF8(data);\n    return shaka.util.XmlUtils.parseXmlString(string, expectedRootElemName);\n  } catch (exception) {}\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.dash.ContentProtection');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.Uint8ArrayUtils');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * @namespace shaka.dash.ContentProtection\n * @summary A set of functions for parsing and interpreting ContentProtection\n *   elements.\n */\n\n\n/**\n * @typedef {{\n *   defaultKeyId: ?string,\n *   defaultInit: Array.<shaka.extern.InitDataOverride>,\n *   drmInfos: !Array.<shaka.extern.DrmInfo>,\n *   firstRepresentation: boolean\n * }}\n *\n * @description\n * Contains information about the ContentProtection elements found at the\n * AdaptationSet level.\n *\n * @property {?string} defaultKeyId\n *   The default key ID to use.  This is used by parseKeyIds as a default.  This\n *   can be null to indicate that there is no default.\n * @property {Array.<shaka.extern.InitDataOverride>} defaultInit\n *   The default init data override.  This can be null to indicate that there\n *   is no default.\n * @property {!Array.<shaka.extern.DrmInfo>} drmInfos\n *   The DrmInfo objects.\n * @property {boolean} firstRepresentation\n *   True when first parsed; changed to false after the first call to\n *   parseKeyIds.  This is used to determine if a dummy key-system should be\n *   overwritten; namely that the first representation can replace the dummy\n *   from the AdaptationSet.\n */\nshaka.dash.ContentProtection.Context;\n\n\n/**\n * @typedef {{\n *   node: !Element,\n *   schemeUri: string,\n *   keyId: ?string,\n *   init: Array.<shaka.extern.InitDataOverride>\n * }}\n *\n * @description\n * The parsed result of a single ContentProtection element.\n *\n * @property {!Element} node\n *   The ContentProtection XML element.\n * @property {string} schemeUri\n *   The scheme URI.\n * @property {?string} keyId\n *   The default key ID, if present.\n * @property {Array.<shaka.extern.InitDataOverride>} init\n *   The init data, if present.  If there is no init data, it will be null.  If\n *   this is non-null, there is at least one element.\n */\nshaka.dash.ContentProtection.Element;\n\n\n/**\n * A map of scheme URI to key system name.\n *\n * @const {!Map.<string, string>}\n * @private\n */\nshaka.dash.ContentProtection.defaultKeySystems_ = new Map()\n    .set('urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b',\n         'org.w3.clearkey')\n    .set('urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed',\n         'com.widevine.alpha')\n    .set('urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95',\n         'com.microsoft.playready')\n    .set('urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb',\n         'com.adobe.primetime');\n\n\n/**\n * @const {string}\n * @private\n */\nshaka.dash.ContentProtection.MP4Protection_ =\n    'urn:mpeg:dash:mp4protection:2011';\n\n\n/**\n * @const {string}\n * @private\n */\nshaka.dash.ContentProtection.CencNamespaceUri_ = 'urn:mpeg:cenc:2013';\n\n\n/**\n * Parses info from the ContentProtection elements at the AdaptationSet level.\n *\n * @param {!Array.<!Element>} elems\n * @param {shaka.extern.DashContentProtectionCallback} callback\n * @param {boolean} ignoreDrmInfo\n * @return {shaka.dash.ContentProtection.Context}\n */\nshaka.dash.ContentProtection.parseFromAdaptationSet = function(\n    elems, callback, ignoreDrmInfo) {\n  const ContentProtection = shaka.dash.ContentProtection;\n  const ManifestParserUtils = shaka.util.ManifestParserUtils;\n  let parsed = ContentProtection.parseElements_(elems);\n  /** @type {Array.<shaka.extern.InitDataOverride>} */\n  let defaultInit = null;\n  /** @type {!Array.<shaka.extern.DrmInfo>} */\n  let drmInfos = [];\n  let parsedNonCenc = [];\n\n  // Get the default key ID; if there are multiple, they must all match.\n  const keyIds = new Set(parsed.map((element) => element.keyId));\n  // Remove any possible null value (elements may have no key ids).\n  keyIds.delete(null);\n\n  if (keyIds.size > 1) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_CONFLICTING_KEY_IDS);\n  }\n\n  if (!ignoreDrmInfo) {\n    // Find the default key ID and init data.  Create a new array of all the\n    // non-CENC elements.\n    parsedNonCenc = parsed.filter(function(elem) {\n      if (elem.schemeUri == ContentProtection.MP4Protection_) {\n        goog.asserts.assert(!elem.init || elem.init.length,\n                            'Init data must be null or non-empty.');\n        defaultInit = elem.init || defaultInit;\n        return false;\n      } else {\n        return true;\n      }\n    });\n\n    if (parsedNonCenc.length) {\n      drmInfos = ContentProtection.convertElements_(\n          defaultInit, callback, parsedNonCenc);\n\n      // If there are no drmInfos after parsing, then add a dummy entry.\n      // This may be removed in parseKeyIds.\n      if (drmInfos.length == 0) {\n        drmInfos = [ManifestParserUtils.createDrmInfo('', defaultInit)];\n      }\n    }\n  }\n\n  // If there are only CENC element(s) or ignoreDrmInfo flag is set, assume all\n  // key-systems are supported.\n  if (parsed.length && (ignoreDrmInfo || !parsedNonCenc.length)) {\n    drmInfos = [];\n\n    const keySystems = ContentProtection.defaultKeySystems_;\n    for (const keySystem of keySystems.values()) {\n      // If the manifest doesn't specify any key systems, we shouldn't\n      // put clearkey in this list.  Otherwise, it may be triggered when\n      // a real key system should be used instead.\n      if (keySystem != 'org.w3.clearkey') {\n        const info = ManifestParserUtils.createDrmInfo(keySystem, defaultInit);\n        drmInfos.push(info);\n      }\n    }\n  }\n\n  // If we have a default key id, apply it to every initData.\n  const defaultKeyId = Array.from(keyIds)[0] || null;\n\n  if (defaultKeyId) {\n    for (const info of drmInfos) {\n      for (const initData of info.initData) {\n        initData.keyId = defaultKeyId;\n      }\n    }\n  }\n\n  return {\n    defaultKeyId: defaultKeyId,\n    defaultInit: defaultInit,\n    drmInfos: drmInfos,\n    firstRepresentation: true,\n  };\n};\n\n\n/**\n * Parses the given ContentProtection elements found at the Representation\n * level.  This may update the |context|.\n *\n * @param {!Array.<!Element>} elems\n * @param {shaka.extern.DashContentProtectionCallback} callback\n * @param {shaka.dash.ContentProtection.Context} context\n * @param {boolean} ignoreDrmInfo\n * @return {?string} The parsed key ID\n */\nshaka.dash.ContentProtection.parseFromRepresentation = function(\n    elems, callback, context, ignoreDrmInfo) {\n  const ContentProtection = shaka.dash.ContentProtection;\n  let repContext = ContentProtection.parseFromAdaptationSet(\n      elems, callback, ignoreDrmInfo);\n\n  if (context.firstRepresentation) {\n    let asUnknown = context.drmInfos.length == 1 &&\n        !context.drmInfos[0].keySystem;\n    let asUnencrypted = context.drmInfos.length == 0;\n    let repUnencrypted = repContext.drmInfos.length == 0;\n\n    // There are two cases where we need to replace the |drmInfos| in the\n    // context with those in the Representation:\n    //   1. The AdaptationSet does not list any ContentProtection.\n    //   2. The AdaptationSet only lists unknown key-systems.\n    if (asUnencrypted || (asUnknown && !repUnencrypted)) {\n      context.drmInfos = repContext.drmInfos;\n    }\n    context.firstRepresentation = false;\n  } else if (repContext.drmInfos.length > 0) {\n    // If this is not the first Representation, then we need to remove entries\n    // from the context that do not appear in this Representation.\n    context.drmInfos = context.drmInfos.filter(function(asInfo) {\n      return repContext.drmInfos.some(function(repInfo) {\n        return repInfo.keySystem == asInfo.keySystem;\n      });\n    });\n    // If we have filtered out all key-systems, throw an error.\n    if (context.drmInfos.length == 0) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_COMMON_KEY_SYSTEM);\n    }\n  }\n\n  return repContext.defaultKeyId || context.defaultKeyId;\n};\n\n\n/**\n * Gets a Widevine license URL from a content protection element\n * containing a custom `ms:laurl` element\n *\n * @param {shaka.dash.ContentProtection.Element} element\n * @return {string}\n */\nshaka.dash.ContentProtection.getWidevineLicenseUrl = function(element) {\n  const mslaurlNode = shaka.util.XmlUtils.findChildNS(\n    element.node, 'urn:microsoft', 'laurl');\n  if (mslaurlNode) {\n    return mslaurlNode.getAttribute('licenseUrl') || '';\n  }\n  return '';\n};\n\n\n/**\n * @typedef {{\n *   type: number,\n *   value: !Uint8Array\n * }}\n *\n * @description\n * The parsed result of a PlayReady object record.\n *\n * @property {number} type\n *   Type of data stored in the record.\n * @property {!Uint8Array} value\n *   Record content.\n */\nshaka.dash.ContentProtection.PlayReadyRecord;\n\n/**\n * Enum for PlayReady record types.\n * @enum {number}\n */\nshaka.dash.ContentProtection.PLAYREADY_RECORD_TYPES = {\n  RIGHTS_MANAGEMENT: 0x001,\n  RESERVED: 0x002,\n  EMBEDDED_LICENSE: 0x003,\n};\n\n\n/**\n * Parses an Array buffer starting at byteOffset for PlayReady Object Records.\n * Each PRO Record is preceded by its PlayReady Record type and length in bytes.\n *\n * PlayReady Object Record format: https://goo.gl/FTcu46\n *\n * @param {!ArrayBuffer} recordData\n * @param {number} byteOffset\n * @return {!Array.<shaka.dash.ContentProtection.PlayReadyRecord>}\n * @private\n */\nshaka.dash.ContentProtection.parseMsProRecords_ = function(\n  recordData, byteOffset) {\n  const records = [];\n  const view = new DataView(recordData);\n\n  while (byteOffset < recordData.byteLength - 1) {\n    const type = view.getUint16(byteOffset, true);\n    byteOffset += 2;\n\n    const byteLength = view.getUint16(byteOffset, true);\n    byteOffset += 2;\n\n    goog.asserts.assert(\n      (byteLength & 1) === 0,\n      'expected byteLength to be an even number');\n\n    const recordValue = new Uint8Array(recordData, byteOffset, byteLength);\n\n    records.push({\n      type: type,\n      value: recordValue,\n    });\n\n    byteOffset += byteLength;\n  }\n\n  return records;\n};\n\n\n/**\n * Parses an ArrayBuffer for PlayReady Objects.  The data\n * should contain a 32-bit integer indicating the length of\n * the PRO in bytes.  Following that, a 16-bit integer for\n * the number of PlayReady Object Records in the PRO.  Lastly,\n * a byte array of the PRO Records themselves.\n *\n * PlayReady Object format: https://goo.gl/W8yAN4\n *\n * @param {!ArrayBuffer} data\n * @return {!Array.<shaka.dash.ContentProtection.PlayReadyRecord>}\n * @private\n */\nshaka.dash.ContentProtection.parseMsPro_ = function(data) {\n  let byteOffset = 0;\n  const view = new DataView(data);\n\n  // First 4 bytes is the PRO length (DWORD)\n  const byteLength = view.getUint32(byteOffset, true /* littleEndian */);\n  byteOffset += 4;\n\n  if (byteLength !== data.byteLength) {\n    // Malformed PRO\n    shaka.log.warning('PlayReady Object with invalid length encountered.');\n    return [];\n  }\n\n  // Skip PRO Record count (WORD)\n  byteOffset += 2;\n\n  // Rest of the data contains the PRO Records\n  const ContentProtection = shaka.dash.ContentProtection;\n  return ContentProtection.parseMsProRecords_(data, byteOffset);\n};\n\n\n/**\n * PlayReady Header format: https://goo.gl/dBzxNA\n *\n * @param {!Element} xml\n * @return {string}\n * @private\n */\nshaka.dash.ContentProtection.getLaurl_ = function(xml) {\n  // LA_URL element is optional and no more than one is\n  // allowed inside the DATA element. Only absolute URLs are allowed.\n  // If the LA_URL element exists, it must not be empty.\n  const laurlNode = xml.querySelector('DATA > LA_URL');\n  if (laurlNode) {\n    return laurlNode.textContent;\n  }\n\n  // Not found\n  return '';\n};\n\n\n/**\n * Gets a PlayReady license URL from a content protection element\n * containing a PlayReady Header Object\n *\n * @param {shaka.dash.ContentProtection.Element} element\n * @return {string}\n */\nshaka.dash.ContentProtection.getPlayReadyLicenseUrl = function(element) {\n  const proNode = shaka.util.XmlUtils.findChildNS(\n    element.node, 'urn:microsoft:playready', 'pro');\n\n  if (!proNode) {\n    return '';\n  }\n\n  const ContentProtection = shaka.dash.ContentProtection;\n  const PLAYREADY_RECORD_TYPES = ContentProtection.PLAYREADY_RECORD_TYPES;\n\n  const bytes = shaka.util.Uint8ArrayUtils.fromBase64(proNode.textContent);\n  const records = ContentProtection.parseMsPro_(bytes.buffer);\n  const record = records.filter((record) => {\n    return record.type === PLAYREADY_RECORD_TYPES.RIGHTS_MANAGEMENT;\n  })[0];\n\n  if (!record) {\n    return '';\n  }\n\n  const xml = shaka.util.StringUtils.fromUTF16(record.value, true);\n  const rootElement = shaka.util.XmlUtils.parseXmlString(xml, 'WRMHEADER');\n  if (!rootElement) {\n    return '';\n  }\n\n  return ContentProtection.getLaurl_(rootElement);\n};\n\n\n/**\n * Creates DrmInfo objects from the given element.\n *\n * @param {Array.<shaka.extern.InitDataOverride>} defaultInit\n * @param {shaka.extern.DashContentProtectionCallback} callback\n * @param {!Array.<shaka.dash.ContentProtection.Element>} elements\n * @return {!Array.<shaka.extern.DrmInfo>}\n * @private\n */\nshaka.dash.ContentProtection.convertElements_ = function(\n  defaultInit, callback, elements) {\n  const ContentProtection = shaka.dash.ContentProtection;\n  const ManifestParserUtils = shaka.util.ManifestParserUtils;\n  const defaultKeySystems = ContentProtection.defaultKeySystems_;\n  const licenseUrlParsers = ContentProtection.licenseUrlParsers_;\n\n  /** @type {!Array.<shaka.extern.DrmInfo>} */\n  const out = [];\n\n  for (const element of elements) {\n    const keySystem = defaultKeySystems.get(element.schemeUri);\n    if (keySystem) {\n      goog.asserts.assert(\n          !element.init || element.init.length,\n          'Init data must be null or non-empty.');\n\n      const initData = element.init || defaultInit;\n      const info = ManifestParserUtils.createDrmInfo(keySystem, initData);\n      const licenseParser = licenseUrlParsers.get(keySystem);\n      if (licenseParser) {\n        info.licenseServerUri = licenseParser(element);\n      }\n\n      out.push(info);\n    } else {\n      goog.asserts.assert(callback, 'ContentProtection callback is required');\n      const infos = callback(element.node) || [];\n      for (const info of infos) {\n        out.push(info);\n      }\n    }\n  }\n\n  return out;\n};\n\n\n/**\n * A map of key system name to license server url parser.\n *\n * @const {!Map.<string, function(shaka.dash.ContentProtection.Element)>}\n * @private\n */\nshaka.dash.ContentProtection.licenseUrlParsers_ = new Map()\n    .set('com.widevine.alpha',\n         shaka.dash.ContentProtection.getWidevineLicenseUrl)\n    .set('com.microsoft.playready',\n         shaka.dash.ContentProtection.getPlayReadyLicenseUrl);\n\n\n/**\n * Parses the given ContentProtection elements.  If there is an error, it\n * removes those elements.\n *\n * @param {!Array.<!Element>} elems\n * @return {!Array.<shaka.dash.ContentProtection.Element>}\n * @private\n */\nshaka.dash.ContentProtection.parseElements_ = function(elems) {\n  /** @type {!Array.<shaka.dash.ContentProtection.Element>} */\n  const out = [];\n\n  for (const elem of elems) {\n    const parsed = shaka.dash.ContentProtection.parseElement_(elem);\n    if (parsed) {\n      out.push(parsed);\n    }\n  }\n\n  return out;\n};\n\n\n/**\n * Parses the given ContentProtection element.\n *\n * @param {!Element} elem\n * @return {?shaka.dash.ContentProtection.Element}\n * @private\n */\nshaka.dash.ContentProtection.parseElement_ = function(elem) {\n  const NS = shaka.dash.ContentProtection.CencNamespaceUri_;\n\n  /** @type {?string} */\n  let schemeUri = elem.getAttribute('schemeIdUri');\n  /** @type {?string} */\n  let keyId = shaka.util.XmlUtils.getAttributeNS(elem, NS, 'default_KID');\n  /** @type {!Array.<string>} */\n  const psshs = shaka.util.XmlUtils.findChildrenNS(elem, NS, 'pssh')\n                  .map(shaka.util.XmlUtils.getContents);\n\n  if (!schemeUri) {\n    shaka.log.error('Missing required schemeIdUri attribute on',\n                    'ContentProtection element', elem);\n    return null;\n  }\n\n  schemeUri = schemeUri.toLowerCase();\n  if (keyId) {\n    keyId = keyId.replace(/-/g, '').toLowerCase();\n    if (keyId.includes(' ')) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED);\n    }\n  }\n\n  /** @type {!Array.<shaka.extern.InitDataOverride>} */\n  let init = [];\n  try {\n    // Try parsing PSSH data.\n    init = psshs.map((pssh) => {\n      return {\n        initDataType: 'cenc',\n        initData: shaka.util.Uint8ArrayUtils.fromBase64(pssh),\n        keyId: null,\n      };\n    });\n  } catch (e) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_PSSH_BAD_ENCODING);\n  }\n\n  return {\n    node: elem,\n    schemeUri: schemeUri,\n    keyId: keyId,\n    init: (init.length > 0 ? init : null),\n  };\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.dash.MpdUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * @namespace shaka.dash.MpdUtils\n * @summary MPD processing utility functions.\n */\n\n\n/**\n * @typedef {{\n *   start: number,\n *   unscaledStart: number,\n *   end: number\n * }}\n *\n * @description\n * Defines a time range of a media segment.  Times are in seconds.\n *\n * @property {number} start\n *   The start time of the range.\n * @property {number} unscaledStart\n *   The start time of the range in representation timescale units.\n * @property {number} end\n *   The end time (exclusive) of the range.\n */\nshaka.dash.MpdUtils.TimeRange;\n\n\n/**\n * @typedef {{\n *   timescale: number,\n *   segmentDuration: ?number,\n *   startNumber: number,\n *   scaledPresentationTimeOffset: number,\n *   unscaledPresentationTimeOffset: number,\n *   timeline: Array.<shaka.dash.MpdUtils.TimeRange>\n * }}\n *\n * @description\n * Contains common information between SegmentList and SegmentTemplate items.\n *\n * @property {number} timescale\n *   The time-scale of the representation.\n * @property {?number} segmentDuration\n *   The duration of the segments in seconds, if given.\n * @property {number} startNumber\n *   The start number of the segments; 1 or greater.\n * @property {number} scaledPresentationTimeOffset\n *   The presentation time offset of the representation, in seconds.\n * @property {number} unscaledPresentationTimeOffset\n *   The presentation time offset of the representation, in timescale units.\n * @property {Array.<shaka.dash.MpdUtils.TimeRange>} timeline\n *   The timeline of the representation, if given.  Times in seconds.\n */\nshaka.dash.MpdUtils.SegmentInfo;\n\n\n/**\n * @const {string}\n * @private\n */\nshaka.dash.MpdUtils.XlinkNamespaceUri_ = 'http://www.w3.org/1999/xlink';\n\n\n/**\n * Fills a SegmentTemplate URI template.  This function does not validate the\n * resulting URI.\n *\n * @param {string} uriTemplate\n * @param {?string} representationId\n * @param {?number} number\n * @param {?number} bandwidth\n * @param {?number} time\n * @return {string} A URI string.\n * @see ISO/IEC 23009-1:2014 section 5.3.9.4.4\n */\nshaka.dash.MpdUtils.fillUriTemplate = function(\n    uriTemplate, representationId, number, bandwidth, time) {\n  /** @type {!Object.<string, ?number|?string>} */\n  let valueTable = {\n    'RepresentationID': representationId,\n    'Number': number,\n    'Bandwidth': bandwidth,\n    'Time': time,\n  };\n\n  const re =\n      /\\$(RepresentationID|Number|Bandwidth|Time)?(?:%0([0-9]+)([diouxX]))?\\$/g;\n  let uri = uriTemplate.replace(re, function(match, name, widthString, format) {\n    if (match == '$$') {\n      return '$';\n    }\n\n    let value = valueTable[name];\n    goog.asserts.assert(value !== undefined, 'Unrecognized identifier');\n\n    // Note that |value| may be 0 or ''.\n    if (value == null) {\n      shaka.log.warning(\n          'URL template does not have an available substitution for identifier',\n          '\"' + name + '\":',\n          uriTemplate);\n      return match;\n    }\n\n    if (name == 'RepresentationID' && widthString) {\n      shaka.log.warning(\n          'URL template should not contain a width specifier for identifier',\n          '\"RepresentationID\":',\n          uriTemplate);\n      widthString = undefined;\n    }\n\n    if (name == 'Time') {\n      goog.asserts.assert(Math.abs(value - Math.round(value)) < 0.2,\n                          'Calculated $Time$ values must be close to integers');\n      value = Math.round(value);\n    }\n\n    /** @type {string} */\n    let valueString;\n    switch (format) {\n      case undefined:  // Happens if there is no format specifier.\n      case 'd':\n      case 'i':\n      case 'u':\n        valueString = value.toString();\n        break;\n      case 'o':\n        valueString = value.toString(8);\n        break;\n      case 'x':\n        valueString = value.toString(16);\n        break;\n      case 'X':\n        valueString = value.toString(16).toUpperCase();\n        break;\n      default:\n        goog.asserts.assert(false, 'Unhandled format specifier');\n        valueString = value.toString();\n        break;\n    }\n\n    // Create a padding string.\n    let width = window.parseInt(widthString, 10) || 1;\n    let paddingSize = Math.max(0, width - valueString.length);\n    let padding = (new Array(paddingSize + 1)).join('0');\n\n    return padding + valueString;\n  });\n\n  return uri;\n};\n\n\n/**\n * Expands a SegmentTimeline into an array-based timeline.  The results are in\n * seconds.\n *\n * @param {!Element} segmentTimeline\n * @param {number} timescale\n * @param {number} unscaledPresentationTimeOffset\n * @param {number} periodDuration The Period's duration in seconds.\n *   Infinity indicates that the Period continues indefinitely.\n * @return {!Array.<shaka.dash.MpdUtils.TimeRange>}\n */\nshaka.dash.MpdUtils.createTimeline =\n    function(segmentTimeline, timescale, unscaledPresentationTimeOffset,\n             periodDuration) {\n  goog.asserts.assert(\n      timescale > 0 && timescale < Infinity,\n      'timescale must be a positive, finite integer');\n  goog.asserts.assert(periodDuration > 0,\n                      'period duration must be a positive integer');\n\n  // Alias.\n  const XmlUtils = shaka.util.XmlUtils;\n\n  let timePoints = XmlUtils.findChildren(segmentTimeline, 'S');\n\n  /** @type {!Array.<shaka.dash.MpdUtils.TimeRange>} */\n  let timeline = [];\n  let lastEndTime = 0;\n\n  for (let i = 0; i < timePoints.length; ++i) {\n    let timePoint = timePoints[i];\n    let t = XmlUtils.parseAttr(timePoint, 't', XmlUtils.parseNonNegativeInt);\n    let d = XmlUtils.parseAttr(timePoint, 'd', XmlUtils.parseNonNegativeInt);\n    let r = XmlUtils.parseAttr(timePoint, 'r', XmlUtils.parseInt);\n\n    // Adjust the start time to account for the presentation time offset.\n    if (t != null) {\n      t -= unscaledPresentationTimeOffset;\n    }\n\n    if (!d) {\n      shaka.log.warning(\n          '\"S\" element must have a duration:',\n          'ignoring the remaining \"S\" elements.',\n          timePoint);\n      return timeline;\n    }\n\n    let startTime = t != null ? t : lastEndTime;\n\n    let repeat = r || 0;\n    if (repeat < 0) {\n      if (i + 1 < timePoints.length) {\n        let nextTimePoint = timePoints[i + 1];\n        let nextStartTime = XmlUtils.parseAttr(\n            nextTimePoint, 't', XmlUtils.parseNonNegativeInt);\n        if (nextStartTime == null) {\n          shaka.log.warning(\n              'An \"S\" element cannot have a negative repeat',\n              'if the next \"S\" element does not have a valid start time:',\n              'ignoring the remaining \"S\" elements.',\n              timePoint);\n          return timeline;\n        } else if (startTime >= nextStartTime) {\n          shaka.log.warning(\n              'An \"S\" element cannot have a negative repeat',\n              'if its start time exceeds the next \"S\" element\\'s start time:',\n              'ignoring the remaining \"S\" elements.',\n              timePoint);\n          return timeline;\n        }\n        repeat = Math.ceil((nextStartTime - startTime) / d) - 1;\n      } else {\n        if (periodDuration == Infinity) {\n          // The DASH spec. actually allows the last \"S\" element to have a\n          // negative repeat value even when the Period has an infinite\n          // duration.  No one uses this feature and no one ever should, ever.\n          shaka.log.warning(\n              'The last \"S\" element cannot have a negative repeat',\n              'if the Period has an infinite duration:',\n              'ignoring the last \"S\" element.',\n              timePoint);\n          return timeline;\n        } else if (startTime / timescale >= periodDuration) {\n          shaka.log.warning(\n              'The last \"S\" element cannot have a negative repeat',\n              'if its start time exceeds the Period\\'s duration:',\n              'igoring the last \"S\" element.',\n              timePoint);\n          return timeline;\n        }\n        repeat = Math.ceil((periodDuration * timescale - startTime) / d) - 1;\n      }\n    }\n\n    // The end of the last segment may be before the start of the current\n    // segment (a gap) or after the start of the current segment (an overlap).\n    // If there is a gap/overlap then stretch/compress the end of the last\n    // segment to the start of the current segment.\n    //\n    // Note: it is possible to move the start of the current segment to the\n    // end of the last segment, but this would complicate the computation of\n    // the $Time$ placeholder later on.\n    if ((timeline.length > 0) && (startTime != lastEndTime)) {\n      let delta = startTime - lastEndTime;\n\n      if (Math.abs(delta / timescale) >=\n          shaka.util.ManifestParserUtils.GAP_OVERLAP_TOLERANCE_SECONDS) {\n        shaka.log.warning(\n            'SegmentTimeline contains a large gap/overlap:',\n            'the content may have errors in it.',\n            timePoint);\n      }\n\n      timeline[timeline.length - 1].end = startTime / timescale;\n    }\n\n    for (let j = 0; j <= repeat; ++j) {\n      let endTime = startTime + d;\n      let item = {\n        start: startTime / timescale,\n        end: endTime / timescale,\n        unscaledStart: startTime,\n      };\n      timeline.push(item);\n\n      startTime = endTime;\n      lastEndTime = endTime;\n    }\n  }\n\n  return timeline;\n};\n\n\n/**\n * Parses common segment info for SegmentList and SegmentTemplate.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n *   Gets the element that contains the segment info.\n * @return {shaka.dash.MpdUtils.SegmentInfo}\n */\nshaka.dash.MpdUtils.parseSegmentInfo = function(context, callback) {\n  goog.asserts.assert(\n      callback(context.representation),\n      'There must be at least one element of the given type.');\n  const MpdUtils = shaka.dash.MpdUtils;\n  const XmlUtils = shaka.util.XmlUtils;\n\n  let timescaleStr = MpdUtils.inheritAttribute(context, callback, 'timescale');\n  let timescale = 1;\n  if (timescaleStr) {\n    timescale = XmlUtils.parsePositiveInt(timescaleStr) || 1;\n  }\n\n  let durationStr = MpdUtils.inheritAttribute(context, callback, 'duration');\n  let segmentDuration = XmlUtils.parsePositiveInt(durationStr || '');\n  if (segmentDuration) {\n    segmentDuration /= timescale;\n  }\n\n  let startNumberStr =\n      MpdUtils.inheritAttribute(context, callback, 'startNumber');\n  let unscaledPresentationTimeOffset =\n      Number(MpdUtils.inheritAttribute(context, callback,\n                                       'presentationTimeOffset')) || 0;\n  let startNumber = XmlUtils.parseNonNegativeInt(startNumberStr || '');\n  if (startNumberStr == null || startNumber == null) {\n    startNumber = 1;\n  }\n\n  let timelineNode =\n      MpdUtils.inheritChild(context, callback, 'SegmentTimeline');\n  /** @type {Array.<shaka.dash.MpdUtils.TimeRange>} */\n  let timeline = null;\n  if (timelineNode) {\n    timeline = MpdUtils.createTimeline(\n        timelineNode, timescale, unscaledPresentationTimeOffset,\n        context.periodInfo.duration || Infinity);\n  }\n\n  let scaledPresentationTimeOffset =\n      (unscaledPresentationTimeOffset / timescale) || 0;\n  return {\n    timescale: timescale,\n    segmentDuration: segmentDuration,\n    startNumber: startNumber,\n    scaledPresentationTimeOffset: scaledPresentationTimeOffset,\n    unscaledPresentationTimeOffset: unscaledPresentationTimeOffset,\n    timeline: timeline,\n  };\n};\n\n\n/**\n * Searches the inheritance for a Segment* with the given attribute.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n *   Gets the Element that contains the attribute to inherit.\n * @param {string} attribute\n * @return {?string}\n */\nshaka.dash.MpdUtils.inheritAttribute = function(context, callback, attribute) {\n  const Functional = shaka.util.Functional;\n  goog.asserts.assert(\n      callback(context.representation),\n      'There must be at least one element of the given type');\n\n  /** @type {!Array.<!Element>} */\n  let nodes = [\n    callback(context.representation),\n    callback(context.adaptationSet),\n    callback(context.period),\n  ].filter(Functional.isNotNull);\n\n  return nodes\n      .map(function(s) { return s.getAttribute(attribute); })\n      .reduce(function(all, part) { return all || part; });\n};\n\n\n/**\n * Searches the inheritance for a Segment* with the given child.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n *   Gets the Element that contains the child to inherit.\n * @param {string} child\n * @return {Element}\n */\nshaka.dash.MpdUtils.inheritChild = function(context, callback, child) {\n  const Functional = shaka.util.Functional;\n  goog.asserts.assert(\n      callback(context.representation),\n      'There must be at least one element of the given type');\n\n  /** @type {!Array.<!Element>} */\n  let nodes = [\n    callback(context.representation),\n    callback(context.adaptationSet),\n    callback(context.period),\n  ].filter(Functional.isNotNull);\n\n  const XmlUtils = shaka.util.XmlUtils;\n  return nodes\n      .map(function(s) { return XmlUtils.findChild(s, child); })\n      .reduce(function(all, part) { return all || part; });\n};\n\n\n/**\n * Follow the xlink link contained in the given element.\n * It also strips the xlink properties off of the element,\n * even if the process fails.\n *\n * @param {!Element} element\n * @param {!shaka.extern.RetryParameters} retryParameters\n * @param {boolean} failGracefully\n * @param {string} baseUri\n * @param {!shaka.net.NetworkingEngine} networkingEngine\n * @param {number} linkDepth\n * @return {!shaka.util.AbortableOperation.<!Element>}\n * @private\n */\nshaka.dash.MpdUtils.handleXlinkInElement_ =\n    function(element, retryParameters, failGracefully, baseUri,\n             networkingEngine, linkDepth) {\n  const MpdUtils = shaka.dash.MpdUtils;\n  const XmlUtils = shaka.util.XmlUtils;\n  const Error = shaka.util.Error;\n  const ManifestParserUtils = shaka.util.ManifestParserUtils;\n  const NS = MpdUtils.XlinkNamespaceUri_;\n\n  let xlinkHref = XmlUtils.getAttributeNS(element, NS, 'href');\n  let xlinkActuate =\n      XmlUtils.getAttributeNS(element, NS, 'actuate') || 'onRequest';\n\n  // Remove the xlink properties, so it won't download again\n  // when re-processed.\n  for (let i = 0; i < element.attributes.length; i++) {\n    let attribute = element.attributes[i];\n    if (attribute.namespaceURI == NS) {\n      element.removeAttributeNS(attribute.namespaceURI, attribute.localName);\n      i -= 1;\n    }\n  }\n\n  if (linkDepth >= 5) {\n    return shaka.util.AbortableOperation.failed(new Error(\n        Error.Severity.CRITICAL, Error.Category.MANIFEST,\n        Error.Code.DASH_XLINK_DEPTH_LIMIT));\n  }\n\n  if (xlinkActuate != 'onLoad') {\n    // Only xlink:actuate=\"onLoad\" is supported.\n    // When no value is specified, the assumed value is \"onRequest\".\n    return shaka.util.AbortableOperation.failed(new Error(\n        Error.Severity.CRITICAL, Error.Category.MANIFEST,\n        Error.Code.DASH_UNSUPPORTED_XLINK_ACTUATE));\n  }\n\n  // Resolve the xlink href, in case it's a relative URL.\n  let uris = ManifestParserUtils.resolveUris([baseUri], [xlinkHref]);\n\n  // Load in the linked elements.\n  const requestType = shaka.net.NetworkingEngine.RequestType.MANIFEST;\n  let request = shaka.net.NetworkingEngine.makeRequest(\n      uris, retryParameters);\n\n  let requestOperation = networkingEngine.request(requestType, request);\n  // The interface is abstract, but we know it was implemented with the\n  // more capable internal class.\n  goog.asserts.assert(requestOperation instanceof shaka.util.AbortableOperation,\n                      'Unexpected implementation of IAbortableOperation!');\n  // Satisfy the compiler with a cast.\n  let networkOperation =\n      /** @type {!shaka.util.AbortableOperation.<shaka.extern.Response>} */(\n          requestOperation);\n\n  // Chain onto that operation.\n  return networkOperation.chain((response) => {\n    // This only supports the case where the loaded xml has a single\n    // top-level element.  If there are multiple roots, it will be rejected.\n    let rootElem = shaka.util.XmlUtils.parseXml(response.data, element.tagName);\n    if (!rootElem) {\n      // It was not valid XML.\n      return shaka.util.AbortableOperation.failed(new Error(\n          Error.Severity.CRITICAL, Error.Category.MANIFEST,\n          Error.Code.DASH_INVALID_XML, xlinkHref));\n    }\n\n    // Now that there is no other possibility of the process erroring,\n    // the element can be changed further.\n\n    // Remove the current contents of the node.\n    while (element.childNodes.length) {\n      element.removeChild(element.childNodes[0]);\n    }\n\n    // Move the children of the loaded xml into the current element.\n    while (rootElem.childNodes.length) {\n      let child = rootElem.childNodes[0];\n      rootElem.removeChild(child);\n      element.appendChild(child);\n    }\n\n    // Move the attributes of the loaded xml into the current element.\n    for (let i = 0; i < rootElem.attributes.length; i++) {\n      let attribute = rootElem.attributes[i].nodeName;\n      let attributeValue = rootElem.getAttribute(attribute);\n      element.setAttribute(attribute, attributeValue);\n    }\n\n    return shaka.dash.MpdUtils.processXlinks(\n        element, retryParameters, failGracefully, uris[0], networkingEngine,\n        linkDepth + 1);\n  });\n};\n\n\n/**\n * Filter the contents of a node recursively, replacing xlink links\n * with their associated online data.\n *\n * @param {!Element} element\n * @param {!shaka.extern.RetryParameters} retryParameters\n * @param {boolean} failGracefully\n * @param {string} baseUri\n * @param {!shaka.net.NetworkingEngine} networkingEngine\n * @param {number=} linkDepth, default set to 0\n * @return {!shaka.util.AbortableOperation.<!Element>}\n */\nshaka.dash.MpdUtils.processXlinks =\n    function(element, retryParameters, failGracefully, baseUri,\n             networkingEngine, linkDepth = 0) {\n  const MpdUtils = shaka.dash.MpdUtils;\n  const XmlUtils = shaka.util.XmlUtils;\n  const NS = MpdUtils.XlinkNamespaceUri_;\n\n  if (XmlUtils.getAttributeNS(element, NS, 'href')) {\n    let handled = MpdUtils.handleXlinkInElement_(\n        element, retryParameters, failGracefully, baseUri,\n        networkingEngine, linkDepth);\n    if (failGracefully) {\n      // Catch any error and go on.\n      handled = handled.chain(undefined, (error) => {\n        // handleXlinkInElement_ strips the xlink properties off of the element\n        // even if it fails, so calling processXlinks again will handle whatever\n        // contents the element natively has.\n        return MpdUtils.processXlinks(element, retryParameters, failGracefully,\n                                      baseUri, networkingEngine,\n                                      linkDepth);\n      });\n    }\n    return handled;\n  }\n\n  let childOperations = [];\n  for (let i = 0; i < element.childNodes.length; i++) {\n    let child = element.childNodes[i];\n    if (child instanceof Element) {\n      const resolveToZeroString = 'urn:mpeg:dash:resolve-to-zero:2013';\n      if (XmlUtils.getAttributeNS(child, NS, 'href') == resolveToZeroString) {\n        // This is a 'resolve to zero' code; it means the element should\n        // be removed, as specified by the mpeg-dash rules for xlink.\n        element.removeChild(child);\n        i -= 1;\n      } else if (child.tagName != 'SegmentTimeline') {\n        // Don't recurse into a SegmentTimeline since xlink attributes aren't\n        // valid in there and looking at each segment can take a long time with\n        // larger manifests.\n\n        // Replace the child with its processed form.\n        childOperations.push(shaka.dash.MpdUtils.processXlinks(\n            /** @type {!Element} */ (child), retryParameters, failGracefully,\n            baseUri, networkingEngine, linkDepth));\n      }\n    }\n  }\n\n  return shaka.util.AbortableOperation.all(childOperations).chain(() => {\n    return element;\n  });\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.InitSegmentReference');\ngoog.provide('shaka.media.SegmentReference');\n\ngoog.require('goog.asserts');\n\n\n/**\n * Creates an InitSegmentReference, which provides the location to an\n * initialization segment.\n *\n * @param {function():!Array.<string>} uris A function that creates the URIs of\n *   the resource containing the segment.\n * @param {number} startByte The offset from the start of the resource to the\n *   start of the segment.\n * @param {?number} endByte The offset from the start of the resource to the\n *   end of the segment, inclusive.  A value of null indicates that the segment\n *   extends to the end of the resource.\n *\n * @constructor\n * @struct\n * @export\n */\nshaka.media.InitSegmentReference = function(uris, startByte, endByte) {\n  /** @type {function():!Array.<string>} */\n  this.getUris = uris;\n\n  /** @const {number} */\n  this.startByte = startByte;\n\n  /** @const {?number} */\n  this.endByte = endByte;\n};\n\n\n/**\n * Creates the URIs of the resource containing the segment.\n *\n * @return {!Array.<string>}\n * @export\n */\nshaka.media.InitSegmentReference.prototype.createUris = function() {\n  return this.getUris();\n};\n\n\n/**\n * Returns the offset from the start of the resource to the\n * start of the segment.\n *\n * @return {number}\n * @export\n */\nshaka.media.InitSegmentReference.prototype.getStartByte = function() {\n  return this.startByte;\n};\n\n\n/**\n * Returns the offset from the start of the resource to the end of the segment,\n * inclusive.  A value of null indicates that the segment extends to the end of\n * the resource.\n *\n * @return {?number}\n * @export\n */\nshaka.media.InitSegmentReference.prototype.getEndByte = function() {\n  return this.endByte;\n};\n\n\n/**\n * Returns the size of the init segment.\n * @return {?number}\n */\nshaka.media.InitSegmentReference.prototype.getSize = function() {\n  if (this.endByte) {\n    return this.endByte - this.startByte;\n  } else {\n    return null;\n  }\n};\n\n\n/**\n * Creates a SegmentReference, which provides the start time, end time, and\n * location to a media segment.\n *\n * @param {number} position The segment's position within a particular Period.\n *   The following should hold true between any two SegmentReferences from the\n *   same Period, r1 and r2:\n *   IF r2.position > r1.position THEN\n *     [ (r2.startTime > r1.startTime) OR\n *       (r2.startTime == r1.startTime AND r2.endTime >= r1.endTime) ]\n * @param {number} startTime The segment's start time in seconds, relative to\n *   the start of a particular Period.\n * @param {number} endTime The segment's end time in seconds, relative to\n *   the start of a particular Period.  The segment ends the instant before\n *   this time, so |endTime| must be strictly greater than |startTime|.\n * @param {function():!Array.<string>} uris\n *   A function that creates the URIs of the resource containing the segment.\n * @param {number} startByte The offset from the start of the resource to the\n *   start of the segment.\n * @param {?number} endByte The offset from the start of the resource to the\n *   end of the segment, inclusive.  A value of null indicates that the segment\n *   extends to the end of the resource.\n *\n * @constructor\n * @struct\n * @export\n */\nshaka.media.SegmentReference = function(\n    position, startTime, endTime, uris, startByte, endByte) {\n  goog.asserts.assert(startTime < endTime,\n                      'startTime must be less than endTime');\n  goog.asserts.assert((startByte < endByte) || (endByte == null),\n                      'startByte must be < endByte');\n  /** @const {number} */\n  this.position = position;\n\n  /** @type {number} */\n  this.startTime = startTime;\n\n  /** @type {number} */\n  this.endTime = endTime;\n\n  /** @type {function():!Array.<string>} */\n  this.getUris = uris;\n\n  /** @const {number} */\n  this.startByte = startByte;\n\n  /** @const {?number} */\n  this.endByte = endByte;\n};\n\n\n/**\n * Returns the segment's position within a particular Period.\n *\n * @return {number} The segment's position.\n * @export\n */\nshaka.media.SegmentReference.prototype.getPosition = function() {\n  return this.position;\n};\n\n\n/**\n * Returns the segment's start time in seconds, relative to\n * the start of a particular Period.\n *\n * @return {number}\n * @export\n */\nshaka.media.SegmentReference.prototype.getStartTime = function() {\n  return this.startTime;\n};\n\n\n/**\n * Returns the segment's end time in seconds, relative to\n * the start of a particular Period.\n *\n * @return {number}\n * @export\n */\nshaka.media.SegmentReference.prototype.getEndTime = function() {\n  return this.endTime;\n};\n\n\n/**\n * Creates the URIs of the resource containing the segment.\n *\n * @return {!Array.<string>}\n * @export\n */\nshaka.media.SegmentReference.prototype.createUris = function() {\n  return this.getUris();\n};\n\n\n/**\n * Returns the offset from the start of the resource to the\n * start of the segment.\n *\n * @return {number}\n * @export\n */\nshaka.media.SegmentReference.prototype.getStartByte = function() {\n  return this.startByte;\n};\n\n\n/**\n * Returns the offset from the start of the resource to the end of the segment,\n * inclusive.  A value of null indicates that the segment extends to the end of\n * the resource.\n *\n * @return {?number}\n * @export\n */\nshaka.media.SegmentReference.prototype.getEndByte = function() {\n  return this.endByte;\n};\n\n\n/**\n * Returns the size of the segment.\n * @return {?number}\n */\nshaka.media.SegmentReference.prototype.getSize = function() {\n  if (this.endByte) {\n    return this.endByte - this.startByte;\n  } else {\n    return null;\n  }\n};\n\n\n/**\n * A convenient typedef for when either type of reference is acceptable.\n *\n * @typedef {shaka.media.InitSegmentReference|shaka.media.SegmentReference}\n */\nshaka.media.AnySegmentReference;\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.DataViewReader');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * Creates a DataViewReader, which abstracts a DataView object.\n *\n * @param {!DataView} dataView The DataView.\n * @param {shaka.util.DataViewReader.Endianness} endianness The endianness.\n *\n * @struct\n * @constructor\n * @export\n */\nshaka.util.DataViewReader = function(dataView, endianness) {\n  /** @private {!DataView} */\n  this.dataView_ = dataView;\n\n  /** @private {boolean} */\n  this.littleEndian_ =\n      endianness == shaka.util.DataViewReader.Endianness.LITTLE_ENDIAN;\n\n  /** @private {number} */\n  this.position_ = 0;\n};\n\n\n/**\n * Endianness.\n * @enum {number}\n * @export\n */\nshaka.util.DataViewReader.Endianness = {\n  BIG_ENDIAN: 0,\n  LITTLE_ENDIAN: 1,\n};\n\n\n/**\n * @return {boolean} True if the reader has more data, false otherwise.\n * @export\n */\nshaka.util.DataViewReader.prototype.hasMoreData = function() {\n  return this.position_ < this.dataView_.byteLength;\n};\n\n\n/**\n * Gets the current byte position.\n * @return {number}\n * @export\n */\nshaka.util.DataViewReader.prototype.getPosition = function() {\n  return this.position_;\n};\n\n\n/**\n * Gets the byte length of the DataView.\n * @return {number}\n * @export\n */\nshaka.util.DataViewReader.prototype.getLength = function() {\n  return this.dataView_.byteLength;\n};\n\n\n/**\n * Reads an unsigned 8 bit integer, and advances the reader.\n * @return {number} The integer.\n * @throws {shaka.util.Error} when reading past the end of the data view.\n * @export\n */\nshaka.util.DataViewReader.prototype.readUint8 = function() {\n  try {\n    let value = this.dataView_.getUint8(this.position_);\n    this.position_ += 1;\n    return value;\n  } catch (exception) {\n    this.throwOutOfBounds_();\n  }\n};\n\n\n/**\n * Reads an unsigned 16 bit integer, and advances the reader.\n * @return {number} The integer.\n * @throws {shaka.util.Error} when reading past the end of the data view.\n * @export\n */\nshaka.util.DataViewReader.prototype.readUint16 = function() {\n  try {\n    let value = this.dataView_.getUint16(this.position_, this.littleEndian_);\n    this.position_ += 2;\n    return value;\n  } catch (exception) {\n    this.throwOutOfBounds_();\n  }\n};\n\n\n/**\n * Reads an unsigned 32 bit integer, and advances the reader.\n * @return {number} The integer.\n * @throws {shaka.util.Error} when reading past the end of the data view.\n * @export\n */\nshaka.util.DataViewReader.prototype.readUint32 = function() {\n  try {\n    let value = this.dataView_.getUint32(this.position_, this.littleEndian_);\n    this.position_ += 4;\n    return value;\n  } catch (exception) {\n    this.throwOutOfBounds_();\n  }\n};\n\n\n/**\n * Reads a signed 32 bit integer, and advances the reader.\n * @return {number} The integer.\n * @throws {shaka.util.Error} when reading past the end of the data view.\n * @export\n */\nshaka.util.DataViewReader.prototype.readInt32 = function() {\n  try {\n    let value = this.dataView_.getInt32(this.position_, this.littleEndian_);\n    this.position_ += 4;\n    return value;\n  } catch (exception) {\n    this.throwOutOfBounds_();\n  }\n};\n\n\n/**\n * Reads an unsigned 64 bit integer, and advances the reader.\n * @return {number} The integer.\n * @throws {shaka.util.Error} when reading past the end of the data view or\n *   when reading an integer too large to store accurately in JavaScript.\n * @export\n */\nshaka.util.DataViewReader.prototype.readUint64 = function() {\n  /** @type {number} */\n  let low;\n  /** @type {number} */\n  let high;\n\n  try {\n    if (this.littleEndian_) {\n      low = this.dataView_.getUint32(this.position_, true);\n      high = this.dataView_.getUint32(this.position_ + 4, true);\n    } else {\n      high = this.dataView_.getUint32(this.position_, false);\n      low = this.dataView_.getUint32(this.position_ + 4, false);\n    }\n  } catch (exception) {\n    this.throwOutOfBounds_();\n  }\n\n  if (high > 0x1FFFFF) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.JS_INTEGER_OVERFLOW);\n  }\n\n  this.position_ += 8;\n\n  // NOTE: This is subtle, but in JavaScript you can't shift left by 32 and get\n  // the full range of 53-bit values possible.  You must multiply by 2^32.\n  return (high * Math.pow(2, 32)) + low;\n};\n\n\n/**\n * Reads the specified number of raw bytes.\n * @param {number} bytes The number of bytes to read.\n * @return {!Uint8Array}\n * @throws {shaka.util.Error} when reading past the end of the data view.\n * @export\n */\nshaka.util.DataViewReader.prototype.readBytes = function(bytes) {\n  goog.asserts.assert(bytes >= 0, 'Bad call to DataViewReader.readBytes');\n  if (this.position_ + bytes > this.dataView_.byteLength) {\n    this.throwOutOfBounds_();\n  }\n\n  let value = new Uint8Array(\n      this.dataView_.buffer, this.dataView_.byteOffset + this.position_, bytes);\n  this.position_ += bytes;\n  return new Uint8Array(value);\n};\n\n\n/**\n * Skips the specified number of bytes.\n * @param {number} bytes The number of bytes to skip.\n * @throws {shaka.util.Error} when skipping past the end of the data view.\n * @export\n */\nshaka.util.DataViewReader.prototype.skip = function(bytes) {\n  goog.asserts.assert(bytes >= 0, 'Bad call to DataViewReader.skip');\n  if (this.position_ + bytes > this.dataView_.byteLength) {\n    this.throwOutOfBounds_();\n  }\n  this.position_ += bytes;\n};\n\n\n/**\n * Rewinds the specified number of bytes.\n * @param {number} bytes The number of bytes to rewind.\n * @throws {shaka.util.Error} when rewinding past the beginning of the data\n *   view.\n * @export\n */\nshaka.util.DataViewReader.prototype.rewind = function(bytes) {\n  goog.asserts.assert(bytes >= 0, 'Bad call to DataViewReader.rewind');\n  if (this.position_ < bytes) {\n    this.throwOutOfBounds_();\n  }\n  this.position_ -= bytes;\n};\n\n\n/**\n * Seeks to a specified position.\n * @param {number} position The desired byte position within the DataView.\n * @throws {shaka.util.Error} when seeking outside the range of the data view.\n * @export\n */\nshaka.util.DataViewReader.prototype.seek = function(position) {\n  goog.asserts.assert(position >= 0, 'Bad call to DataViewReader.seek');\n  if (position < 0 || position > this.dataView_.byteLength) {\n    this.throwOutOfBounds_();\n  }\n  this.position_ = position;\n};\n\n\n/**\n * Keeps reading until it reaches a byte that equals to zero.  The text is\n * assumed to be UTF-8.\n * @return {string}\n * @export\n */\nshaka.util.DataViewReader.prototype.readTerminatedString = function() {\n  let start = this.position_;\n  while (this.hasMoreData()) {\n    let value = this.dataView_.getUint8(this.position_);\n    if (value == 0) break;\n    this.position_ += 1;\n  }\n\n  let ret = new Uint8Array(\n      this.dataView_.buffer, this.dataView_.byteOffset + start,\n      this.position_ - start);\n  // Skip string termination.\n  this.position_ += 1;\n  return shaka.util.StringUtils.fromUTF8(ret);\n};\n\n\n/**\n * @throws {shaka.util.Error}\n * @private\n */\nshaka.util.DataViewReader.prototype.throwOutOfBounds_ = function() {\n  throw new shaka.util.Error(\n      shaka.util.Error.Severity.CRITICAL,\n      shaka.util.Error.Category.MEDIA,\n      shaka.util.Error.Code.BUFFER_READ_OUT_OF_BOUNDS);\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.EbmlElement');\ngoog.provide('shaka.util.EbmlParser');\n\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * Creates an Extensible Binary Markup Language (EBML) parser.\n * @param {!DataView} dataView The EBML data.\n * @constructor\n * @struct\n */\nshaka.util.EbmlParser = function(dataView) {\n  /** @private {!DataView} */\n  this.dataView_ = dataView;\n\n  /** @private {!shaka.util.DataViewReader} */\n  this.reader_ = new shaka.util.DataViewReader(\n      dataView,\n      shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n  // If not already constructed, build a list of EBML dynamic size constants.\n  // This is not done at load-time to avoid exceptions on unsupported browsers.\n  if (!shaka.util.EbmlParser.DYNAMIC_SIZES) {\n    shaka.util.EbmlParser.DYNAMIC_SIZES = [\n      new Uint8Array([0xff]),\n      new Uint8Array([0x7f, 0xff]),\n      new Uint8Array([0x3f, 0xff, 0xff]),\n      new Uint8Array([0x1f, 0xff, 0xff, 0xff]),\n      new Uint8Array([0x0f, 0xff, 0xff, 0xff, 0xff]),\n      new Uint8Array([0x07, 0xff, 0xff, 0xff, 0xff, 0xff]),\n      new Uint8Array([0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),\n      new Uint8Array([0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),\n    ];\n  }\n};\n\n\n/** @const {!Array.<!Uint8Array>} */\nshaka.util.EbmlParser.DYNAMIC_SIZES;\n\n\n/**\n * @return {boolean} True if the parser has more data, false otherwise.\n */\nshaka.util.EbmlParser.prototype.hasMoreData = function() {\n  return this.reader_.hasMoreData();\n};\n\n\n/**\n * Parses an EBML element from the parser's current position, and advances\n * the parser.\n * @return {!shaka.util.EbmlElement} The EBML element.\n * @throws {shaka.util.Error}\n * @see http://matroska.org/technical/specs/rfc/index.html\n */\nshaka.util.EbmlParser.prototype.parseElement = function() {\n  let id = this.parseId_();\n\n  // Parse the element's size.\n  let vint = this.parseVint_();\n  let size;\n  if (shaka.util.EbmlParser.isDynamicSizeValue_(vint)) {\n    // If this has an unknown size, assume that it takes up the rest of the\n    // data.\n    size = this.dataView_.byteLength - this.reader_.getPosition();\n  } else {\n    size = shaka.util.EbmlParser.getVintValue_(vint);\n  }\n\n  // Note that if the element's size is larger than the buffer then we are\n  // parsing a \"partial element\". This may occur if for example we are\n  // parsing the beginning of some WebM container data, but our buffer does\n  // not contain the entire WebM container data.\n  let elementSize =\n      this.reader_.getPosition() + size <= this.dataView_.byteLength ?\n      size :\n      this.dataView_.byteLength - this.reader_.getPosition();\n\n  let dataView = new DataView(\n      this.dataView_.buffer,\n      this.dataView_.byteOffset + this.reader_.getPosition(), elementSize);\n\n  this.reader_.skip(elementSize);\n\n  return new shaka.util.EbmlElement(id, dataView);\n};\n\n\n/**\n * Parses an EBML ID from the parser's current position, and advances the\n * parser.\n * @throws {shaka.util.Error}\n * @return {number} The EBML ID.\n * @private\n */\nshaka.util.EbmlParser.prototype.parseId_ = function() {\n  let vint = this.parseVint_();\n\n  if (vint.length > 7) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.EBML_OVERFLOW);\n  }\n\n  let id = 0;\n  for (let i = 0; i < vint.length; i++) {\n    // Note that we cannot use << since |value| may exceed 32 bits.\n    id = (256 * id) + vint[i];\n  }\n\n  return id;\n};\n\n\n/**\n * Parses a variable sized integer from the parser's current position, and\n * advances the parser.\n * For example:\n *   1 byte  wide: 1xxx xxxx\n *   2 bytes wide: 01xx xxxx xxxx xxxx\n *   3 bytes wide: 001x xxxx xxxx xxxx xxxx xxxx\n * @throws {shaka.util.Error}\n * @return {!Uint8Array} The variable sized integer.\n * @private\n */\nshaka.util.EbmlParser.prototype.parseVint_ = function() {\n  let firstByte = this.reader_.readUint8();\n  let numBytes;\n\n  // Determine the byte width of the variable sized integer.\n  for (numBytes = 1; numBytes <= 8; numBytes++) {\n    let mask = 0x1 << (8 - numBytes);\n    if (firstByte & mask) {\n      break;\n    }\n  }\n\n  if (numBytes > 8) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.EBML_OVERFLOW);\n  }\n\n  let vint = new Uint8Array(numBytes);\n  vint[0] = firstByte;\n\n  // Include the remaining bytes.\n  for (let i = 1; i < numBytes; i++) {\n    vint[i] = this.reader_.readUint8();\n  }\n\n  return vint;\n};\n\n\n/**\n * Gets the value of a variable sized integer.\n * For example, the x's below are part of the vint's value.\n *    7-bit value: 1xxx xxxx\n *   14-bit value: 01xx xxxx xxxx xxxx\n *   21-bit value: 001x xxxx xxxx xxxx xxxx xxxx\n * @param {!Uint8Array} vint The variable sized integer.\n * @throws {shaka.util.Error}\n * @return {number} The value of the variable sized integer.\n * @private\n */\nshaka.util.EbmlParser.getVintValue_ = function(vint) {\n  // If |vint| is 8 bytes wide then we must ensure that it does not have more\n  // than 53 meaningful bits. For example, assume |vint| is 8 bytes wide,\n  // so it has the following structure,\n  // 0000 0001 | xxxx xxxx ...\n  // Thus, the first 3 bits following the first byte of |vint| must be 0.\n  if ((vint.length == 8) && (vint[1] & 0xe0)) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.JS_INTEGER_OVERFLOW);\n  }\n\n  // Mask out the first few bits of |vint|'s first byte to get the most\n  // significant bits of |vint|'s value. If |vint| is 8 bytes wide then |value|\n  // will be set to 0.\n  let mask = 0x1 << (8 - vint.length);\n  let value = vint[0] & (mask - 1);\n\n  // Add the remaining bytes.\n  for (let i = 1; i < vint.length; i++) {\n    // Note that we cannot use << since |value| may exceed 32 bits.\n    value = (256 * value) + vint[i];\n  }\n\n  return value;\n};\n\n\n/**\n * Checks if the given variable sized integer represents a dynamic size value.\n * @param {!Uint8Array} vint The variable sized integer.\n * @return {boolean} true if |vint| represents a dynamic size value,\n *   false otherwise.\n * @private\n */\nshaka.util.EbmlParser.isDynamicSizeValue_ = function(vint) {\n  const EbmlParser = shaka.util.EbmlParser;\n  let uint8ArrayEqual = shaka.util.Uint8ArrayUtils.equal;\n\n  for (let i = 0; i < EbmlParser.DYNAMIC_SIZES.length; i++) {\n    if (uint8ArrayEqual(vint, EbmlParser.DYNAMIC_SIZES[i])) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n\n/**\n * Creates an EbmlElement.\n * @param {number} id The ID.\n * @param {!DataView} dataView The DataView.\n * @constructor\n */\nshaka.util.EbmlElement = function(id, dataView) {\n  /** @type {number} */\n  this.id = id;\n\n  /** @private {!DataView} */\n  this.dataView_ = dataView;\n};\n\n\n/**\n * Gets the element's offset from the beginning of the buffer.\n * @return {number}\n */\nshaka.util.EbmlElement.prototype.getOffset = function() {\n  return this.dataView_.byteOffset;\n};\n\n\n/**\n * Interpret the element's data as a list of sub-elements.\n * @throws {shaka.util.Error}\n * @return {!shaka.util.EbmlParser} A parser over the sub-elements.\n */\nshaka.util.EbmlElement.prototype.createParser = function() {\n  return new shaka.util.EbmlParser(this.dataView_);\n};\n\n\n/**\n * Interpret the element's data as an unsigned integer.\n * @throws {shaka.util.Error}\n * @return {number}\n */\nshaka.util.EbmlElement.prototype.getUint = function() {\n  if (this.dataView_.byteLength > 8) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.EBML_OVERFLOW);\n  }\n\n  // Ensure we have at most 53 meaningful bits.\n  if ((this.dataView_.byteLength == 8) && (this.dataView_.getUint8(0) & 0xe0)) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.JS_INTEGER_OVERFLOW);\n  }\n\n  let value = 0;\n\n  for (let i = 0; i < this.dataView_.byteLength; i++) {\n    let chunk = this.dataView_.getUint8(i);\n    value = (256 * value) + chunk;\n  }\n\n  return value;\n};\n\n\n/**\n * Interpret the element's data as a floating point number (32 bits or 64 bits).\n * 80-bit floating point numbers are not supported.\n * @throws {shaka.util.Error}\n * @return {number}\n */\nshaka.util.EbmlElement.prototype.getFloat = function() {\n  if (this.dataView_.byteLength == 4) {\n    return this.dataView_.getFloat32(0);\n  } else if (this.dataView_.byteLength == 8) {\n    return this.dataView_.getFloat64(0);\n  } else {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.EBML_BAD_FLOATING_POINT_SIZE);\n  }\n};\n\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.Mp4Parser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.DataViewReader');\n\n\n/**\n * Create a new MP4 Parser\n * @struct\n * @constructor\n * @export\n */\nshaka.util.Mp4Parser = function() {\n  /** @private {!Object.<number, shaka.util.Mp4Parser.BoxType_>} */\n  this.headers_ = [];\n\n  /** @private {!Object.<number, !shaka.util.Mp4Parser.CallbackType>} */\n  this.boxDefinitions_ = [];\n\n  /** @private {boolean} */\n  this.done_ = false;\n};\n\n\n/**\n * @typedef {function(!shaka.extern.ParsedBox)}\n * @exportInterface\n */\nshaka.util.Mp4Parser.CallbackType;\n\n\n/**\n * An enum used to track the type of box so that the correct values can be\n * read from the header.\n *\n * @enum {number}\n * @private\n */\nshaka.util.Mp4Parser.BoxType_ = {\n  BASIC_BOX: 0,\n  FULL_BOX: 1,\n};\n\n\n/**\n * Declare a box type as a Box.\n *\n * @param {string} type\n * @param {!shaka.util.Mp4Parser.CallbackType} definition\n * @return {!shaka.util.Mp4Parser}\n * @export\n */\nshaka.util.Mp4Parser.prototype.box = function(type, definition) {\n  let typeCode = shaka.util.Mp4Parser.typeFromString_(type);\n  this.headers_[typeCode] = shaka.util.Mp4Parser.BoxType_.BASIC_BOX;\n  this.boxDefinitions_[typeCode] = definition;\n  return this;\n};\n\n\n/**\n * Declare a box type as a Full Box.\n *\n * @param {string} type\n * @param {!shaka.util.Mp4Parser.CallbackType} definition\n * @return {!shaka.util.Mp4Parser}\n * @export\n */\nshaka.util.Mp4Parser.prototype.fullBox = function(type, definition) {\n  let typeCode = shaka.util.Mp4Parser.typeFromString_(type);\n  this.headers_[typeCode] = shaka.util.Mp4Parser.BoxType_.FULL_BOX;\n  this.boxDefinitions_[typeCode] = definition;\n  return this;\n};\n\n\n/**\n * Stop parsing.  Useful for extracting information from partial segments and\n * avoiding an out-of-bounds error once you find what you are looking for.\n *\n * @export\n */\nshaka.util.Mp4Parser.prototype.stop = function() {\n  this.done_ = true;\n};\n\n\n/**\n * Parse the given data using the added callbacks.\n *\n * @param {!BufferSource} data\n * @param {boolean=} partialOkay If true, allow reading partial payloads\n *   from some boxes. If the goal is a child box, we can sometimes find it\n *   without enough data to find all child boxes.\n * @export\n */\nshaka.util.Mp4Parser.prototype.parse = function(data, partialOkay) {\n  let wrapped = new Uint8Array(data);\n  let reader = new shaka.util.DataViewReader(\n      new DataView(wrapped.buffer, wrapped.byteOffset, wrapped.byteLength),\n      shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n  this.done_ = false;\n  while (reader.hasMoreData() && !this.done_) {\n    this.parseNext(0, reader, partialOkay);\n  }\n};\n\n\n/**\n * Parse the next box on the current level.\n *\n * @param {number} absStart The absolute start position in the original\n *   byte array.\n * @param {!shaka.util.DataViewReader} reader\n * @param {boolean=} partialOkay If true, allow reading partial payloads\n *   from some boxes. If the goal is a child box, we can sometimes find it\n *   without enough data to find all child boxes.\n * @export\n */\nshaka.util.Mp4Parser.prototype.parseNext =\n    function(absStart, reader, partialOkay) {\n  let start = reader.getPosition();\n\n  let size = reader.readUint32();\n  let type = reader.readUint32();\n  let name = shaka.util.Mp4Parser.typeToString(type);\n  shaka.log.v2('Parsing MP4 box', name);\n\n  switch (size) {\n    case 0:\n      size = reader.getLength() - start;\n      break;\n    case 1:\n      size = reader.readUint64();\n      break;\n  }\n\n  let boxDefinition = this.boxDefinitions_[type];\n\n  if (boxDefinition) {\n    let version = null;\n    let flags = null;\n\n    if (this.headers_[type] == shaka.util.Mp4Parser.BoxType_.FULL_BOX) {\n      let versionAndFlags = reader.readUint32();\n      version = versionAndFlags >>> 24;\n      flags = versionAndFlags & 0xFFFFFF;\n    }\n\n    // Read the whole payload so that the current level can be safely read\n    // regardless of how the payload is parsed.\n    let end = start + size;\n    if (partialOkay && end > reader.getLength()) {\n      // For partial reads, truncate the payload if we must.\n      end = reader.getLength();\n    }\n    let payloadSize = end - reader.getPosition();\n    let payload =\n        (payloadSize > 0) ? reader.readBytes(payloadSize) : new Uint8Array(0);\n\n    let payloadReader = new shaka.util.DataViewReader(\n        new DataView(payload.buffer, payload.byteOffset, payload.byteLength),\n        shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n    /** @type {shaka.extern.ParsedBox} */\n    let box = {\n      parser: this,\n      partialOkay: partialOkay || false,\n      version: version,\n      flags: flags,\n      reader: payloadReader,\n      size: size,\n      start: start + absStart,\n    };\n\n    boxDefinition(box);\n  } else {\n    // Move the read head to be at the end of the box.\n    // If the box is longer than the remaining parts of the file, e.g. the\n    // mp4 is improperly formatted, or this was a partial range request that\n    // ended in the middle of a box, just skip to the end.\n    const skipLength = Math.min(\n        start + size - reader.getPosition(),\n        reader.getLength() - reader.getPosition());\n    reader.skip(skipLength);\n  }\n};\n\n\n/**\n * A callback that tells the Mp4 parser to treat the body of a box as a series\n * of boxes. The number of boxes is limited by the size of the parent box.\n *\n * @param {!shaka.extern.ParsedBox} box\n * @export\n */\nshaka.util.Mp4Parser.children = function(box) {\n  while (box.reader.hasMoreData() && !box.parser.done_) {\n    box.parser.parseNext(box.start, box.reader, box.partialOkay);\n  }\n};\n\n\n/**\n * A callback that tells the Mp4 parser to treat the body of a box as a sample\n * description. A sample description box has a fixed number of children. The\n * number of children is represented by a 4 byte unsigned integer. Each child\n * is a box.\n *\n * @param {!shaka.extern.ParsedBox} box\n * @export\n */\nshaka.util.Mp4Parser.sampleDescription = function(box) {\n  for (let count = box.reader.readUint32();\n       count > 0 && !box.parser.done_;\n       count -= 1) {\n    box.parser.parseNext(box.start, box.reader, box.partialOkay);\n  }\n};\n\n\n/**\n * Create a callback that tells the Mp4 parser to treat the body of a box as a\n * binary blob and to parse the body's contents using the provided callback.\n *\n * @param {function(!Uint8Array)} callback\n * @return {!shaka.util.Mp4Parser.CallbackType}\n * @export\n */\nshaka.util.Mp4Parser.allData = function(callback) {\n  return function(box) {\n    let all = box.reader.getLength() - box.reader.getPosition();\n    callback(box.reader.readBytes(all));\n  };\n};\n\n\n/**\n * Convert an ascii string name to the integer type for a box.\n *\n * @param {string} name The name of the box. The name must be four\n *                      characters long.\n * @return {number}\n * @private\n */\nshaka.util.Mp4Parser.typeFromString_ = function(name) {\n  goog.asserts.assert(\n      name.length == 4,\n      'Mp4 box names must be 4 characters long');\n\n  let code = 0;\n  for (let i = 0; i < name.length; i++) {\n    code = (code << 8) | name.charCodeAt(i);\n  }\n  return code;\n};\n\n\n/**\n * Convert an integer type from a box into an ascii string name.\n * Useful for debugging.\n *\n * @param {number} type The type of the box, a uint32.\n * @return {string}\n * @export\n */\nshaka.util.Mp4Parser.typeToString = function(type) {\n  let name = String.fromCharCode(\n      (type >> 24) & 0xff,\n      (type >> 16) & 0xff,\n      (type >> 8) & 0xff,\n      type & 0xff);\n  return name;\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.Mp4SegmentIndexParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Mp4Parser');\n\n\n/**\n * Parses SegmentReferences from an ISO BMFF SIDX structure.\n * @param {!ArrayBuffer} sidxData The MP4's container's SIDX.\n * @param {number} sidxOffset The SIDX's offset, in bytes, from the start of\n *   the MP4 container.\n * @param {!Array.<string>} uris The possible locations of the MP4 file that\n *   contains the segments.\n * @param {number} scaledPresentationTimeOffset\n * @return {!Array.<!shaka.media.SegmentReference>}\n * @throws {shaka.util.Error}\n */\nshaka.media.Mp4SegmentIndexParser = function(\n    sidxData, sidxOffset, uris, scaledPresentationTimeOffset) {\n  const Mp4SegmentIndexParser = shaka.media.Mp4SegmentIndexParser;\n\n  let references;\n\n  let parser = new shaka.util.Mp4Parser()\n      .fullBox('sidx', function(box) {\n        references = Mp4SegmentIndexParser.parseSIDX_(\n            sidxOffset,\n            scaledPresentationTimeOffset,\n            uris,\n            box);\n      });\n\n  if (sidxData) {\n    parser.parse(sidxData);\n  }\n\n  if (references) {\n    return references;\n  } else {\n    shaka.log.error('Invalid box type, expected \"sidx\".');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.MP4_SIDX_WRONG_BOX_TYPE);\n  }\n};\n\n\n/**\n * Parse a SIDX box from the given reader.\n *\n * @param {number} sidxOffset\n * @param {number} scaledPresentationTimeOffset\n * @param {!Array.<string>} uris The possible locations of the MP4 file that\n *   contains the segments.\n * @param {!shaka.extern.ParsedBox} box\n * @return {!Array.<!shaka.media.SegmentReference>}\n * @private\n */\nshaka.media.Mp4SegmentIndexParser.parseSIDX_ = function(\n    sidxOffset,\n    scaledPresentationTimeOffset,\n    uris,\n    box) {\n  goog.asserts.assert(\n      box.version != null,\n      'SIDX is a full box and should have a valid version.');\n\n  let references = [];\n\n  // Parse the SIDX structure.\n  // Skip reference_ID (32 bits).\n  box.reader.skip(4);\n\n  let timescale = box.reader.readUint32();\n\n  if (timescale == 0) {\n    shaka.log.error('Invalid timescale.');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.MP4_SIDX_INVALID_TIMESCALE);\n  }\n\n  let earliestPresentationTime;\n  let firstOffset;\n\n  if (box.version == 0) {\n    earliestPresentationTime = box.reader.readUint32();\n    firstOffset = box.reader.readUint32();\n  } else {\n    earliestPresentationTime = box.reader.readUint64();\n    firstOffset = box.reader.readUint64();\n  }\n\n  // Skip reserved (16 bits).\n  box.reader.skip(2);\n\n  // Add references.\n  let referenceCount = box.reader.readUint16();\n\n  // Substract the presentation time offset\n  let unscaledStartTime = earliestPresentationTime;\n  let startByte = sidxOffset + box.size + firstOffset;\n\n  for (let i = 0; i < referenceCount; i++) {\n    // |chunk| is 1 bit for |referenceType|, and 31 bits for |referenceSize|.\n    let chunk = box.reader.readUint32();\n    let referenceType = (chunk & 0x80000000) >>> 31;\n    let referenceSize = chunk & 0x7FFFFFFF;\n\n    let subsegmentDuration = box.reader.readUint32();\n\n    // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n    // for |sapDelta|.\n    box.reader.skip(4);\n\n    // If |referenceType| is 1 then the reference is to another SIDX.\n    // We do not support this.\n    if (referenceType == 1) {\n      shaka.log.error('Heirarchical SIDXs are not supported.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.MP4_SIDX_TYPE_NOT_SUPPORTED);\n    }\n\n    references.push(\n        new shaka.media.SegmentReference(\n            references.length,\n            (unscaledStartTime / timescale) -\n                scaledPresentationTimeOffset,\n            ((unscaledStartTime + subsegmentDuration) / timescale) -\n                scaledPresentationTimeOffset,\n            function() { return uris; },\n            startByte,\n            startByte + referenceSize - 1));\n\n    unscaledStartTime += subsegmentDuration;\n    startByte += referenceSize;\n  }\n\n  box.parser.stop();\n  return references;\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.SegmentIndex');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.IDestroyable');\n\n\n/**\n * Creates a SegmentIndex.\n *\n * @param {!Array.<!shaka.media.SegmentReference>} references The list of\n *   SegmentReferences, which must be sorted first by their start times\n *   (ascending) and second by their end times (ascending).  They must have\n *   continuous, increasing positions.\n *\n * @constructor\n * @struct\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.media.SegmentIndex = function(references) {\n  if (goog.DEBUG) {\n    shaka.media.SegmentIndex.assertCorrectReferences_(references);\n  }\n\n  /** @private {Array.<!shaka.media.SegmentReference>} */\n  this.references_ = references;\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.media.SegmentIndex.prototype.destroy = function() {\n  this.references_ = null;\n  return Promise.resolve();\n};\n\n\n/**\n * Finds the position of the segment for the given time, in seconds, relative\n * to the start of a particular Period.  Returns the position of the segment\n * with the largest end time if more than one segment is known for the given\n * time.\n *\n * @param {number} time\n * @return {?number} The position of the segment, or null\n *   if the position of the segment could not be determined.\n * @export\n */\nshaka.media.SegmentIndex.prototype.find = function(time) {\n  // For live streams, searching from the end is faster.  For VOD, it balances\n  // out either way.  In both cases, references_.length is small enough that the\n  // difference isn't huge.\n  for (let i = this.references_.length - 1; i >= 0; --i) {\n    let r = this.references_[i];\n    // Note that a segment ends immediately before the end time.\n    if ((time >= r.startTime) && (time < r.endTime)) {\n      return r.position;\n    }\n  }\n  if (this.references_.length && time < this.references_[0].startTime) {\n    return this.references_[0].position;\n  }\n\n  return null;\n};\n\n\n/**\n * Gets the SegmentReference for the segment at the given position.\n *\n * @param {number} position The position of the segment.\n * @return {shaka.media.SegmentReference} The SegmentReference, or null if\n *   no such SegmentReference exists.\n * @export\n */\nshaka.media.SegmentIndex.prototype.get = function(position) {\n  if (this.references_.length == 0) {\n    return null;\n  }\n\n  let index = position - this.references_[0].position;\n  if (index < 0 || index >= this.references_.length) {\n    return null;\n  }\n\n  return this.references_[index];\n};\n\n\n/**\n * Offset all segment references by a fixed amount.\n *\n * @param {number} offset The amount to add to each segment's start and end\n *   times.\n * @export\n */\nshaka.media.SegmentIndex.prototype.offset = function(offset) {\n  for (let i = 0; i < this.references_.length; ++i) {\n    this.references_[i].startTime += offset;\n    this.references_[i].endTime += offset;\n  }\n};\n\n\n/**\n * Merges the given SegmentReferences.  Supports extending the original\n * references only.  Will not replace old references or interleave new ones.\n *\n * @param {!Array.<!shaka.media.SegmentReference>} references The list of\n *   SegmentReferences, which must be sorted first by their start times\n *   (ascending) and second by their end times (ascending).  They must have\n *   continuous, increasing positions.\n * @export\n */\nshaka.media.SegmentIndex.prototype.merge = function(references) {\n  if (goog.DEBUG) {\n    shaka.media.SegmentIndex.assertCorrectReferences_(references);\n  }\n\n  let newReferences = [];\n  let i = 0;\n  let j = 0;\n\n  while ((i < this.references_.length) && (j < references.length)) {\n    let r1 = this.references_[i];\n    let r2 = references[j];\n\n    if (r1.startTime < r2.startTime) {\n      newReferences.push(r1);\n      i++;\n    } else if (r1.startTime > r2.startTime) {\n      if (i == 0) {\n        // If the reference appears before any existing reference, it may have\n        // been evicted before; in this case, simply add it back and it will be\n        // evicted again later.\n        newReferences.push(r2);\n      } else {\n        // Drop the new reference if it would have to be interleaved with the\n        // old one.  Issue a warning, since this is not a supported update.\n        shaka.log.warning('Refusing to rewrite original references on update!');\n      }\n      j++;\n    } else {\n      // When period is changed, fit() will expand the last segment to the start\n      // of the next period.  So, it is valid to have end time updated to the\n      // last segment reference in a period.\n      if (Math.abs(r1.endTime - r2.endTime) > 0.1) {\n        goog.asserts.assert(r2.endTime > r1.endTime &&\n            i == this.references_.length - 1 &&\n            j == references.length - 1,\n            'This should be an update of the last segment in a period');\n        let r = new shaka.media.SegmentReference(r1.position,\n            r2.startTime, r2.endTime, r2.getUris, r2.startByte, r2.endByte);\n        newReferences.push(r);\n      } else {\n        // Drop the new reference if there's an old reference with the\n        // same time.\n        newReferences.push(r1);\n      }\n      i++;\n      j++;\n    }\n  }\n\n  while (i < this.references_.length) {\n    newReferences.push(this.references_[i++]);\n  }\n\n  if (newReferences.length) {\n    // The rest of these references may need to be renumbered.\n    let nextPosition = newReferences[newReferences.length - 1].position + 1;\n    while (j < references.length) {\n      let r = references[j++];\n      let r2 = new shaka.media.SegmentReference(nextPosition++,\n          r.startTime, r.endTime, r.getUris, r.startByte, r.endByte);\n      newReferences.push(r2);\n    }\n  } else {\n    newReferences = references;\n  }\n\n  if (goog.DEBUG) {\n    shaka.media.SegmentIndex.assertCorrectReferences_(newReferences);\n  }\n\n  this.references_ = newReferences;\n};\n\n\n/**\n * Replace existing references with new ones, without merging.\n *\n * @param {!Array.<!shaka.media.SegmentReference>} newReferences\n */\nshaka.media.SegmentIndex.prototype.replace = function(newReferences) {\n  if (goog.DEBUG) {\n    shaka.media.SegmentIndex.assertCorrectReferences_(newReferences);\n  }\n  this.references_ = newReferences;\n};\n\n\n/**\n * Removes all SegmentReferences that end before the given time.\n *\n * @param {number} time The time in seconds.\n * @export\n */\nshaka.media.SegmentIndex.prototype.evict = function(time) {\n  for (let i = 0; i < this.references_.length; ++i) {\n    if (this.references_[i].endTime > time) {\n      this.references_.splice(0, i);\n      return;\n    }\n  }\n  this.references_ = [];\n};\n\n\n/**\n * Expands the first SegmentReference so it begins at the start of its Period\n * if it already begins close to the start of its Period.\n *\n * Also expands or contracts the last SegmentReference so it ends at the end of\n * its Period.\n *\n * Do not call on the last period of a live presentation (unknown duration).\n * It is okay to call on the other periods of a live presentation, where the\n * duration is known and another period has been added.\n *\n * @param {?number} periodDuration\n */\nshaka.media.SegmentIndex.prototype.fit = function(periodDuration) {\n  goog.asserts.assert(periodDuration != null,\n                      'Period duration must be known for static content!');\n  goog.asserts.assert(periodDuration != Infinity,\n                      'Period duration must be finite for static content!');\n\n  // Trim out references we will never use.\n  while (this.references_.length) {\n    let lastReference = this.references_[this.references_.length - 1];\n    if (lastReference.startTime >= periodDuration) {\n      this.references_.pop();\n    } else {\n      break;\n    }\n  }\n  while (this.references_.length) {\n    let firstReference = this.references_[0];\n    if (firstReference.endTime <= 0) {\n      this.references_.shift();\n    } else {\n      break;\n    }\n  }\n\n  if (this.references_.length == 0) {\n    return;\n  }\n\n  // Adjust the last SegmentReference.\n  let lastReference = this.references_[this.references_.length - 1];\n  this.references_[this.references_.length - 1] =\n      new shaka.media.SegmentReference(\n          lastReference.position,\n          lastReference.startTime,\n          /* endTime */ periodDuration,\n          lastReference.getUris,\n          lastReference.startByte,\n          lastReference.endByte);\n};\n\n\nif (goog.DEBUG) {\n  /**\n   * Asserts that the given SegmentReferences are sorted and have continuous,\n   * increasing positions.\n   *\n   * @param {!Array.<shaka.media.SegmentReference>} references\n   * @private\n   */\n  shaka.media.SegmentIndex.assertCorrectReferences_ = function(references) {\n    goog.asserts.assert(references.every(function(r2, i) {\n      if (i == 0) return true;\n      let r1 = references[i - 1];\n      if (r2.position != r1.position + 1) return false;\n      if (r1.startTime < r2.startTime) {\n        return true;\n      } else if (r1.startTime > r2.startTime) {\n        return false;\n      } else {\n        if (r1.endTime <= r2.endTime) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    }), 'SegmentReferences are incorrect');\n  };\n}\n\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.WebmSegmentIndexParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.EbmlElement');\ngoog.require('shaka.util.EbmlParser');\ngoog.require('shaka.util.Error');\n\n\n/**\n * Creates a WebM Cues element parser.\n *\n * @constructor\n * @struct\n */\nshaka.media.WebmSegmentIndexParser = function() {};\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.EBML_ID = 0x1a45dfa3;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.SEGMENT_ID = 0x18538067;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.INFO_ID = 0x1549a966;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.TIMECODE_SCALE_ID = 0x2ad7b1;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.DURATION_ID = 0x4489;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUES_ID = 0x1c53bb6b;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_POINT_ID = 0xbb;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_TIME_ID = 0xb3;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_TRACK_POSITIONS_ID = 0xb7;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_CLUSTER_POSITION = 0xf1;\n\n\n/**\n * Parses SegmentReferences from a WebM container.\n * @param {!ArrayBuffer} cuesData The WebM container's \"Cueing Data\" section.\n * @param {!ArrayBuffer} initData The WebM container's headers.\n * @param {!Array.<string>} uris The possible locations of the WebM file that\n *   contains the segments.\n * @param {number} scaledPresentationTimeOffset\n\n * @return {!Array.<!shaka.media.SegmentReference>}\n * @throws {shaka.util.Error}\n * @see http://www.matroska.org/technical/specs/index.html\n * @see http://www.webmproject.org/docs/container/\n */\nshaka.media.WebmSegmentIndexParser.prototype.parse = function(\n    cuesData, initData, uris, scaledPresentationTimeOffset) {\n  let tuple = this.parseWebmContainer_(initData);\n  let parser = new shaka.util.EbmlParser(new DataView(cuesData));\n  let cuesElement = parser.parseElement();\n  if (cuesElement.id != shaka.media.WebmSegmentIndexParser.CUES_ID) {\n    shaka.log.error('Not a Cues element.');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.WEBM_CUES_ELEMENT_MISSING);\n  }\n\n  return this.parseCues_(\n      cuesElement, tuple.segmentOffset, tuple.timecodeScale, tuple.duration,\n      uris, scaledPresentationTimeOffset);\n};\n\n\n/**\n * Parses a WebM container to get the segment's offset, timecode scale, and\n * duration.\n *\n * @param {!ArrayBuffer} initData\n * @return {{segmentOffset: number, timecodeScale: number, duration: number}}\n *   The segment's offset in bytes, the segment's timecode scale in seconds,\n *   and the duration in seconds.\n * @throws {shaka.util.Error}\n * @private\n */\nshaka.media.WebmSegmentIndexParser.prototype.parseWebmContainer_ = function(\n    initData) {\n  let parser = new shaka.util.EbmlParser(new DataView(initData));\n\n  // Check that the WebM container data starts with the EBML header, but\n  // skip its contents.\n  let ebmlElement = parser.parseElement();\n  if (ebmlElement.id != shaka.media.WebmSegmentIndexParser.EBML_ID) {\n    shaka.log.error('Not an EBML element.');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.WEBM_EBML_HEADER_ELEMENT_MISSING);\n  }\n\n  let segmentElement = parser.parseElement();\n  if (segmentElement.id != shaka.media.WebmSegmentIndexParser.SEGMENT_ID) {\n    shaka.log.error('Not a Segment element.');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.WEBM_SEGMENT_ELEMENT_MISSING);\n  }\n\n  // This value is used as the initial offset to the first referenced segment.\n  let segmentOffset = segmentElement.getOffset();\n\n  // Parse the Segment element to get the segment info.\n  let segmentInfo = this.parseSegment_(segmentElement);\n  return {\n    segmentOffset: segmentOffset,\n    timecodeScale: segmentInfo.timecodeScale,\n    duration: segmentInfo.duration,\n  };\n};\n\n\n/**\n * Parses a WebM Info element to get the segment's timecode scale and duration.\n * @param {!shaka.util.EbmlElement} segmentElement\n * @return {{timecodeScale: number, duration: number}} The segment's timecode\n *   scale in seconds and duration in seconds.\n * @throws {shaka.util.Error}\n * @private\n */\nshaka.media.WebmSegmentIndexParser.prototype.parseSegment_ = function(\n    segmentElement) {\n  let parser = segmentElement.createParser();\n\n  // Find the Info element.\n  let infoElement = null;\n  while (parser.hasMoreData()) {\n    let elem = parser.parseElement();\n    if (elem.id != shaka.media.WebmSegmentIndexParser.INFO_ID) {\n      continue;\n    }\n\n    infoElement = elem;\n\n    break;\n  }\n\n  if (!infoElement) {\n    shaka.log.error('Not an Info element.');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.WEBM_INFO_ELEMENT_MISSING);\n  }\n\n  return this.parseInfo_(infoElement);\n};\n\n\n/**\n * Parses a WebM Info element to get the segment's timecode scale and duration.\n * @param {!shaka.util.EbmlElement} infoElement\n * @return {{timecodeScale: number, duration: number}} The segment's timecode\n *   scale in seconds and duration in seconds.\n * @throws {shaka.util.Error}\n * @private\n */\nshaka.media.WebmSegmentIndexParser.prototype.parseInfo_ = function(\n    infoElement) {\n  let parser = infoElement.createParser();\n\n  // The timecode scale factor in units of [nanoseconds / T], where [T] are the\n  // units used to express all other time values in the WebM container. By\n  // default it's assumed that [T] == [milliseconds].\n  let timecodeScaleNanoseconds = 1000000;\n  /** @type {?number} */\n  let durationScale = null;\n\n  while (parser.hasMoreData()) {\n    let elem = parser.parseElement();\n    if (elem.id == shaka.media.WebmSegmentIndexParser.TIMECODE_SCALE_ID) {\n      timecodeScaleNanoseconds = elem.getUint();\n    } else if (elem.id == shaka.media.WebmSegmentIndexParser.DURATION_ID) {\n      durationScale = elem.getFloat();\n    }\n  }\n  if (durationScale == null) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.WEBM_DURATION_ELEMENT_MISSING);\n  }\n\n  // The timecode scale factor in units of [seconds / T].\n  let timecodeScale = timecodeScaleNanoseconds / 1000000000;\n  // The duration is stored in units of [T]\n  let durationSeconds = durationScale * timecodeScale;\n\n  return {timecodeScale: timecodeScale, duration: durationSeconds};\n};\n\n\n/**\n * Parses a WebM CuesElement.\n * @param {!shaka.util.EbmlElement} cuesElement\n * @param {number} segmentOffset\n * @param {number} timecodeScale\n * @param {number} duration\n * @param {!Array.<string>} uris\n * @param {number} scaledPresentationTimeOffset\n * @return {!Array.<!shaka.media.SegmentReference>}\n * @throws {shaka.util.Error}\n * @private\n */\nshaka.media.WebmSegmentIndexParser.prototype.parseCues_ = function(\n    cuesElement, segmentOffset, timecodeScale, duration, uris,\n    scaledPresentationTimeOffset) {\n  let references = [];\n  let getUris = function() { return uris; };\n\n  let parser = cuesElement.createParser();\n\n  let lastTime = null;\n  let lastOffset = null;\n\n  while (parser.hasMoreData()) {\n    let elem = parser.parseElement();\n    if (elem.id != shaka.media.WebmSegmentIndexParser.CUE_POINT_ID) {\n      continue;\n    }\n\n    let tuple = this.parseCuePoint_(elem);\n    if (!tuple) {\n      continue;\n    }\n\n    // Substract the presentation time offset from the unscaled time\n    let currentTime = timecodeScale * tuple.unscaledTime;\n    let currentOffset = segmentOffset + tuple.relativeOffset;\n\n    if (lastTime != null) {\n      goog.asserts.assert(lastOffset != null, 'last offset cannot be null');\n\n      references.push(\n          new shaka.media.SegmentReference(\n              references.length,\n              lastTime - scaledPresentationTimeOffset,\n              currentTime - scaledPresentationTimeOffset,\n              getUris,\n              lastOffset, currentOffset - 1));\n    }\n\n    lastTime = currentTime;\n    lastOffset = currentOffset;\n  }\n\n  if (lastTime != null) {\n    goog.asserts.assert(lastOffset != null, 'last offset cannot be null');\n\n    references.push(\n        new shaka.media.SegmentReference(\n            references.length,\n            lastTime - scaledPresentationTimeOffset,\n            duration - scaledPresentationTimeOffset,\n            getUris,\n            lastOffset, null));\n  }\n\n  return references;\n};\n\n\n/**\n * Parses a WebM CuePointElement to get an \"unadjusted\" segment reference.\n * @param {shaka.util.EbmlElement} cuePointElement\n * @return {{unscaledTime: number, relativeOffset: number}} The referenced\n *   segment's start time in units of [T] (see parseInfo_()), and the\n *   referenced segment's offset in bytes, relative to a WebM Segment\n *   element.\n * @throws {shaka.util.Error}\n * @private\n */\nshaka.media.WebmSegmentIndexParser.prototype.parseCuePoint_ = function(\n    cuePointElement) {\n  let parser = cuePointElement.createParser();\n\n  // Parse CueTime element.\n  let cueTimeElement = parser.parseElement();\n  if (cueTimeElement.id != shaka.media.WebmSegmentIndexParser.CUE_TIME_ID) {\n    shaka.log.warning('Not a CueTime element.');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.WEBM_CUE_TIME_ELEMENT_MISSING);\n  }\n  let unscaledTime = cueTimeElement.getUint();\n\n  // Parse CueTrackPositions element.\n  let cueTrackPositionsElement = parser.parseElement();\n  if (cueTrackPositionsElement.id !=\n      shaka.media.WebmSegmentIndexParser.CUE_TRACK_POSITIONS_ID) {\n    shaka.log.warning('Not a CueTrackPositions element.');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING);\n  }\n\n  let cueTrackParser = cueTrackPositionsElement.createParser();\n  let relativeOffset = 0;\n\n  while (cueTrackParser.hasMoreData()) {\n    let elem = cueTrackParser.parseElement();\n    if (elem.id != shaka.media.WebmSegmentIndexParser.CUE_CLUSTER_POSITION) {\n      continue;\n    }\n\n    relativeOffset = elem.getUint();\n    break;\n  }\n\n  return {unscaledTime: unscaledTime, relativeOffset: relativeOffset};\n};\n\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.dash.SegmentBase');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.Mp4SegmentIndexParser');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.WebmSegmentIndexParser');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * @namespace shaka.dash.SegmentBase\n * @summary A set of functions for parsing SegmentBase elements.\n */\n\n\n/**\n * Creates an init segment reference from a Context object.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n * @return {shaka.media.InitSegmentReference}\n */\nshaka.dash.SegmentBase.createInitSegment = function(context, callback) {\n  const MpdUtils = shaka.dash.MpdUtils;\n  const XmlUtils = shaka.util.XmlUtils;\n  const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n  let initialization =\n      MpdUtils.inheritChild(context, callback, 'Initialization');\n  if (!initialization) {\n    return null;\n  }\n\n  let resolvedUris = context.representation.baseUris;\n  let uri = initialization.getAttribute('sourceURL');\n  if (uri) {\n    resolvedUris =\n        ManifestParserUtils.resolveUris(context.representation.baseUris, [uri]);\n  }\n\n  let startByte = 0;\n  let endByte = null;\n  let range = XmlUtils.parseAttr(initialization, 'range', XmlUtils.parseRange);\n  if (range) {\n    startByte = range.start;\n    endByte = range.end;\n  }\n\n  let getUris = function() { return resolvedUris; };\n  return new shaka.media.InitSegmentReference(getUris, startByte, endByte);\n};\n\n\n/**\n * Creates a new Stream object.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.DashParser.RequestInitSegmentCallback} requestInitSegment\n * @throws shaka.util.Error When there is a parsing error.\n * @return {shaka.dash.DashParser.StreamInfo}\n */\nshaka.dash.SegmentBase.createStream = function(context, requestInitSegment) {\n  goog.asserts.assert(context.representation.segmentBase,\n                      'Should only be called with SegmentBase');\n  // Since SegmentBase does not need updates, simply treat any call as\n  // the initial parse.\n  const MpdUtils = shaka.dash.MpdUtils;\n  const SegmentBase = shaka.dash.SegmentBase;\n  const XmlUtils = shaka.util.XmlUtils;\n\n  let unscaledPresentationTimeOffset = Number(MpdUtils.inheritAttribute(\n      context, SegmentBase.fromInheritance_, 'presentationTimeOffset')) || 0;\n\n  let timescaleStr = MpdUtils.inheritAttribute(\n      context, SegmentBase.fromInheritance_, 'timescale');\n  let timescale = 1;\n  if (timescaleStr) {\n    timescale = XmlUtils.parsePositiveInt(timescaleStr) || 1;\n  }\n\n  let scaledPresentationTimeOffset =\n      (unscaledPresentationTimeOffset / timescale) || 0;\n\n  let init =\n      SegmentBase.createInitSegment(context, SegmentBase.fromInheritance_);\n  let index = SegmentBase.createSegmentIndex_(\n      context, requestInitSegment, init, scaledPresentationTimeOffset);\n\n  return {\n    createSegmentIndex: index.createSegmentIndex,\n    findSegmentPosition: index.findSegmentPosition,\n    getSegmentReference: index.getSegmentReference,\n    initSegmentReference: init,\n    scaledPresentationTimeOffset: scaledPresentationTimeOffset,\n  };\n};\n\n\n/**\n * Creates segment index info for the given info.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.DashParser.RequestInitSegmentCallback} requestInitSegment\n * @param {shaka.media.InitSegmentReference} init\n * @param {!Array.<string>} uris\n * @param {number} startByte\n * @param {?number} endByte\n * @param {string} containerType\n * @param {number} scaledPresentationTimeOffset\n * @return {shaka.dash.DashParser.SegmentIndexFunctions}\n */\nshaka.dash.SegmentBase.createSegmentIndexFromUris = function(\n    context, requestInitSegment, init, uris,\n    startByte, endByte, containerType, scaledPresentationTimeOffset) {\n  let presentationTimeline = context.presentationTimeline;\n  let fitLast = !context.dynamic || !context.periodInfo.isLastPeriod;\n  let periodStart = context.periodInfo.start;\n  let periodDuration = context.periodInfo.duration;\n\n  // Create a local variable to bind to so we can set to null to help the GC.\n  let localRequest = requestInitSegment;\n  let segmentIndex = null;\n  let create = function() {\n    let async = [\n      localRequest(uris, startByte, endByte),\n      containerType == 'webm' ?\n          localRequest(init.getUris(), init.startByte, init.endByte) :\n          null,\n    ];\n\n    localRequest = null;\n    return Promise.all(async).then(function(results) {\n      let indexData = results[0];\n      let initData = results[1] || null;\n      let references = null;\n\n      if (containerType == 'mp4') {\n        // eslint-disable-next-line new-cap\n        references = shaka.media.Mp4SegmentIndexParser(\n            indexData, startByte, uris, scaledPresentationTimeOffset);\n      } else {\n        goog.asserts.assert(initData, 'WebM requires init data');\n        let parser = new shaka.media.WebmSegmentIndexParser();\n        references = parser.parse(indexData, initData, uris,\n            scaledPresentationTimeOffset);\n      }\n\n      presentationTimeline.notifySegments(references, periodStart);\n\n      // Since containers are never updated, we don't need to store the\n      // segmentIndex in the map.\n      goog.asserts.assert(!segmentIndex,\n                          'Should not call createSegmentIndex twice');\n\n      segmentIndex = new shaka.media.SegmentIndex(references);\n      if (fitLast) {\n        segmentIndex.fit(periodDuration);\n      }\n    });\n  };\n  let get = function(i) {\n    goog.asserts.assert(segmentIndex, 'Must call createSegmentIndex first');\n    return segmentIndex.get(i);\n  };\n  let find = function(t) {\n    goog.asserts.assert(segmentIndex, 'Must call createSegmentIndex first');\n    return segmentIndex.find(t);\n  };\n\n  return {\n    createSegmentIndex: create,\n    findSegmentPosition: find,\n    getSegmentReference: get,\n  };\n};\n\n\n/**\n * @param {?shaka.dash.DashParser.InheritanceFrame} frame\n * @return {Element}\n * @private\n */\nshaka.dash.SegmentBase.fromInheritance_ = function(frame) {\n  return frame.segmentBase;\n};\n\n\n/**\n * Creates segment index info from a Context object.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.DashParser.RequestInitSegmentCallback} requestInitSegment\n * @param {shaka.media.InitSegmentReference} init\n * @param {number} scaledPresentationTimeOffset\n * @return {shaka.dash.DashParser.SegmentIndexFunctions}\n * @throws shaka.util.Error When there is a parsing error.\n * @private\n */\nshaka.dash.SegmentBase.createSegmentIndex_ = function(\n    context, requestInitSegment, init, scaledPresentationTimeOffset) {\n  const MpdUtils = shaka.dash.MpdUtils;\n  const SegmentBase = shaka.dash.SegmentBase;\n  const XmlUtils = shaka.util.XmlUtils;\n  const ManifestParserUtils = shaka.util.ManifestParserUtils;\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  let contentType = context.representation.contentType;\n  let containerType = context.representation.mimeType.split('/')[1];\n  if (contentType != ContentType.TEXT && containerType != 'mp4' &&\n      containerType != 'webm') {\n    shaka.log.error(\n        'SegmentBase specifies an unsupported container type.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_UNSUPPORTED_CONTAINER);\n  }\n\n  if ((containerType == 'webm') && !init) {\n    shaka.log.error(\n        'SegmentBase does not contain sufficient segment information:',\n        'the SegmentBase uses a WebM container,',\n        'but does not contain an Initialization element.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_WEBM_MISSING_INIT);\n  }\n\n  let representationIndex = MpdUtils.inheritChild(\n      context, SegmentBase.fromInheritance_, 'RepresentationIndex');\n  let indexRangeElem = MpdUtils.inheritAttribute(\n      context, SegmentBase.fromInheritance_, 'indexRange');\n\n  let indexUris = context.representation.baseUris;\n  let indexRange = XmlUtils.parseRange(indexRangeElem || '');\n  if (representationIndex) {\n    let representationUri = representationIndex.getAttribute('sourceURL');\n    if (representationUri) {\n      indexUris = ManifestParserUtils.resolveUris(\n          context.representation.baseUris, [representationUri]);\n    }\n\n    indexRange = XmlUtils.parseAttr(\n        representationIndex, 'range', XmlUtils.parseRange, indexRange);\n  }\n\n  if (!indexRange) {\n    shaka.log.error(\n        'SegmentBase does not contain sufficient segment information:',\n        'the SegmentBase does not contain @indexRange',\n        'or a RepresentationIndex element.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n  }\n\n  return shaka.dash.SegmentBase.createSegmentIndexFromUris(\n      context, requestInitSegment, init, indexUris, indexRange.start,\n      indexRange.end, containerType, scaledPresentationTimeOffset);\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.dash.SegmentList');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.dash.SegmentBase');\ngoog.require('shaka.log');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * @namespace shaka.dash.SegmentList\n * @summary A set of functions for parsing SegmentList elements.\n */\n\n\n/**\n * Creates a new Stream object or updates the Stream in the manifest.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {!Object.<string, !shaka.media.SegmentIndex>} segmentIndexMap\n * @return {shaka.dash.DashParser.StreamInfo}\n */\nshaka.dash.SegmentList.createStream = function(context, segmentIndexMap) {\n  goog.asserts.assert(context.representation.segmentList,\n                      'Should only be called with SegmentList');\n  const SegmentList = shaka.dash.SegmentList;\n\n  let init = shaka.dash.SegmentBase.createInitSegment(\n      context, SegmentList.fromInheritance_);\n  let info = SegmentList.parseSegmentListInfo_(context);\n\n  SegmentList.checkSegmentListInfo_(context, info);\n\n  /** @type {shaka.media.SegmentIndex} */\n  let segmentIndex = null;\n  let id = null;\n  if (context.period.id && context.representation.id) {\n    // Only check/store the index if period and representation IDs are set.\n    id = context.period.id + ',' + context.representation.id;\n    segmentIndex = segmentIndexMap[id];\n  }\n\n  let references = SegmentList.createSegmentReferences_(\n      context.periodInfo.duration, info.startNumber,\n      context.representation.baseUris, info);\n\n  if (segmentIndex) {\n    segmentIndex.merge(references);\n    let start = context.presentationTimeline.getSegmentAvailabilityStart();\n    segmentIndex.evict(start - context.periodInfo.start);\n  } else {\n    context.presentationTimeline.notifySegments(\n        references, context.periodInfo.start);\n    segmentIndex = new shaka.media.SegmentIndex(references);\n    if (id && context.dynamic) {\n      segmentIndexMap[id] = segmentIndex;\n    }\n  }\n\n  if (!context.dynamic || !context.periodInfo.isLastPeriod) {\n    segmentIndex.fit(context.periodInfo.duration);\n  }\n\n  return {\n    createSegmentIndex: Promise.resolve.bind(Promise),\n    findSegmentPosition: segmentIndex.find.bind(segmentIndex),\n    getSegmentReference: segmentIndex.get.bind(segmentIndex),\n    initSegmentReference: init,\n    scaledPresentationTimeOffset: info.scaledPresentationTimeOffset,\n  };\n};\n\n\n/**\n * @typedef {{\n *   mediaUri: string,\n *   start: number,\n *   end: ?number\n * }}\n *\n * @property {string} mediaUri\n *   The URI of the segment.\n * @property {number} start\n *   The start byte of the segment.\n * @property {?number} end\n *   The end byte of the segment, or null.\n */\nshaka.dash.SegmentList.MediaSegment;\n\n\n/**\n * @typedef {{\n *   segmentDuration: ?number,\n *   startTime: number,\n *   startNumber: number,\n *   scaledPresentationTimeOffset: number,\n *   timeline: Array.<shaka.dash.MpdUtils.TimeRange>,\n *   mediaSegments: !Array.<shaka.dash.SegmentList.MediaSegment>\n * }}\n * @private\n *\n * @description\n * Contains information about a SegmentList.\n *\n * @property {?number} segmentDuration\n *   The duration of the segments, if given.\n * @property {number} startTime\n *   The start time of the first segment, in seconds.\n * @property {number} startNumber\n *   The start number of the segments; 1 or greater.\n * @property {number} scaledPresentationTimeOffset\n *   The scaledPresentationTimeOffset of the representation, in seconds.\n * @property {Array.<shaka.dash.MpdUtils.TimeRange>} timeline\n *   The timeline of the representation, if given.  Times in seconds.\n * @property {!Array.<shaka.dash.SegmentList.MediaSegment>} mediaSegments\n *   The URI and byte-ranges of the media segments.\n */\nshaka.dash.SegmentList.SegmentListInfo;\n\n\n/**\n * @param {?shaka.dash.DashParser.InheritanceFrame} frame\n * @return {Element}\n * @private\n */\nshaka.dash.SegmentList.fromInheritance_ = function(frame) {\n  return frame.segmentList;\n};\n\n\n/**\n * Parses the SegmentList items to create an info object.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @return {shaka.dash.SegmentList.SegmentListInfo}\n * @private\n */\nshaka.dash.SegmentList.parseSegmentListInfo_ = function(context) {\n  const SegmentList = shaka.dash.SegmentList;\n  const MpdUtils = shaka.dash.MpdUtils;\n\n  let mediaSegments = SegmentList.parseMediaSegments_(context);\n  let segmentInfo =\n      MpdUtils.parseSegmentInfo(context, SegmentList.fromInheritance_);\n\n  let startNumber = segmentInfo.startNumber;\n  if (startNumber == 0) {\n    shaka.log.warning('SegmentList@startNumber must be > 0');\n    startNumber = 1;\n  }\n\n  let startTime = 0;\n  if (segmentInfo.segmentDuration) {\n    // See DASH sec. 5.3.9.5.3\n    // Don't use presentationTimeOffset for @duration.\n    startTime = segmentInfo.segmentDuration * (startNumber - 1);\n  } else if (segmentInfo.timeline && segmentInfo.timeline.length > 0) {\n    // The presentationTimeOffset was considered in timeline creation.\n    startTime = segmentInfo.timeline[0].start;\n  }\n\n  return {\n    segmentDuration: segmentInfo.segmentDuration,\n    startTime: startTime,\n    startNumber: startNumber,\n    scaledPresentationTimeOffset: segmentInfo.scaledPresentationTimeOffset,\n    timeline: segmentInfo.timeline,\n    mediaSegments: mediaSegments,\n  };\n};\n\n\n/**\n * Checks whether a SegmentListInfo object is valid.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.SegmentList.SegmentListInfo} info\n * @throws shaka.util.Error When there is a parsing error.\n * @private\n */\nshaka.dash.SegmentList.checkSegmentListInfo_ = function(context, info) {\n  if (!info.segmentDuration && !info.timeline &&\n      info.mediaSegments.length > 1) {\n    shaka.log.warning(\n        'SegmentList does not contain sufficient segment information:',\n        'the SegmentList specifies multiple segments,',\n        'but does not specify a segment duration or timeline.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n  }\n\n  if (!info.segmentDuration && !context.periodInfo.duration && !info.timeline &&\n      info.mediaSegments.length == 1) {\n    shaka.log.warning(\n        'SegmentList does not contain sufficient segment information:',\n        'the SegmentList specifies one segment,',\n        'but does not specify a segment duration, period duration,',\n        'or timeline.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n  }\n\n  if (info.timeline && info.timeline.length == 0) {\n    shaka.log.warning(\n        'SegmentList does not contain sufficient segment information:',\n        'the SegmentList has an empty timeline.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n  }\n};\n\n\n/**\n * Creates an array of segment references for the given data.\n *\n * @param {?number} periodDuration in seconds.\n * @param {number} startNumber\n * @param {!Array.<string>} baseUris\n * @param {shaka.dash.SegmentList.SegmentListInfo} info\n * @return {!Array.<!shaka.media.SegmentReference>}\n * @private\n */\nshaka.dash.SegmentList.createSegmentReferences_ = function(\n    periodDuration, startNumber, baseUris, info) {\n  const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n  let max = info.mediaSegments.length;\n  if (info.timeline && info.timeline.length != info.mediaSegments.length) {\n    max = Math.min(info.timeline.length, info.mediaSegments.length);\n    shaka.log.warning(\n        'The number of items in the segment timeline and the number of segment',\n        'URLs do not match, truncating', info.mediaSegments.length, 'to', max);\n  }\n\n  /** @type {!Array.<!shaka.media.SegmentReference>} */\n  let references = [];\n  let prevEndTime = info.startTime;\n  for (let i = 0; i < max; i++) {\n    let segment = info.mediaSegments[i];\n    let mediaUri = ManifestParserUtils.resolveUris(\n        baseUris, [segment.mediaUri]);\n\n    let startTime = prevEndTime;\n    let endTime;\n\n    if (info.segmentDuration != null) {\n      endTime = startTime + info.segmentDuration;\n    } else if (info.timeline) {\n      // Ignore the timepoint start since they are continuous.\n      endTime = info.timeline[i].end;\n    } else {\n      // If segmentDuration and timeline are null then there must\n      // be exactly one segment.\n      goog.asserts.assert(\n          info.mediaSegments.length == 1 && periodDuration,\n          'There should be exactly one segment with a Period duration.');\n      endTime = startTime + periodDuration;\n    }\n\n    let getUris = (function(uris) { return uris; }.bind(null, mediaUri));\n    references.push(\n        new shaka.media.SegmentReference(\n            i + startNumber, startTime, endTime, getUris, segment.start,\n            segment.end));\n    prevEndTime = endTime;\n  }\n\n  return references;\n};\n\n\n/**\n * Parses the media URIs from the context.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @return {!Array.<shaka.dash.SegmentList.MediaSegment>}\n * @private\n */\nshaka.dash.SegmentList.parseMediaSegments_ = function(context) {\n  const Functional = shaka.util.Functional;\n  /** @type {!Array.<!Element>} */\n  let segmentLists = [\n    context.representation.segmentList,\n    context.adaptationSet.segmentList,\n    context.period.segmentList,\n  ].filter(Functional.isNotNull);\n\n  const XmlUtils = shaka.util.XmlUtils;\n  // Search each SegmentList for one with at least one SegmentURL element,\n  // select the first one, and convert each SegmentURL element to a tuple.\n  return segmentLists\n      .map(function(node) { return XmlUtils.findChildren(node, 'SegmentURL'); })\n      .reduce(function(all, part) { return all.length > 0 ? all : part; })\n      .map(function(urlNode) {\n        if (urlNode.getAttribute('indexRange') &&\n            !context.indexRangeWarningGiven) {\n          context.indexRangeWarningGiven = true;\n          shaka.log.warning(\n              'We do not support the SegmentURL@indexRange attribute on ' +\n              'SegmentList.  We only use the SegmentList@duration attribute ' +\n              'or SegmentTimeline, which must be accurate.');\n        }\n\n        let uri = urlNode.getAttribute('media');\n        let range = XmlUtils.parseAttr(\n            urlNode, 'mediaRange', XmlUtils.parseRange, {start: 0, end: null});\n        return {mediaUri: uri, start: range.start, end: range.end};\n      });\n};\n\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.dash.SegmentTemplate');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.dash.SegmentBase');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.ManifestParserUtils');\n\n\n/**\n * @namespace shaka.dash.SegmentTemplate\n * @summary A set of functions for parsing SegmentTemplate elements.\n */\n\n\n/**\n * Creates a new Stream object or updates the Stream in the manifest.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.DashParser.RequestInitSegmentCallback} requestInitSegment\n * @param {!Object.<string, !shaka.media.SegmentIndex>} segmentIndexMap\n * @param {boolean} isUpdate True if the manifest is being updated.\n * @throws shaka.util.Error When there is a parsing error.\n * @return {shaka.dash.DashParser.StreamInfo}\n */\nshaka.dash.SegmentTemplate.createStream = function(\n    context, requestInitSegment, segmentIndexMap, isUpdate) {\n  goog.asserts.assert(context.representation.segmentTemplate,\n                      'Should only be called with SegmentTemplate');\n  const SegmentTemplate = shaka.dash.SegmentTemplate;\n\n  let init = SegmentTemplate.createInitSegment_(context);\n  let info = SegmentTemplate.parseSegmentTemplateInfo_(context);\n\n  SegmentTemplate.checkSegmentTemplateInfo_(context, info);\n\n  /** @type {?shaka.dash.DashParser.SegmentIndexFunctions} */\n  let segmentIndexFunctions = null;\n  if (info.indexTemplate) {\n    segmentIndexFunctions = SegmentTemplate.createFromIndexTemplate_(\n        context, requestInitSegment, init, info);\n  } else if (info.segmentDuration) {\n    if (!isUpdate) {\n      context.presentationTimeline.notifyMaxSegmentDuration(\n          info.segmentDuration);\n      context.presentationTimeline.notifyMinSegmentStartTime(\n        context.periodInfo.start);\n    }\n    segmentIndexFunctions = SegmentTemplate.createFromDuration_(context, info);\n  } else {\n    /** @type {shaka.media.SegmentIndex} */\n    let segmentIndex = null;\n    let id = null;\n    if (context.period.id && context.representation.id) {\n      // Only check/store the index if period and representation IDs are set.\n      id = context.period.id + ',' + context.representation.id;\n      segmentIndex = segmentIndexMap[id];\n    }\n\n    let references = SegmentTemplate.createFromTimeline_(context, info);\n\n    // Don't fit live content, since it might receive more segments.\n    // Unless that live content is multi-period; it's safe to fit every period\n    // but the last one, since only the last period might receive new segments.\n    let shouldFit = !context.dynamic || !context.periodInfo.isLastPeriod;\n\n    if (segmentIndex) {\n      if (shouldFit) {\n        // Fit the new references before merging them, so that the merge\n        // algorithm has a more accurate view of their start and end times.\n        let wrapper = new shaka.media.SegmentIndex(references);\n        wrapper.fit(context.periodInfo.duration);\n      }\n\n      segmentIndex.merge(references);\n      let start = context.presentationTimeline.getSegmentAvailabilityStart();\n      segmentIndex.evict(start - context.periodInfo.start);\n    } else {\n      context.presentationTimeline.notifySegments(\n          references, context.periodInfo.start);\n      segmentIndex = new shaka.media.SegmentIndex(references);\n      if (id && context.dynamic) {\n        segmentIndexMap[id] = segmentIndex;\n      }\n    }\n\n    if (shouldFit) {\n      segmentIndex.fit(context.periodInfo.duration);\n    }\n\n    segmentIndexFunctions = {\n      createSegmentIndex: Promise.resolve.bind(Promise),\n      findSegmentPosition: segmentIndex.find.bind(segmentIndex),\n      getSegmentReference: segmentIndex.get.bind(segmentIndex),\n    };\n  }\n\n  return {\n    createSegmentIndex: segmentIndexFunctions.createSegmentIndex,\n    findSegmentPosition: segmentIndexFunctions.findSegmentPosition,\n    getSegmentReference: segmentIndexFunctions.getSegmentReference,\n    initSegmentReference: init,\n    scaledPresentationTimeOffset: info.scaledPresentationTimeOffset,\n  };\n};\n\n\n/**\n * @typedef {{\n *   timescale: number,\n *   segmentDuration: ?number,\n *   startNumber: number,\n *   scaledPresentationTimeOffset: number,\n *   unscaledPresentationTimeOffset: number,\n *   timeline: Array.<shaka.dash.MpdUtils.TimeRange>,\n *   mediaTemplate: ?string,\n *   indexTemplate: ?string\n * }}\n * @private\n *\n * @description\n * Contains information about a SegmentTemplate.\n *\n * @property {number} timescale\n *   The time-scale of the representation.\n * @property {?number} segmentDuration\n *   The duration of the segments in seconds, if given.\n * @property {number} startNumber\n *   The start number of the segments; 1 or greater.\n * @property {number} scaledPresentationTimeOffset\n *   The presentation time offset of the representation, in seconds.\n * @property {number} unscaledPresentationTimeOffset\n *   The presentation time offset of the representation, in timescale units.\n * @property {Array.<shaka.dash.MpdUtils.TimeRange>} timeline\n *   The timeline of the representation, if given.  Times in seconds.\n * @property {?string} mediaTemplate\n *   The media URI template, if given.\n * @property {?string} indexTemplate\n *   The index URI template, if given.\n */\nshaka.dash.SegmentTemplate.SegmentTemplateInfo;\n\n\n/**\n * @param {?shaka.dash.DashParser.InheritanceFrame} frame\n * @return {Element}\n * @private\n */\nshaka.dash.SegmentTemplate.fromInheritance_ = function(frame) {\n  return frame.segmentTemplate;\n};\n\n\n/**\n * Parses a SegmentTemplate element into an info object.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @return {shaka.dash.SegmentTemplate.SegmentTemplateInfo}\n * @private\n */\nshaka.dash.SegmentTemplate.parseSegmentTemplateInfo_ = function(context) {\n  const SegmentTemplate = shaka.dash.SegmentTemplate;\n  const MpdUtils = shaka.dash.MpdUtils;\n  let segmentInfo =\n      MpdUtils.parseSegmentInfo(context, SegmentTemplate.fromInheritance_);\n\n  let media = MpdUtils.inheritAttribute(\n      context, SegmentTemplate.fromInheritance_, 'media');\n  let index = MpdUtils.inheritAttribute(\n      context, SegmentTemplate.fromInheritance_, 'index');\n\n  return {\n    segmentDuration: segmentInfo.segmentDuration,\n    timescale: segmentInfo.timescale,\n    startNumber: segmentInfo.startNumber,\n    scaledPresentationTimeOffset: segmentInfo.scaledPresentationTimeOffset,\n    unscaledPresentationTimeOffset: segmentInfo.unscaledPresentationTimeOffset,\n    timeline: segmentInfo.timeline,\n    mediaTemplate: media,\n    indexTemplate: index,\n  };\n};\n\n\n/**\n * Verifies a SegmentTemplate info object.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n * @throws shaka.util.Error When there is a parsing error.\n * @private\n */\nshaka.dash.SegmentTemplate.checkSegmentTemplateInfo_ = function(context, info) {\n  let n = 0;\n  n += info.indexTemplate ? 1 : 0;\n  n += info.timeline ? 1 : 0;\n  n += info.segmentDuration ? 1 : 0;\n\n  if (n == 0) {\n    shaka.log.error(\n        'SegmentTemplate does not contain any segment information:',\n        'the SegmentTemplate must contain either an index URL template',\n        'a SegmentTimeline, or a segment duration.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n  } else if (n != 1) {\n    shaka.log.warning(\n        'SegmentTemplate containes multiple segment information sources:',\n        'the SegmentTemplate should only contain an index URL template,',\n        'a SegmentTimeline or a segment duration.',\n        context.representation);\n    if (info.indexTemplate) {\n      shaka.log.info('Using the index URL template by default.');\n      info.timeline = null;\n      info.segmentDuration = null;\n    } else {\n      goog.asserts.assert(info.timeline, 'There should be a timeline');\n      shaka.log.info('Using the SegmentTimeline by default.');\n      info.segmentDuration = null;\n    }\n  }\n\n  if (!info.indexTemplate && !info.mediaTemplate) {\n    shaka.log.error(\n        'SegmentTemplate does not contain sufficient segment information:',\n        'the SegmentTemplate\\'s media URL template is missing.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n  }\n};\n\n\n/**\n * Creates segment index functions from a index URL template.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.DashParser.RequestInitSegmentCallback} requestInitSegment\n * @param {shaka.media.InitSegmentReference} init\n * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n * @throws shaka.util.Error When there is a parsing error.\n * @return {shaka.dash.DashParser.SegmentIndexFunctions}\n * @private\n */\nshaka.dash.SegmentTemplate.createFromIndexTemplate_ = function(\n    context, requestInitSegment, init, info) {\n  const MpdUtils = shaka.dash.MpdUtils;\n  const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n  // Determine the container type.\n  let containerType = context.representation.mimeType.split('/')[1];\n  if ((containerType != 'mp4') && (containerType != 'webm')) {\n    shaka.log.error(\n        'SegmentTemplate specifies an unsupported container type.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_UNSUPPORTED_CONTAINER);\n  }\n\n  if ((containerType == 'webm') && !init) {\n    shaka.log.error(\n        'SegmentTemplate does not contain sufficient segment information:',\n        'the SegmentTemplate uses a WebM container,',\n        'but does not contain an initialization URL template.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_WEBM_MISSING_INIT);\n  }\n\n  goog.asserts.assert(info.indexTemplate, 'must be using index template');\n  let filledTemplate = MpdUtils.fillUriTemplate(\n      info.indexTemplate, context.representation.id,\n      null, context.bandwidth || null, null);\n\n  let resolvedUris = ManifestParserUtils.resolveUris(\n      context.representation.baseUris, [filledTemplate]);\n\n  return shaka.dash.SegmentBase.createSegmentIndexFromUris(\n      context, requestInitSegment, init, resolvedUris, 0, null, containerType,\n      info.scaledPresentationTimeOffset);\n};\n\n\n/**\n * Creates segment index functions from a segment duration.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n * @return {shaka.dash.DashParser.SegmentIndexFunctions}\n * @private\n */\nshaka.dash.SegmentTemplate.createFromDuration_ = function(context, info) {\n  goog.asserts.assert(info.mediaTemplate,\n                      'There should be a media template with duration');\n  const MpdUtils = shaka.dash.MpdUtils;\n  const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n  let periodDuration = context.periodInfo.duration;\n  let segmentDuration = info.segmentDuration;\n  let startNumber = info.startNumber;\n  let timescale = info.timescale;\n\n  let template = info.mediaTemplate;\n  let bandwidth = context.bandwidth || null;\n  let id = context.representation.id;\n  let baseUris = context.representation.baseUris;\n\n  let find = function(periodTime) {\n    if (periodTime < 0) {\n      return null;\n    } else if (periodDuration && periodTime >= periodDuration) {\n      return null;\n    }\n\n    return Math.floor(periodTime / segmentDuration);\n  };\n  let get = function(position) {\n    let segmentStart = position * segmentDuration;\n    // Cap the segment end at the period end, to avoid period transition issues\n    // in StreamingEngine.\n    let segmentEnd = segmentStart + segmentDuration;\n    if (periodDuration) segmentEnd = Math.min(segmentEnd, periodDuration);\n\n    // Do not construct segments references that should not exist.\n    if (segmentEnd < 0) {\n      return null;\n    } else if (periodDuration && segmentStart >= periodDuration) {\n      return null;\n    }\n\n    let getUris = function() {\n      let mediaUri = MpdUtils.fillUriTemplate(\n          template, id, position + startNumber, bandwidth,\n          segmentStart * timescale);\n      return ManifestParserUtils.resolveUris(baseUris, [mediaUri]);\n    };\n\n    return new shaka.media.SegmentReference(\n        position, segmentStart, segmentEnd, getUris, 0, null);\n  };\n\n  return {\n    createSegmentIndex: Promise.resolve.bind(Promise),\n    findSegmentPosition: find,\n    getSegmentReference: get,\n  };\n};\n\n\n/**\n * Creates segment references from a timeline.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n * @return {!Array.<!shaka.media.SegmentReference>}\n * @private\n */\nshaka.dash.SegmentTemplate.createFromTimeline_ = function(context, info) {\n  goog.asserts.assert(info.mediaTemplate,\n                      'There should be a media template with a timeline');\n  const MpdUtils = shaka.dash.MpdUtils;\n  const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n  /** @type {!Array.<!shaka.media.SegmentReference>} */\n  let references = [];\n  for (let i = 0; i < info.timeline.length; i++) {\n    let start = info.timeline[i].start;\n    let unscaledStart = info.timeline[i].unscaledStart;\n    let end = info.timeline[i].end;\n\n    // Note: i = k - 1, where k indicates the k'th segment listed in the MPD.\n    // (See section 5.3.9.5.3 of the DASH spec.)\n    let segmentReplacement = i + info.startNumber;\n\n    // Consider the presentation time offset in segment uri computation\n    let timeReplacement = unscaledStart +\n        info.unscaledPresentationTimeOffset;\n    let createUris = (function(\n            template, repId, bandwidth, baseUris, segmentId, time) {\n          let mediaUri = MpdUtils.fillUriTemplate(\n              template, repId, segmentId, bandwidth, time);\n          return ManifestParserUtils.resolveUris(baseUris, [mediaUri])\n              .map(function(g) { return g.toString(); });\n        }.bind(null, info.mediaTemplate, context.representation.id,\n               context.bandwidth || null, context.representation.baseUris,\n               segmentReplacement, timeReplacement));\n\n    references.push(new shaka.media.SegmentReference(\n        segmentReplacement, start, end, createUris, 0, null));\n  }\n\n  return references;\n};\n\n\n/**\n * Creates an init segment reference from a context object.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @return {shaka.media.InitSegmentReference}\n * @private\n */\nshaka.dash.SegmentTemplate.createInitSegment_ = function(context) {\n  const MpdUtils = shaka.dash.MpdUtils;\n  const ManifestParserUtils = shaka.util.ManifestParserUtils;\n  const SegmentTemplate = shaka.dash.SegmentTemplate;\n\n  let initialization = MpdUtils.inheritAttribute(\n      context, SegmentTemplate.fromInheritance_, 'initialization');\n  if (!initialization) {\n    return null;\n  }\n\n  let repId = context.representation.id;\n  let bandwidth = context.bandwidth || null;\n  let baseUris = context.representation.baseUris;\n  let getUris = function() {\n    goog.asserts.assert(initialization, 'Should have returned earler');\n    let filledTemplate = MpdUtils.fillUriTemplate(\n        initialization, repId, null, bandwidth, null);\n    let resolvedUris = ManifestParserUtils.resolveUris(\n        baseUris, [filledTemplate]);\n    return resolvedUris;\n  };\n\n  return new shaka.media.InitSegmentReference(getUris, 0, null);\n};\n\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.ManifestParser');\n\ngoog.require('goog.Uri');\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Platform');\n\n\n/**\n * @namespace shaka.media.ManifestParser\n * @summary An interface to register manifest parsers.\n * @exportDoc\n */\n\n\n/**\n * Contains the parser factory functions indexed by MIME type.\n *\n * @type {!Object.<string, shaka.extern.ManifestParser.Factory>}\n */\nshaka.media.ManifestParser.parsersByMime = {};\n\n\n/**\n * Contains the parser factory functions indexed by file extension.\n *\n * @type {!Object.<string, shaka.extern.ManifestParser.Factory>}\n */\nshaka.media.ManifestParser.parsersByExtension = {};\n\n\n/**\n * Registers a manifest parser by file extension.\n *\n * @param {string} extension The file extension of the manifest.\n * @param {shaka.extern.ManifestParser.Factory} parserFactory The factory\n *   used to create parser instances.\n * @export\n */\nshaka.media.ManifestParser.registerParserByExtension = function(\n    extension, parserFactory) {\n  shaka.media.ManifestParser.parsersByExtension[extension] = parserFactory;\n};\n\n\n/**\n * Registers a manifest parser by MIME type.\n *\n * @param {string} mimeType The MIME type of the manifest.\n * @param {shaka.extern.ManifestParser.Factory} parserFactory The factory\n *   used to create parser instances.\n * @export\n */\nshaka.media.ManifestParser.registerParserByMime = function(\n    mimeType, parserFactory) {\n  shaka.media.ManifestParser.parsersByMime[mimeType] = parserFactory;\n};\n\n\n/**\n * Returns a map of manifest support for well-known types.\n *\n * @return {!Object.<string, boolean>}\n */\nshaka.media.ManifestParser.probeSupport = function() {\n  const ManifestParser = shaka.media.ManifestParser;\n  let support = {};\n\n  // Make sure all registered parsers are shown, but only for MSE-enabled\n  // platforms where our parsers matter.\n  if (shaka.util.Platform.supportsMediaSource()) {\n    for (let type in ManifestParser.parsersByMime) {\n      support[type] = true;\n    }\n    for (let type in ManifestParser.parsersByExtension) {\n      support[type] = true;\n    }\n  }\n\n  // Make sure all well-known types are tested as well, just to show an explicit\n  // false for things people might be expecting.\n  const testMimeTypes = [\n    // DASH\n    'application/dash+xml',\n    // HLS\n    'application/x-mpegurl',\n    'application/vnd.apple.mpegurl',\n    // SmoothStreaming\n    'application/vnd.ms-sstr+xml',\n  ];\n  const testExtensions = {\n    // DASH\n    'mpd': 'application/dash+xml',\n    // HLS\n    'm3u8': 'application/x-mpegurl',\n    // SmoothStreaming\n    'ism': 'application/vnd.ms-sstr+xml',\n  };\n\n  for (let type of testMimeTypes) {\n    // Only query our parsers for MSE-enabled platforms.  Otherwise, query a\n    // temporary media element for native support for these types.\n    if (shaka.util.Platform.supportsMediaSource()) {\n      support[type] = !!ManifestParser.parsersByMime[type];\n    } else {\n      support[type] = shaka.util.Platform.supportsMediaType(type);\n    }\n  }\n\n  for (let extension in testExtensions) {\n    // Only query our parsers for MSE-enabled platforms.  Otherwise, query a\n    // temporary media element for native support for these MIME type for the\n    // extension.\n    if (shaka.util.Platform.supportsMediaSource()) {\n      support[extension] = !!ManifestParser.parsersByExtension[extension];\n    } else {\n      const type = testExtensions[extension];\n      support[extension] = shaka.util.Platform.supportsMediaType(type);\n    }\n  }\n\n  return support;\n};\n\n\n/**\n * Create a manifest parser to parse the manifest at |uri|.\n *\n * @param {string} uri\n * @param {!shaka.net.NetworkingEngine} netEngine\n * @param {shaka.extern.RetryParameters} retryParams\n * @param {?string} mimeType\n * @return {!Promise.<!shaka.extern.ManifestParser>}\n */\nshaka.media.ManifestParser.create = async function(\n    uri, netEngine, retryParams, mimeType) {\n  try {\n    const Factory = await shaka.media.ManifestParser.getFactory_(\n        uri, netEngine, retryParams, mimeType);\n\n    return new Factory();\n  } catch (error) {\n    goog.asserts.assert(\n        error instanceof shaka.util.Error, 'Incorrect error type');\n\n    // Regardless of what the error was, we need to upgrade it to a critical\n    // error. We can't do anything if we can't create a manifest parser.\n    error.severity = shaka.util.Error.Severity.CRITICAL;\n\n    throw error;\n  }\n};\n\n\n/**\n * Get a factory that can create a manifest parser that should be able to parse\n * the manifest at |uri|.\n *\n * @param {string} uri\n * @param {!shaka.net.NetworkingEngine} netEngine\n * @param {shaka.extern.RetryParameters} retryParams\n * @param {?string} mimeType\n * @return {!Promise.<shaka.extern.ManifestParser.Factory>}\n * @private\n */\nshaka.media.ManifestParser.getFactory_ = async function(\n    uri, netEngine, retryParams, mimeType) {\n  const ManifestParser = shaka.media.ManifestParser;\n\n  // Try using the MIME type we were given.\n  if (mimeType) {\n    const factory = ManifestParser.parsersByMime[mimeType.toLowerCase()];\n    if (factory) {\n      return factory;\n    }\n\n    shaka.log.warning(\n        'Could not determine manifest type using MIME type ', mimeType);\n  }\n\n  const extension = ManifestParser.getExtension(uri);\n  if (extension) {\n    const factory = ManifestParser.parsersByExtension[extension];\n    if (factory) {\n      return factory;\n    }\n\n    shaka.log.warning(\n        'Could not determine manifest type for extension ', extension);\n  } else {\n    shaka.log.warning('Could not find extension for ', uri);\n  }\n\n  if (!mimeType) {\n    mimeType = await ManifestParser.getMimeType(uri, netEngine, retryParams);\n\n    if (mimeType) {\n      const factory = shaka.media.ManifestParser.parsersByMime[mimeType];\n      if (factory) {\n        return factory;\n      }\n\n      shaka.log.warning('Could not determine manifest type using MIME type',\n                        mimeType);\n    }\n  }\n\n  throw new shaka.util.Error(\n      shaka.util.Error.Severity.CRITICAL,\n      shaka.util.Error.Category.MANIFEST,\n      shaka.util.Error.Code.UNABLE_TO_GUESS_MANIFEST_TYPE,\n      uri);\n};\n\n\n/**\n * @param {string} uri\n * @param {!shaka.net.NetworkingEngine} netEngine\n * @param {shaka.extern.RetryParameters} retryParams\n * @return {!Promise.<string>}\n */\nshaka.media.ManifestParser.getMimeType = async function(\n    uri, netEngine, retryParams) {\n  const type = shaka.net.NetworkingEngine.RequestType.MANIFEST;\n\n  let request = shaka.net.NetworkingEngine.makeRequest([uri], retryParams);\n  request.method = 'HEAD';\n\n  let response = await netEngine.request(type, request).promise;\n\n  // https://bit.ly/2K9s9kf says this header should always be available,\n  // but just to be safe:\n  let mimeType = response.headers['content-type'];\n  return mimeType ? mimeType.toLowerCase() : '';\n};\n\n\n/**\n * @param {string} uri\n * @return {string}\n */\nshaka.media.ManifestParser.getExtension = function(uri) {\n  const uriObj = new goog.Uri(uri);\n  const uriPieces = uriObj.getPath().split('/');\n  const uriFilename = uriPieces.pop();\n  const filenamePieces = uriFilename.split('.');\n\n  // Only one piece means there is no extension.\n  if (filenamePieces.length == 1) {\n    return '';\n  }\n\n  return filenamePieces.pop().toLowerCase();\n};\n\n\n/**\n * Determines whether or not this URI and MIME type are supported by our own\n * manifest parsers on this platform.  This takes into account whether or not\n * MediaSource is available, as well as which parsers are registered to the\n * system.\n *\n * @param {string} uri\n * @param {string} mimeType\n * @return {boolean}\n */\nshaka.media.ManifestParser.isSupported = function(uri, mimeType) {\n  // Without MediaSource, our own parsers are useless.\n  if (!shaka.util.Platform.supportsMediaSource()) {\n    return false;\n  }\n\n  if (mimeType in shaka.media.ManifestParser.parsersByMime) {\n    return true;\n  }\n\n  const extension = shaka.media.ManifestParser.getExtension(uri);\n  if (extension in shaka.media.ManifestParser.parsersByExtension) {\n    return true;\n  }\n\n  return false;\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.PresentationTimeline');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.SegmentReference');\n\n\n/**\n * Creates a PresentationTimeline.\n *\n * @param {?number} presentationStartTime The wall-clock time, in seconds,\n *   when the presentation started or will start. Only required for live.\n * @param {number} presentationDelay The delay to give the presentation, in\n *   seconds.  Only required for live.\n * @param {boolean=} autoCorrectDrift Whether to account for drift when\n *   determining the availability window.\n *\n * @see {shaka.extern.Manifest}\n * @see {@tutorial architecture}\n *\n * @constructor\n * @struct\n * @export\n */\nshaka.media.PresentationTimeline = function(\n    presentationStartTime, presentationDelay, autoCorrectDrift = true) {\n  /** @private {?number} */\n  this.presentationStartTime_ = presentationStartTime;\n\n  /** @private {number} */\n  this.presentationDelay_ = presentationDelay;\n\n  /** @private {number} */\n  this.duration_ = Infinity;\n\n  /** @private {number} */\n  this.segmentAvailabilityDuration_ = Infinity;\n\n  /**\n   * The maximum segment duration (in seconds).  Can be based on explicitly-\n   * known segments or on signalling in the manifest.\n   *\n   * @private {number}\n   */\n  this.maxSegmentDuration_ = 1;\n\n  /**\n   * The minimum segment start time (in seconds, in the presentation timeline)\n   * for segments we explicitly know about.\n   *\n   * This is null if we have no explicit descriptions of segments, such as in\n   * DASH when using SegmentTemplate w/ duration.\n   *\n   * @private {?number}\n   */\n  this.minSegmentStartTime_ = null;\n\n  /**\n   * The maximum segment end time (in seconds, in the presentation timeline) for\n   * segments we explicitly know about.\n   *\n   * This is null if we have no explicit descriptions of segments, such as in\n   * DASH when using SegmentTemplate w/ duration.  When this is non-null, the\n   * presentation start time is calculated from the segment end times.\n   *\n   * @private {?number}\n   */\n  this.maxSegmentEndTime_ = null;\n\n  /** @private {number} */\n  this.clockOffset_ = 0;\n\n  /** @private {boolean} */\n  this.static_ = true;\n\n  /** @private {number} */\n  this.userSeekStart_ = 0;\n\n  /** @private {boolean} */\n  this.autoCorrectDrift_ = autoCorrectDrift;\n};\n\n\n/**\n * @return {number} The presentation's duration in seconds.\n *   Infinity indicates that the presentation continues indefinitely.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.getDuration = function() {\n  return this.duration_;\n};\n\n\n/**\n * @return {number} The presentation's max segment duration in seconds.\n */\nshaka.media.PresentationTimeline.prototype.getMaxSegmentDuration = function() {\n  return this.maxSegmentDuration_;\n};\n\n\n/**\n * Sets the presentation's duration.\n *\n * @param {number} duration The presentation's duration in seconds.\n *   Infinity indicates that the presentation continues indefinitely.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.setDuration = function(duration) {\n  goog.asserts.assert(duration > 0, 'duration must be > 0');\n  this.duration_ = duration;\n};\n\n\n/**\n * @return {?number} The presentation's start time in seconds.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.getPresentationStartTime =\n    function() {\n  return this.presentationStartTime_;\n};\n\n\n/**\n * Sets the clock offset, which is the difference between the client's clock\n * and the server's clock, in milliseconds (i.e., serverTime = Date.now() +\n * clockOffset).\n *\n * @param {number} offset The clock offset, in ms.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.setClockOffset = function(offset) {\n  this.clockOffset_ = offset;\n};\n\n\n/**\n * Sets the presentation's static flag.\n *\n * @param {boolean} isStatic If true, the presentation is static, meaning all\n *   segments are available at once.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.setStatic = function(isStatic) {\n  // NOTE: the argument name is not \"static\" because that's a keyword in ES6\n  this.static_ = isStatic;\n};\n\n\n/**\n * Sets the presentation's segment availability duration. The segment\n * availability duration should only be set for live.\n *\n * @param {number} segmentAvailabilityDuration The presentation's new segment\n *   availability duration in seconds.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.setSegmentAvailabilityDuration =\n    function(segmentAvailabilityDuration) {\n  goog.asserts.assert(segmentAvailabilityDuration >= 0,\n                      'segmentAvailabilityDuration must be >= 0');\n  this.segmentAvailabilityDuration_ = segmentAvailabilityDuration;\n};\n\n\n/**\n * Sets the presentation delay in seconds.\n *\n * @param {number} delay\n * @export\n */\nshaka.media.PresentationTimeline.prototype.setDelay = function(delay) {\n  // NOTE: This is no longer used internally, but is exported.\n  // So we cannot remove it without deprecating it and waiting one release\n  // cycle, or else we risk breaking custom manifest parsers.\n  goog.asserts.assert(delay >= 0, 'delay must be >= 0');\n  this.presentationDelay_ = delay;\n};\n\n\n/**\n * Gets the presentation delay in seconds.\n * @return {number}\n * @export\n */\nshaka.media.PresentationTimeline.prototype.getDelay = function() {\n  return this.presentationDelay_;\n};\n\n\n/**\n * Gives PresentationTimeline a Stream's segments so it can size and position\n * the segment availability window, and account for missing segment\n * information.  This function should be called once for each Stream (no more,\n * no less).\n *\n * @param {!Array.<!shaka.media.SegmentReference>} references\n * @param {number} periodStart\n * @export\n */\nshaka.media.PresentationTimeline.prototype.notifySegments = function(\n    references, periodStart) {\n  if (references.length == 0) {\n    return;\n  }\n\n  // TODO: Make SegmentReferences use timestamps in the presentation timeline,\n  // not the period timeline.\n  const firstReferenceStartTime = references[0].startTime + periodStart;\n  const lastReferenceEndTime =\n      references[references.length - 1].endTime + periodStart;\n\n  this.notifyMinSegmentStartTime(firstReferenceStartTime);\n\n  this.maxSegmentDuration_ = references.reduce(\n      function(max, r) { return Math.max(max, r.endTime - r.startTime); },\n      this.maxSegmentDuration_);\n\n  this.maxSegmentEndTime_ =\n      Math.max(this.maxSegmentEndTime_, lastReferenceEndTime);\n\n  if (this.presentationStartTime_ != null && this.autoCorrectDrift_) {\n    // Since we have explicit segment end times, calculate a presentation start\n    // based on them.  This start time accounts for drift.\n    // Date.now() is in milliseconds, from which we compute \"now\" in seconds.\n    let now = (Date.now() + this.clockOffset_) / 1000.0;\n    this.presentationStartTime_ =\n        now - this.maxSegmentEndTime_ - this.maxSegmentDuration_;\n  }\n\n  shaka.log.v1('notifySegments:',\n               'maxSegmentDuration=' + this.maxSegmentDuration_);\n};\n\n\n/**\n * Gives PresentationTimeline a Stream's minimum segment start time.\n *\n * @param {number} startTime\n * @export\n */\nshaka.media.PresentationTimeline.prototype.notifyMinSegmentStartTime = function(\n    startTime) {\n  if (this.minSegmentStartTime_ == null) {\n    // No data yet, and Math.min(null, startTime) is always 0.  So just store\n    // startTime.\n    this.minSegmentStartTime_ = startTime;\n  } else {\n    this.minSegmentStartTime_ =\n        Math.min(this.minSegmentStartTime_, startTime);\n  }\n};\n\n\n/**\n * Gives PresentationTimeline a Stream's maximum segment duration so it can\n * size and position the segment availability window.  This function should be\n * called once for each Stream (no more, no less), but does not have to be\n * called if notifySegments() is called instead for a particular stream.\n *\n * @param {number} maxSegmentDuration The maximum segment duration for a\n *   particular stream.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.notifyMaxSegmentDuration = function(\n    maxSegmentDuration) {\n  this.maxSegmentDuration_ = Math.max(\n      this.maxSegmentDuration_, maxSegmentDuration);\n\n  shaka.log.v1('notifyNewSegmentDuration:',\n               'maxSegmentDuration=' + this.maxSegmentDuration_);\n};\n\n\n/**\n * Offsets the segment times by the given amount.\n *\n * @param {number} offset The number of seconds to offset by.  A positive number\n *   adjusts the segment times forward.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.offset = function(offset) {\n  if (this.minSegmentStartTime_ != null) {\n    this.minSegmentStartTime_ += offset;\n  }\n  if (this.maxSegmentEndTime_ != null) {\n    this.maxSegmentEndTime_ += offset;\n  }\n};\n\n\n/**\n * @return {boolean} True if the presentation is live; otherwise, return\n *   false.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.isLive = function() {\n  return this.duration_ == Infinity &&\n         !this.static_;\n};\n\n\n/**\n * @return {boolean} True if the presentation is in progress (meaning not live,\n *   but also not completely available); otherwise, return false.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.isInProgress = function() {\n  return this.duration_ != Infinity &&\n         !this.static_;\n};\n\n\n/**\n * Gets the presentation's current segment availability start time.  Segments\n * ending at or before this time should be assumed to be unavailable.\n *\n * @return {number} The current segment availability start time, in seconds,\n *   relative to the start of the presentation.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.getSegmentAvailabilityStart =\n    function() {\n  goog.asserts.assert(this.segmentAvailabilityDuration_ >= 0,\n                      'The availability duration should be positive');\n\n  if (this.segmentAvailabilityDuration_ == Infinity) {\n    return this.userSeekStart_;\n  }\n\n  let end = this.getSegmentAvailabilityEnd();\n  let start = end - this.segmentAvailabilityDuration_;\n  return Math.max(this.userSeekStart_, start);\n};\n\n\n/**\n * Sets the start time of the user-defined seek range.  This is only used for\n * VOD content.\n *\n * @param {number} time\n * @export\n */\nshaka.media.PresentationTimeline.prototype.setUserSeekStart =\n    function(time) {\n  this.userSeekStart_ = time;\n};\n\n\n/**\n * Gets the presentation's current segment availability end time.  Segments\n * starting after this time should be assumed to be unavailable.\n *\n * @return {number} The current segment availability end time, in seconds,\n *   relative to the start of the presentation.  Always returns the\n *   presentation's duration for video-on-demand.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.getSegmentAvailabilityEnd =\n    function() {\n  if (!this.isLive() && !this.isInProgress()) {\n    return this.duration_;\n  }\n\n  return Math.min(this.getLiveEdge_(), this.duration_);\n};\n\n\n/**\n * Gets the seek range start time, offset by the given amount.  This is used to\n * ensure that we don't \"fall\" back out of the seek window while we are\n * buffering.\n *\n * @param {number} offset The offset to add to the start time.\n * @return {number} The current seek start time, in seconds, relative to the\n *   start of the presentation.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.getSafeSeekRangeStart = function(\n    offset) {\n  // The earliest known segment time, ignoring segment availability duration.\n  const earliestSegmentTime =\n      Math.max(this.minSegmentStartTime_, this.userSeekStart_);\n  if (this.segmentAvailabilityDuration_ == Infinity) {\n    return earliestSegmentTime;\n  }\n\n  // AKA the live edge for live streams.\n  const availabilityEnd = this.getSegmentAvailabilityEnd();\n\n  // The ideal availability start, not considering known segments.\n  const availabilityStart = availabilityEnd - this.segmentAvailabilityDuration_;\n\n  // Add the offset to the availability start to ensure that we don't fall\n  // outside the availability window while we buffer; we don't need to add the\n  // offset to earliestSegmentTime since that won't change over time.\n  // Also see: https://github.com/google/shaka-player/issues/692\n  const desiredStart =\n      Math.min(availabilityStart + offset, this.getSeekRangeEnd());\n  return Math.max(earliestSegmentTime, desiredStart);\n};\n\n\n/**\n * Gets the seek range start time.\n *\n * @return {number}\n * @export\n */\nshaka.media.PresentationTimeline.prototype.getSeekRangeStart = function() {\n  return this.getSafeSeekRangeStart(/* offset */ 0);\n};\n\n\n/**\n * Gets the seek range end.\n *\n * @return {number}\n * @export\n */\nshaka.media.PresentationTimeline.prototype.getSeekRangeEnd = function() {\n  let useDelay = this.isLive() || this.isInProgress();\n  let delay = useDelay ? this.presentationDelay_ : 0;\n  return Math.max(0, this.getSegmentAvailabilityEnd() - delay);\n};\n\n\n/**\n * True if the presentation start time is being used to calculate the live edge.\n * Using the presentation start time means that the stream may be subject to\n * encoder drift.  At runtime, we will avoid using the presentation start time\n * whenever possible.\n *\n * @return {boolean}\n * @export\n */\nshaka.media.PresentationTimeline.prototype.usingPresentationStartTime =\n    function() {\n  // If it's VOD, IPR, or an HLS \"event\", we are not using the presentation\n  // start time.\n  if (this.presentationStartTime_ == null) {\n    return false;\n  }\n\n  // If we have explicit segment times, we're not using the presentation\n  // start time.\n  if (this.maxSegmentEndTime_ != null) {\n    return false;\n  }\n\n  return true;\n};\n\n\n/**\n * @return {number} The current presentation time in seconds.\n * @private\n */\nshaka.media.PresentationTimeline.prototype.getLiveEdge_ = function() {\n  goog.asserts.assert(this.presentationStartTime_ != null,\n                      'Cannot compute timeline live edge without start time');\n  // Date.now() is in milliseconds, from which we compute \"now\" in seconds.\n  let now = (Date.now() + this.clockOffset_) / 1000.0;\n  return Math.max(\n      0, now - this.maxSegmentDuration_ - this.presentationStartTime_);\n};\n\n\nif (goog.DEBUG) {\n  /**\n   * Debug only: assert that the timeline parameters make sense for the type of\n   *   presentation (VOD, IPR, live).\n   */\n  shaka.media.PresentationTimeline.prototype.assertIsValid = function() {\n    if (this.isLive()) {\n      // Implied by isLive(): infinite and dynamic.\n      // Live streams should have a start time.\n      goog.asserts.assert(this.presentationStartTime_ != null,\n          'Detected as live stream, but does not match our model of live!');\n    } else if (this.isInProgress()) {\n      // Implied by isInProgress(): finite and dynamic.\n      // IPR streams should have a start time, and segments should not expire.\n      goog.asserts.assert(this.presentationStartTime_ != null &&\n                          this.segmentAvailabilityDuration_ == Infinity,\n          'Detected as IPR stream, but does not match our model of IPR!');\n    } else {  // VOD\n      // VOD segments should not expire and the presentation should be finite\n      // and static.\n      goog.asserts.assert(this.segmentAvailabilityDuration_ == Infinity &&\n                          this.duration_ != Infinity &&\n                          this.static_,\n          'Detected as VOD stream, but does not match our model of VOD!');\n    }\n  };\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.Networking');\n\n\n/**\n * A collection of shared utilities that bridge the gap between our networking\n * code and the other parts of our code base. This is to allow\n * |shaka.net.NetworkingEngine| to remain general.\n *\n * @final\n */\nshaka.util.Networking = class {\n  /**\n   * Create a request message for a segment. Providing |start| and |end|\n   * will set the byte range. A non-zero start must be provided for |end| to\n   * be used.\n   *\n   * @param {!Array.<string>} uris\n   * @param {?number} start\n   * @param {?number} end\n   * @param {shaka.extern.RetryParameters} retryParameters\n   * @return {shaka.extern.Request}\n   */\n  static createSegmentRequest(uris, start, end, retryParameters) {\n    const request = shaka.net.NetworkingEngine.makeRequest(\n        uris, retryParameters);\n\n    if (start == 0 && end == null) {\n      // This is a request for the entire segment.  The Range header is not\n      // required.  Note that some web servers don't accept Range headers, so\n      // don't set one if it's not strictly required.\n    } else {\n      if (end) {\n        request.headers['Range'] = 'bytes=' + start + '-' + end;\n      } else {\n        request.headers['Range'] = 'bytes=' + start + '-';\n      }\n    }\n\n    return request;\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.dash.DashParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.abr.Ewma');\ngoog.require('shaka.dash.ContentProtection');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.dash.SegmentBase');\ngoog.require('shaka.dash.SegmentList');\ngoog.require('shaka.dash.SegmentTemplate');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Networking');\ngoog.require('shaka.util.OperationManager');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * Creates a new DASH parser.\n *\n * @struct\n * @constructor\n * @implements {shaka.extern.ManifestParser}\n * @export\n */\nshaka.dash.DashParser = function() {\n  /** @private {?shaka.extern.ManifestConfiguration} */\n  this.config_ = null;\n\n  /** @private {?shaka.extern.ManifestParser.PlayerInterface} */\n  this.playerInterface_ = null;\n\n  /** @private {!Array.<string>} */\n  this.manifestUris_ = [];\n\n  /** @private {?shaka.extern.Manifest} */\n  this.manifest_ = null;\n\n  /** @private {!Array.<string>} */\n  this.periodIds_ = [];\n\n  /** @private {number} */\n  this.globalId_ = 1;\n\n  /**\n   * A map of IDs to SegmentIndex objects.\n   * ID: Period@id,AdaptationSet@id,@Representation@id\n   * e.g.: '1,5,23'\n   * @private {!Object.<string, !shaka.media.SegmentIndex>}\n   */\n  this.segmentIndexMap_ = {};\n\n  /**\n   * The update period in seconds, or 0 for no updates.\n   * @private {number}\n   */\n  this.updatePeriod_ = 0;\n\n  /**\n   * An ewma that tracks how long updates take.\n   * This is to mitigate issues caused by slow parsing on embedded devices.\n   * @private {!shaka.abr.Ewma}\n   */\n  this.averageUpdateDuration_ = new shaka.abr.Ewma(5);\n\n  /** @private {shaka.util.Timer} */\n  this.updateTimer_ = new shaka.util.Timer(() => {\n    this.onUpdate_();\n  });\n\n  /** @private {!shaka.util.OperationManager} */\n  this.operationManager_ = new shaka.util.OperationManager();\n};\n\n\n/**\n * Contains the minimum amount of time, in seconds, between manifest update\n * requests.\n *\n * @private\n * @const {number}\n */\nshaka.dash.DashParser.MIN_UPDATE_PERIOD_ = 3;\n\n\n/**\n * @typedef {\n *   function(!Array.<string>, ?number, ?number):!Promise.<!ArrayBuffer>\n * }\n */\nshaka.dash.DashParser.RequestInitSegmentCallback;\n\n\n/**\n * @typedef {{\n *   segmentBase: Element,\n *   segmentList: Element,\n *   segmentTemplate: Element,\n *   baseUris: !Array.<string>,\n *   width: (number|undefined),\n *   height: (number|undefined),\n *   contentType: string,\n *   mimeType: string,\n *   codecs: string,\n *   frameRate: (number|undefined),\n *   emsgSchemeIdUris: !Array.<string>,\n *   id: ?string,\n *   numChannels: ?number\n * }}\n *\n * @description\n * A collection of elements and properties which are inherited across levels\n * of a DASH manifest.\n *\n * @property {Element} segmentBase\n *   The XML node for SegmentBase.\n * @property {Element} segmentList\n *   The XML node for SegmentList.\n * @property {Element} segmentTemplate\n *   The XML node for SegmentTemplate.\n * @property {!Array.<string>} baseUris\n *   An array of absolute base URIs for the frame.\n * @property {(number|undefined)} width\n *   The inherited width value.\n * @property {(number|undefined)} height\n *   The inherited height value.\n * @property {string} contentType\n *   The inherited media type.\n * @property {string} mimeType\n *   The inherited MIME type value.\n * @property {string} codecs\n *   The inherited codecs value.\n * @property {(number|undefined)} frameRate\n *   The inherited framerate value.\n * @property {!Array.<string>} emsgSchemeIdUris\n *   emsg registered schemeIdUris.\n * @property {?string} id\n *   The ID of the element.\n * @property {?number} numChannels\n *   The number of audio channels, or null if unknown.\n */\nshaka.dash.DashParser.InheritanceFrame;\n\n\n/**\n * @typedef {{\n *   dynamic: boolean,\n *   presentationTimeline: !shaka.media.PresentationTimeline,\n *   period: ?shaka.dash.DashParser.InheritanceFrame,\n *   periodInfo: ?shaka.dash.DashParser.PeriodInfo,\n *   adaptationSet: ?shaka.dash.DashParser.InheritanceFrame,\n *   representation: ?shaka.dash.DashParser.InheritanceFrame,\n *   bandwidth: number,\n *   indexRangeWarningGiven: boolean\n * }}\n *\n * @description\n * Contains context data for the streams.\n *\n * @property {boolean} dynamic\n *   True if the MPD is dynamic (not all segments available at once)\n * @property {!shaka.media.PresentationTimeline} presentationTimeline\n *   The PresentationTimeline.\n * @property {?shaka.dash.DashParser.InheritanceFrame} period\n *   The inheritance from the Period element.\n * @property {?shaka.dash.DashParser.PeriodInfo} periodInfo\n *   The Period info for the current Period.\n * @property {?shaka.dash.DashParser.InheritanceFrame} adaptationSet\n *   The inheritance from the AdaptationSet element.\n * @property {?shaka.dash.DashParser.InheritanceFrame} representation\n *   The inheritance from the Representation element.\n * @property {number} bandwidth\n *   The bandwidth of the Representation, or zero if missing.\n * @property {boolean} indexRangeWarningGiven\n *   True if the warning about SegmentURL@indexRange has been printed.\n */\nshaka.dash.DashParser.Context;\n\n\n/**\n * @typedef {{\n *   start: number,\n *   duration: ?number,\n *   node: !Element,\n *   isLastPeriod: boolean\n * }}\n *\n * @description\n * Contains information about a Period element.\n *\n * @property {number} start\n *   The start time of the period.\n * @property {?number} duration\n *   The duration of the period; or null if the duration is not given.  This\n *   will be non-null for all periods except the last.\n * @property {!Element} node\n *   The XML Node for the Period.\n * @property {boolean} isLastPeriod\n *   Whether this Period is the last one in the manifest.\n */\nshaka.dash.DashParser.PeriodInfo;\n\n\n/**\n * @typedef {{\n *   id: string,\n *   contentType: ?string,\n *   language: string,\n *   main: boolean,\n *   streams: !Array.<shaka.extern.Stream>,\n *   drmInfos: !Array.<shaka.extern.DrmInfo>,\n *   trickModeFor: ?string,\n *   representationIds: !Array.<string>\n * }}\n *\n * @description\n * Contains information about an AdaptationSet element.\n *\n * @property {string} id\n *   The unique ID of the adaptation set.\n * @property {?string} contentType\n *   The content type of the AdaptationSet.\n * @property {string} language\n *   The language of the AdaptationSet.\n * @property {boolean} main\n *   Whether the AdaptationSet has the 'main' type.\n * @property {!Array.<shaka.extern.Stream>} streams\n *   The streams this AdaptationSet contains.\n * @property {!Array.<shaka.extern.DrmInfo>} drmInfos\n *   The DRM info for the AdaptationSet.\n * @property {?string} trickModeFor\n *   If non-null, this AdaptationInfo represents trick mode tracks.  This\n *   property is the ID of the normal AdaptationSet these tracks should be\n *   associated with.\n * @property {!Array.<string>} representationIds\n *   An array of the IDs of the Representations this AdaptationSet contains.\n */\nshaka.dash.DashParser.AdaptationInfo;\n\n\n/**\n * @typedef {{\n *   createSegmentIndex: shaka.extern.CreateSegmentIndexFunction,\n *   findSegmentPosition: shaka.extern.FindSegmentPositionFunction,\n *   getSegmentReference: shaka.extern.GetSegmentReferenceFunction\n * }}\n *\n * @description\n * Contains functions used to create and find segment references.  Used as\n * a return value, to temporarily store them before StreamInfo is created.\n *\n * @property {shaka.extern.CreateSegmentIndexFunction} createSegmentIndex\n *   The createSegmentIndex function.\n * @property {shaka.extern.FindSegmentPositionFunction} findSegmentPosition\n *   The findSegmentPosition function.\n * @property {shaka.extern.GetSegmentReferenceFunction} getSegmentReference\n *   The getSegmentReference function.\n */\nshaka.dash.DashParser.SegmentIndexFunctions;\n\n\n/**\n * @typedef {{\n *   createSegmentIndex: shaka.extern.CreateSegmentIndexFunction,\n *   findSegmentPosition: shaka.extern.FindSegmentPositionFunction,\n *   getSegmentReference: shaka.extern.GetSegmentReferenceFunction,\n *   initSegmentReference: shaka.media.InitSegmentReference,\n *   scaledPresentationTimeOffset: number\n * }}\n *\n * @description\n * Contains information about a Stream.  This is passed from the createStream\n * methods.\n *\n * @property {shaka.extern.CreateSegmentIndexFunction} createSegmentIndex\n *   The createSegmentIndex function for the stream.\n * @property {shaka.extern.FindSegmentPositionFunction} findSegmentPosition\n *   The findSegmentPosition function for the stream.\n * @property {shaka.extern.GetSegmentReferenceFunction} getSegmentReference\n *   The getSegmentReference function for the stream.\n * @property {shaka.media.InitSegmentReference} initSegmentReference\n *   The init segment for the stream.\n * @property {number} scaledPresentationTimeOffset\n *   The presentation time offset for the stream, in seconds.\n */\nshaka.dash.DashParser.StreamInfo;\n\n\n/**\n * @override\n * @exportInterface\n */\nshaka.dash.DashParser.prototype.configure = function(config) {\n  goog.asserts.assert(config.dash != null,\n                      'DashManifestConfiguration should not be null!');\n\n  this.config_ = config;\n};\n\n\n/**\n * @override\n * @exportInterface\n */\nshaka.dash.DashParser.prototype.start = async function(uri, playerInterface) {\n  goog.asserts.assert(this.config_, 'Must call configure() before start()!');\n  this.manifestUris_ = [uri];\n  this.playerInterface_ = playerInterface;\n\n  const updateDelay = await this.requestManifest_();\n\n  if (this.playerInterface_) {\n    this.setUpdateTimer_(updateDelay);\n  }\n\n  // Make sure that the parser has not been destroyed.\n  if (!this.playerInterface_) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.OPERATION_ABORTED);\n  }\n\n  goog.asserts.assert(this.manifest_, 'Manifest should be non-null!');\n  return this.manifest_;\n};\n\n\n/**\n * @override\n * @exportInterface\n */\nshaka.dash.DashParser.prototype.stop = function() {\n  this.playerInterface_ = null;\n  this.config_ = null;\n  this.manifestUris_ = [];\n  this.manifest_ = null;\n  this.periodIds_ = [];\n  this.segmentIndexMap_ = {};\n\n  if (this.updateTimer_ != null) {\n    this.updateTimer_.stop();\n    this.updateTimer_ = null;\n  }\n\n  return this.operationManager_.destroy();\n};\n\n\n/**\n * @override\n * @exportInterface\n */\nshaka.dash.DashParser.prototype.update = function() {\n  this.requestManifest_().catch(function(error) {\n    if (!this.playerInterface_) return;\n    this.playerInterface_.onError(error);\n  }.bind(this));\n};\n\n\n/**\n * @override\n * @exportInterface\n */\nshaka.dash.DashParser.prototype.onExpirationUpdated = function(\n    sessionId, expiration) {\n  // No-op\n};\n\n\n/**\n * Makes a network request for the manifest and parses the resulting data.\n *\n * @return {!Promise.<number>} Resolves with the time it took, in seconds, to\n *   fulfill the request and parse the data.\n * @private\n */\nshaka.dash.DashParser.prototype.requestManifest_ = function() {\n  const requestType = shaka.net.NetworkingEngine.RequestType.MANIFEST;\n  let request = shaka.net.NetworkingEngine.makeRequest(\n      this.manifestUris_, this.config_.retryParameters);\n  let networkingEngine = this.playerInterface_.networkingEngine;\n\n  const startTime = Date.now();\n  let operation = networkingEngine.request(requestType, request);\n  this.operationManager_.manage(operation);\n\n  return operation.promise.then((response) => {\n    // Detect calls to stop().\n    if (!this.playerInterface_) {\n      return;\n    }\n\n    // For redirections add the response uri to the first entry in the\n    // Manifest Uris array.\n    if (response.uri && !this.manifestUris_.includes(response.uri)) {\n      this.manifestUris_.unshift(response.uri);\n    }\n\n    // This may throw, but it will result in a failed promise.\n    return this.parseManifest_(response.data, response.uri);\n  }).then(() => {\n    // Keep track of how long the longest manifest update took.\n    const endTime = Date.now();\n    const updateDuration = (endTime - startTime) / 1000.0;\n    this.averageUpdateDuration_.sample(1, updateDuration);\n\n    // Let the caller know how long this update took.\n    return updateDuration;\n  });\n};\n\n\n/**\n * Parses the manifest XML.  This also handles updates and will update the\n * stored manifest.\n *\n * @param {ArrayBuffer} data\n * @param {string} finalManifestUri The final manifest URI, which may\n *   differ from this.manifestUri_ if there has been a redirect.\n * @return {!Promise}\n * @throws shaka.util.Error When there is a parsing error.\n * @private\n */\nshaka.dash.DashParser.prototype.parseManifest_ =\n    function(data, finalManifestUri) {\n  const Error = shaka.util.Error;\n  const MpdUtils = shaka.dash.MpdUtils;\n\n  let mpd = shaka.util.XmlUtils.parseXml(data, 'MPD');\n  if (!mpd) {\n    throw new Error(\n        Error.Severity.CRITICAL, Error.Category.MANIFEST,\n        Error.Code.DASH_INVALID_XML, finalManifestUri);\n  }\n\n  // Process the mpd to account for xlink connections.\n  let failGracefully = this.config_.dash.xlinkFailGracefully;\n  let xlinkOperation = MpdUtils.processXlinks(\n      mpd, this.config_.retryParameters, failGracefully, finalManifestUri,\n      this.playerInterface_.networkingEngine);\n  this.operationManager_.manage(xlinkOperation);\n  return xlinkOperation.promise.then((finalMpd) => {\n    return this.processManifest_(finalMpd, finalManifestUri);\n  });\n};\n\n\n/**\n * Takes a formatted MPD and converts it into a manifest.\n *\n * @param {!Element} mpd\n * @param {string} finalManifestUri The final manifest URI, which may\n *   differ from this.manifestUri_ if there has been a redirect.\n * @return {!Promise}\n * @throws shaka.util.Error When there is a parsing error.\n * @private\n */\nshaka.dash.DashParser.prototype.processManifest_ =\n    async function(mpd, finalManifestUri) {\n  const Functional = shaka.util.Functional;\n  const XmlUtils = shaka.util.XmlUtils;\n\n  // Get any Location elements.  This will update the manifest location and\n  // the base URI.\n  /** @type {!Array.<string>} */\n  let manifestBaseUris = [finalManifestUri];\n  /** @type {!Array.<string>} */\n  let locations = XmlUtils.findChildren(mpd, 'Location')\n                      .map(XmlUtils.getContents)\n                      .filter(Functional.isNotNull);\n  if (locations.length > 0) {\n    const absoluteLocations = shaka.util.ManifestParserUtils.resolveUris(\n          manifestBaseUris, locations);\n    this.manifestUris_ = absoluteLocations;\n    manifestBaseUris = absoluteLocations;\n  }\n\n  let uris = XmlUtils.findChildren(mpd, 'BaseURL').map(XmlUtils.getContents);\n  let baseUris = shaka.util.ManifestParserUtils.resolveUris(\n      manifestBaseUris, uris);\n\n  let ignoreMinBufferTime = this.config_.dash.ignoreMinBufferTime;\n  let minBufferTime = 0;\n  if (!ignoreMinBufferTime) {\n    minBufferTime =\n      XmlUtils.parseAttr(mpd, 'minBufferTime', XmlUtils.parseDuration);\n  }\n\n  this.updatePeriod_ = /** @type {number} */ (XmlUtils.parseAttr(\n      mpd, 'minimumUpdatePeriod', XmlUtils.parseDuration, -1));\n\n  let presentationStartTime = XmlUtils.parseAttr(\n      mpd, 'availabilityStartTime', XmlUtils.parseDate);\n  let segmentAvailabilityDuration = XmlUtils.parseAttr(\n      mpd, 'timeShiftBufferDepth', XmlUtils.parseDuration);\n  let suggestedPresentationDelay = XmlUtils.parseAttr(\n      mpd, 'suggestedPresentationDelay', XmlUtils.parseDuration);\n  let maxSegmentDuration = XmlUtils.parseAttr(\n      mpd, 'maxSegmentDuration', XmlUtils.parseDuration);\n  let mpdType = mpd.getAttribute('type') || 'static';\n\n  /** @type {!shaka.media.PresentationTimeline} */\n  let presentationTimeline;\n  if (this.manifest_) {\n    presentationTimeline = this.manifest_.presentationTimeline;\n  } else {\n    // DASH IOP v3.0 suggests using a default delay between minBufferTime and\n    // timeShiftBufferDepth.  This is literally the range of all feasible\n    // choices for the value.  Nothing older than timeShiftBufferDepth is still\n    // available, and anything less than minBufferTime will cause buffering\n    // issues.\n    //\n    // We have decided that our default will be 1.5 * minBufferTime,\n    // or 10s (configurable) whichever is larger.  This is fairly conservative.\n    // Content providers should provide a suggestedPresentationDelay\n    // whenever possible to optimize the live streaming experience.\n    let defaultPresentationDelay = Math.max(\n        this.config_.dash.defaultPresentationDelay,\n        minBufferTime * 1.5);\n    let presentationDelay = suggestedPresentationDelay != null ?\n        suggestedPresentationDelay : defaultPresentationDelay;\n    presentationTimeline = new shaka.media.PresentationTimeline(\n        presentationStartTime, presentationDelay,\n        this.config_.dash.autoCorrectDrift);\n  }\n\n  /** @type {shaka.dash.DashParser.Context} */\n  let context = {\n    // Don't base on updatePeriod_ since emsg boxes can cause manifest updates.\n    dynamic: mpdType != 'static',\n    presentationTimeline: presentationTimeline,\n    period: null,\n    periodInfo: null,\n    adaptationSet: null,\n    representation: null,\n    bandwidth: 0,\n    indexRangeWarningGiven: false,\n  };\n\n  let periodsAndDuration = this.parsePeriods_(context, baseUris, mpd);\n  let duration = periodsAndDuration.duration;\n  let periods = periodsAndDuration.periods;\n\n  presentationTimeline.setStatic(mpdType == 'static');\n  if (mpdType == 'static' || !periodsAndDuration.durationDerivedFromPeriods) {\n    // Ignore duration calculated from Period lengths if this is dynamic.\n    presentationTimeline.setDuration(duration || Infinity);\n  }\n\n  let isLive = presentationTimeline.isLive();\n\n  // If it's live, we check for an override.\n  if (isLive && !isNaN(this.config_.availabilityWindowOverride)) {\n    segmentAvailabilityDuration = this.config_.availabilityWindowOverride;\n  }\n\n  // If it's null, that means segments are always available.  This is always the\n  // case for VOD, and sometimes the case for live.\n  if (segmentAvailabilityDuration == null) {\n    segmentAvailabilityDuration = Infinity;\n  }\n\n  presentationTimeline.setSegmentAvailabilityDuration(\n      segmentAvailabilityDuration);\n\n  // Use @maxSegmentDuration to override smaller, derived values.\n  presentationTimeline.notifyMaxSegmentDuration(maxSegmentDuration || 1);\n  if (goog.DEBUG) presentationTimeline.assertIsValid();\n\n  // These steps are not done on manifest update.\n  if (!this.manifest_) {\n    this.manifest_ = {\n      presentationTimeline: presentationTimeline,\n      periods: periods,\n      offlineSessionIds: [],\n      minBufferTime: minBufferTime || 0,\n    };\n\n    // We only need to do clock sync when we're using presentation start time.\n    // This condition also excludes VOD streams.\n    if (presentationTimeline.usingPresentationStartTime()) {\n      let timingElements = XmlUtils.findChildren(mpd, 'UTCTiming');\n      const offset = await this.parseUtcTiming_(baseUris, timingElements);\n      // Detect calls to stop().\n      if (!this.playerInterface_) {\n        return;\n      }\n      presentationTimeline.setClockOffset(offset);\n    }\n  }\n};\n\n\n/**\n * Reads and parses the periods from the manifest.  This first does some\n * partial parsing so the start and duration is available when parsing children.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {!Array.<string>} baseUris\n * @param {!Element} mpd\n * @return {{\n *   periods: !Array.<shaka.extern.Period>,\n *   duration: ?number,\n *   durationDerivedFromPeriods: boolean\n * }}\n * @private\n */\nshaka.dash.DashParser.prototype.parsePeriods_ = function(\n    context, baseUris, mpd) {\n  const XmlUtils = shaka.util.XmlUtils;\n  let presentationDuration = XmlUtils.parseAttr(\n      mpd, 'mediaPresentationDuration', XmlUtils.parseDuration);\n\n  let periods = [];\n  let prevEnd = 0;\n  let periodNodes = XmlUtils.findChildren(mpd, 'Period');\n  for (let i = 0; i < periodNodes.length; i++) {\n    let elem = periodNodes[i];\n    let start = /** @type {number} */ (\n        XmlUtils.parseAttr(elem, 'start', XmlUtils.parseDuration, prevEnd));\n    let givenDuration =\n        XmlUtils.parseAttr(elem, 'duration', XmlUtils.parseDuration);\n\n    let periodDuration = null;\n    if (i != periodNodes.length - 1) {\n      // \"The difference between the start time of a Period and the start time\n      // of the following Period is the duration of the media content\n      // represented by this Period.\"\n      let nextPeriod = periodNodes[i + 1];\n      let nextStart =\n          XmlUtils.parseAttr(nextPeriod, 'start', XmlUtils.parseDuration);\n      if (nextStart != null) {\n        periodDuration = nextStart - start;\n      }\n    } else if (presentationDuration != null) {\n      // \"The Period extends until the Period.start of the next Period, or\n      // until the end of the Media Presentation in the case of the last\n      // Period.\"\n      periodDuration = presentationDuration - start;\n    }\n\n    let threshold =\n        shaka.util.ManifestParserUtils.GAP_OVERLAP_TOLERANCE_SECONDS;\n    if (periodDuration && givenDuration &&\n        Math.abs(periodDuration - givenDuration) > threshold) {\n      shaka.log.warning('There is a gap/overlap between Periods', elem);\n    }\n    // Only use the @duration in the MPD if we can't calculate it.  We should\n    // favor the @start of the following Period.  This ensures that there aren't\n    // gaps between Periods.\n    if (periodDuration == null) {\n      periodDuration = givenDuration;\n    }\n\n    // Parse child nodes.\n    let info = {\n      start: start,\n      duration: periodDuration,\n      node: elem,\n      isLastPeriod: periodDuration == null || i == periodNodes.length - 1,\n    };\n    let period = this.parsePeriod_(context, baseUris, info);\n    periods.push(period);\n\n    // If the period ID is new, add it to the list.  This must be done for both\n    // the initial manifest parse and for updates.\n    // See https://github.com/google/shaka-player/issues/963\n    let periodId = context.period.id;\n    goog.asserts.assert(periodId, 'Period IDs should not be null!');\n    if (!this.periodIds_.includes(periodId)) {\n      this.periodIds_.push(periodId);\n\n      // If this is an update, call filterNewPeriod and add it to the manifest.\n      // If this is the first parse of the manifest (this.manifest_ == null),\n      // filterAllPeriods will be called later.\n      if (this.manifest_) {\n        this.playerInterface_.filterNewPeriod(period);\n        this.manifest_.periods.push(period);\n      }\n    }\n\n    if (periodDuration == null) {\n      if (i != periodNodes.length - 1) {\n        // If the duration is still null and we aren't at the end, then we will\n        // skip any remaining periods.\n        shaka.log.warning(\n            'Skipping Period', i + 1, 'and any subsequent Periods:', 'Period',\n            i + 1, 'does not have a valid start time.', periods[i + 1]);\n      }\n\n      // The duration is unknown, so the end is unknown.\n      prevEnd = null;\n      break;\n    }\n\n    prevEnd = start + periodDuration;\n  } // end of period parsing loop\n\n  // Call filterAllPeriods if this is the initial parse.\n  if (this.manifest_ == null) {\n    this.playerInterface_.filterAllPeriods(periods);\n  }\n\n  if (presentationDuration != null) {\n    if (prevEnd != presentationDuration) {\n      shaka.log.warning(\n          '@mediaPresentationDuration does not match the total duration of all',\n          'Periods.');\n      // Assume @mediaPresentationDuration is correct.\n    }\n    return {\n      periods: periods,\n      duration: presentationDuration,\n      durationDerivedFromPeriods: false,\n    };\n  } else {\n    return {\n      periods: periods,\n      duration: prevEnd,\n      durationDerivedFromPeriods: true,\n    };\n  }\n};\n\n\n/**\n * Parses a Period XML element.  Unlike the other parse methods, this is not\n * given the Node; it is given a PeriodInfo structure.  Also, partial parsing\n * was done before this was called so start and duration are valid.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {!Array.<string>} baseUris\n * @param {shaka.dash.DashParser.PeriodInfo} periodInfo\n * @return {shaka.extern.Period}\n * @throws shaka.util.Error When there is a parsing error.\n * @private\n */\nshaka.dash.DashParser.prototype.parsePeriod_ = function(\n    context, baseUris, periodInfo) {\n  const Functional = shaka.util.Functional;\n  const XmlUtils = shaka.util.XmlUtils;\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  context.period = this.createFrame_(periodInfo.node, null, baseUris);\n  context.periodInfo = periodInfo;\n\n  // If the period doesn't have an ID, give it one based on its start time.\n  if (!context.period.id) {\n    shaka.log.info(\n        'No Period ID given for Period with start time ' + periodInfo.start +\n        ',  Assigning a default');\n    context.period.id = '__shaka_period_' + periodInfo.start;\n  }\n\n  let eventStreamNodes = XmlUtils.findChildren(periodInfo.node, 'EventStream');\n  eventStreamNodes.forEach(\n      this.parseEventStream_.bind(this, periodInfo.start, periodInfo.duration));\n\n  let adaptationSetNodes =\n      XmlUtils.findChildren(periodInfo.node, 'AdaptationSet');\n  let adaptationSets = adaptationSetNodes\n      .map(this.parseAdaptationSet_.bind(this, context))\n      .filter(Functional.isNotNull);\n\n  // For dynamic manifests, we use rep IDs internally, and they must be unique.\n  if (context.dynamic) {\n    const ids = [];\n    for (const set of adaptationSets) {\n      for (const id of set.representationIds) {\n        ids.push(id);\n      }\n    }\n\n    const uniqueIds = new Set(ids);\n\n    if (ids.length != uniqueIds.size) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_DUPLICATE_REPRESENTATION_ID);\n    }\n  }\n\n  let normalAdaptationSets = adaptationSets\n      .filter(function(as) { return !as.trickModeFor; });\n\n  let trickModeAdaptationSets = adaptationSets\n      .filter(function(as) { return as.trickModeFor; });\n\n  // Attach trick mode tracks to normal tracks.\n  trickModeAdaptationSets.forEach(function(trickModeSet) {\n    // There may be multiple trick mode streams, but we do not currently\n    // support that.  Just choose one.\n    let trickModeVideo = trickModeSet.streams[0];\n    let targetId = trickModeSet.trickModeFor;\n    normalAdaptationSets.forEach(function(normalSet) {\n      if (normalSet.id == targetId) {\n        normalSet.streams.forEach(function(stream) {\n          stream.trickModeVideo = trickModeVideo;\n        });\n      }\n    });\n  });\n\n  let videoSets = this.getSetsOfType_(normalAdaptationSets, ContentType.VIDEO);\n  let audioSets = this.getSetsOfType_(normalAdaptationSets, ContentType.AUDIO);\n\n  if (!videoSets.length && !audioSets.length) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_EMPTY_PERIOD);\n  }\n\n  // In case of audio-only or video-only content, we create an array of one item\n  // containing a null.  This way, the double-loop works for all kinds of\n  // content.\n  if (!audioSets.length) {\n    audioSets = [null];\n  }\n  if (!videoSets.length) {\n    videoSets = [null];\n  }\n\n  // TODO: Limit number of combinations.  Come up with a heuristic\n  // to decide which audio tracks to combine with which video tracks.\n  let variants = [];\n  for (let i = 0; i < audioSets.length; i++) {\n    for (let j = 0; j < videoSets.length; j++) {\n      let audioSet = audioSets[i];\n      let videoSet = videoSets[j];\n      this.createVariants_(audioSet, videoSet, variants);\n    }\n  }\n\n  let textSets = this.getSetsOfType_(normalAdaptationSets, ContentType.TEXT);\n  let textStreams = [];\n  for (let i = 0; i < textSets.length; i++) {\n    textStreams.push.apply(textStreams, textSets[i].streams);\n  }\n\n  return {\n    startTime: periodInfo.start,\n    textStreams: textStreams,\n    variants: variants,\n  };\n};\n\n\n/**\n * @param {!Array.<!shaka.dash.DashParser.AdaptationInfo>} adaptationSets\n * @param {string} type\n * @return {!Array.<!shaka.dash.DashParser.AdaptationInfo>}\n * @private\n */\nshaka.dash.DashParser.prototype.getSetsOfType_ = function(\n    adaptationSets, type) {\n  return adaptationSets.filter(function(as) {\n    return as.contentType == type;\n  });\n};\n\n\n/**\n * Combines Streams into Variants\n *\n * @param {?shaka.dash.DashParser.AdaptationInfo} audio\n * @param {?shaka.dash.DashParser.AdaptationInfo} video\n * @param {!Array.<shaka.extern.Variant>} variants New variants are pushed onto\n *   this array.\n * @private\n */\nshaka.dash.DashParser.prototype.createVariants_ =\n    function(audio, video, variants) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  // Since both audio and video are of the same type, this assertion will catch\n  // certain mistakes at runtime that the compiler would miss.\n  goog.asserts.assert(!audio || audio.contentType == ContentType.AUDIO,\n                      'Audio parameter mismatch!');\n  goog.asserts.assert(!video || video.contentType == ContentType.VIDEO,\n                      'Video parameter mismatch!');\n\n  /** @type {number} */\n  let bandwidth;\n  /** @type {shaka.extern.Variant} */\n  let variant;\n\n  if (!audio && !video) {\n    return;\n  }\n\n  if (audio && video) {\n    // Audio+video variants\n    const DrmEngine = shaka.media.DrmEngine;\n    if (DrmEngine.areDrmCompatible(audio.drmInfos, video.drmInfos)) {\n      let drmInfos = DrmEngine.getCommonDrmInfos(audio.drmInfos,\n                                                 video.drmInfos);\n\n      for (let i = 0; i < audio.streams.length; i++) {\n        for (let j = 0; j < video.streams.length; j++) {\n          bandwidth =\n              (video.streams[j].bandwidth || 0) +\n              (audio.streams[i].bandwidth || 0);\n          variant = {\n            id: this.globalId_++,\n            language: audio.language,\n            primary: audio.main || video.main,\n            audio: audio.streams[i],\n            video: video.streams[j],\n            bandwidth: bandwidth,\n            drmInfos: drmInfos,\n            allowedByApplication: true,\n            allowedByKeySystem: true,\n          };\n\n          variants.push(variant);\n        }\n      }\n    }\n  } else {\n    // Audio or video only variants\n    let set = audio || video;\n    for (let i = 0; i < set.streams.length; i++) {\n      bandwidth = set.streams[i].bandwidth || 0;\n      variant = {\n        id: this.globalId_++,\n        language: set.language || 'und',\n        primary: set.main,\n        audio: audio ? set.streams[i] : null,\n        video: video ? set.streams[i] : null,\n        bandwidth: bandwidth,\n        drmInfos: set.drmInfos,\n        allowedByApplication: true,\n        allowedByKeySystem: true,\n      };\n\n      variants.push(variant);\n    }\n  }\n};\n\n\n/**\n * Parses an AdaptationSet XML element.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {!Element} elem The AdaptationSet element.\n * @return {?shaka.dash.DashParser.AdaptationInfo}\n * @throws shaka.util.Error When there is a parsing error.\n * @private\n */\nshaka.dash.DashParser.prototype.parseAdaptationSet_ = function(context, elem) {\n  const XmlUtils = shaka.util.XmlUtils;\n  const Functional = shaka.util.Functional;\n  const ManifestParserUtils = shaka.util.ManifestParserUtils;\n  const ContentType = ManifestParserUtils.ContentType;\n\n  context.adaptationSet = this.createFrame_(elem, context.period, null);\n\n  let main = false;\n  let roleElements = XmlUtils.findChildren(elem, 'Role');\n  let roleValues = roleElements.map(function(role) {\n    return role.getAttribute('value');\n  }).filter(Functional.isNotNull);\n\n  // Default kind for text streams is 'subtitle' if unspecified in the manifest.\n  let kind = undefined;\n  const isText =\n      context.adaptationSet.contentType == ManifestParserUtils.ContentType.TEXT;\n  if (isText) {\n    kind = ManifestParserUtils.TextStreamKind.SUBTITLE;\n  }\n\n  for (let i = 0; i < roleElements.length; i++) {\n    let scheme = roleElements[i].getAttribute('schemeIdUri');\n    if (scheme == null || scheme == 'urn:mpeg:dash:role:2011') {\n      // These only apply for the given scheme, but allow them to be specified\n      // if there is no scheme specified.\n      // See: DASH section 5.8.5.5\n      let value = roleElements[i].getAttribute('value');\n      switch (value) {\n        case 'main':\n          main = true;\n          break;\n        case 'caption':\n        case 'subtitle':\n          kind = value;\n          break;\n      }\n    }\n  }\n\n  let essentialProperties = XmlUtils.findChildren(elem, 'EssentialProperty');\n  // ID of real AdaptationSet if this is a trick mode set:\n  let trickModeFor = null;\n  let unrecognizedEssentialProperty = false;\n  essentialProperties.forEach(function(prop) {\n    let schemeId = prop.getAttribute('schemeIdUri');\n    if (schemeId == 'http://dashif.org/guidelines/trickmode') {\n      trickModeFor = prop.getAttribute('value');\n    } else {\n      unrecognizedEssentialProperty = true;\n    }\n  });\n\n  const accessibilities = XmlUtils.findChildren(elem, 'Accessibility');\n  const LanguageUtils = shaka.util.LanguageUtils;\n  let closedCaptions = new Map();\n  for (const prop of accessibilities) {\n    let schemeId = prop.getAttribute('schemeIdUri');\n    if (schemeId == 'urn:scte:dash:cc:cea-608:2015' ||\n        schemeId == 'urn:scte:dash:cc:cea-708:2015') {\n      let channelId = 1;\n      let closedCaptionsValue = prop.getAttribute('value');\n      if (closedCaptionsValue != null) {\n        closedCaptionsValue.split(';').forEach((captionStr) => {\n          let channel;\n          let language;\n          // Some closed caption descriptions have channel number and language,\n          // like \"CC1=eng\" or \"1=lang:eng\", others may only have the language,\n          // like \"eng\".\n          if (!captionStr.includes('=')) {\n            // Since only odd numbers are used as channel numbers, like CC1,\n            // CC3, CC5, etc, when the channel number is not provided, use an\n            // odd number as the key. https://en.wikipedia.org/wiki/EIA-608\n            channel = 'CC' + channelId;\n            channelId += 2;\n            language = captionStr;\n          } else {\n            const channelAndLanguage = captionStr.split('=');\n            // The channel info can be '1' or 'CC1'.\n            // If the channel info only has channel number(like '1'), add 'CC'\n            // as prefix so that it can be a full channel id (like 'CC1').\n            channel = channelAndLanguage[0].startsWith('CC') ?\n                channelAndLanguage[0] : 'CC' + channelAndLanguage[0];\n            // The language info can be different formats, like 'eng',\n            // 'lang:eng', or 'lang:eng,war:1,er:1'. Extract the language info\n            // and convert it to 2-letter language code format.\n            language = channelAndLanguage[1].split(',')[0].split(':').pop();\n          }\n          closedCaptions.set(channel, LanguageUtils.normalize(language));\n        });\n      } else {\n        // If channel and language information has not been provided, assign\n        // 'CC1' as channel id and 'und' as language info.\n        closedCaptions.set('CC1', 'und');\n      }\n    }\n  }\n\n  // According to DASH spec (2014) section 5.8.4.8, \"the successful processing\n  // of the descriptor is essential to properly use the information in the\n  // parent element\".  According to DASH IOP v3.3, section 3.3.4, \"if the scheme\n  // or the value\" for EssentialProperty is not recognized, \"the DASH client\n  // shall ignore the parent element.\"\n  if (unrecognizedEssentialProperty) {\n    // Stop parsing this AdaptationSet and let the caller filter out the nulls.\n    return null;\n  }\n\n  let contentProtectionElems = XmlUtils.findChildren(elem, 'ContentProtection');\n  let contentProtection = shaka.dash.ContentProtection.parseFromAdaptationSet(\n      contentProtectionElems, this.config_.dash.customScheme,\n      this.config_.dash.ignoreDrmInfo);\n\n  let language =\n      shaka.util.LanguageUtils.normalize(elem.getAttribute('lang') || 'und');\n\n  // This attribute is currently non-standard, but it is supported by Kaltura.\n  let label = elem.getAttribute('label');\n\n  // Parse Representations into Streams.\n  let representations = XmlUtils.findChildren(elem, 'Representation');\n  let streams = representations\n      .map(this.parseRepresentation_.bind(this, context, contentProtection,\n          kind, language, label, main, roleValues, closedCaptions))\n      .filter(function(s) { return !!s; });\n\n  if (streams.length == 0) {\n    // Ignore empty AdaptationSets if they are for text content.\n    if (isText) {\n      return null;\n    }\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_EMPTY_ADAPTATION_SET);\n  }\n\n  // If AdaptationSet's type is unknown or is ambiguously \"application\",\n  // guess based on the information in the first stream.  If the attributes\n  // mimeType and codecs are split across levels, they will both be inherited\n  // down to the stream level by this point, so the stream will have all the\n  // necessary information.\n  if (!context.adaptationSet.contentType ||\n      context.adaptationSet.contentType == ContentType.APPLICATION) {\n    let mimeType = streams[0].mimeType;\n    let codecs = streams[0].codecs;\n    context.adaptationSet.contentType =\n        shaka.dash.DashParser.guessContentType_(mimeType, codecs);\n\n    streams.forEach(function(stream) {\n      stream.type = context.adaptationSet.contentType;\n    });\n  }\n\n  streams.forEach(function(stream) {\n    // Some DRM license providers require that we have a default\n    // key ID from the manifest in the wrapped license request.\n    // Thus, it should be put in drmInfo to be accessible to request filters.\n    contentProtection.drmInfos.forEach(function(drmInfo) {\n      if (stream.keyId) {\n        drmInfo.keyIds.push(stream.keyId);\n      }\n    });\n  });\n\n  let repIds = representations\n      .map(function(node) { return node.getAttribute('id'); })\n      .filter(shaka.util.Functional.isNotNull);\n\n  return {\n    id: context.adaptationSet.id || ('__fake__' + this.globalId_++),\n    contentType: context.adaptationSet.contentType,\n    language: language,\n    main: main,\n    streams: streams,\n    drmInfos: contentProtection.drmInfos,\n    trickModeFor: trickModeFor,\n    representationIds: repIds,\n  };\n};\n\n\n/**\n * Parses a Representation XML element.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.ContentProtection.Context} contentProtection\n * @param {(string|undefined)} kind\n * @param {string} language\n * @param {string} label\n * @param {boolean} isPrimary\n * @param {!Array.<string>} roles\n * @param {Map.<string, string>} closedCaptions\n * @param {!Element} node\n * @return {?shaka.extern.Stream} The Stream, or null when there is a\n *   non-critical parsing error.\n * @throws shaka.util.Error When there is a parsing error.\n * @private\n */\nshaka.dash.DashParser.prototype.parseRepresentation_ = function(\n    context, contentProtection, kind, language, label, isPrimary, roles,\n    closedCaptions, node) {\n  const XmlUtils = shaka.util.XmlUtils;\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  context.representation = this.createFrame_(node, context.adaptationSet, null);\n  if (!this.verifyRepresentation_(context.representation)) {\n    shaka.log.warning('Skipping Representation', context.representation);\n    return null;\n  }\n\n  // NOTE: bandwidth is a mandatory attribute according to the spec, and zero\n  // does not make sense in the DASH spec's bandwidth formulas.\n  // In some content, however, the attribute is missing or zero.\n  // To avoid NaN at the variant level on broken content, fall back to zero.\n  // https://github.com/google/shaka-player/issues/938#issuecomment-317278180\n  context.bandwidth =\n      XmlUtils.parseAttr(node, 'bandwidth', XmlUtils.parsePositiveInt) || 0;\n\n  /** @type {?shaka.dash.DashParser.StreamInfo} */\n  let streamInfo;\n\n  const contentType = context.representation.contentType;\n  const isText = contentType == ContentType.TEXT ||\n                 contentType == ContentType.APPLICATION;\n\n  try {\n    const requestInitSegment = this.requestInitSegment_.bind(this);\n    if (context.representation.segmentBase) {\n      streamInfo = shaka.dash.SegmentBase.createStream(\n          context, requestInitSegment);\n    } else if (context.representation.segmentList) {\n      streamInfo = shaka.dash.SegmentList.createStream(\n          context, this.segmentIndexMap_);\n    } else if (context.representation.segmentTemplate) {\n      streamInfo = shaka.dash.SegmentTemplate.createStream(\n          context, requestInitSegment, this.segmentIndexMap_, !!this.manifest_);\n    } else {\n      goog.asserts.assert(isText,\n          'Must have Segment* with non-text streams.');\n\n      let baseUris = context.representation.baseUris;\n      let duration = context.periodInfo.duration || 0;\n      streamInfo = {\n        createSegmentIndex: Promise.resolve.bind(Promise),\n        findSegmentPosition:\n            /** @return {?number} */ function(/** number */ time) {\n              if (time >= 0 && time < duration) {\n                return 1;\n              } else {\n                return null;\n              }\n            },\n        getSegmentReference:\n            /** @return {shaka.media.SegmentReference} */\n            function(/** number */ ref) {\n              if (ref != 1) {\n                return null;\n              }\n\n              return new shaka.media.SegmentReference(\n                  1, 0, duration, function() { return baseUris; }, 0, null);\n            },\n        initSegmentReference: null,\n        scaledPresentationTimeOffset: 0,\n      };\n    }\n  } catch (error) {\n    if (isText && error.code == shaka.util.Error.Code.DASH_NO_SEGMENT_INFO) {\n      // We will ignore any DASH_NO_SEGMENT_INFO errors for text streams.\n      return null;\n    }\n\n    // For anything else, re-throw.\n    throw error;\n  }\n\n  let contentProtectionElems = XmlUtils.findChildren(node, 'ContentProtection');\n  let keyId = shaka.dash.ContentProtection.parseFromRepresentation(\n      contentProtectionElems, this.config_.dash.customScheme,\n      contentProtection, this.config_.dash.ignoreDrmInfo);\n\n  return {\n    id: this.globalId_++,\n    originalId: context.representation.id,\n    createSegmentIndex: streamInfo.createSegmentIndex,\n    findSegmentPosition: streamInfo.findSegmentPosition,\n    getSegmentReference: streamInfo.getSegmentReference,\n    initSegmentReference: streamInfo.initSegmentReference,\n    presentationTimeOffset: streamInfo.scaledPresentationTimeOffset,\n    mimeType: context.representation.mimeType,\n    codecs: context.representation.codecs,\n    frameRate: context.representation.frameRate,\n    bandwidth: context.bandwidth,\n    width: context.representation.width,\n    height: context.representation.height,\n    kind: kind,\n    encrypted: contentProtection.drmInfos.length > 0,\n    keyId: keyId,\n    language: language,\n    label: label,\n    type: context.adaptationSet.contentType,\n    primary: isPrimary,\n    trickModeVideo: null,\n    emsgSchemeIdUris:\n        context.representation.emsgSchemeIdUris,\n    roles: roles,\n    channelsCount: context.representation.numChannels,\n    closedCaptions: closedCaptions,\n  };\n};\n\n\n/**\n * Called when the update timer ticks.\n *\n * @return {!Promise}\n * @private\n */\nshaka.dash.DashParser.prototype.onUpdate_ = async function() {\n  goog.asserts.assert(this.updatePeriod_ >= 0,\n                      'There should be an update period');\n\n  shaka.log.info('Updating manifest...');\n\n  // Default the update delay to 0 seconds so that if there is an error we can\n  // try again right away.\n  let updateDelay = 0;\n\n  try {\n    updateDelay = await this.requestManifest_();\n  } catch (error) {\n    goog.asserts.assert(error instanceof shaka.util.Error,\n                        'Should only receive a Shaka error');\n\n    // Try updating again, but ensure we haven't been destroyed.\n    if (this.playerInterface_) {\n      // We will retry updating, so override the severity of the error.\n      error.severity = shaka.util.Error.Severity.RECOVERABLE;\n      this.playerInterface_.onError(error);\n    }\n  }\n\n  // Detect a call to stop()\n  if (!this.playerInterface_) {\n    return;\n  }\n\n  this.setUpdateTimer_(updateDelay);\n};\n\n\n/**\n * Sets the update timer.  Does nothing if the manifest does not specify an\n * update period.\n *\n * @param {number} offset An offset, in seconds, to apply to the manifest's\n *   update period.\n * @private\n */\nshaka.dash.DashParser.prototype.setUpdateTimer_ = function(offset) {\n  // NOTE: An updatePeriod_ of -1 means the attribute was missing.\n  // An attribute which is present and set to 0 should still result in periodic\n  // updates.  For more, see: https://github.com/google/shaka-player/issues/331\n  if (this.updatePeriod_ < 0) {\n    return;\n  }\n\n  const finalDelay = Math.max(\n      shaka.dash.DashParser.MIN_UPDATE_PERIOD_,\n      this.updatePeriod_ - offset,\n      this.averageUpdateDuration_.getEstimate());\n\n  // We do not run the timer as repeating because part of update is async and we\n  // need schedule the update after it finished.\n  this.updateTimer_.tickAfter(/* seconds= */ finalDelay);\n};\n\n\n/**\n * Creates a new inheritance frame for the given element.\n *\n * @param {!Element} elem\n * @param {?shaka.dash.DashParser.InheritanceFrame} parent\n * @param {Array.<string>} baseUris\n * @return {shaka.dash.DashParser.InheritanceFrame}\n * @private\n */\nshaka.dash.DashParser.prototype.createFrame_ = function(\n    elem, parent, baseUris) {\n  goog.asserts.assert(parent || baseUris,\n                      'Must provide either parent or baseUris');\n  const ManifestParserUtils = shaka.util.ManifestParserUtils;\n  const XmlUtils = shaka.util.XmlUtils;\n  parent = parent || /** @type {shaka.dash.DashParser.InheritanceFrame} */ ({\n    contentType: '',\n    mimeType: '',\n    codecs: '',\n    emsgSchemeIdUris: [],\n    frameRate: undefined,\n    numChannels: null,\n  });\n  baseUris = baseUris || parent.baseUris;\n\n  let parseNumber = XmlUtils.parseNonNegativeInt;\n  let evalDivision = XmlUtils.evalDivision;\n  let uris = XmlUtils.findChildren(elem, 'BaseURL').map(XmlUtils.getContents);\n\n  let contentType = elem.getAttribute('contentType') || parent.contentType;\n  let mimeType = elem.getAttribute('mimeType') || parent.mimeType;\n  let codecs = elem.getAttribute('codecs') || parent.codecs;\n  let frameRate =\n      XmlUtils.parseAttr(elem, 'frameRate', evalDivision) || parent.frameRate;\n  let emsgSchemeIdUris = this.emsgSchemeIdUris_(\n      XmlUtils.findChildren(elem, 'InbandEventStream'),\n      parent.emsgSchemeIdUris);\n  let audioChannelConfigs =\n      XmlUtils.findChildren(elem, 'AudioChannelConfiguration');\n  let numChannels =\n      this.parseAudioChannels_(audioChannelConfigs) || parent.numChannels;\n\n  if (!contentType) {\n    contentType = shaka.dash.DashParser.guessContentType_(mimeType, codecs);\n  }\n\n  return {\n    baseUris: ManifestParserUtils.resolveUris(baseUris, uris),\n    segmentBase: XmlUtils.findChild(elem, 'SegmentBase') || parent.segmentBase,\n    segmentList: XmlUtils.findChild(elem, 'SegmentList') || parent.segmentList,\n    segmentTemplate:\n        XmlUtils.findChild(elem, 'SegmentTemplate') || parent.segmentTemplate,\n    width: XmlUtils.parseAttr(elem, 'width', parseNumber) || parent.width,\n    height: XmlUtils.parseAttr(elem, 'height', parseNumber) || parent.height,\n    contentType: contentType,\n    mimeType: mimeType,\n    codecs: codecs,\n    frameRate: frameRate,\n    emsgSchemeIdUris: emsgSchemeIdUris,\n    id: elem.getAttribute('id'),\n    numChannels: numChannels,\n  };\n};\n\n/**\n * Returns a new array of InbandEventStream schemeIdUri containing the union of\n * the ones parsed from inBandEventStreams and the ones provided in\n * emsgSchemeIdUris.\n *\n * @param {!Array.<!Element>} inBandEventStreams Array of InbandEventStream\n *     elements to parse and add to the returned array.\n * @param {!Array.<string>} emsgSchemeIdUris Array of parsed\n *     InbandEventStream schemeIdUri attributes to add to the returned array.\n * @return {!Array.<string>} schemeIdUris Array of parsed\n *     InbandEventStream schemeIdUri attributes.\n * @private\n */\nshaka.dash.DashParser.prototype.emsgSchemeIdUris_ = function(\n    inBandEventStreams, emsgSchemeIdUris) {\n  let schemeIdUris = emsgSchemeIdUris.slice();\n  for (let event of inBandEventStreams) {\n    let schemeIdUri = event.getAttribute('schemeIdUri');\n    if (!schemeIdUris.includes(schemeIdUri)) {\n      schemeIdUris.push(schemeIdUri);\n    }\n  }\n  return schemeIdUris;\n};\n\n/**\n * @param {!Array.<!Element>} audioChannelConfigs An array of\n *   AudioChannelConfiguration elements.\n * @return {?number} The number of audio channels, or null if unknown.\n * @private\n */\nshaka.dash.DashParser.prototype.parseAudioChannels_ =\n    function(audioChannelConfigs) {\n  for (let i = 0; i < audioChannelConfigs.length; ++i) {\n    let elem = audioChannelConfigs[i];\n\n    let scheme = elem.getAttribute('schemeIdUri');\n    if (!scheme) continue;\n\n    let value = elem.getAttribute('value');\n    if (!value) continue;\n\n    switch (scheme) {\n      case 'urn:mpeg:dash:outputChannelPositionList:2012':\n        // A space-separated list of speaker positions, so the number of\n        // channels is the length of this list.\n        return value.trim().split(/ +/).length;\n\n      case 'urn:mpeg:dash:23003:3:audio_channel_configuration:2011':\n      case 'urn:dts:dash:audio_channel_configuration:2012': {\n        // As far as we can tell, this is a number of channels.\n        let intValue = parseInt(value, 10);\n        if (!intValue) {  // 0 or NaN\n          shaka.log.warning('Channel parsing failure! ' +\n                            'Ignoring scheme and value', scheme, value);\n          continue;\n        }\n        return intValue;\n      }\n\n      case 'tag:dolby.com,2014:dash:audio_channel_configuration:2011':\n      case 'urn:dolby:dash:audio_channel_configuration:2011': {\n        // A hex-encoded 16-bit integer, in which each bit represents a channel.\n        let hexValue = parseInt(value, 16);\n        if (!hexValue) {  // 0 or NaN\n          shaka.log.warning('Channel parsing failure! ' +\n                            'Ignoring scheme and value', scheme, value);\n          continue;\n        }\n        // Count the 1-bits in hexValue.\n        let numBits = 0;\n        while (hexValue) {\n          if (hexValue & 1) ++numBits;\n          hexValue >>= 1;\n        }\n        return numBits;\n      }\n\n      default:\n        shaka.log.warning('Unrecognized audio channel scheme:', scheme, value);\n        continue;\n    }\n  }\n\n  return null;\n};\n\n\n/**\n * Verifies that a Representation has exactly one Segment* element.  Prints\n * warnings if there is a problem.\n *\n * @param {shaka.dash.DashParser.InheritanceFrame} frame\n * @return {boolean} True if the Representation is usable; otherwise return\n *   false.\n * @private\n */\nshaka.dash.DashParser.prototype.verifyRepresentation_ = function(frame) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  let n = 0;\n  n += frame.segmentBase ? 1 : 0;\n  n += frame.segmentList ? 1 : 0;\n  n += frame.segmentTemplate ? 1 : 0;\n\n  if (n == 0) {\n    // TODO: Extend with the list of MIME types registered to TextEngine.\n    if (frame.contentType == ContentType.TEXT ||\n        frame.contentType == ContentType.APPLICATION) {\n      return true;\n    } else {\n      shaka.log.warning(\n          'Representation does not contain a segment information source:',\n          'the Representation must contain one of SegmentBase, SegmentList,',\n          'SegmentTemplate, or explicitly indicate that it is \"text\".',\n          frame);\n      return false;\n    }\n  }\n\n  if (n != 1) {\n    shaka.log.warning(\n        'Representation contains multiple segment information sources:',\n        'the Representation should only contain one of SegmentBase,',\n        'SegmentList, or SegmentTemplate.',\n        frame);\n    if (frame.segmentBase) {\n      shaka.log.info('Using SegmentBase by default.');\n      frame.segmentList = null;\n      frame.segmentTemplate = null;\n    } else {\n      goog.asserts.assert(frame.segmentList, 'There should be a SegmentList');\n      shaka.log.info('Using SegmentList by default.');\n      frame.segmentTemplate = null;\n    }\n  }\n\n  return true;\n};\n\n\n/**\n * Makes a request to the given URI and calculates the clock offset.\n *\n * @param {!Array.<string>} baseUris\n * @param {string} uri\n * @param {string} method\n * @return {!Promise.<number>}\n * @private\n */\nshaka.dash.DashParser.prototype.requestForTiming_ =\n    function(baseUris, uri, method) {\n  let requestUris = shaka.util.ManifestParserUtils.resolveUris(baseUris, [uri]);\n  let request = shaka.net.NetworkingEngine.makeRequest(\n      requestUris, this.config_.retryParameters);\n  request.method = method;\n  const type = shaka.net.NetworkingEngine.RequestType.TIMING;\n\n  let operation = this.playerInterface_.networkingEngine.request(type, request);\n  this.operationManager_.manage(operation);\n\n  return operation.promise.then((response) => {\n    let text;\n    if (method == 'HEAD') {\n      if (!response.headers || !response.headers['date']) {\n        shaka.log.warning('UTC timing response is missing',\n                          'expected date header');\n        return 0;\n      }\n      text = response.headers['date'];\n    } else {\n      text = shaka.util.StringUtils.fromUTF8(response.data);\n    }\n    let date = Date.parse(text);\n    if (isNaN(date)) {\n      shaka.log.warning('Unable to parse date from UTC timing response');\n      return 0;\n    }\n    return (date - Date.now());\n  });\n};\n\n\n/**\n * Parses an array of UTCTiming elements.\n *\n * @param {!Array.<string>} baseUris\n * @param {!Array.<!Element>} elems\n * @return {!Promise.<number>}\n * @private\n */\nshaka.dash.DashParser.prototype.parseUtcTiming_ = function(baseUris, elems) {\n  let schemesAndValues = elems.map(function(elem) {\n    return {\n      scheme: elem.getAttribute('schemeIdUri'),\n      value: elem.getAttribute('value'),\n    };\n  });\n\n  // If there's nothing specified in the manifest, but we have a default from\n  // the config, use that.\n  let clockSyncUri = this.config_.dash.clockSyncUri;\n  if (!schemesAndValues.length && clockSyncUri) {\n    schemesAndValues.push({\n      scheme: 'urn:mpeg:dash:utc:http-head:2014',\n      value: clockSyncUri,\n    });\n  }\n\n  const Functional = shaka.util.Functional;\n  return Functional.createFallbackPromiseChain(schemesAndValues, function(sv) {\n    let scheme = sv.scheme;\n    let value = sv.value;\n    switch (scheme) {\n      // See DASH IOP Guidelines Section 4.7\n      // https://bit.ly/DashIop3-2\n      // Some old ISO23009-1 drafts used 2012.\n      case 'urn:mpeg:dash:utc:http-head:2014':\n      case 'urn:mpeg:dash:utc:http-head:2012':\n        return this.requestForTiming_(baseUris, value, 'HEAD');\n      case 'urn:mpeg:dash:utc:http-xsdate:2014':\n      case 'urn:mpeg:dash:utc:http-iso:2014':\n      case 'urn:mpeg:dash:utc:http-xsdate:2012':\n      case 'urn:mpeg:dash:utc:http-iso:2012':\n        return this.requestForTiming_(baseUris, value, 'GET');\n      case 'urn:mpeg:dash:utc:direct:2014':\n      case 'urn:mpeg:dash:utc:direct:2012': {\n        let date = Date.parse(value);\n        return isNaN(date) ? 0 : (date - Date.now());\n      }\n\n      case 'urn:mpeg:dash:utc:http-ntp:2014':\n      case 'urn:mpeg:dash:utc:ntp:2014':\n      case 'urn:mpeg:dash:utc:sntp:2014':\n        shaka.log.alwaysWarn('NTP UTCTiming scheme is not supported');\n        return Promise.reject();\n      default:\n        shaka.log.alwaysWarn(\n            'Unrecognized scheme in UTCTiming element', scheme);\n        return Promise.reject();\n    }\n  }.bind(this)).catch(function() {\n    shaka.log.alwaysWarn(\n        'A UTCTiming element should always be given in live manifests! ' +\n        'This content may not play on clients with bad clocks!');\n    return 0;\n  });\n};\n\n\n/**\n * Parses an EventStream element.\n *\n * @param {number} periodStart\n * @param {?number} periodDuration\n * @param {!Element} elem\n * @private\n */\nshaka.dash.DashParser.prototype.parseEventStream_ = function(\n    periodStart, periodDuration, elem) {\n  const XmlUtils = shaka.util.XmlUtils;\n  let parseNumber = XmlUtils.parseNonNegativeInt;\n\n  let schemeIdUri = elem.getAttribute('schemeIdUri') || '';\n  let value = elem.getAttribute('value') || '';\n  let timescale = XmlUtils.parseAttr(elem, 'timescale', parseNumber) || 1;\n\n  XmlUtils.findChildren(elem, 'Event').forEach(function(eventNode) {\n    let presentationTime =\n        XmlUtils.parseAttr(eventNode, 'presentationTime', parseNumber) || 0;\n    let duration = XmlUtils.parseAttr(eventNode, 'duration', parseNumber) || 0;\n\n    let startTime = presentationTime / timescale + periodStart;\n    let endTime = startTime + (duration / timescale);\n    if (periodDuration != null) {\n      // An event should not go past the Period, even if the manifest says so.\n      // See: Dash sec. 5.10.2.1\n      startTime = Math.min(startTime, periodStart + periodDuration);\n      endTime = Math.min(endTime, periodStart + periodDuration);\n    }\n\n    /** @type {shaka.extern.TimelineRegionInfo} */\n    let region = {\n      schemeIdUri: schemeIdUri,\n      value: value,\n      startTime: startTime,\n      endTime: endTime,\n      id: eventNode.getAttribute('id') || '',\n      eventElement: eventNode,\n    };\n\n    this.playerInterface_.onTimelineRegionAdded(region);\n  }.bind(this));\n};\n\n\n/**\n * Makes a network request on behalf of SegmentBase.createStream.\n *\n * @param {!Array.<string>} uris\n * @param {?number} startByte\n * @param {?number} endByte\n * @return {!Promise.<!ArrayBuffer>}\n * @private\n */\nshaka.dash.DashParser.prototype.requestInitSegment_ = function(\n    uris, startByte, endByte) {\n  const requestType = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n  const request = shaka.util.Networking.createSegmentRequest(\n      uris,\n      startByte,\n      endByte,\n      this.config_.retryParameters);\n\n  let networkingEngine = this.playerInterface_.networkingEngine;\n  let operation = networkingEngine.request(requestType, request);\n  this.operationManager_.manage(operation);\n  return operation.promise.then((response) => response.data);\n};\n\n\n/**\n * Guess the content type based on MIME type and codecs.\n *\n * @param {string} mimeType\n * @param {string} codecs\n * @return {string}\n * @private\n */\nshaka.dash.DashParser.guessContentType_ = function(mimeType, codecs) {\n  let fullMimeType = shaka.util.MimeUtils.getFullType(mimeType, codecs);\n\n  if (shaka.text.TextEngine.isTypeSupported(fullMimeType)) {\n    // If it's supported by TextEngine, it's definitely text.\n    // We don't check MediaSourceEngine, because that would report support\n    // for platform-supported video and audio types as well.\n    return shaka.util.ManifestParserUtils.ContentType.TEXT;\n  }\n\n  // Otherwise, just split the MIME type.  This handles video and audio\n  // types well.\n  return mimeType.split('/')[0];\n};\n\n\nshaka.media.ManifestParser.registerParserByExtension(\n    'mpd', shaka.dash.DashParser);\nshaka.media.ManifestParser.registerParserByMime(\n    'application/dash+xml', shaka.dash.DashParser);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.hls.Attribute');\ngoog.provide('shaka.hls.Playlist');\ngoog.provide('shaka.hls.PlaylistType');\ngoog.provide('shaka.hls.Segment');\ngoog.provide('shaka.hls.Tag');\n\ngoog.require('goog.asserts');\n\n\n/**\n * Creates an HLS playlist object.\n *\n * @param {string} absoluteUri An absolute, final URI after redirects.\n * @param {!shaka.hls.PlaylistType} type\n * @param {!Array.<shaka.hls.Tag>} tags\n * @param {!Array.<shaka.hls.Segment>=} segments\n *\n * @constructor\n * @struct\n */\nshaka.hls.Playlist = function(absoluteUri, type, tags, segments) {\n  /**\n   * An absolute, final URI after redirects.\n   *\n   * @const {string}\n   */\n  this.absoluteUri = absoluteUri;\n\n  /** @const {shaka.hls.PlaylistType} */\n  this.type = type;\n\n  /** @const {!Array.<!shaka.hls.Tag>} */\n  this.tags = tags;\n\n  /** @const {Array.<!shaka.hls.Segment>} */\n  this.segments = segments || null;\n};\n\n\n/**\n * @enum {number}\n */\nshaka.hls.PlaylistType = {\n  MASTER: 0,\n  MEDIA: 1,\n};\n\n\n/**\n * Creates an HLS tag object.\n *\n * @param {number} id\n * @param {string} name\n * @param {!Array.<shaka.hls.Attribute>} attributes\n * @param {?string=} value\n *\n * @constructor\n * @struct\n */\nshaka.hls.Tag = function(id, name, attributes, value = null) {\n  /** @const {number} */\n  this.id = id;\n\n  /** @const {string} */\n  this.name = name;\n\n  /** @const {Array.<shaka.hls.Attribute>} */\n  this.attributes = attributes;\n\n  /** @const {?string} */\n  this.value = value;\n};\n\n\n/**\n * Create the string representation of the tag.\n *\n * For the DRM system - the full tag needs to be passed down to the CDM.  There\n * are two ways of doing this (1) save the original tag or (2) recreate the tag.\n * As in some cases (like in tests) the tag never existed in string form, it\n * is far easier to recreate the tag from the parsed form.\n *\n * @return {string}\n * @override\n */\nshaka.hls.Tag.prototype.toString = function() {\n  /**\n   * @param {shaka.hls.Attribute} attr\n   * @return {string}\n   */\n  let attrToStr = function(attr) {\n    const isNumericAttr = !isNaN(Number(attr.value));\n\n    const value = (isNumericAttr ? attr.value : '\"' + attr.value + '\"');\n\n    return attr.name + '=' + value;\n  };\n\n\n  // A valid tag can only follow 1 of 4 patterns.\n  //  1) <NAME>:<VALUE>\n  //  2) <NAME>:<ATTRIBUTE LIST>\n  //  3) <NAME>\n  //  4) <NAME>:<VALUE>,<ATTRIBUTE_LIST>\n\n  let tagStr = '#' + this.name;\n  const appendages = this.attributes ? this.attributes.map(attrToStr) : [];\n\n  if (this.value) {\n    appendages.unshift(this.value);\n  }\n\n  if (appendages.length > 0) {\n    tagStr += ':' + appendages.join(',');\n  }\n\n  return tagStr;\n};\n\n\n/**\n * Creates an HLS attribute object.\n *\n * @param {string} name\n * @param {string} value\n *\n * @constructor\n * @struct\n */\nshaka.hls.Attribute = function(name, value) {\n  /** @const {string} */\n  this.name = name;\n\n  /** @const {string} */\n  this.value = value;\n};\n\n\n/**\n * Adds an attribute to an HLS Tag.\n *\n * @param {!shaka.hls.Attribute} attribute\n */\nshaka.hls.Tag.prototype.addAttribute = function(attribute) {\n  this.attributes.push(attribute);\n};\n\n\n/**\n * Gets the first attribute of the tag with a specified name.\n *\n * @param {string} name\n * @return {?shaka.hls.Attribute} attribute\n */\nshaka.hls.Tag.prototype.getAttribute = function(name) {\n  let attributes = this.attributes.filter(function(attr) {\n    return attr.name == name;\n  });\n\n  goog.asserts.assert(attributes.length < 2,\n                      'A tag should not have multiple attributes ' +\n                      'with the same name!');\n\n  if (attributes.length) {\n    return attributes[0];\n  } else {\n    return null;\n  }\n};\n\n\n/**\n * Gets the value of the first attribute of the tag with a specified name.\n * If not found, returns an optional default value.\n *\n * @param {string} name\n * @param {string=} defaultValue\n * @return {?string}\n */\nshaka.hls.Tag.prototype.getAttributeValue = function(name, defaultValue) {\n  let attribute = this.getAttribute(name);\n  return attribute ? attribute.value : (defaultValue || null);\n};\n\n\n/**\n * Creates an HLS segment object.\n *\n * @param {string} absoluteUri An absolute URI.\n * @param {!Array.<shaka.hls.Tag>} tags\n *\n * @constructor\n * @struct\n */\nshaka.hls.Segment = function(absoluteUri, tags) {\n  /** @const {!Array.<shaka.hls.Tag>} */\n  this.tags = tags;\n\n  /**\n   * An absolute URI.\n   *\n   * @const {string}\n   */\n  this.absoluteUri = absoluteUri;\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.hls.Utils');\n\ngoog.require('shaka.util.ManifestParserUtils');\n\n\n/**\n *\n * @param {!Array.<!shaka.hls.Tag>} tags\n * @param {string} name\n * @return {!Array.<!shaka.hls.Tag>}\n */\nshaka.hls.Utils.filterTagsByName = function(tags, name) {\n  return tags.filter(function(tag) {\n    return tag.name == name;\n  });\n};\n\n\n/**\n *\n * @param {!Array.<!shaka.hls.Tag>} tags\n * @param {string} name\n * @return {?shaka.hls.Tag}\n */\nshaka.hls.Utils.getFirstTagWithName = function(tags, name) {\n  let tagsWithName = shaka.hls.Utils.filterTagsByName(tags, name);\n  if (!tagsWithName.length) return null;\n\n  return tagsWithName[0];\n};\n\n\n/**\n * @param {!Array.<!shaka.hls.Tag>} tags An array of EXT-X-MEDIA tags.\n * @param {string} type\n * @param {string} groupId\n * @return {!Array.<!shaka.hls.Tag>} The first tag that has the given media type\n *   and group id.\n */\nshaka.hls.Utils.findMediaTags = function(tags, type, groupId) {\n  return tags.filter(function(tag) {\n    let typeAttr = tag.getAttribute('TYPE');\n    let groupIdAttr = tag.getAttribute('GROUP-ID');\n    return typeAttr.value == type && groupIdAttr.value == groupId;\n  });\n};\n\n\n/**\n * @param {string} parentAbsoluteUri\n * @param {string} uri\n * @return {string}\n */\nshaka.hls.Utils.constructAbsoluteUri = function(parentAbsoluteUri, uri) {\n  let uris = shaka.util.ManifestParserUtils.resolveUris(\n      [parentAbsoluteUri], [uri]);\n\n  return uris[0];\n};\n\n\n/**\n * Matches a string to an HLS comment format and returns the result.\n *\n * @param {string} line\n * @return {boolean}\n */\nshaka.hls.Utils.isComment = function(line) {\n  return /^#(?!EXT)/m.test(line);\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.TextParser');\n\ngoog.require('goog.asserts');\n\n\n/**\n * Reads elements from strings.\n *\n * @param {string} data\n * @constructor\n * @struct\n */\nshaka.util.TextParser = function(data) {\n  /**\n   * @const\n   * @private {string}\n   */\n  this.data_ = data;\n\n  /** @private {number} */\n  this.position_ = 0;\n};\n\n\n/** @return {boolean} Whether it is at the end of the string. */\nshaka.util.TextParser.prototype.atEnd = function() {\n  return this.position_ == this.data_.length;\n};\n\n\n/**\n * Reads a line from the parser.  This will read but not return the newline.\n * Returns null at the end.\n *\n * @return {?string}\n */\nshaka.util.TextParser.prototype.readLine = function() {\n  return this.readRegexReturnCapture_(/(.*?)(\\n|$)/gm, 1);\n};\n\n\n/**\n * Reads a word from the parser.  This will not read or return any whitespace\n * before or after the word (including newlines).  Returns null at the end.\n *\n * @return {?string}\n */\nshaka.util.TextParser.prototype.readWord = function() {\n  return this.readRegexReturnCapture_(/[^ \\t\\n]*/gm, 0);\n};\n\n\n/**\n * Skips any continuous whitespace from the parser.  Returns null at the end.\n */\nshaka.util.TextParser.prototype.skipWhitespace = function() {\n  this.readRegex(/[ \\t]+/gm);\n};\n\n\n/**\n * Reads the given regular expression from the parser.  This requires the match\n * to be at the current position; there is no need to include a head anchor.\n * This requires that the regex have the global flag to be set so that it can\n * set lastIndex to start the search at the current position.  Returns null at\n * the end or if the regex does not match the current position.\n *\n * @param {!RegExp} regex\n * @return {Array.<string>}\n */\nshaka.util.TextParser.prototype.readRegex = function(regex) {\n  let index = this.indexOf_(regex);\n  if (this.atEnd() || index == null || index.position != this.position_) {\n    return null;\n  }\n\n  this.position_ += index.length;\n  return index.results;\n};\n\n\n/**\n * Reads a regex from the parser and returns the given capture.\n *\n * @param {!RegExp} regex\n * @param {number} index\n * @return {?string}\n * @private\n */\nshaka.util.TextParser.prototype.readRegexReturnCapture_ = function(\n    regex, index) {\n  if (this.atEnd()) {\n    return null;\n  }\n\n  let ret = this.readRegex(regex);\n  if (!ret) {\n    return null;\n  } else {\n    return ret[index];\n  }\n};\n\n\n/**\n * Returns the index info about a regular expression match.\n *\n * @param {!RegExp} regex\n * @return {?{position: number, length: number, results: !Array.<string>}}\n * @private\n */\nshaka.util.TextParser.prototype.indexOf_ = function(regex) {\n  // The global flag is required to use lastIndex.\n  goog.asserts.assert(regex.global, 'global flag should be set');\n\n  regex.lastIndex = this.position_;\n  let results = regex.exec(this.data_);\n  if (results == null) {\n    return null;\n  } else {\n    return {\n      position: results.index,\n      length: results[0].length,\n      results: results,\n    };\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.hls.ManifestTextParser');\n\ngoog.require('shaka.hls.Attribute');\ngoog.require('shaka.hls.Playlist');\ngoog.require('shaka.hls.PlaylistType');\ngoog.require('shaka.hls.Segment');\ngoog.require('shaka.hls.Tag');\ngoog.require('shaka.hls.Utils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.TextParser');\n\n\n/**\n * Creates a new ManifestTextParser.\n *\n * @constructor\n * @struct\n */\nshaka.hls.ManifestTextParser = function() {\n  /** @private {number} */\n  this.globalId_ = 0;\n};\n\n\n/**\n * @param {ArrayBuffer} data\n * @param {string} absolutePlaylistUri An absolute, final URI after redirects.\n * @return {!shaka.hls.Playlist}\n * @throws {shaka.util.Error}\n */\nshaka.hls.ManifestTextParser.prototype.parsePlaylist =\n    function(data, absolutePlaylistUri) {\n  const MEDIA_PLAYLIST_TAGS = shaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGS;\n  const SEGMENT_TAGS = shaka.hls.ManifestTextParser.SEGMENT_TAGS;\n\n  // Get the input as a string.  Normalize newlines to \\n.\n  let str = shaka.util.StringUtils.fromUTF8(data);\n  str = str.replace(/\\r\\n|\\r(?=[^\\n]|$)/gm, '\\n').trim();\n\n  const lines = str.split(/\\n+/m);\n\n  if (!/^#EXTM3U($|[ \\t\\n])/m.test(lines[0])) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.HLS_PLAYLIST_HEADER_MISSING);\n  }\n\n  /** shaka.hls.PlaylistType */\n  let playlistType = shaka.hls.PlaylistType.MASTER;\n\n  // First, look for media playlist tags, so that we know what the playlist\n  // type really is before we start parsing.\n  for (let i = 1; i < lines.length; i++) {\n    // Ignore comments.\n    if (!shaka.hls.Utils.isComment(lines[i])) {\n      const tag = this.parseTag_(lines[i]);\n      // These tags won't actually be used, so don't increment the global id.\n      this.globalId_ -= 1;\n\n      if (MEDIA_PLAYLIST_TAGS.includes(tag.name)) {\n        playlistType = shaka.hls.PlaylistType.MEDIA;\n        break;\n      } else if (tag.name == 'EXT-X-STREAM-INF') {\n        i += 1;\n      }\n    }\n  }\n\n  /** {Array.<shaka.hls.Tag>} */\n  const tags = [];\n  for (let i = 1; i < lines.length;) {\n    // Skip comments\n    if (shaka.hls.Utils.isComment(lines[i])) {\n      i += 1;\n      continue;\n    }\n\n    const tag = this.parseTag_(lines[i]);\n    if (SEGMENT_TAGS.includes(tag.name)) {\n      if (playlistType != shaka.hls.PlaylistType.MEDIA) {\n        // Only media playlists should contain segment tags\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.HLS_INVALID_PLAYLIST_HIERARCHY);\n      }\n\n      const segmentsData = lines.splice(i, lines.length - i);\n      const segments = this.parseSegments_(\n          absolutePlaylistUri, segmentsData, tags);\n      return new shaka.hls.Playlist(\n          absolutePlaylistUri, playlistType, tags, segments);\n    }\n\n    tags.push(tag);\n    i += 1;\n\n    // An EXT-X-STREAM-INF tag is followed by a URI of a media playlist.\n    // Add the URI to the tag object.\n    if (tag.name == 'EXT-X-STREAM-INF') {\n      const tagUri = new shaka.hls.Attribute('URI', lines[i]);\n      tag.addAttribute(tagUri);\n      i += 1;\n    }\n  }\n\n  return new shaka.hls.Playlist(absolutePlaylistUri, playlistType, tags);\n};\n\n\n/**\n * Parses an array of strings into an array of HLS Segment objects.\n *\n * @param {string} absoluteMediaPlaylistUri\n * @param {!Array.<string>} lines\n * @param {!Array.<!shaka.hls.Tag>} playlistTags\n * @return {!Array.<shaka.hls.Segment>}\n * @private\n * @throws {shaka.util.Error}\n */\nshaka.hls.ManifestTextParser.prototype.parseSegments_ =\n    function(absoluteMediaPlaylistUri, lines, playlistTags) {\n  /** @type {!Array.<shaka.hls.Segment>} */\n  let segments = [];\n  /** @type {!Array.<shaka.hls.Tag>} */\n  let segmentTags = [];\n  lines.forEach((line) => {\n    if (/^(#EXT)/.test(line)) {\n      let tag = this.parseTag_(line);\n      if (shaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGS.includes(tag.name)) {\n        playlistTags.push(tag);\n      } else {\n        segmentTags.push(tag);\n      }\n    } else if (shaka.hls.Utils.isComment(line)) {\n      // Skip comments.\n      return [];\n    } else {\n      const verbatimSegmentUri = line.trim();\n      const absoluteSegmentUri = shaka.hls.Utils.constructAbsoluteUri(\n          absoluteMediaPlaylistUri, verbatimSegmentUri);\n\n      // The URI appears after all of the tags describing the segment.\n      const segment = new shaka.hls.Segment(absoluteSegmentUri, segmentTags);\n      segments.push(segment);\n      segmentTags = [];\n    }\n  });\n  return segments;\n};\n\n\n/**\n * Parses a string into an HLS Tag object while tracking what id to use next.\n *\n * @param {string} word\n * @return {!shaka.hls.Tag}\n * @throws {shaka.util.Error}\n * @private\n */\nshaka.hls.ManifestTextParser.prototype.parseTag_ = function(word) {\n  return shaka.hls.ManifestTextParser.parseTag(this.globalId_++, word);\n};\n\n\n/**\n * Parses a string into an HLS Tag object.\n *\n * @param {number} id\n * @param {string} word\n * @return {!shaka.hls.Tag}\n * @throws {shaka.util.Error}\n */\nshaka.hls.ManifestTextParser.parseTag = function(id, word) {\n  /* HLS tags start with '#EXT'. A tag can have a set of attributes\n    (#EXT-<tagname>:<attribute list>) and/or a value (#EXT-<tagname>:<value>).\n    An attribute's format is 'AttributeName=AttributeValue'.\n    The parsing logic goes like this:\n     1. Everything before ':' is a name (we ignore '#').\n     2. Everything after ':' is a list of comma-seprated items,\n          2a. The first item might be a value, if it does not contain '='.\n          2b. Otherwise, items are attributes.\n     3. If there is no \":\", it's a simple tag with no attributes and no value */\n  const blocks = word.match(/^#(EXT[^:]*)(?::(.*))?$/);\n  if (!blocks) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.INVALID_HLS_TAG,\n        word);\n  }\n  const name = blocks[1];\n  const data = blocks[2];\n  const attributes = [];\n  let value;\n\n  if (data) {\n    const parser = new shaka.util.TextParser(data);\n    let blockAttrs;\n\n    // Regex: any number of non-equals-sign characters at the beginning\n    // terminated by comma or end of line\n    const valueRegex = /^([^,=]+)(?:,|$)/g;\n\n    const blockValue = parser.readRegex(valueRegex);\n\n    if (blockValue) {\n      value = blockValue[1];\n    }\n\n    // Regex:\n    // 1. Key name ([1])\n    // 2. Equals sign\n    // 3. Either:\n    //   a. A quoted string (everything up to the next quote, [2])\n    //   b. An unquoted string\n    //    (everything up to the next comma or end of line, [3])\n    // 4. Either:\n    //   a. A comma\n    //   b. End of line\n    const attributeRegex = /([^=]+)=(?:\"([^\"]*)\"|([^\",]*))(?:,|$)/g;\n\n    while ((blockAttrs = parser.readRegex(attributeRegex))) {\n      const attrName = blockAttrs[1];\n      const attrValue = blockAttrs[2] || blockAttrs[3];\n      const attribute = new shaka.hls.Attribute(attrName, attrValue);\n      attributes.push(attribute);\n    }\n  }\n\n  return new shaka.hls.Tag(id, name, attributes, value);\n};\n\n\n/**\n * HLS tags that only appear on Media Playlists.\n * Used to determine a playlist type.\n *\n * @const {!Array.<string>}\n */\nshaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGS = [\n  'EXT-X-TARGETDURATION',\n  'EXT-X-MEDIA-SEQUENCE',\n  'EXT-X-DISCONTINUITY-SEQUENCE',\n  'EXT-X-PLAYLIST-TYPE',\n  'EXT-X-MAP',\n  'EXT-X-I-FRAMES-ONLY',\n  'EXT-X-ENDLIST',\n];\n\n\n/**\n * HLS tags that only appear on Segments in a Media Playlists.\n * Used to determine the start of the segments info.\n *\n * @const {!Array.<string>}\n */\nshaka.hls.ManifestTextParser.SEGMENT_TAGS = [\n  'EXTINF',\n  'EXT-X-BYTERANGE',\n  'EXT-X-DISCONTINUITY',\n  'EXT-X-PROGRAM-DATE-TIME',\n  'EXT-X-KEY',\n  'EXT-X-DATERANGE',\n];\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.net.DataUriPlugin');\n\ngoog.require('shaka.log');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @namespace\n * @summary A networking plugin to handle data URIs.\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/data_URIs\n * @param {string} uri\n * @param {shaka.extern.Request} request\n * @param {shaka.net.NetworkingEngine.RequestType} requestType\n * @param {shaka.extern.ProgressUpdated} progressUpdated Called when a\n *   progress event happened.\n * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n * @export\n */\nshaka.net.DataUriPlugin = function(uri, request, requestType, progressUpdated) {\n  try {\n    let parsed = shaka.net.DataUriPlugin.parse(uri);\n\n    /** @type {shaka.extern.Response} */\n    let response = {\n      uri: uri,\n      originalUri: uri,\n      data: parsed.data,\n      headers: {\n        'content-type': parsed.contentType,\n      },\n    };\n\n    return shaka.util.AbortableOperation.completed(response);\n  } catch (error) {\n    return shaka.util.AbortableOperation.failed(error);\n  }\n};\n\n\n/**\n * @param {string} uri\n * @return {{data: ArrayBuffer, contentType: string}}\n */\nshaka.net.DataUriPlugin.parse = function(uri) {\n  // Extract the scheme.\n  let parts = uri.split(':');\n  if (parts.length < 2 || parts[0] != 'data') {\n    shaka.log.error('Bad data URI, failed to parse scheme');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.NETWORK,\n        shaka.util.Error.Code.MALFORMED_DATA_URI,\n        uri);\n  }\n  let path = parts.slice(1).join(':');\n\n  // Extract the encoding and MIME type (required but can be empty).\n  let infoAndData = path.split(',');\n  if (infoAndData.length < 2) {\n    shaka.log.error('Bad data URI, failed to extract encoding and MIME type');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.NETWORK,\n        shaka.util.Error.Code.MALFORMED_DATA_URI,\n        uri);\n  }\n  let info = infoAndData[0];\n  let dataStr = window.decodeURIComponent(infoAndData.slice(1).join(','));\n\n  // Extract the encoding (optional).\n  let typeAndEncoding = info.split(';');\n  let encoding = null;\n  if (typeAndEncoding.length > 1) {\n    encoding = typeAndEncoding[1];\n  }\n\n  // Convert the data.\n  /** @type {ArrayBuffer} */\n  let data;\n  if (encoding == 'base64') {\n    data = shaka.util.Uint8ArrayUtils.fromBase64(dataStr).buffer;\n  } else if (encoding) {\n    shaka.log.error('Bad data URI, unknown encoding');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.NETWORK,\n        shaka.util.Error.Code.UNKNOWN_DATA_URI_ENCODING,\n        uri);\n  } else {\n    data = shaka.util.StringUtils.toUTF8(dataStr);\n  }\n\n  return {data: data, contentType: typeAndEncoding[0]};\n};\n\n\nshaka.net.NetworkingEngine.registerScheme('data', shaka.net.DataUriPlugin);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\ngoog.provide('shaka.hls.HlsParser');\n\ngoog.require('goog.Uri');\ngoog.require('goog.asserts');\ngoog.require('shaka.Deprecate');\ngoog.require('shaka.hls.ManifestTextParser');\ngoog.require('shaka.hls.Playlist');\ngoog.require('shaka.hls.PlaylistType');\ngoog.require('shaka.hls.Tag');\ngoog.require('shaka.hls.Utils');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.net.DataUriPlugin');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.Networking');\ngoog.require('shaka.util.OperationManager');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * Creates a new HLS parser.\n *\n * @struct\n * @constructor\n * @implements {shaka.extern.ManifestParser}\n * @export\n */\nshaka.hls.HlsParser = function() {\n  /** @private {?shaka.extern.ManifestParser.PlayerInterface} */\n  this.playerInterface_ = null;\n\n  /** @private {?shaka.extern.ManifestConfiguration} */\n  this.config_ = null;\n\n  /** @private {number} */\n  this.globalId_ = 1;\n\n  /**\n   * @private {!Map.<number, shaka.hls.HlsParser.StreamInfo>}\n   */\n  // TODO: This is now only used for text codec detection, try to remove.\n  this.mediaTagsToStreamInfosMap_ = new Map();\n\n  /**\n   * The values are strings of the form \"<VIDEO URI> - <AUDIO URI>\",\n   * where the URIs are the verbatim media playlist URIs as they appeared in the\n   * master playlist.\n   *\n   * Used to avoid duplicates that vary only in their text stream.\n   *\n   * @private {!Set.<string>}\n   */\n  this.variantUriSet_ = new Set();\n\n  /**\n   * A map from (verbatim) media playlist URI to stream infos representing the\n   * playlists.\n   *\n   * On update, used to iterate through and update from media playlists.\n   *\n   * On initial parse, used to iterate through and determine minimum timestamps,\n   * offsets, and to handle TS rollover.\n   *\n   * During parsing, used to avoid duplicates in the async methods\n   * createStreamInfoFromMediaTag_ and createStreamInfoFromVariantTag_.\n   *\n   * During parsing of updates, used by getStartTime_ to determine the start\n   * time of the first segment from existing segment references.\n   *\n   * @private {!Map.<string, shaka.hls.HlsParser.StreamInfo>}\n   */\n  this.uriToStreamInfosMap_ = new Map();\n\n  /** @private {?shaka.media.PresentationTimeline} */\n  this.presentationTimeline_ = null;\n\n  /**\n   * The master playlist URI, after redirects.\n   *\n   * @private {string}\n   */\n  this.masterPlaylistUri_ = '';\n\n  /** @private {shaka.hls.ManifestTextParser} */\n  this.manifestTextParser_ = new shaka.hls.ManifestTextParser();\n\n  /**\n   * This is the number of seconds we want to wait between finishing a manifest\n   * update and starting the next one. This will be set when we parse the\n   * manifest.\n   *\n   * @private {number}\n   */\n  this.updatePlaylistDelay_ = 0;\n\n  /**\n   * This timer is used to trigger the start of a manifest update. A manifest\n   * update is async. Once the update is finished, the timer will be restarted\n   * to trigger the next update. The timer will only be started if the content\n   * is live content.\n   *\n   * @private {shaka.util.Timer}\n   */\n  this.updatePlaylistTimer_ = new shaka.util.Timer(() => {\n    this.onUpdate_();\n  });\n\n  /** @private {shaka.hls.HlsParser.PresentationType_} */\n  this.presentationType_ = shaka.hls.HlsParser.PresentationType_.VOD;\n\n  /** @private {?shaka.extern.Manifest} */\n  this.manifest_ = null;\n\n  /** @private {number} */\n  this.maxTargetDuration_ = 0;\n\n  /** @private {number} */\n  this.minTargetDuration_ = Infinity;\n\n  /** @private {shaka.util.OperationManager} */\n  this.operationManager_ = new shaka.util.OperationManager();\n\n  /** @private {!Array.<!Array.<!shaka.media.SegmentReference>>} */\n  this.segmentsToNotifyByStream_ = [];\n\n  /** A map from closed captions' group id, to a map of closed captions info.\n   * {group id -> {closed captions channel id -> language}}\n   * @private {Map.<string, Map.<string, string>>}\n   */\n  this.groupIdToClosedCaptionsMap_ = new Map();\n\n  /** True if some of the variants in  the playlist is encrypted with AES-128.\n   * @private {boolean} */\n  this.aesEncrypted_ = false;\n};\n\n\n/**\n * @typedef {{\n *   stream: !shaka.extern.Stream,\n *   segmentIndex: !shaka.media.SegmentIndex,\n *   drmInfos: !Array.<shaka.extern.DrmInfo>,\n *   verbatimMediaPlaylistUri: string,\n *   absoluteMediaPlaylistUri: string,\n *   minTimestamp: number,\n *   maxTimestamp: number,\n *   duration: number\n * }}\n *\n * @description\n * Contains a stream and information about it.\n *\n * @property {!shaka.extern.Stream} stream\n *   The Stream itself.\n * @property {!shaka.media.SegmentIndex} segmentIndex\n *   SegmentIndex of the stream.\n * @property {!Array.<shaka.extern.DrmInfo>} drmInfos\n *   DrmInfos of the stream.  There may be multiple for multi-DRM content.\n * @property {string} verbatimMediaPlaylistUri\n *   The verbatim media playlist URI, as it appeared in the master playlist.\n *   This has not been canonicalized into an absolute URI.  This gives us a\n *   consistent key for this playlist, even if redirects cause us to update\n *   from different origins each time.\n * @property {string} absoluteMediaPlaylistUri\n *   The absolute media playlist URI, resolved relative to the master playlist\n *   and updated to reflect any redirects.\n * @property {number} minTimestamp\n *   The minimum timestamp found in the stream.\n * @property {number} maxTimestamp\n *   The maximum timestamp found in the stream.\n * @property {number} duration\n *   The duration of the playlist.  Used for VOD only.\n */\nshaka.hls.HlsParser.StreamInfo;\n\n\n/**\n * @override\n * @exportInterface\n */\nshaka.hls.HlsParser.prototype.configure = function(config) {\n  this.config_ = config;\n};\n\n\n/**\n * @override\n * @exportInterface\n */\nshaka.hls.HlsParser.prototype.start = async function(uri, playerInterface) {\n  goog.asserts.assert(this.config_, 'Must call configure() before start()!');\n  this.playerInterface_ = playerInterface;\n\n  const response = await this.requestManifest_(uri);\n\n  // Record the master playlist URI after redirects.\n  this.masterPlaylistUri_ = response.uri;\n\n  goog.asserts.assert(response.data, 'Response data should be non-null!');\n  await this.parseManifest_(response.data);\n\n  // Start the update timer if we want updates.\n  const delay = this.updatePlaylistDelay_;\n  if (delay > 0) {\n    this.updatePlaylistTimer_.tickAfter(/* seconds = */ delay);\n  }\n\n  goog.asserts.assert(this.manifest_, 'Manifest should be non-null');\n  return this.manifest_;\n};\n\n\n/**\n * @override\n * @exportInterface\n */\nshaka.hls.HlsParser.prototype.stop = function() {\n  // Make sure we don't update the manifest again. Even if the timer is not\n  // running, this is safe to call.\n  if (this.updatePlaylistTimer_) {\n    this.updatePlaylistTimer_.stop();\n    this.updatePlaylistTimer_ = null;\n  }\n\n  /** @type {!Array.<!Promise>} */\n  const pending = [];\n\n  if (this.operationManager_) {\n    pending.push(this.operationManager_.destroy());\n    this.operationManager_ = null;\n  }\n\n  this.playerInterface_ = null;\n  this.config_ = null;\n  this.mediaTagsToStreamInfosMap_.clear();\n  this.variantUriSet_.clear();\n  this.uriToStreamInfosMap_.clear();\n  this.manifest_ = null;\n\n  return Promise.all(pending);\n};\n\n\n/**\n * @override\n * @exportInterface\n */\nshaka.hls.HlsParser.prototype.update = function() {\n  if (!this.isLive_()) {\n    return;\n  }\n\n  /** @type {!Array.<!Promise>} */\n  const updates = [];\n\n  for (const streamInfo of this.uriToStreamInfosMap_.values()) {\n    updates.push(this.updateStream_(streamInfo));\n  }\n\n  return Promise.all(updates);\n};\n\n\n/**\n * Updates a stream.\n *\n * @param {!shaka.hls.HlsParser.StreamInfo} streamInfo\n * @return {!Promise}\n * @throws shaka.util.Error\n * @private\n */\nshaka.hls.HlsParser.prototype.updateStream_ = async function(streamInfo) {\n  const Utils = shaka.hls.Utils;\n  const PresentationType = shaka.hls.HlsParser.PresentationType_;\n\n  const manifestUri = streamInfo.absoluteMediaPlaylistUri;\n  const response = await this.requestManifest_(manifestUri);\n\n  /** @type {shaka.hls.Playlist} */\n  const playlist = this.manifestTextParser_.parsePlaylist(\n      response.data, response.uri);\n\n  if (playlist.type != shaka.hls.PlaylistType.MEDIA) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.HLS_INVALID_PLAYLIST_HIERARCHY);\n  }\n\n  const mediaSequenceTag = Utils.getFirstTagWithName(\n      playlist.tags, 'EXT-X-MEDIA-SEQUENCE');\n\n  const startPosition = mediaSequenceTag ? Number(mediaSequenceTag.value) : 0;\n  const stream = streamInfo.stream;\n\n  const segments = await this.createSegments_(\n        streamInfo.verbatimMediaPlaylistUri,\n        playlist,\n        startPosition,\n        stream.mimeType,\n        stream.codecs);\n\n  streamInfo.segmentIndex.replace(segments);\n\n  const newestSegment = segments[segments.length - 1];\n  goog.asserts.assert(newestSegment, 'Should have segments!');\n\n  // Once the last segment has been added to the playlist,\n  // #EXT-X-ENDLIST tag will be appended.\n  // If that happened, treat the rest of the EVENT presentation as VOD.\n  const endListTag = Utils.getFirstTagWithName(playlist.tags, 'EXT-X-ENDLIST');\n\n  if (endListTag) {\n    // Convert the presentation to VOD and set the duration to the last\n    // segment's end time.\n    this.setPresentationType_(PresentationType.VOD);\n    this.presentationTimeline_.setDuration(newestSegment.endTime);\n  }\n};\n\n\n/**\n * @override\n * @exportInterface\n */\nshaka.hls.HlsParser.prototype.onExpirationUpdated = function(\n    sessionId, expiration) {\n  // No-op\n};\n\n\n/**\n * Parses the manifest.\n *\n * @param {!ArrayBuffer} data\n * @throws shaka.util.Error When there is a parsing error.\n * @return {!Promise}\n * @private\n */\nshaka.hls.HlsParser.prototype.parseManifest_ = async function(data) {\n  goog.asserts.assert(this.masterPlaylistUri_,\n      'Master playlist URI must be set before calling parseManifest_!');\n\n  const playlist = this.manifestTextParser_.parsePlaylist(\n      data, this.masterPlaylistUri_);\n\n  // We don't support directly providing a Media Playlist.\n  // See the error code for details.\n  if (playlist.type != shaka.hls.PlaylistType.MASTER) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.HLS_MASTER_PLAYLIST_NOT_PROVIDED);\n  }\n\n  const period = await this.createPeriod_(playlist);\n\n  // Make sure that the parser has not been destroyed.\n  if (!this.playerInterface_) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.OPERATION_ABORTED);\n  }\n\n  if (this.aesEncrypted_ && period.variants.length == 0) {\n    // We do not support AES-128 encryption with HLS yet. Variants is null\n    // when the playlist is encrypted with AES-128.\n    shaka.log.info('No stream is created, because we don\\'t support AES-128',\n        'encryption yet');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.HLS_AES_128_ENCRYPTION_NOT_SUPPORTED);\n  }\n\n  // HLS has no notion of periods.  We're treating the whole presentation as\n  // one period.\n  this.playerInterface_.filterAllPeriods([period]);\n\n  // Find the min and max timestamp of the earliest segment in all streams.\n  // Find the minimum duration of all streams as well.\n  let minFirstTimestamp = Infinity;\n  let maxFirstTimestamp = 0;\n  let maxLastTimestamp = 0;\n  let minDuration = Infinity;\n\n  for (const streamInfo of this.uriToStreamInfosMap_.values()) {\n    minFirstTimestamp =\n        Math.min(minFirstTimestamp, streamInfo.minTimestamp);\n    maxFirstTimestamp =\n        Math.max(maxFirstTimestamp, streamInfo.minTimestamp);\n    maxLastTimestamp =\n        Math.max(maxLastTimestamp, streamInfo.maxTimestamp);\n    if (streamInfo.stream.type != 'text') {\n      minDuration = Math.min(minDuration, streamInfo.duration);\n    }\n  }\n\n  // This assert is our own sanity check.\n  goog.asserts.assert(this.presentationTimeline_ == null,\n                      'Presentation timeline created early!');\n  this.createPresentationTimeline_(maxLastTimestamp);\n\n  // This assert satisfies the compiler that it is not null for the rest of\n  // the method.\n  goog.asserts.assert(this.presentationTimeline_,\n                      'Presentation timeline not created!');\n\n  if (this.isLive_()) {\n    // The HLS spec (RFC 8216) states in 6.3.4:\n    // \"the client MUST wait for at least the target duration before\n    // attempting to reload the Playlist file again\"\n    this.updatePlaylistDelay_ = this.minTargetDuration_;\n\n    // The spec says nothing much about seeking in live content, but Safari's\n    // built-in HLS implementation does not allow it.  Therefore we will set\n    // the availability window equal to the presentation delay.  The player\n    // will be able to buffer ahead three segments, but the seek window will\n    // be zero-sized.\n    const PresentationType = shaka.hls.HlsParser.PresentationType_;\n\n    if (this.presentationType_ == PresentationType.LIVE) {\n      // This defaults to the presentation delay, which has the effect of\n      // making the live stream unseekable.  This is consistent with Apple's\n      // HLS implementation.\n      let segmentAvailabilityDuration = this.presentationTimeline_.getDelay();\n\n      // The app can override that with a longer duration, to allow seeking.\n      if (!isNaN(this.config_.availabilityWindowOverride)) {\n        segmentAvailabilityDuration = this.config_.availabilityWindowOverride;\n      }\n\n      this.presentationTimeline_.setSegmentAvailabilityDuration(\n          segmentAvailabilityDuration);\n    }\n\n    let rolloverSeconds =\n        shaka.hls.HlsParser.TS_ROLLOVER_ / shaka.hls.HlsParser.TS_TIMESCALE_;\n    let offset = 0;\n    while (maxFirstTimestamp >= rolloverSeconds) {\n      offset += rolloverSeconds;\n      maxFirstTimestamp -= rolloverSeconds;\n    }\n    if (offset) {\n      shaka.log.debug('Offsetting live streams by', offset,\n                      'to compensate for rollover');\n\n      for (const streamInfo of this.uriToStreamInfosMap_.values()) {\n        if (streamInfo.minTimestamp < rolloverSeconds) {\n          shaka.log.v1('Offset applied to', streamInfo.stream.type);\n          // This is the offset that StreamingEngine must apply to align the\n          // actual segment times with the period.\n          streamInfo.stream.presentationTimeOffset = -offset;\n          // The segments were created with actual media times, rather than\n          // period-aligned times, so offset them all to period time.\n          streamInfo.segmentIndex.offset(offset);\n        } else {\n          shaka.log.v1('Offset NOT applied to', streamInfo.stream.type);\n        }\n      }\n    }\n  } else {\n    // For VOD/EVENT content, offset everything back to 0.\n    // Use the minimum timestamp as the offset for all streams.\n    // Use the minimum duration as the presentation duration.\n    this.presentationTimeline_.setDuration(minDuration);\n    // Use a negative offset to adjust towards 0.\n    this.presentationTimeline_.offset(-minFirstTimestamp);\n\n    for (const streamInfo of this.uriToStreamInfosMap_.values()) {\n      // This is the offset that StreamingEngine must apply to align the\n      // actual segment times with the period.\n      streamInfo.stream.presentationTimeOffset = minFirstTimestamp;\n      // The segments were created with actual media times, rather than\n      // period-aligned times, so offset them all now.\n      streamInfo.segmentIndex.offset(-minFirstTimestamp);\n      // Finally, fit the segments to the period duration.\n      streamInfo.segmentIndex.fit(minDuration);\n    }\n  }\n\n  this.manifest_ = {\n    presentationTimeline: this.presentationTimeline_,\n    periods: [period],\n    offlineSessionIds: [],\n    minBufferTime: 0,\n  };\n};\n\n\n/**\n * Parses a playlist into a Period object.\n *\n * @param {!shaka.hls.Playlist} playlist\n * @return {!Promise.<!shaka.extern.Period>}\n * @private\n */\nshaka.hls.HlsParser.prototype.createPeriod_ = async function(playlist) {\n  const Utils = shaka.hls.Utils;\n  const Functional = shaka.util.Functional;\n  let tags = playlist.tags;\n\n  let mediaTags = Utils.filterTagsByName(playlist.tags, 'EXT-X-MEDIA');\n  let textStreamTags = mediaTags.filter(function(tag) {\n    let type = shaka.hls.HlsParser.getRequiredAttributeValue_(tag, 'TYPE');\n    return type == 'SUBTITLES';\n  }.bind(this));\n\n  let textStreamPromises = textStreamTags.map(function(tag) {\n    return this.createTextStream_(tag, playlist);\n  }.bind(this));\n\n  const closedCaptionsTags = mediaTags.filter((tag) => {\n    const type = shaka.hls.HlsParser.getRequiredAttributeValue_(tag, 'TYPE');\n    return type == 'CLOSED-CAPTIONS';\n  });\n\n  this.parseClosedCaptions_(closedCaptionsTags);\n\n  const textStreams = await Promise.all(textStreamPromises);\n  // Create Variants for every 'EXT-X-STREAM-INF' tag.  Do this after text\n  // streams have been created, so that we can push text codecs found on the\n  // variant tag back into the created text streams.\n  let variantTags = Utils.filterTagsByName(tags, 'EXT-X-STREAM-INF');\n  let variantsPromises = variantTags.map(function(tag) {\n    return this.createVariantsForTag_(tag, playlist);\n  }.bind(this));\n\n  const allVariants = await Promise.all(variantsPromises);\n  let variants = allVariants.reduce(Functional.collapseArrays, []);\n  // Filter out null variants.\n  variants = variants.filter((variant) => variant != null);\n\n  return {\n    startTime: 0,\n    variants: variants,\n    textStreams: textStreams,\n  };\n};\n\n\n/**\n * @param {!shaka.hls.Tag} tag\n * @param {!shaka.hls.Playlist} playlist\n * @return {!Promise.<!Array.<!shaka.extern.Variant>>}\n * @private\n */\nshaka.hls.HlsParser.prototype.createVariantsForTag_ =\n    async function(tag, playlist) {\n  goog.asserts.assert(tag.name == 'EXT-X-STREAM-INF',\n                      'Should only be called on variant tags!');\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  const Utils = shaka.hls.Utils;\n\n  // These are the default codecs to assume if none are specified.\n  //\n  // The video codec is H.264, with baseline profile and level 3.0.\n  // http://blog.pearce.org.nz/2013/11/what-does-h264avc1-codecs-parameters.html\n  //\n  // The audio codec is \"low-complexity\" AAC.\n  const defaultCodecs = 'avc1.42E01E,mp4a.40.2';\n\n  const codecsString = tag.getAttributeValue('CODECS', defaultCodecs);\n  // Strip out internal whitespace while splitting on commas:\n  /** @type {!Array.<string>} */\n  let codecs =\n      shaka.hls.HlsParser.filterDuplicateCodecs_(codecsString.split(/\\s*,\\s*/));\n  let resolutionAttr = tag.getAttribute('RESOLUTION');\n  let width = null;\n  let height = null;\n  let frameRate = tag.getAttributeValue('FRAME-RATE');\n  let bandwidth =\n      Number(shaka.hls.HlsParser.getRequiredAttributeValue_(tag, 'BANDWIDTH'));\n\n  if (resolutionAttr) {\n    let resBlocks = resolutionAttr.value.split('x');\n    width = resBlocks[0];\n    height = resBlocks[1];\n  }\n\n  // After filtering, this is a list of the media tags we will process to\n  // combine with the variant tag (EXT-X-STREAM-INF) we are working on.\n  let mediaTags = Utils.filterTagsByName(playlist.tags, 'EXT-X-MEDIA');\n\n  // Do not create stream info from closed captions media tags, which are\n  // embedded in video streams.\n  mediaTags = mediaTags.filter((tag) => {\n    const type = shaka.hls.HlsParser.getRequiredAttributeValue_(tag, 'TYPE');\n    return type != 'CLOSED-CAPTIONS';\n  });\n\n  // AUDIO or VIDEO tags without a URI attribute are valid.\n  // If there is no uri, it means that audio/video is embedded in the\n  // stream described by the Variant tag.\n  // Do not create stream from AUDIO/VIDEO EXT-X-MEDIA tags without URI\n  mediaTags = mediaTags.filter((tag) => {\n    const uri = tag.getAttributeValue('URI') || '';\n    const type = tag.getAttributeValue('TYPE') || '';\n    return type == 'SUBTITLES' || uri != '';\n  });\n\n  let audioGroupId = tag.getAttributeValue('AUDIO');\n  let videoGroupId = tag.getAttributeValue('VIDEO');\n  goog.asserts.assert(audioGroupId == null || videoGroupId == null,\n      'Unexpected: both video and audio described by media tags!');\n\n  // Find any associated audio or video groups and create streams for them.\n  if (audioGroupId) {\n    mediaTags = Utils.findMediaTags(mediaTags, 'AUDIO', audioGroupId);\n  } else if (videoGroupId) {\n    mediaTags = Utils.findMediaTags(mediaTags, 'VIDEO', videoGroupId);\n  }\n\n  // There may be a codec string for the text stream.  We should identify it,\n  // add it to the appropriate stream, then strip it out of the variant to\n  // avoid confusing our multiplex detection below.\n  let textCodecs = this.guessCodecsSafe_(ContentType.TEXT, codecs);\n  if (textCodecs) {\n    // We found a text codec in the list, so look for an associated text stream.\n    let subGroupId = tag.getAttributeValue('SUBTITLES');\n    if (subGroupId) {\n      let textTags = Utils.findMediaTags(mediaTags, 'SUBTITLES', subGroupId);\n      goog.asserts.assert(textTags.length == 1,\n                          'Exactly one text tag expected!');\n      if (textTags.length) {\n        // We found a text codec and text stream, so make sure the codec is\n        // attached to the stream.\n        const textStreamInfo =\n            this.mediaTagsToStreamInfosMap_.get(textTags[0].id);\n        textStreamInfo.stream.codecs = textCodecs;\n      }\n    }\n\n    // Remove this entry from the list of codecs that belong to audio/video.\n    shaka.util.ArrayUtils.remove(codecs, textCodecs);\n  }\n\n  let promises = mediaTags.map(function(tag) {\n    return this.createStreamInfoFromMediaTag_(tag, codecs);\n  }.bind(this));\n\n  let audioStreamInfos = [];\n  let videoStreamInfos = [];\n\n  let streamInfo;\n  let data = await Promise.all(promises);\n  // Filter out null streamInfo.\n  data = data.filter((info) => info != null);\n  if (audioGroupId) {\n    audioStreamInfos = data;\n  } else if (videoGroupId) {\n    videoStreamInfos = data;\n  }\n\n  // Make an educated guess about the stream type.\n  shaka.log.debug('Guessing stream type for', tag.toString());\n  let type;\n  let ignoreStream = false;\n  if (!audioStreamInfos.length && !videoStreamInfos.length) {\n    // There are no associated streams.  This is either an audio-only stream,\n    // a video-only stream, or a multiplexed stream.\n\n    if (codecs.length == 1) {\n      // There is only one codec, so it shouldn't be multiplexed.\n\n      let videoCodecs = this.guessCodecsSafe_(ContentType.VIDEO, codecs);\n      if (resolutionAttr || frameRate || videoCodecs) {\n        // Assume video-only.\n        shaka.log.debug('Guessing video-only.');\n        type = ContentType.VIDEO;\n      } else {\n        // Assume audio-only.\n        shaka.log.debug('Guessing audio-only.');\n        type = ContentType.AUDIO;\n      }\n    } else {\n      // There are multiple codecs, so assume multiplexed content.\n      // Note that the default used when CODECS is missing assumes multiple\n      // (and therefore multiplexed).\n      // Recombine the codec strings into one so that MediaSource isn't\n      // lied to later.  (That would trigger an error in Chrome.)\n      shaka.log.debug('Guessing multiplexed audio+video.');\n      type = ContentType.VIDEO;\n      codecs = [codecs.join(',')];\n    }\n  } else if (audioStreamInfos.length) {\n    let streamURI = shaka.hls.HlsParser.getRequiredAttributeValue_(tag, 'URI');\n    let firstAudioStreamURI = audioStreamInfos[0].verbatimMediaPlaylistUri;\n    if (streamURI == firstAudioStreamURI) {\n      // The Microsoft HLS manifest generators will make audio-only variants\n      // that link to their URI both directly and through an audio tag.\n      // In that case, ignore the local URI and use the version in the\n      // AUDIO tag, so you inherit its language.\n      // As an example, see the manifest linked in issue #860.\n      shaka.log.debug('Guessing audio-only.');\n      type = ContentType.AUDIO;\n      ignoreStream = true;\n    } else {\n      // There are associated audio streams.  Assume this is video.\n      shaka.log.debug('Guessing video.');\n      type = ContentType.VIDEO;\n    }\n  } else {\n    // There are associated video streams.  Assume this is audio.\n    goog.asserts.assert(videoStreamInfos.length,\n        'No video streams!  This should have been handled already!');\n    shaka.log.debug('Guessing audio.');\n    type = ContentType.AUDIO;\n  }\n\n  goog.asserts.assert(type, 'Type should have been set by now!');\n  if (!ignoreStream) {\n    streamInfo =\n        await this.createStreamInfoFromVariantTag_(tag, codecs, type);\n  }\n\n  if (streamInfo) {\n    if (streamInfo.stream.type == ContentType.AUDIO) {\n      audioStreamInfos = [streamInfo];\n    } else {\n      videoStreamInfos = [streamInfo];\n    }\n  } else if (streamInfo === null) {  // Triple-equals to distinguish undefined\n    // We do not support AES-128 encryption with HLS yet. If the streamInfo is\n    // null because of AES-128 encryption, do not create variants for that.\n    shaka.log.debug('streamInfo is null');\n    return [];\n  }\n\n  goog.asserts.assert(videoStreamInfos.length || audioStreamInfos.length,\n      'We should have created a stream!');\n\n  if (videoStreamInfos) {\n    this.filterLegacyCodecs_(videoStreamInfos);\n  }\n  if (audioStreamInfos) {\n    this.filterLegacyCodecs_(audioStreamInfos);\n  }\n\n  return this.createVariants_(\n      audioStreamInfos,\n      videoStreamInfos,\n      bandwidth,\n      width,\n      height,\n      frameRate);\n};\n\n\n/**\n * Filters out unsupported codec strings from an array of stream infos.\n * @param {!Array.<shaka.hls.HlsParser.StreamInfo>} streamInfos\n * @private\n */\nshaka.hls.HlsParser.prototype.filterLegacyCodecs_ = function(streamInfos) {\n  streamInfos.forEach(function(streamInfo) {\n    let codecs = streamInfo.stream.codecs.split(',');\n    codecs = codecs.filter(function(codec) {\n      // mp4a.40.34 is a nonstandard codec string that is sometimes used in HLS\n      // for legacy reasons.  It is not recognized by non-Apple MSE.\n      // See https://bugs.chromium.org/p/chromium/issues/detail?id=489520\n      // Therefore, ignore this codec string.\n      return codec != 'mp4a.40.34';\n    });\n    streamInfo.stream.codecs = codecs.join(',');\n  });\n};\n\n\n/**\n * @param {!Array.<!shaka.hls.HlsParser.StreamInfo>} audioInfos\n * @param {!Array.<!shaka.hls.HlsParser.StreamInfo>} videoInfos\n * @param {number} bandwidth\n * @param {?string} width\n * @param {?string} height\n * @param {?string} frameRate\n * @return {!Array.<!shaka.extern.Variant>}\n * @private\n */\nshaka.hls.HlsParser.prototype.createVariants_ =\n    function(audioInfos, videoInfos, bandwidth, width, height, frameRate) {\n  const DrmEngine = shaka.media.DrmEngine;\n\n  videoInfos.forEach(function(info) {\n    this.addVideoAttributes_(info.stream, width, height, frameRate);\n  }.bind(this));\n\n  // In case of audio-only or video-only content, we create an array of\n  // one item containing a null.  This way, the double-loop works for all\n  // kinds of content.\n  // NOTE: we currently don't have support for audio-only content.\n  if (!audioInfos.length) {\n    audioInfos = [null];\n  }\n  if (!videoInfos.length) {\n    videoInfos = [null];\n  }\n\n  const variants = [];\n  for (const audioInfo of audioInfos) {\n    for (const videoInfo of videoInfos) {\n      const audioStream = audioInfo ? audioInfo.stream : null;\n      const videoStream = videoInfo ? videoInfo.stream : null;\n      const audioDrmInfos = audioInfo ? audioInfo.drmInfos : null;\n      const videoDrmInfos = videoInfo ? videoInfo.drmInfos : null;\n      const videoStreamUri =\n          videoInfo ? videoInfo.verbatimMediaPlaylistUri : '';\n      const audioStreamUri =\n          audioInfo ? audioInfo.verbatimMediaPlaylistUri : '';\n      const variantUriKey = videoStreamUri + ' - ' + audioStreamUri;\n\n      let drmInfos;\n      if (audioStream && videoStream) {\n        if (DrmEngine.areDrmCompatible(audioDrmInfos, videoDrmInfos)) {\n          drmInfos = DrmEngine.getCommonDrmInfos(audioDrmInfos, videoDrmInfos);\n        } else {\n          shaka.log.warning('Incompatible DRM info in HLS variant.  Skipping.');\n          continue;\n        }\n      } else if (audioStream) {\n        drmInfos = audioDrmInfos;\n      } else if (videoStream) {\n        drmInfos = videoDrmInfos;\n      }\n\n      if (this.variantUriSet_.has(variantUriKey)) {\n        // This happens when two variants only differ in their text streams.\n        shaka.log.debug('Skipping variant which only differs in text streams.');\n        continue;\n      }\n\n      const variant = this.createVariant_(\n          audioStream, videoStream, bandwidth, drmInfos);\n      variants.push(variant);\n      this.variantUriSet_.add(variantUriKey);\n    }\n  }\n  return variants;\n};\n\n\n/**\n * @param {shaka.extern.Stream} audio\n * @param {shaka.extern.Stream} video\n * @param {number} bandwidth\n * @param {!Array.<shaka.extern.DrmInfo>} drmInfos\n * @return {!shaka.extern.Variant}\n * @private\n */\nshaka.hls.HlsParser.prototype.createVariant_ =\n    function(audio, video, bandwidth, drmInfos) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  // Since both audio and video are of the same type, this assertion will catch\n  // certain mistakes at runtime that the compiler would miss.\n  goog.asserts.assert(!audio || audio.type == ContentType.AUDIO,\n                      'Audio parameter mismatch!');\n  goog.asserts.assert(!video || video.type == ContentType.VIDEO,\n                      'Video parameter mismatch!');\n\n  return {\n    id: this.globalId_++,\n    language: audio ? audio.language : 'und',\n    primary: (!!audio && audio.primary) || (!!video && video.primary),\n    audio: audio,\n    video: video,\n    bandwidth: bandwidth,\n    drmInfos: drmInfos,\n    allowedByApplication: true,\n    allowedByKeySystem: true,\n  };\n};\n\n\n/**\n * Parses an EXT-X-MEDIA tag with TYPE=\"SUBTITLES\" into a text stream.\n *\n * @param {!shaka.hls.Tag} tag\n * @param {!shaka.hls.Playlist} playlist\n * @return {!Promise.<?shaka.extern.Stream>}\n * @private\n */\nshaka.hls.HlsParser.prototype.createTextStream_ =\n    async function(tag, playlist) {\n  goog.asserts.assert(tag.name == 'EXT-X-MEDIA',\n                      'Should only be called on media tags!');\n\n  let type = shaka.hls.HlsParser.getRequiredAttributeValue_(tag, 'TYPE');\n  goog.asserts.assert(type == 'SUBTITLES',\n                      'Should only be called on tags with TYPE=\"SUBTITLES\"!');\n\n  const streamInfo = await this.createStreamInfoFromMediaTag_(tag, []);\n  goog.asserts.assert(streamInfo, 'Should always have a streamInfo for text');\n  return streamInfo.stream;\n};\n\n\n/**\n * Parses an EXT-X-MEDIA tag with TYPE=\"CLOSED-CAPTIONS\", add store the values\n * into the map of group id to closed captions.\n *\n * @param {!Array.<shaka.hls.Tag>} tags\n * @private\n */\nshaka.hls.HlsParser.prototype.parseClosedCaptions_ = function(tags) {\n  for (const tag of tags) {\n    goog.asserts.assert(tag.name == 'EXT-X-MEDIA',\n        'Should only be called on media tags!');\n    const type = shaka.hls.HlsParser.getRequiredAttributeValue_(tag, 'TYPE');\n    goog.asserts.assert(type == 'CLOSED-CAPTIONS',\n        'Should only be called on tags with TYPE=\"CLOSED-CAPTIONS\"!');\n\n    const LanguageUtils = shaka.util.LanguageUtils;\n    const languageValue = tag.getAttributeValue('LANGUAGE') || 'und';\n    const language = LanguageUtils.normalize(languageValue);\n\n    // The GROUP-ID value is a quoted-string that specifies the group to which\n    // the Rendition belongs.\n    const groupId =\n        shaka.hls.HlsParser.getRequiredAttributeValue_(tag, 'GROUP-ID');\n\n    // The value of INSTREAM-ID is a quoted-string that specifies a Rendition\n    // within the segments in the Media Playlist. This attribute is REQUIRED if\n    // the TYPE attribute is CLOSED-CAPTIONS.\n    const instreamId =\n        shaka.hls.HlsParser.getRequiredAttributeValue_(tag, 'INSTREAM-ID');\n    if (!this.groupIdToClosedCaptionsMap_.get(groupId)) {\n      this.groupIdToClosedCaptionsMap_.set(groupId, new Map());\n    }\n    this.groupIdToClosedCaptionsMap_.get(groupId).set(instreamId, language);\n  }\n};\n\n\n/**\n * Parse EXT-X-MEDIA media tag into a Stream object.\n *\n * @param {shaka.hls.Tag} tag\n * @param {!Array.<string>} allCodecs\n * @return {!Promise.<?shaka.hls.HlsParser.StreamInfo>}\n * @private\n */\nshaka.hls.HlsParser.prototype.createStreamInfoFromMediaTag_ =\n    async function(tag, allCodecs) {\n  goog.asserts.assert(tag.name == 'EXT-X-MEDIA',\n                      'Should only be called on media tags!');\n\n  const HlsParser = shaka.hls.HlsParser;\n  const verbatimMediaPlaylistUri = HlsParser.getRequiredAttributeValue_(\n      tag, 'URI');\n\n  // Check if the stream has already been created as part of another Variant\n  // and return it if it has.\n  if (this.uriToStreamInfosMap_.has(verbatimMediaPlaylistUri)) {\n    return this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n  }\n\n  let type = HlsParser.getRequiredAttributeValue_(tag, 'TYPE').toLowerCase();\n  // Shaka recognizes the content types 'audio', 'video' and 'text'.\n  // The HLS 'subtitles' type needs to be mapped to 'text'.\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  if (type == 'subtitles') type = ContentType.TEXT;\n\n  const LanguageUtils = shaka.util.LanguageUtils;\n  let language = LanguageUtils.normalize(/** @type {string} */(\n      tag.getAttributeValue('LANGUAGE', 'und')));\n  const name = tag.getAttributeValue('NAME');\n\n  let defaultAttr = tag.getAttribute('DEFAULT');\n  let autoselectAttr = tag.getAttribute('AUTOSELECT');\n  // TODO: Should we take into account some of the currently ignored attributes:\n  // FORCED, INSTREAM-ID, CHARACTERISTICS, CHANNELS?\n  // Attribute descriptions: https://bit.ly/2lpjOhj\n  let channelsAttribute = tag.getAttributeValue('CHANNELS');\n  let channelsCount = type == 'audio' ?\n      this.getChannelCount_(channelsAttribute) : null;\n  let primary = !!defaultAttr || !!autoselectAttr;\n  const streamInfo = await this.createStreamInfo_(\n      verbatimMediaPlaylistUri, allCodecs, type, language, primary, name,\n      channelsCount, /* closedCaptions */ null);\n  if (streamInfo == null) return null;\n  // TODO: This check is necessary because of the possibility of multiple\n  // calls to createStreamInfoFromMediaTag_ before either has resolved.\n  if (this.uriToStreamInfosMap_.has(verbatimMediaPlaylistUri)) {\n    return this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n  }\n\n  this.mediaTagsToStreamInfosMap_.set(tag.id, streamInfo);\n  this.uriToStreamInfosMap_.set(verbatimMediaPlaylistUri, streamInfo);\n  return streamInfo;\n};\n\n\n/**\n * Get the channel count information for an HLS audio track.\n *\n * @param {?string} channels A string that specifies an ordered, \"/\" separated\n *   list of parameters.  If the type is audio, the first parameter will be a\n *   decimal integer specifying the number of independent, simultaneous audio\n *   channels.\n *   No other channels parameters are currently defined.\n * @return {?number} channelcount\n * @private\n */\nshaka.hls.HlsParser.prototype.getChannelCount_ = function(channels) {\n  if (!channels) return null;\n  let channelcountstring = channels.split('/')[0];\n  let count = parseInt(channelcountstring, 10);\n  return count;\n};\n\n\n/**\n * Parse an EXT-X-STREAM-INF media tag into a Stream object.\n *\n * @param {!shaka.hls.Tag} tag\n * @param {!Array.<string>} allCodecs\n * @param {string} type\n * @return {!Promise.<?shaka.hls.HlsParser.StreamInfo>}\n * @private\n */\nshaka.hls.HlsParser.prototype.createStreamInfoFromVariantTag_ =\n    async function(tag, allCodecs, type) {\n  goog.asserts.assert(tag.name == 'EXT-X-STREAM-INF',\n                      'Should only be called on media tags!');\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  const HlsParser = shaka.hls.HlsParser;\n  const verbatimMediaPlaylistUri = HlsParser.getRequiredAttributeValue_(\n      tag, 'URI');\n\n  if (this.uriToStreamInfosMap_.has(verbatimMediaPlaylistUri)) {\n    return this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n  }\n  // The attribute of closed captions is optional, and the value may be 'NONE'.\n  const closedCaptionsAttr = tag.getAttributeValue('CLOSED-CAPTIONS');\n\n  // EXT-X-STREAM-INF tags may have CLOSED-CAPTIONS attributes.\n  // The value can be either a quoted-string or an enumerated-string with the\n  // value NONE. If the value is a quoted-string, it MUST match the value of\n  // the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the Playlist\n  // whose TYPE attribute is CLOSED-CAPTIONS.\n  let closedCaptions = null;\n  if (type == ContentType.VIDEO && closedCaptionsAttr &&\n      closedCaptionsAttr != 'NONE') {\n    closedCaptions = this.groupIdToClosedCaptionsMap_.get(closedCaptionsAttr);\n  }\n\n  const streamInfo = await this.createStreamInfo_(verbatimMediaPlaylistUri,\n       allCodecs, type, /* language */ 'und', /* primary */ false,\n       /* name */ null, /* channelcount */ null, closedCaptions);\n  if (streamInfo == null) return null;\n  // TODO: This check is necessary because of the possibility of multiple\n  // calls to createStreamInfoFromVariantTag_ before either has resolved.\n  if (this.uriToStreamInfosMap_.has(verbatimMediaPlaylistUri)) {\n    return this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n  }\n\n  this.uriToStreamInfosMap_.set(verbatimMediaPlaylistUri, streamInfo);\n  return streamInfo;\n};\n\n\n/**\n * @param {string} verbatimMediaPlaylistUri\n * @param {!Array.<string>} allCodecs\n * @param {string} type\n * @param {string} language\n * @param {boolean} primary\n * @param {?string} name\n * @param {?number} channelsCount\n * @param {Map.<string, string>} closedCaptions\n * @return {!Promise.<?shaka.hls.HlsParser.StreamInfo>}\n * @throws shaka.util.Error\n * @private\n */\nshaka.hls.HlsParser.prototype.createStreamInfo_ = async function(\n    verbatimMediaPlaylistUri, allCodecs, type, language, primary, name,\n    channelsCount, closedCaptions) {\n  // TODO: Refactor, too many parameters\n  const Utils = shaka.hls.Utils;\n\n  let absoluteMediaPlaylistUri = Utils.constructAbsoluteUri(\n      this.masterPlaylistUri_, verbatimMediaPlaylistUri);\n\n  /** @type {!shaka.hls.Playlist} */\n  let playlist;\n  /** @type {string} */\n  let codecs = '';\n  /** @type {string} */\n  let mimeType;\n\n  const response = await this.requestManifest_(absoluteMediaPlaylistUri);\n  // Record the final URI after redirects.\n  absoluteMediaPlaylistUri = response.uri;\n\n  // Record the redirected, final URI of this media playlist when we parse it.\n  playlist = this.manifestTextParser_.parsePlaylist(\n      response.data, absoluteMediaPlaylistUri);\n\n  if (playlist.type != shaka.hls.PlaylistType.MEDIA) {\n    // EXT-X-MEDIA tags should point to media playlists.\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.HLS_INVALID_PLAYLIST_HIERARCHY);\n  }\n\n  /** @type {!Array.<!shaka.hls.Tag>} */\n  let drmTags = [];\n  playlist.segments.forEach(function(segment) {\n    const segmentKeyTags = Utils.filterTagsByName(segment.tags,\n                                                'EXT-X-KEY');\n    drmTags.push.apply(drmTags, segmentKeyTags);\n  });\n\n  let encrypted = false;\n  /** @type {!Array.<shaka.extern.DrmInfo>}*/\n  let drmInfos = [];\n  let keyId = null;\n\n  // TODO: May still need changes to support key rotation.\n  for (const drmTag of drmTags) {\n    let method =\n        shaka.hls.HlsParser.getRequiredAttributeValue_(drmTag, 'METHOD');\n    if (method != 'NONE') {\n      encrypted = true;\n\n      // We do not support AES-128 encryption with HLS yet. So, do not create\n      // StreamInfo for the playlist encrypted with AES-128.\n      // TODO: Remove the error message once we add support for AES-128.\n      if (method == 'AES-128') {\n        shaka.log.warning('Unsupported HLS Encryption', method);\n        this.aesEncrypted_ = true;\n        return null;\n      }\n\n      let keyFormat =\n          shaka.hls.HlsParser.getRequiredAttributeValue_(drmTag, 'KEYFORMAT');\n      let drmParser =\n          shaka.hls.HlsParser.KEYFORMATS_TO_DRM_PARSERS_[keyFormat];\n\n      let drmInfo = drmParser ? drmParser(drmTag) : null;\n      if (drmInfo) {\n        if (drmInfo.keyIds.length) {\n          keyId = drmInfo.keyIds[0];\n        }\n        drmInfos.push(drmInfo);\n      } else {\n        shaka.log.warning('Unsupported HLS KEYFORMAT', keyFormat);\n      }\n    }\n  }\n\n  if (encrypted && !drmInfos.length) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.HLS_KEYFORMATS_NOT_SUPPORTED);\n  }\n\n\n  goog.asserts.assert(playlist.segments != null,\n                      'Media playlist should have segments!');\n\n  this.determinePresentationType_(playlist);\n\n  codecs = this.guessCodecs_(type, allCodecs);\n  const mimeTypeArg = await this.guessMimeType_(type, codecs, playlist);\n\n  mimeType = mimeTypeArg;\n\n  let mediaSequenceTag = Utils.getFirstTagWithName(playlist.tags,\n                                                   'EXT-X-MEDIA-SEQUENCE');\n\n  let startPosition = mediaSequenceTag ? Number(mediaSequenceTag.value) : 0;\n\n  const segments = await this.createSegments_(\n      verbatimMediaPlaylistUri, playlist, startPosition, mimeType, codecs);\n\n  let minTimestamp = segments[0].startTime;\n  let lastEndTime = segments[segments.length - 1].endTime;\n  let duration = lastEndTime - minTimestamp;\n  let segmentIndex = new shaka.media.SegmentIndex(segments);\n\n  const initSegmentReference = this.createInitSegmentReference_(playlist);\n\n  let kind = undefined;\n  if (type == shaka.util.ManifestParserUtils.ContentType.TEXT) {\n    kind = shaka.util.ManifestParserUtils.TextStreamKind.SUBTITLE;\n  }\n\n\n  /** @type {shaka.extern.Stream} */\n  let stream = {\n    id: this.globalId_++,\n    originalId: name,\n    createSegmentIndex: Promise.resolve.bind(Promise),\n    findSegmentPosition: segmentIndex.find.bind(segmentIndex),\n    getSegmentReference: segmentIndex.get.bind(segmentIndex),\n    initSegmentReference: initSegmentReference,\n    presentationTimeOffset: 0,\n    mimeType: mimeType,\n    codecs: codecs,\n    kind: kind,\n    encrypted: encrypted,\n    keyId: keyId,\n    language: language,\n    label: name,  // For historical reasons, since before \"originalId\".\n    type: type,\n    primary: primary,\n    // TODO: trick mode\n    trickModeVideo: null,\n    emsgSchemeIdUris: null,\n    frameRate: undefined,\n    width: undefined,\n    height: undefined,\n    bandwidth: undefined,\n    roles: [],\n    channelsCount: channelsCount,\n    closedCaptions: closedCaptions,\n  };\n\n  return {\n    stream: stream,\n    segmentIndex: segmentIndex,\n    drmInfos: drmInfos,\n    verbatimMediaPlaylistUri: verbatimMediaPlaylistUri,\n    absoluteMediaPlaylistUri: absoluteMediaPlaylistUri,\n    minTimestamp: minTimestamp,\n    maxTimestamp: lastEndTime,\n    duration: duration,\n  };\n};\n\n\n/**\n * @param {!shaka.hls.Playlist} playlist\n * @private\n */\nshaka.hls.HlsParser.prototype.determinePresentationType_ = function(playlist) {\n  const Utils = shaka.hls.Utils;\n  const PresentationType = shaka.hls.HlsParser.PresentationType_;\n  let presentationTypeTag = Utils.getFirstTagWithName(playlist.tags,\n                                                      'EXT-X-PLAYLIST-TYPE');\n  let endListTag = Utils.getFirstTagWithName(playlist.tags, 'EXT-X-ENDLIST');\n\n  let isVod = (presentationTypeTag && presentationTypeTag.value == 'VOD') ||\n      endListTag;\n  let isEvent = presentationTypeTag && presentationTypeTag.value == 'EVENT' &&\n      !isVod;\n  let isLive = !isVod && !isEvent;\n\n  if (isVod) {\n    this.setPresentationType_(PresentationType.VOD);\n  } else {\n    // If it's not VOD, it must be presentation type LIVE or an ongoing EVENT.\n    if (isLive) {\n      this.setPresentationType_(PresentationType.LIVE);\n    } else {\n      this.setPresentationType_(PresentationType.EVENT);\n    }\n\n    let targetDurationTag = this.getRequiredTag_(playlist.tags,\n                                                 'EXT-X-TARGETDURATION');\n    let targetDuration = Number(targetDurationTag.value);\n\n    // According to the HLS spec, updates should not happen more often than\n    // once in targetDuration.  It also requires us to only update the active\n    // variant.  We might implement that later, but for now every variant\n    // will be updated.  To get the update period, choose the smallest\n    // targetDuration value across all playlists.\n\n    // Update the longest target duration if need be to use as a presentation\n    // delay later.\n    this.maxTargetDuration_ = Math.max(targetDuration, this.maxTargetDuration_);\n    // Update the shortest one to use as update period and segment availability\n    // time (for LIVE).\n    this.minTargetDuration_ = Math.min(targetDuration, this.minTargetDuration_);\n  }\n};\n\n\n/**\n * @param {number} lastTimestamp\n * @throws shaka.util.Error\n * @private\n */\nshaka.hls.HlsParser.prototype.createPresentationTimeline_ =\n    function(lastTimestamp) {\n  if (this.isLive_()) {\n    // The live edge will be calculated from segments, so we don't need to set\n    // a presentation start time.  We will assert later that this is working as\n    // expected.\n\n    // The HLS spec (RFC 8216) states in 6.3.3:\n    //\n    // \"The client SHALL choose which Media Segment to play first ... the\n    // client SHOULD NOT choose a segment that starts less than three target\n    // durations from the end of the Playlist file.  Doing so can trigger\n    // playback stalls.\"\n    //\n    // We accomplish this in our DASH-y model by setting a presentation delay\n    // of 3 segments.  This will be the \"live edge\" of the presentation.\n    this.presentationTimeline_ = new shaka.media.PresentationTimeline(\n        /* presentationStartTime */ 0, /* delay */ this.maxTargetDuration_ * 3);\n    this.presentationTimeline_.setStatic(false);\n  } else {\n    this.presentationTimeline_ = new shaka.media.PresentationTimeline(\n        /* presentationStartTime */ null, /* delay */ 0);\n    this.presentationTimeline_.setStatic(true);\n  }\n\n  this.notifySegments_();\n\n  // This asserts that the live edge is being calculated from segment times.\n  // For VOD and event streams, this check should still pass.\n  goog.asserts.assert(\n      !this.presentationTimeline_.usingPresentationStartTime(),\n      'We should not be using the presentation start time in HLS!');\n};\n\n\n/**\n * @param {!shaka.hls.Playlist} playlist\n * @return {shaka.media.InitSegmentReference}\n * @private\n * @throws {shaka.util.Error}\n */\nshaka.hls.HlsParser.prototype.createInitSegmentReference_ = function(playlist) {\n  const Utils = shaka.hls.Utils;\n  let mapTags = Utils.filterTagsByName(playlist.tags, 'EXT-X-MAP');\n  // TODO: Support multiple map tags?\n  // For now, we don't support multiple map tags and will throw an error.\n  if (!mapTags.length) {\n    return null;\n  } else if (mapTags.length > 1) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.HLS_MULTIPLE_MEDIA_INIT_SECTIONS_FOUND);\n  }\n\n  // Map tag example: #EXT-X-MAP:URI=\"main.mp4\",BYTERANGE=\"720@0\"\n  let mapTag = mapTags[0];\n  const verbatimInitSegmentUri =\n      shaka.hls.HlsParser.getRequiredAttributeValue_(mapTag, 'URI');\n  const absoluteInitSegmentUri =\n      Utils.constructAbsoluteUri(playlist.absoluteUri, verbatimInitSegmentUri);\n\n  let startByte = 0;\n  let endByte = null;\n  let byterange = mapTag.getAttributeValue('BYTERANGE');\n  // If a BYTERANGE attribute is not specified, the segment consists\n  // of the entire resource.\n  if (byterange) {\n    let blocks = byterange.split('@');\n    let byteLength = Number(blocks[0]);\n    startByte = Number(blocks[1]);\n    endByte = startByte + byteLength - 1;\n  }\n\n  return new shaka.media.InitSegmentReference(\n      () => [absoluteInitSegmentUri],\n      startByte,\n      endByte);\n};\n\n\n/**\n * Parses one shaka.hls.Segment object into a shaka.media.SegmentReference.\n *\n * @param {!shaka.hls.Playlist} playlist\n * @param {shaka.media.SegmentReference} previousReference\n * @param {!shaka.hls.Segment} hlsSegment\n * @param {number} position\n * @param {number} startTime\n * @return {!shaka.media.SegmentReference}\n * @private\n */\nshaka.hls.HlsParser.prototype.createSegmentReference_ =\n    function(playlist, previousReference, hlsSegment, position, startTime) {\n  const Utils = shaka.hls.Utils;\n  const tags = hlsSegment.tags;\n  const absoluteSegmentUri = hlsSegment.absoluteUri;\n\n  let extinfTag = this.getRequiredTag_(tags, 'EXTINF');\n  // The EXTINF tag format is '#EXTINF:<duration>,[<title>]'.\n  // We're interested in the duration part.\n  let extinfValues = extinfTag.value.split(',');\n  let duration = Number(extinfValues[0]);\n  let endTime = startTime + duration;\n\n  let startByte = 0;\n  let endByte = null;\n  let byterange = Utils.getFirstTagWithName(tags, 'EXT-X-BYTERANGE');\n\n  // If BYTERANGE is not specified, the segment consists of the entire resource.\n  if (byterange) {\n    let blocks = byterange.value.split('@');\n    let byteLength = Number(blocks[0]);\n    if (blocks[1]) {\n      startByte = Number(blocks[1]);\n    } else {\n      goog.asserts.assert(previousReference,\n                          'Cannot refer back to previous HLS segment!');\n      startByte = previousReference.endByte + 1;\n    }\n    endByte = startByte + byteLength - 1;\n  }\n\n  return new shaka.media.SegmentReference(\n      position,\n      startTime,\n      endTime,\n      () => [absoluteSegmentUri],\n      startByte,\n      endByte);\n};\n\n\n/** @private */\nshaka.hls.HlsParser.prototype.notifySegments_ = function() {\n  // The presentation timeline may or may not be set yet.\n  // If it does not yet exist, hold onto the segments until it does.\n  if (!this.presentationTimeline_) {\n    return;\n  }\n  this.segmentsToNotifyByStream_.forEach((segments) => {\n    // HLS doesn't have separate periods.\n    this.presentationTimeline_.notifySegments(segments, /* periodStart */ 0);\n  });\n  this.segmentsToNotifyByStream_ = [];\n};\n\n\n/**\n * Parses shaka.hls.Segment objects into shaka.media.SegmentReferences.\n *\n * @param {string} verbatimMediaPlaylistUri\n * @param {!shaka.hls.Playlist} playlist\n * @param {number} startPosition\n * @param {string} mimeType\n * @param {string} codecs\n * @return {!Promise<!Array.<!shaka.media.SegmentReference>>}\n * @private\n */\nshaka.hls.HlsParser.prototype.createSegments_ = async function(\n    verbatimMediaPlaylistUri, playlist, startPosition, mimeType, codecs) {\n  /** @type {Array.<!shaka.hls.Segment>} */\n  const hlsSegments = playlist.segments;\n  /** @type {!Array.<!shaka.media.SegmentReference>} */\n  const references = [];\n\n  goog.asserts.assert(hlsSegments.length, 'Playlist should have segments!');\n  // We may need to look at the media itself to determine a segment start time.\n  const firstSegmentUri = hlsSegments[0].absoluteUri;\n  const firstSegmentRef =\n      this.createSegmentReference_(\n          playlist,\n          null /* previousReference */,\n          hlsSegments[0],\n          startPosition,\n          0 /* startTime, irrelevant */);\n\n  const initSegmentRef = this.createInitSegmentReference_(playlist);\n\n  const firstStartTime = await this.getStartTime_(verbatimMediaPlaylistUri,\n                            initSegmentRef, firstSegmentRef, mimeType, codecs);\n  shaka.log.debug('First segment', firstSegmentUri.split('/').pop(),\n                  'starts at', firstStartTime);\n  for (let i = 0; i < hlsSegments.length; ++i) {\n    let hlsSegment = hlsSegments[i];\n    let previousReference = references[references.length - 1];\n    let startTime = (i == 0) ? firstStartTime : previousReference.endTime;\n    let position = startPosition + i;\n\n    let reference = this.createSegmentReference_(\n        playlist,\n        previousReference,\n        hlsSegment,\n        position,\n        startTime);\n    references.push(reference);\n  }\n\n  this.segmentsToNotifyByStream_.push(references);\n  this.notifySegments_();\n\n  return references;\n};\n\n\n/**\n * Try to fetch a partial segment, and fall back to a full segment if we have\n * to.\n *\n * @param {!shaka.media.AnySegmentReference} reference\n * @return {!Promise.<shaka.extern.Response>}\n * @throws {shaka.util.Error}\n * @private\n */\nshaka.hls.HlsParser.prototype.fetchPartialSegment_ = async function(reference) {\n  const RequestType = shaka.net.NetworkingEngine.RequestType;\n\n  // Create two requests:\n  //  1. A partial request meant to fetch the smallest part of the segment\n  //     required to get the time stamp.\n  //  2. A full request meant as a fallback for when the server does not support\n  //     partial requests.\n\n  const partialRequest = shaka.util.Networking.createSegmentRequest(\n      reference.getUris(),\n      reference.startByte,\n      reference.startByte + shaka.hls.HlsParser.PARTIAL_SEGMENT_SIZE_ - 1,\n      this.config_.retryParameters);\n\n  const fullRequest = shaka.util.Networking.createSegmentRequest(\n      reference.getUris(),\n      reference.startByte,\n      reference.endByte,\n      this.config_.retryParameters);\n\n  // TODO(vaage): The need to do fall back requests is not likely to be unique\n  //    to here. It would be nice if the fallback(s) could be included into the\n  //    same abortable operation as the original request.\n  //\n  //    What would need to change with networking engine to support requests\n  //    with fallback(s)?\n\n  try {\n    const response = await this.makeNetworkRequest_(\n        partialRequest, RequestType.SEGMENT);\n\n    return response;\n  } catch (e) {\n    // If the networking operation was aborted, we don't want to treat it as\n    // a request failure. We surface the error so that the OPERATION_ABORTED\n    // error will be handled correctly.\n    if (e.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n      throw e;\n    }\n\n    // The partial request may fail for a number of reasons.\n    // Some servers do not support Range requests, and others do not support\n    // the OPTIONS request which must be made before any cross-origin Range\n    // request.  Since this fallback is expensive, warn the app developer.\n    shaka.log.alwaysWarn('Unable to fetch a partial HLS segment! ' +\n                         'Falling back to a full segment request, ' +\n                         'which is expensive!  Your server should ' +\n                         'support Range requests and CORS preflights.',\n                         partialRequest.uris[0]);\n\n    const response = await this.makeNetworkRequest_(\n        fullRequest, RequestType.SEGMENT);\n\n    return response;\n  }\n};\n\n\n/**\n * Gets the start time of a segment from the existing manifest (if possible) or\n * by downloading it and parsing it otherwise.\n *\n * @param {string} verbatimMediaPlaylistUri\n * @param {shaka.media.InitSegmentReference} initSegmentRef\n * @param {!shaka.media.SegmentReference} segmentRef\n * @param {string} mimeType\n * @param {string} codecs\n * @return {!Promise.<number>}\n * @throws {shaka.util.Error}\n * @private\n */\nshaka.hls.HlsParser.prototype.getStartTime_ = async function(\n    verbatimMediaPlaylistUri, initSegmentRef, segmentRef, mimeType, codecs) {\n  // If we are updating the manifest, we can usually skip fetching the segment\n  // by examining the references we already have.  This won't be possible if\n  // there was some kind of lag or delay updating the manifest on the server,\n  // in which extreme case we would fall back to fetching a segment.  This\n  // allows us to both avoid fetching segments when possible, and recover from\n  // certain server-side issues gracefully.\n  if (this.manifest_) {\n    const streamInfo = this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n    const segmentIndex = streamInfo.segmentIndex;\n    const reference = segmentIndex.get(segmentRef.position);\n    if (reference) {\n      // We found it!  Avoid fetching and parsing the segment.\n      shaka.log.v1('Found segment start time in previous manifest');\n      return reference.startTime;\n    }\n\n    shaka.log.debug('Unable to find segment start time in previous manifest!');\n  }\n\n  // TODO: Introduce a new tag to extend HLS and provide the first segment's\n  // start time.  This will avoid the need for these fetches in content packaged\n  // with Shaka Packager.  This web-friendly extension to HLS can then be\n  // proposed to Apple for inclusion in a future version of HLS.\n  // See https://github.com/google/shaka-packager/issues/294\n\n  shaka.log.v1('Fetching segment to find start time');\n\n  if (mimeType == 'audio/mpeg') {\n    // There is no standard way to embed timestamps in mp3 files, so the\n    // start time is presumably 0.\n    return 0;\n  }\n\n  if (mimeType == 'video/mp4' || mimeType == 'audio/mp4') {\n    // We also need the init segment to get the correct timescale. But if the\n    // stream is self-initializing, use the same response for both.\n    const fetches = [this.fetchPartialSegment_(segmentRef)];\n\n    if (initSegmentRef) {\n      fetches.push(this.fetchPartialSegment_(initSegmentRef));\n    }\n\n    const responses = await Promise.all(fetches);\n\n    // If the stream is self-initializing, use the main segment in-place of the\n    // init segment.\n    const segmentResponse = responses[0];\n    const initSegmentResponse = responses[1] || responses[0];\n\n    return this.getStartTimeFromMp4Segment_(\n        segmentResponse.data, initSegmentResponse.data);\n  }\n\n  if (mimeType == 'video/mp2t') {\n    const response = await this.fetchPartialSegment_(segmentRef);\n    goog.asserts.assert(response.data, 'Should have a response body!');\n    return this.getStartTimeFromTsSegment_(response.data);\n  }\n\n  if (mimeType == 'application/mp4' || mimeType.startsWith('text/')) {\n    const response = await this.fetchPartialSegment_(segmentRef);\n    goog.asserts.assert(response.data, 'Should have a response body!');\n    return this.getStartTimeFromTextSegment_(mimeType, codecs, response.data);\n  }\n\n  // TODO(vaage): Add support for additional formats.\n  //\n  //   Formats:\n  //    - WebM\n  //    - AAC\n  //\n  //    Since we want to add more formats, how would a more general registry\n  //    system work to allow additional formats to be \"plugged-into\" the\n  //    parser.\n\n  throw new shaka.util.Error(\n      shaka.util.Error.Severity.CRITICAL,\n      shaka.util.Error.Category.MANIFEST,\n      shaka.util.Error.Code.HLS_COULD_NOT_PARSE_SEGMENT_START_TIME);\n};\n\n\n/**\n * Parses an mp4 segment to get its start time.\n *\n * @param {!ArrayBuffer} mediaData\n * @param {!ArrayBuffer} initData\n * @return {number}\n * @throws {shaka.util.Error}\n * @private\n */\nshaka.hls.HlsParser.prototype.getStartTimeFromMp4Segment_ =\n    function(mediaData, initData) {\n  const Mp4Parser = shaka.util.Mp4Parser;\n\n  let timescale = 0;\n  new Mp4Parser()\n      .box('moov', Mp4Parser.children)\n      .box('trak', Mp4Parser.children)\n      .box('mdia', Mp4Parser.children)\n      .fullBox('mdhd', function(box) {\n        goog.asserts.assert(\n            box.version == 0 || box.version == 1,\n            'MDHD version can only be 0 or 1');\n\n        // Skip \"creation_time\" and \"modification_time\".\n        // They are 4 bytes each if the mdhd box is version 0, 8 bytes each if\n        // it is version 1.\n        box.reader.skip(box.version == 0 ? 8 : 16);\n\n        timescale = box.reader.readUint32();\n        box.parser.stop();\n      }).parse(initData, true /* partialOkay */);\n\n  if (!timescale) {\n    shaka.log.error('Unable to find timescale in init segment!');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.HLS_COULD_NOT_PARSE_SEGMENT_START_TIME);\n  }\n\n  let startTime = 0;\n  let parsedMedia = false;\n  new Mp4Parser()\n      .box('moof', Mp4Parser.children)\n      .box('traf', Mp4Parser.children)\n      .fullBox('tfdt', function(box) {\n        goog.asserts.assert(\n            box.version == 0 || box.version == 1,\n            'TFDT version can only be 0 or 1');\n        let baseTime = (box.version == 0) ?\n            box.reader.readUint32() :\n            box.reader.readUint64();\n        startTime = baseTime / timescale;\n        parsedMedia = true;\n        box.parser.stop();\n      }).parse(mediaData, true /* partialOkay */);\n\n  if (!parsedMedia) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.HLS_COULD_NOT_PARSE_SEGMENT_START_TIME);\n  }\n  return startTime;\n};\n\n\n/**\n * Parses a TS segment to get its start time.\n *\n * @param {!ArrayBuffer} data\n * @return {number}\n * @throws {shaka.util.Error}\n * @private\n */\nshaka.hls.HlsParser.prototype.getStartTimeFromTsSegment_ = function(data) {\n  let reader = new shaka.util.DataViewReader(\n      new DataView(data), shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n  const fail = function() {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.HLS_COULD_NOT_PARSE_SEGMENT_START_TIME);\n  };\n\n  let packetStart = 0;\n  let syncByte = 0;\n\n  const skipPacket = function() {\n    // 188-byte packets are standard, so assume that.\n    reader.seek(packetStart + 188);\n    syncByte = reader.readUint8();\n    if (syncByte != 0x47) {\n      // We haven't found the sync byte, so try it as a 192-byte packet.\n      reader.seek(packetStart + 192);\n      syncByte = reader.readUint8();\n    }\n    if (syncByte != 0x47) {\n      // We still haven't found the sync byte, so try as a 204-byte packet.\n      reader.seek(packetStart + 204);\n      syncByte = reader.readUint8();\n    }\n    if (syncByte != 0x47) {\n      // We still haven't found the sync byte, so the packet was of a\n      // non-standard size.\n      fail();\n    }\n    // Put the sync byte back so we can read it in the next loop.\n    reader.rewind(1);\n  };\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    // Format reference: https://bit.ly/TsPacket\n    packetStart = reader.getPosition();\n\n    syncByte = reader.readUint8();\n    if (syncByte != 0x47) fail();\n\n    let flagsAndPacketId = reader.readUint16();\n    let hasPesPacket = flagsAndPacketId & 0x4000;\n    if (!hasPesPacket) fail();\n\n    let flags = reader.readUint8();\n    let adaptationFieldControl = (flags & 0x30) >> 4;\n    if (adaptationFieldControl == 0 /* reserved */ ||\n        adaptationFieldControl == 2 /* adaptation field, no payload */) {\n      fail();\n    }\n\n    if (adaptationFieldControl == 3) {\n      // Skip over adaptation field.\n      let length = reader.readUint8();\n      reader.skip(length);\n    }\n\n    // Now we come to the PES header (hopefully).\n    // Format reference: https://bit.ly/TsPES\n    let startCode = reader.readUint32();\n    let startCodePrefix = startCode >> 8;\n    if (startCodePrefix != 1) {\n      // Not a PES packet yet.  Skip this TS packet and try again.\n      skipPacket();\n      continue;\n    }\n\n    // Skip the 16-bit PES length and the first 8 bits of the optional header.\n    reader.skip(3);\n    // The next 8 bits contain flags about DTS & PTS.\n    let ptsDtsIndicator = reader.readUint8() >> 6;\n    if (ptsDtsIndicator == 0 /* no timestamp */ ||\n        ptsDtsIndicator == 1 /* forbidden */) {\n      fail();\n    }\n\n    let pesHeaderLengthRemaining = reader.readUint8();\n    if (pesHeaderLengthRemaining == 0) {\n      fail();\n    }\n\n    if (ptsDtsIndicator == 2 /* PTS only */) {\n      goog.asserts.assert(pesHeaderLengthRemaining == 5, 'Bad PES header?');\n    } else if (ptsDtsIndicator == 3 /* PTS and DTS */) {\n      goog.asserts.assert(pesHeaderLengthRemaining == 10, 'Bad PES header?');\n    }\n\n    let pts0 = reader.readUint8();\n    let pts1 = reader.readUint16();\n    let pts2 = reader.readUint16();\n    // Reconstruct 33-bit PTS from the 5-byte, padded structure.\n    let ptsHigh3 = (pts0 & 0x0e) >> 1;\n    let ptsLow30 = ((pts1 & 0xfffe) << 14) | ((pts2 & 0xfffe) >> 1);\n    // Reconstruct the PTS as a float.  Avoid bitwise operations to combine\n    // because bitwise ops treat the values as 32-bit ints.\n    let pts = ptsHigh3 * (1 << 30) + ptsLow30;\n    return pts / shaka.hls.HlsParser.TS_TIMESCALE_;\n  }\n};\n\n\n/**\n * Parses a text segment to get its start time.\n *\n * @param {string} mimeType\n * @param {string} codecs\n * @param {!ArrayBuffer} data\n * @return {number}\n * @throws {shaka.util.Error}\n * @private\n */\nshaka.hls.HlsParser.prototype.getStartTimeFromTextSegment_ =\n    function(mimeType, codecs, data) {\n  let fullMimeType = shaka.util.MimeUtils.getFullType(mimeType, codecs);\n  if (!shaka.text.TextEngine.isTypeSupported(fullMimeType)) {\n    // We won't be able to parse this, but it will be filtered out anyway.\n    // So we don't have to care about the start time.\n    return 0;\n  }\n\n  let textEngine = new shaka.text.TextEngine(/* displayer */ null);\n  textEngine.initParser(fullMimeType);\n  return textEngine.getStartTime(data);\n};\n\n\n/**\n * Filters out duplicate codecs from the codec list.\n * @param {!Array.<string>} codecs\n * @return {!Array.<string>}\n * @private\n */\nshaka.hls.HlsParser.filterDuplicateCodecs_ = function(codecs) {\n  const seen = new Set();\n  const ret = [];\n  for (const codec of codecs) {\n    // HLS says the CODECS field needs to include all codecs that appear in the\n    // content.  This means that if the content changes profiles, it should\n    // include both.  Since all known browsers support changing profiles without\n    // any other work, just ignore them  See also:\n    // https://github.com/google/shaka-player/issues/1817\n    const shortCodec = shaka.util.MimeUtils.getCodecBase(codec);\n    if (!seen.has(shortCodec)) {\n      ret.push(codec);\n      seen.add(shortCodec);\n    } else {\n      shaka.log.debug('Ignoring duplicate codec');\n    }\n  }\n  return ret;\n};\n\n\n/**\n * Attempts to guess which codecs from the codecs list belong to a given content\n * type.  Does not assume a single codec is anything special, and does not throw\n * if it fails to match.\n *\n * @param {string} contentType\n * @param {!Array.<string>} codecs\n * @return {?string} or null if no match is found\n * @private\n */\nshaka.hls.HlsParser.prototype.guessCodecsSafe_ = function(contentType, codecs) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  const HlsParser = shaka.hls.HlsParser;\n  let formats = HlsParser.CODEC_REGEXPS_BY_CONTENT_TYPE_[contentType];\n\n  for (let i = 0; i < formats.length; i++) {\n    for (let j = 0; j < codecs.length; j++) {\n      if (formats[i].test(codecs[j].trim())) {\n        return codecs[j].trim();\n      }\n    }\n  }\n\n  // Text does not require a codec string.\n  if (contentType == ContentType.TEXT) {\n    return '';\n  }\n\n  return null;\n};\n\n\n/**\n * Attempts to guess which codecs from the codecs list belong to a given content\n * type.  Assumes that at least one codec is correct, and throws if none are.\n *\n * @param {string} contentType\n * @param {!Array.<string>} codecs\n * @return {string}\n * @private\n * @throws {shaka.util.Error}\n */\nshaka.hls.HlsParser.prototype.guessCodecs_ = function(contentType, codecs) {\n  if (codecs.length == 1) {\n    return codecs[0];\n  }\n\n  let match = this.guessCodecsSafe_(contentType, codecs);\n  // A failure is specifically denoted by null; an empty string represents a\n  // valid match of no codec.\n  if (match != null) {\n    return match;\n  }\n\n  // Unable to guess codecs.\n  throw new shaka.util.Error(\n      shaka.util.Error.Severity.CRITICAL,\n      shaka.util.Error.Category.MANIFEST,\n      shaka.util.Error.Code.HLS_COULD_NOT_GUESS_CODECS,\n      codecs);\n};\n\n\n/**\n * Attempts to guess stream's mime type based on content type and URI.\n *\n * @param {string} contentType\n * @param {string} codecs\n * @param {!shaka.hls.Playlist} playlist\n * @return {!Promise.<string>}\n * @private\n * @throws {shaka.util.Error}\n */\nshaka.hls.HlsParser.prototype.guessMimeType_ =\n    async function(contentType, codecs, playlist) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  const HlsParser = shaka.hls.HlsParser;\n  const RequestType = shaka.net.NetworkingEngine.RequestType;\n\n  goog.asserts.assert(playlist.segments.length,\n                      'Playlist should have segments!');\n  const firstSegmentUri = playlist.segments[0].absoluteUri;\n\n  let parsedUri = new goog.Uri(firstSegmentUri);\n  let extension = parsedUri.getPath().split('.').pop();\n  let map = HlsParser.EXTENSION_MAP_BY_CONTENT_TYPE_[contentType];\n\n  let mimeType = map[extension];\n  if (mimeType) {\n    return mimeType;\n  }\n\n  if (contentType == ContentType.TEXT) {\n    // The extension map didn't work.\n    if (!codecs || codecs == 'vtt') {\n      // If codecs is 'vtt', it's WebVTT.\n      // If there was no codecs string, assume HLS text streams are WebVTT.\n      return 'text/vtt';\n    } else {\n      // Otherwise, assume MP4-embedded text, since text-based formats tend not\n      // to have a codecs string at all.\n      return 'application/mp4';\n    }\n  }\n\n  // If unable to guess mime type, request a segment and try getting it\n  // from the response.\n  let headRequest = shaka.net.NetworkingEngine.makeRequest(\n      [firstSegmentUri], this.config_.retryParameters);\n  headRequest.method = 'HEAD';\n\n  const response = await this.makeNetworkRequest_(\n      headRequest, RequestType.SEGMENT);\n\n  const contentMimeType = response.headers['content-type'];\n\n  if (!contentMimeType) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.HLS_COULD_NOT_GUESS_MIME_TYPE,\n        extension);\n  }\n\n  // Split the MIME type in case the server sent additional parameters.\n  return contentMimeType.split(';')[0];\n};\n\n\n/**\n * Find the attribute and returns its value.\n * Throws an error if attribute was not found.\n *\n * @param {shaka.hls.Tag} tag\n * @param {string} attributeName\n * @return {string}\n * @private\n * @throws {shaka.util.Error}\n */\nshaka.hls.HlsParser.getRequiredAttributeValue_ = function(tag, attributeName) {\n  let attribute = tag.getAttribute(attributeName);\n  if (!attribute) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.HLS_REQUIRED_ATTRIBUTE_MISSING,\n        attributeName);\n  }\n\n  return attribute.value;\n};\n\n\n/**\n * Returns a tag with a given name.\n * Throws an error if tag was not found.\n *\n * @param {!Array.<shaka.hls.Tag>} tags\n * @param {string} tagName\n * @return {!shaka.hls.Tag}\n * @private\n * @throws {shaka.util.Error}\n */\nshaka.hls.HlsParser.prototype.getRequiredTag_ = function(tags, tagName) {\n  const Utils = shaka.hls.Utils;\n  let tag = Utils.getFirstTagWithName(tags, tagName);\n  if (!tag) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.HLS_REQUIRED_TAG_MISSING, tagName);\n  }\n\n  return tag;\n};\n\n\n/**\n * @param {shaka.extern.Stream} stream\n * @param {?string} width\n * @param {?string} height\n * @param {?string} frameRate\n * @private\n */\nshaka.hls.HlsParser.prototype.addVideoAttributes_ =\n    function(stream, width, height, frameRate) {\n  if (stream) {\n    stream.width = Number(width) || undefined;\n    stream.height = Number(height) || undefined;\n    stream.frameRate = Number(frameRate) || undefined;\n  }\n};\n\n\n/**\n * Makes a network request for the manifest and returns a Promise\n * with the resulting data.\n *\n * @param {string} absoluteUri\n * @return {!Promise.<!shaka.extern.Response>}\n * @private\n */\nshaka.hls.HlsParser.prototype.requestManifest_ = function(absoluteUri) {\n  const RequestType = shaka.net.NetworkingEngine.RequestType;\n\n  const request = shaka.net.NetworkingEngine.makeRequest(\n      [absoluteUri], this.config_.retryParameters);\n\n  return this.makeNetworkRequest_(request, RequestType.MANIFEST);\n};\n\n\n/**\n * A list of regexps to detect well-known video codecs.\n *\n * @const {!Array.<!RegExp>}\n * @private\n */\nshaka.hls.HlsParser.VIDEO_CODEC_REGEXPS_ = [\n  /^avc/,\n  /^hev/,\n  /^hvc/,\n  /^vp0?[89]/,\n  /^av1$/,\n];\n\n\n/**\n * A list of regexps to detect well-known audio codecs.\n *\n * @const {!Array.<!RegExp>}\n * @private\n */\nshaka.hls.HlsParser.AUDIO_CODEC_REGEXPS_ = [\n  /^vorbis$/,\n  /^opus$/,\n  /^flac$/,\n  /^mp4a/,\n  /^[ae]c-3$/,\n];\n\n\n/**\n * A list of regexps to detect well-known text codecs.\n *\n * @const {!Array.<!RegExp>}\n * @private\n */\nshaka.hls.HlsParser.TEXT_CODEC_REGEXPS_ = [\n  /^vtt$/,\n  /^wvtt/,\n  /^stpp/,\n];\n\n\n/**\n * @const {!Object.<string, !Array.<!RegExp>>}\n * @private\n */\nshaka.hls.HlsParser.CODEC_REGEXPS_BY_CONTENT_TYPE_ = {\n  'audio': shaka.hls.HlsParser.AUDIO_CODEC_REGEXPS_,\n  'video': shaka.hls.HlsParser.VIDEO_CODEC_REGEXPS_,\n  'text': shaka.hls.HlsParser.TEXT_CODEC_REGEXPS_,\n};\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.hls.HlsParser.AUDIO_EXTENSIONS_TO_MIME_TYPES_ = {\n  'mp4': 'audio/mp4',\n  'm4s': 'audio/mp4',\n  'm4i': 'audio/mp4',\n  'm4a': 'audio/mp4',\n  // MPEG2-TS also uses video/ for audio: https://bit.ly/TsMse\n  'ts': 'video/mp2t',\n};\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.hls.HlsParser.VIDEO_EXTENSIONS_TO_MIME_TYPES_ = {\n  'mp4': 'video/mp4',\n  'm4s': 'video/mp4',\n  'm4i': 'video/mp4',\n  'm4v': 'video/mp4',\n  'ts': 'video/mp2t',\n};\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.hls.HlsParser.TEXT_EXTENSIONS_TO_MIME_TYPES_ = {\n  'mp4': 'application/mp4',\n  'm4s': 'application/mp4',\n  'm4i': 'application/mp4',\n  'vtt': 'text/vtt',\n  'ttml': 'application/ttml+xml',\n};\n\n\n/**\n * @const {!Object.<string, !Object.<string, string>>}\n * @private\n */\nshaka.hls.HlsParser.EXTENSION_MAP_BY_CONTENT_TYPE_ = {\n  'audio': shaka.hls.HlsParser.AUDIO_EXTENSIONS_TO_MIME_TYPES_,\n  'video': shaka.hls.HlsParser.VIDEO_EXTENSIONS_TO_MIME_TYPES_,\n  'text': shaka.hls.HlsParser.TEXT_EXTENSIONS_TO_MIME_TYPES_,\n};\n\n\n/**\n * @typedef {function(!shaka.hls.Tag):?shaka.extern.DrmInfo}\n * @private\n */\nshaka.hls.HlsParser.DrmParser_;\n\n\n/**\n * @param {!shaka.hls.Tag} drmTag\n * @return {?shaka.extern.DrmInfo}\n * @private\n */\nshaka.hls.HlsParser.widevineDrmParser_ = function(drmTag) {\n  const HlsParser = shaka.hls.HlsParser;\n  let method = HlsParser.getRequiredAttributeValue_(drmTag, 'METHOD');\n  shaka.Deprecate.deprecateFeature(\n      2, 6,\n      'HLS SAMPLE-AES-CENC',\n      'SAMPLE-AES-CENC will no longer be supported, see Issue #1227');\n  const VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];\n  if (!VALID_METHODS.includes(method)) {\n    shaka.log.error('Widevine in HLS is only supported with [',\n                    VALID_METHODS.join(', '), '], not', method);\n    return null;\n  }\n\n  let uri = HlsParser.getRequiredAttributeValue_(drmTag, 'URI');\n  let parsedData = shaka.net.DataUriPlugin.parse(uri);\n\n  // The data encoded in the URI is a PSSH box to be used as init data.\n  let pssh = new Uint8Array(parsedData.data);\n  let drmInfo = shaka.util.ManifestParserUtils.createDrmInfo(\n      'com.widevine.alpha', [\n        {initDataType: 'cenc', initData: pssh},\n      ]);\n\n  let keyId = drmTag.getAttributeValue('KEYID');\n  if (keyId) {\n    // This value should begin with '0x':\n    goog.asserts.assert(keyId.startsWith('0x'), 'Incorrect KEYID format!');\n    // But the output should not contain the '0x':\n    drmInfo.keyIds = [keyId.substr(2).toLowerCase()];\n  }\n  return drmInfo;\n};\n\n\n/**\n * Called when the update timer ticks. Because parsing a manifest is async,\n * this method is async. To work with this, this method will schedule the next\n * update when it finished instead of using a repeating-start.\n *\n * @return {!Promise}\n * @private\n */\nshaka.hls.HlsParser.prototype.onUpdate_ = async function() {\n  shaka.log.info('Updating manifest...');\n\n  goog.asserts.assert(\n      this.updatePlaylistDelay_ > 0,\n      'We should only call |onUpdate_| when we are suppose to be updating.');\n\n  // Detect a call to stop()\n  if (!this.playerInterface_) {\n    return;\n  }\n\n  try {\n    await this.update();\n\n    const delay = this.updatePlaylistDelay_;\n    this.updatePlaylistTimer_.tickAfter(/* seconds= */ delay);\n  } catch (error) {\n    goog.asserts.assert(error instanceof shaka.util.Error,\n                        'Should only receive a Shaka error');\n\n    // We will retry updating, so override the severity of the error.\n    error.severity = shaka.util.Error.Severity.RECOVERABLE;\n    this.playerInterface_.onError(error);\n\n    // Try again very soon.\n    this.updatePlaylistTimer_.tickAfter(/* seconds= */ 0.1);\n  }\n};\n\n\n/**\n * @return {boolean}\n * @private\n */\nshaka.hls.HlsParser.prototype.isLive_ = function() {\n  const PresentationType = shaka.hls.HlsParser.PresentationType_;\n  return this.presentationType_ != PresentationType.VOD;\n};\n\n\n/**\n * @param {shaka.hls.HlsParser.PresentationType_} type\n * @private\n */\nshaka.hls.HlsParser.prototype.setPresentationType_ = function(type) {\n  this.presentationType_ = type;\n\n  if (this.presentationTimeline_) {\n    this.presentationTimeline_.setStatic(!this.isLive_());\n  }\n\n  // If this manifest is not for live content, then we have no reason to\n  // update it.\n  if (!this.isLive_()) {\n    this.updatePlaylistTimer_.stop();\n  }\n};\n\n\n/**\n * Create a networking request. This will manage the request using the parser's\n * operation manager. If the parser has already been stopped, the request will\n * not be made.\n *\n * @param {shaka.extern.Request} request\n * @param {shaka.net.NetworkingEngine.RequestType} type\n * @return {!Promise.<shaka.extern.Response>}\n * @private\n */\nshaka.hls.HlsParser.prototype.makeNetworkRequest_ = function(request, type) {\n  if (!this.operationManager_) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.OPERATION_ABORTED);\n  }\n\n  const op = this.playerInterface_.networkingEngine.request(type, request);\n  this.operationManager_.manage(op);\n\n  return op.promise;\n};\n\n\n/**\n * @const {!Object.<string, shaka.hls.HlsParser.DrmParser_>}\n * @private\n */\nshaka.hls.HlsParser.KEYFORMATS_TO_DRM_PARSERS_ = {\n  /* TODO: https://github.com/google/shaka-player/issues/382\n  'com.apple.streamingkeydelivery':\n      shaka.hls.HlsParser.fairplayDrmParser_,\n  */\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed':\n      shaka.hls.HlsParser.widevineDrmParser_,\n};\n\n\n/**\n * @enum {string}\n * @private\n */\nshaka.hls.HlsParser.PresentationType_ = {\n  VOD: 'VOD',\n  EVENT: 'EVENT',\n  LIVE: 'LIVE',\n};\n\n\n/**\n * @const {number}\n * @private\n */\nshaka.hls.HlsParser.TS_TIMESCALE_ = 90000;\n\n\n/**\n * At this value, timestamps roll over in TS content.\n * @const {number}\n * @private\n */\nshaka.hls.HlsParser.TS_ROLLOVER_ = 0x200000000;\n\n\n/**\n * The amount of data from the start of a segment we will try to fetch when we\n * need to know the segment start time.  This allows us to avoid fetching the\n * entire segment in many cases.\n *\n * @const {number}\n * @private\n */\nshaka.hls.HlsParser.PARTIAL_SEGMENT_SIZE_ = 2048;\n\n\nshaka.media.ManifestParser.registerParserByExtension(\n    'm3u8', shaka.hls.HlsParser);\nshaka.media.ManifestParser.registerParserByMime(\n    'application/x-mpegurl', shaka.hls.HlsParser);\nshaka.media.ManifestParser.registerParserByMime(\n    'application/vnd.apple.mpegurl', shaka.hls.HlsParser);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.ActiveStreamMap');\n\n\n/**\n * A structure used to track which streams were last used in any given period.\n *\n * @final\n */\nshaka.media.ActiveStreamMap = class {\n  constructor() {\n    /**\n     * A mapping between a period and the content last streamed in that period.\n     *\n     * @private {!Map.<shaka.extern.Period, !shaka.media.ActiveStreamMap.Frame>}\n     */\n    this.history_ = new Map();\n  }\n\n  /**\n   * Clear the history.\n   */\n  clear() {\n    // Clear the map to release references to the periods (the key). This\n    // assumes that the references will be broken by doing this.\n    this.history_.clear();\n  }\n\n  /**\n   * Set the variant that was last playing in |period|. Setting it to |null| is\n   * the same as saying \"we were playing no variant in this period\".\n   *\n   * @param {shaka.extern.Period} period\n   * @param {?shaka.extern.Variant} variant\n   */\n  useVariant(period, variant) {\n    this.getFrameFor_(period).variant = variant;\n  }\n\n  /**\n   * Set the text stream that was last displayed in |period|. Setting it to\n   * |null| is the same as saying \"we were displaying no text in this period\".\n   *\n   * @param {shaka.extern.Period} period\n   * @param {?shaka.extern.Stream} stream\n   */\n  useText(period, stream) {\n    this.getFrameFor_(period).text = stream;\n  }\n\n  /**\n   * Get the variant that was playing in the given period. If no variant  was\n   * playing this period or the period had not started playing, then |null| will\n   * be returned.\n   *\n   * @param {shaka.extern.Period} period\n   * @return {?shaka.extern.Variant}\n   */\n  getVariant(period) {\n    return this.getFrameFor_(period).variant;\n  }\n\n  /**\n   * Get the text stream that was playing in the given period. If no text\n   * stream was playing this period or the period had not started playing, then\n   * |null| will be returned.\n   *\n   * @param {shaka.extern.Period} period\n   * @return {?shaka.extern.Stream}\n   */\n  getText(period) {\n    return this.getFrameFor_(period).text;\n  }\n\n  /**\n   * Get the frame for a period. This will ensure that a frame exists for the\n   * given period.\n   *\n   * @param {shaka.extern.Period} period\n   * @return {!shaka.media.ActiveStreamMap.Frame}\n   * @private\n   */\n  getFrameFor_(period) {\n    if (!this.history_.has(period)) {\n      const frame = new shaka.media.ActiveStreamMap.Frame();\n      this.history_.set(period, frame);\n    }\n\n    return this.history_.get(period);\n  }\n};\n\n\n/**\n * A structure used to track which streams were played during a specific\n * time frame.\n *\n * @final\n */\nshaka.media.ActiveStreamMap.Frame = class {\n  constructor() {\n    /** @type {?shaka.extern.Variant} */\n    this.variant = null;\n    /** @type {?shaka.extern.Stream} */\n    this.text = null;\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.AdaptationSet');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.MimeUtils');\n\n\n/**\n * A set of variants that we want to adapt between.\n *\n * @final\n */\nshaka.media.AdaptationSet = class {\n  /**\n   * @param {shaka.extern.Variant} root\n   *    The variant that all other variants will be tested against when being\n   *    added to the adaptation set. If a variant is not compatible with the\n   *    root, it will not be added.\n   * @param {!Iterable.<shaka.extern.Variant>=} candidates\n   *    Variants that may be compatible with the root and should be added if\n   *    compatible. If a candidate is not compatible, it will not end up in the\n   *    adaptation set.\n   */\n  constructor(root, candidates) {\n    /** @private {shaka.extern.Variant} */\n    this.root_ = root;\n    /** @private {!Set.<shaka.extern.Variant>} */\n    this.variants_ = new Set([root]);\n\n    // Try to add all the candidates. If they cannot be added (because they\n    // are not compatible with the root, they will be rejected by |add|.\n    candidates = candidates || [];\n    for (const candidate of candidates) {\n      this.add(candidate);\n    }\n  }\n\n  /**\n   * @param {shaka.extern.Variant} variant\n   * @return {boolean}\n   */\n  add(variant) {\n    if (this.canInclude(variant)) {\n      this.variants_.add(variant);\n      return true;\n    }\n\n    // To be nice, issue a warning if someone is trying to add something that\n    // they shouldn't.\n    shaka.log.warning('Rejecting variant - not compatible with root.');\n    return false;\n  }\n\n  /**\n   * Check if |variant| can be included with the set. If |canInclude| returns\n   * |false|, calling |add| will result in it being ignored.\n   *\n   * @param {shaka.extern.Variant} variant\n   * @return {boolean}\n   */\n  canInclude(variant) {\n    return shaka.media.AdaptationSet.areAdaptable(this.root_, variant);\n  }\n\n  /**\n   * @param {shaka.extern.Variant} a\n   * @param {shaka.extern.Variant} b\n   * @return {boolean}\n   */\n  static areAdaptable(a, b) {\n    const AdaptationSet = shaka.media.AdaptationSet;\n\n    // All variants should have audio or should all not have audio.\n    if (!!a.audio != !!b.audio) {\n      return false;\n    }\n\n    // All variants should have video or should all not have video.\n    if (!!a.video != !!b.video) {\n      return false;\n    }\n\n    // If the languages don't match, we should not adapt between them.\n    if (a.language != b.language) {\n      return false;\n    }\n\n    goog.asserts.assert(\n        !!a.audio == !!b.audio,\n        'Both should either have audio or not have audio.');\n    if (a.audio && b.audio &&\n        !AdaptationSet.areAudiosCompatible_(a.audio, b.audio)) {\n      return false;\n    }\n\n    goog.asserts.assert(\n        !!a.video == !!b.video,\n        'Both should either have video or not have video.');\n    if (a.video && b.video &&\n        !AdaptationSet.areVideosCompatible_(a.video, b.video)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * @return {!Iterable.<shaka.extern.Variant>}\n   */\n  values() {\n    return this.variants_.values();\n  }\n\n  /**\n   * Check if we can switch between two audio streams.\n   *\n   * @param {shaka.extern.Stream} a\n   * @param {shaka.extern.Stream} b\n   * @return {boolean}\n   * @private\n   */\n  static areAudiosCompatible_(a, b) {\n    const AdaptationSet = shaka.media.AdaptationSet;\n\n    // Audio channel counts must not change between adaptations.\n    if (a.channelsCount != b.channelsCount) {\n      return false;\n    }\n\n    // We can only adapt between base-codecs.\n    if (!AdaptationSet.canTransitionBetween_(a, b)) {\n      return false;\n    }\n\n    // Audio roles must not change between adaptations.\n    if (!AdaptationSet.areRolesEqual_(a.roles, b.roles)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if we can switch between two video streams.\n   *\n   * @param {shaka.extern.Stream} a\n   * @param {shaka.extern.Stream} b\n   * @return {boolean}\n   * @private\n   */\n  static areVideosCompatible_(a, b) {\n    const AdaptationSet = shaka.media.AdaptationSet;\n\n    // We can only adapt between base-codecs.\n    if (!AdaptationSet.canTransitionBetween_(a, b)) {\n      return false;\n    }\n\n    // Video roles must not change between adaptations.\n    if (!AdaptationSet.areRolesEqual_(a.roles, b.roles)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if we can switch between two streams based on their codec and mime\n   * type.\n   *\n   * @param {shaka.extern.Stream} a\n   * @param {shaka.extern.Stream} b\n   * @return {boolean}\n   * @private\n   */\n  static canTransitionBetween_(a, b) {\n    if (a.mimeType != b.mimeType) {\n      return false;\n    }\n\n\n    // Get the base codec of each codec in each stream.\n    const codecsA = shaka.util.MimeUtils.splitCodecs(a.codecs).map((codec) => {\n      return shaka.util.MimeUtils.getCodecBase(codec);\n    });\n    const codecsB = shaka.util.MimeUtils.splitCodecs(b.codecs).map((codec) => {\n      return shaka.util.MimeUtils.getCodecBase(codec);\n    });\n\n    // We don't want to allow switching between transmuxed and non-transmuxed\n    // content so the number of codecs should be the same.\n    //\n    // To avoid the case where an codec is used for audio and video we will\n    // codecs using arrays (not sets). While at this time, there are no codecs\n    // that work for audio and video, it is possible for \"raw\" codecs to be\n    // which would share the same name.\n    if (codecsA.length != codecsB.length) {\n      return false;\n    }\n\n    // Sort them so that we can walk through them and compare them\n    // element-by-element.\n    codecsA.sort();\n    codecsB.sort();\n\n    for (let i = 0; i < codecsA.length; i++) {\n      if (codecsA[i] != codecsB[i]) { return false; }\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if two role lists are the equal. This will take into account all\n   * unique behaviours when comparing roles.\n   *\n   * @param {!Iterable.<string>} a\n   * @param {!Iterable.<string>} b\n   * @return {boolean}\n   * @private\n   */\n  static areRolesEqual_(a, b) {\n    const aSet = new Set(a);\n    const bSet = new Set(b);\n\n    // Remove the main role from the role lists (we expect to see them only\n    // in dash manifests).\n    const mainRole = 'main';\n    aSet.delete(mainRole);\n    bSet.delete(mainRole);\n\n    // Make sure that we have the same number roles in each list. Make sure to\n    // do it after correcting for 'main'.\n    if (aSet.size != bSet.size) { return false; }\n\n    // Because we know the two sets are the same size, if any item is missing\n    // if means that they are not the same.\n    for (const x of aSet) {\n      if (!bSet.has(x)) { return false; }\n    }\n\n    return true;\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.AdaptationSetCriteria');\ngoog.provide('shaka.media.ExampleBasedCriteria');\ngoog.provide('shaka.media.PreferenceBasedCriteria');\n\ngoog.require('shaka.media.AdaptationSet');\n\n\n/**\n * An adaptation set criteria is a unit of logic that can take a set of\n * variants and return a subset of variants that should (and can) be\n * adapted between.\n *\n * @interface\n */\nshaka.media.AdaptationSetCriteria = class {\n  /**\n   * Take a set of variants, and return a subset of variants that can be\n   * adapted between.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @return {!shaka.media.AdaptationSet}\n   */\n  create(variants) {}\n};\n\n\n/**\n * @implements {shaka.media.AdaptationSetCriteria}\n * @final\n */\nshaka.media.ExampleBasedCriteria = class {\n  /**\n   * @param {shaka.extern.Variant} example\n   */\n  constructor(example) {\n    /** @private {shaka.extern.Variant} */\n    this.example_ = example;\n\n    // We can't know what role is really the most important, so we don't use\n    // role for this.\n    const role = '';\n    const channelCount = example.audio && example.audio.channelsCount ?\n                         example.audio.channelsCount :\n                         0;\n\n    /** @private {!shaka.media.AdaptationSetCriteria} */\n    this.fallback_ = new shaka.media.PreferenceBasedCriteria(\n        example.language, role, channelCount);\n  }\n\n  /** @override */\n  create(variants) {\n    // We can't assume that the example is |variants| because it could actually\n    // be from another period.\n    const shortList = variants.filter((variant) => {\n      return shaka.media.AdaptationSet.areAdaptable(this.example_, variant);\n    });\n\n    if (shortList.length) {\n      // Use the first item in the short list as the root. It should not matter\n      // which element we use as all items in the short list should already be\n      // compatible.\n      return new shaka.media.AdaptationSet(shortList[0], shortList);\n    } else {\n      return this.fallback_.create(variants);\n    }\n  }\n};\n\n\n/**\n * @implements {shaka.media.AdaptationSetCriteria}\n * @final\n */\nshaka.media.PreferenceBasedCriteria = class {\n  /**\n   * @param {string} language\n   * @param {string} role\n   * @param {number} channelCount\n   */\n  constructor(language, role, channelCount) {\n    /** @private {string} */\n    this.language_ = language;\n    /** @private {string} */\n    this.role_ = role;\n    /** @private {number} */\n    this.channelCount_ = channelCount;\n  }\n\n  /** @override */\n  create(variants) {\n    const Class = shaka.media.PreferenceBasedCriteria;\n    const StreamUtils = shaka.util.StreamUtils;\n\n    let current = [];\n\n    const byLanguage = Class.filterByLanguage_(variants, this.language_);\n    const byPrimary = variants.filter((variant) => variant.primary);\n\n    if (byLanguage.length) {\n      current = byLanguage;\n    } else if (byPrimary.length) {\n      current = byPrimary;\n    } else {\n      current = variants;\n    }\n\n    // Now refine the choice based on role preference.\n    if (this.role_) {\n      const byRole = Class.filterVariantsByRole_(current, this.role_);\n      if (byRole.length) {\n        current = byRole;\n      } else {\n        shaka.log.warning('No exact match for variant role could be found.');\n      }\n    }\n\n    if (this.channelCount_) {\n      const byChannel = StreamUtils.filterVariantsByAudioChannelCount(\n          current, this.channelCount_);\n      if (byChannel.length) {\n        current = byChannel;\n      } else {\n        shaka.log.warning(\n            'No exact match for the channel count could be found.');\n      }\n    }\n\n    // Make sure we only return a valid adaptation set.\n    const set = new shaka.media.AdaptationSet(current[0]);\n    for (const variant of current) {\n      if (set.canInclude(variant)) {\n        set.add(variant);\n      }\n    }\n\n    return set;\n  }\n\n  /**\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {string} preferredLanguage\n   * @return {!Array.<shaka.extern.Variant>}\n   * @private\n   */\n  static filterByLanguage_(variants, preferredLanguage) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    /** @type {string} */\n    const preferredLocale = LanguageUtils.normalize(preferredLanguage);\n\n    /** @type {?string} */\n    const closestLocale = LanguageUtils.findClosestLocale(\n        preferredLocale,\n        variants.map((variant) => LanguageUtils.getLocaleForVariant(variant)));\n\n    // There were no locales close to what we preferred.\n    if (!closestLocale) {\n      return [];\n    }\n\n    // Find the variants that use the closest variant.\n    return variants.filter((variant) => {\n      return closestLocale == LanguageUtils.getLocaleForVariant(variant);\n    });\n  }\n\n  /**\n   * Filter Variants by role.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {string} preferredRole\n   * @return {!Array.<shaka.extern.Variant>}\n   * @private\n   */\n  static filterVariantsByRole_(variants, preferredRole) {\n    return variants.filter((variant) => {\n      const audio = variant.audio;\n      const video = variant.video;\n      return (audio && audio.roles.indexOf(preferredRole) >= 0) ||\n             (video && video.roles.indexOf(preferredRole) >= 0);\n    });\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.BufferingObserver');\n\n\n/**\n * The buffering observer watches how much content has been buffered and raises\n * events when the state changes (enough => not enough or vice versa).\n *\n * @final\n */\nshaka.media.BufferingObserver = class {\n  /**\n   * @param {number} thresholdWhenStarving\n   * @param {number} thresholdWhenSatisfied\n   */\n  constructor(thresholdWhenStarving, thresholdWhenSatisfied) {\n    const State = shaka.media.BufferingObserver.State;\n\n    /** @private {shaka.media.BufferingObserver.State} */\n    this.previousState_ = State.SATISFIED;\n\n    /** @private {!Map.<shaka.media.BufferingObserver.State, number>} */\n    this.thresholds_ = new Map()\n        .set(State.SATISFIED, thresholdWhenSatisfied)\n        .set(State.STARVING, thresholdWhenStarving);\n  }\n\n  /**\n   * Update the observer by telling it how much content has been buffered (in\n   * seconds) and if we are buffered to the end of the presentation. If the\n   * controller believes the state has changed, it will return |true|.\n   *\n   * @param {number} bufferLead\n   * @param {boolean} bufferedToEnd\n   * @return {boolean}\n   */\n  update(bufferLead, bufferedToEnd) {\n    const State = shaka.media.BufferingObserver.State;\n\n    /**\n     * Our threshold for how much we need before we declare ourselves as\n     * starving is based on whether or not we were just starving. If we\n     * were just starving, we are more likely to starve again, so we require\n     * more content to be buffered than if we were not just starving.\n     *\n     * @type {number}\n     */\n    const threshold = this.thresholds_.get(this.previousState_);\n\n    const oldState = this.previousState_;\n    const newState = (bufferedToEnd || bufferLead >= threshold) ?\n                     (State.SATISFIED) :\n                     (State.STARVING);\n\n    // Save the new state now so that calls to |getState| from any callbacks\n    // will be accurate.\n    this.previousState_ = newState;\n\n    // Return |true| only when the state has changed.\n    return oldState != newState;\n  }\n\n  /**\n   * Set which state that the observer should think playback was in.\n   *\n   * @param {shaka.media.BufferingObserver.State} state\n   */\n  setState(state) {\n    this.previousState_ = state;\n  }\n\n  /**\n   * Get the state that the observer last thought playback was in.\n   *\n   * @return {shaka.media.BufferingObserver.State}\n   */\n  getState() {\n    return this.previousState_;\n  }\n};\n\n/**\n * Rather than using booleans to communicate what state we are in, we have this\n * enum.\n *\n * @enum {number}\n */\nshaka.media.BufferingObserver.State = {\n  STARVING: 0,\n  SATISFIED: 1,\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.StallDetector');\ngoog.provide('shaka.media.StallDetector.Implementation');\ngoog.provide('shaka.media.StallDetector.MediaElementImplementation');\n\n/**\n * Some platforms/browsers can get stuck in the middle of a buffered range (e.g.\n * when seeking in a background tab). Detect when we get stuck so that the\n * player can respond.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.StallDetector = class {\n  /**\n   * @param {shaka.media.StallDetector.Implementation} implementation\n   * @param {number} stallThresholdSeconds\n   */\n  constructor(implementation, stallThresholdSeconds) {\n    /** @private {shaka.media.StallDetector.Implementation} */\n    this.implementation_ = implementation;\n\n    /** @private {boolean} */\n    this.wasMakingProgress_ = implementation.shouldBeMakingProgress();\n    /** @private {number} */\n    this.value_ = implementation.getPresentationSeconds();\n    /** @private {number} */\n    this.lastUpdateSeconds_ = implementation.getWallSeconds();\n\n    /**\n     * The amount of time in seconds that we must have the same value of\n     * |value_| before we declare it as a stall.\n     *\n     * @private {number}\n     */\n    this.stallThresholdSeconds_ = stallThresholdSeconds;\n\n    /** @private {function(number, number)} */\n    this.onStall_ = () => {};\n  }\n\n  /** @override */\n  release() {\n    // Drop external references to make things easier on the GC.\n    this.implementation_ = null;\n    this.onStall_ = () => {};\n  }\n\n  /**\n   * Set the callback that should be called when a stall is detected. Calling\n   * this will override any previous calls to |onStall|.\n   *\n   * @param {function(number, number)} doThis\n   */\n  onStall(doThis) {\n    this.onStall_ = doThis;\n  }\n\n  /**\n   * Have the detector update itself and fire the \"on stall\" callback if a stall\n   * was detected.\n   */\n  poll() {\n    const impl = this.implementation_;\n\n    const shouldBeMakingProgress = impl.shouldBeMakingProgress();\n    const value = impl.getPresentationSeconds();\n    const wallTimeSeconds = impl.getWallSeconds();\n\n    const acceptUpdate = this.value_ != value ||\n                         this.wasMakingProgress_ != shouldBeMakingProgress;\n\n    if (acceptUpdate) {\n      this.lastUpdateSeconds_ = wallTimeSeconds;\n      this.value_ = value;\n      this.wasMakingProgress_ = shouldBeMakingProgress;\n    }\n\n    const stallSeconds = wallTimeSeconds - this.lastUpdateSeconds_;\n\n    const triggerCallback = stallSeconds >= this.stallThresholdSeconds_ &&\n                            shouldBeMakingProgress;\n\n    if (triggerCallback) {\n      this.onStall_(this.value_, stallSeconds);\n    }\n  }\n};\n\n/**\n * @interface\n */\nshaka.media.StallDetector.Implementation = class {\n  /**\n   * Check if the presentation time should be changing. This will return |true|\n   * when we expect the presentation time to change.\n   *\n   * @return {boolean}\n   */\n  shouldBeMakingProgress() {}\n\n  /**\n   * Get the presentation time in seconds.\n   *\n   * @return {number}\n   */\n  getPresentationSeconds() {}\n\n  /**\n   * Get the time wall time in seconds.\n   *\n   * @return {number}\n   */\n  getWallSeconds() {}\n};\n\n\n/**\n * Some platforms/browsers can get stuck in the middle of a buffered range (e.g.\n * when seeking in a background tab). Force a seek to help get it going again.\n *\n * @implements {shaka.media.StallDetector.Implementation}\n * @final\n */\nshaka.media.StallDetector.MediaElementImplementation = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   */\n  constructor(mediaElement) {\n    /** @private {!HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n  }\n\n  /** @override */\n  shouldBeMakingProgress() {\n    // If we are not trying to play, the lack of change could be misidentified\n    // as a stall.\n    if (this.mediaElement_.paused) { return false; }\n    if (this.mediaElement_.playbackRate == 0) { return false; }\n\n    // If we have don't have enough content, we are not stalled, we are\n    // buffering.\n    if (this.mediaElement_.buffered == null) { return false; }\n\n    return shaka.media.StallDetector.MediaElementImplementation.hasContentFor_(\n        this.mediaElement_.buffered,\n        /* timeInSeconds= */ this.mediaElement_.currentTime);\n  }\n\n  /** @override */\n  getPresentationSeconds() {\n    return this.mediaElement_.currentTime;\n  }\n\n  /** @override */\n  getWallSeconds() {\n    return Date.now() / 1000;\n  }\n\n  /**\n   * Check if we have buffered enough content to play at |timeInSeconds|. Ignore\n   * the end of the buffered range since it may not play any more on all\n   * platforms.\n   *\n   * @param {!TimeRanges} buffered\n   * @param {number} timeInSeconds\n   * @return {boolean}\n   * @private\n   */\n  static hasContentFor_(buffered, timeInSeconds) {\n    for (let i = 0; i < buffered.length; i++) {\n      const bufferedStart = buffered.start(i);\n      const bufferedEnd = buffered.end(i);\n\n      if (timeInSeconds < bufferedStart) { continue; }\n      if (timeInSeconds > bufferedEnd - 0.5) { continue; }\n\n      return true;\n    }\n\n    return false;\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.GapJumpingController');\n\ngoog.require('shaka.log');\ngoog.require('shaka.media.StallDetector');\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * Creates a new GapJumpingController that handles jumping gaps that appear\n * within the content.  This will only jump gaps between two buffered ranges,\n * so we should not have to worry about the availability window.\n *\n * @param {!HTMLMediaElement} video\n * @param {!shaka.media.PresentationTimeline} timeline\n * @param {shaka.extern.StreamingConfiguration} config\n * @param {shaka.media.StallDetector} stallDetector\n *   The stall detector is used to keep the playhead moving while in a playable\n *   region. The gap jumping controller takes ownership over the stall detector.\n *   If no stall detection logic is desired, |null| may be provided.\n * @param {function(!Event)} onEvent Called when an event is raised to be sent\n *   to the application.\n *\n * @constructor\n * @struct\n * @implements {shaka.util.IReleasable}\n */\nshaka.media.GapJumpingController = function(\n    video, timeline, config, stallDetector, onEvent) {\n  /** @private {HTMLMediaElement} */\n  this.video_ = video;\n\n  /** @private {?shaka.media.PresentationTimeline} */\n  this.timeline_ = timeline;\n\n  /** @private {?shaka.extern.StreamingConfiguration} */\n  this.config_ = config;\n\n  /** @private {?function(!Event)} */\n  this.onEvent_ = onEvent;\n\n  /** @private {shaka.util.EventManager} */\n  this.eventManager_ = new shaka.util.EventManager();\n\n  /** @private {boolean} */\n  this.seekingEventReceived_ = false;\n\n  /** @private {number} */\n  this.prevReadyState_ = video.readyState;\n\n  /** @private {boolean} */\n  this.didFireLargeGap_ = false;\n\n  /**\n   * The stall detector tries to keep the playhead moving forward. It is managed\n   * by the gap-jumping controller to avoid conflicts. On some platforms, the\n   * stall detector is not wanted, so it may be null.\n   *\n   * @private {shaka.media.StallDetector}\n   */\n  this.stallDetector_ = stallDetector;\n\n  /** @private {boolean} */\n  this.hadSegmentAppended_ = false;\n\n  this.eventManager_.listen(video, 'waiting', () => this.onPollGapJump_());\n\n  /**\n   * We can't trust |readyState| or 'waiting' events on all platforms. To make\n   * up for this, we poll the current time. If we think we are in a gap, jump\n   * out of it.\n   *\n   * See: https://bit.ly/2McuXxm and https://bit.ly/2K5xmJO\n   *\n   * @private {?shaka.util.Timer}\n   */\n  this.gapJumpTimer_ = new shaka.util.Timer(() => {\n    this.onPollGapJump_();\n  }).tickEvery(/* seconds= */ 0.25);\n};\n\n\n/**\n * The limit, in seconds, for the gap size that we will assume the browser will\n * handle for us.\n * @const\n */\nshaka.media.GapJumpingController.BROWSER_GAP_TOLERANCE = 0.001;\n\n\n/** @override */\nshaka.media.GapJumpingController.prototype.release = function() {\n  if (this.eventManager_) {\n    this.eventManager_.release();\n    this.eventManager_ = null;\n  }\n\n  if (this.gapJumpTimer_ != null) {\n    this.gapJumpTimer_.stop();\n    this.gapJumpTimer_ = null;\n  }\n\n  if (this.stallDetector_) {\n    this.stallDetector_.release();\n    this.stallDetector_ = null;\n  }\n\n  this.onEvent_ = null;\n  this.timeline_ = null;\n  this.video_ = null;\n};\n\n\n/**\n * Called when a segment is appended by StreamingEngine, but not when a clear is\n * pending.  This means StreamingEngine will continue buffering forward from\n * what is buffered.  So we know about any gaps before the start.\n */\nshaka.media.GapJumpingController.prototype.onSegmentAppended = function() {\n  this.hadSegmentAppended_ = true;\n  this.onPollGapJump_();\n};\n\n\n/** Called when a seek has started. */\nshaka.media.GapJumpingController.prototype.onSeeking = function() {\n  this.seekingEventReceived_ = true;\n  this.hadSegmentAppended_ = false;\n  this.didFireLargeGap_ = false;\n};\n\n\n/**\n * Called on a recurring timer to check for gaps in the media.  This is also\n * called in a 'waiting' event.\n *\n * @private\n */\nshaka.media.GapJumpingController.prototype.onPollGapJump_ = function() {\n  // Don't gap jump before the video is ready to play.\n  if (this.video_.readyState == 0) return;\n  // Do not gap jump if seeking has begun, but the seeking event has not\n  // yet fired for this particular seek.\n  if (this.video_.seeking) {\n    if (!this.seekingEventReceived_) {\n      return;\n    }\n  } else {\n    this.seekingEventReceived_ = false;\n  }\n  // Don't gap jump while paused, so that you don't constantly jump ahead while\n  // paused on a livestream.\n  if (this.video_.paused) return;\n\n\n  // When the ready state changes, we have moved on, so we should fire the large\n  // gap event if we see one.\n  if (this.video_.readyState != this.prevReadyState_) {\n    this.didFireLargeGap_ = false;\n    this.prevReadyState_ = this.video_.readyState;\n  }\n\n  const smallGapLimit = this.config_.smallGapLimit;\n  let currentTime = this.video_.currentTime;\n  let buffered = this.video_.buffered;\n\n  let gapIndex = shaka.media.TimeRangesUtils.getGapIndex(buffered, currentTime);\n\n  // The current time is unbuffered or is too far from a gap.\n  if (gapIndex == null) {\n    if (this.stallDetector_) {\n      this.stallDetector_.poll();\n    }\n\n    return;\n  }\n\n  // If we are before the first buffered range, this could be an unbuffered\n  // seek.  So wait until a segment is appended so we are sure it is a gap.\n  if (gapIndex == 0 && !this.hadSegmentAppended_) {\n    return;\n  }\n\n  // StreamingEngine can buffer past the seek end, but still don't allow seeking\n  // past it.\n  let jumpTo = buffered.start(gapIndex);\n  let seekEnd = this.timeline_.getSeekRangeEnd();\n  if (jumpTo >= seekEnd) {\n    return;\n  }\n\n  let jumpSize = jumpTo - currentTime;\n  let isGapSmall = jumpSize <= smallGapLimit;\n  let jumpLargeGap = false;\n\n  // If we jump to exactly the gap start, we may detect a small gap due to\n  // rounding errors or browser bugs.  We can ignore these extremely small gaps\n  // since the browser should play through them for us.\n  if (jumpSize < shaka.media.GapJumpingController.BROWSER_GAP_TOLERANCE) {\n    return;\n  }\n\n  if (!isGapSmall && !this.didFireLargeGap_) {\n    this.didFireLargeGap_ = true;\n\n    // Event firing is synchronous.\n    let event = new shaka.util.FakeEvent(\n        'largegap', {'currentTime': currentTime, 'gapSize': jumpSize});\n    event.cancelable = true;\n    this.onEvent_(event);\n\n    if (this.config_.jumpLargeGaps && !event.defaultPrevented) {\n      jumpLargeGap = true;\n    } else {\n      shaka.log.info('Ignoring large gap at', currentTime, 'size', jumpSize);\n    }\n  }\n\n  if (isGapSmall || jumpLargeGap) {\n    if (gapIndex == 0) {\n      shaka.log.info(\n          'Jumping forward', jumpSize,\n          'seconds because of gap before start time of', jumpTo);\n    } else {\n      shaka.log.info(\n          'Jumping forward', jumpSize, 'seconds because of gap starting at',\n          buffered.end(gapIndex - 1), 'and ending at', jumpTo);\n    }\n\n    this.video_.currentTime = jumpTo;\n  }\n};\n\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.IPlayheadObserver');\ngoog.provide('shaka.media.PlayheadObserverManager');\n\ngoog.require('shaka.util.IReleasable');\n\n\n/**\n * A playhead observer is a system that watches for meaningful changes in state\n * that are dependent on playhead information. The observer is responsible for\n * managing its own listeners.\n *\n * @extends {shaka.util.IReleasable}\n * @interface\n */\nshaka.media.IPlayheadObserver = class {\n  /**\n   * Check again (using an update playhead summary) if an event should be fired.\n   * If an event should be fired, fire it.\n   *\n   * @param {number} positionInSeconds\n   * @param {boolean} wasSeeking\n   */\n  poll(positionInSeconds, wasSeeking) {}\n};\n\n\n/**\n * The playhead observer mananger is responsible for owning playhead observer\n * instances and polling them when needed. Destroying the manager will destroy\n * all observers managed by the manager.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.PlayheadObserverManager = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   */\n  constructor(mediaElement) {\n    /** @private {HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n\n    /**\n     * The set of all observers that this manager is responsible for updating.\n     * We are using a set to ensure that we don't double update an observer if\n     * it is accidentally added twice.\n     *\n     * @private {!Set.<shaka.media.IPlayheadObserver>}\n     */\n    this.observers_ = new Set();\n\n    /**\n     * To fire events semi-accurately, poll the observers 4 times a second. This\n     * should be frequent enough to trigger an event close enough to its actual\n     * occurrence without the user noticing a delay.\n     *\n     * @private {shaka.util.Timer}\n     */\n    this.pollingLoop_ = new shaka.util.Timer(() => {\n      this.pollAllObservers_(/* seeking= */ false);\n    }).tickEvery(/* seconds= */ 0.25);\n  }\n\n  /** @override */\n  release() {\n    // We need to stop the loop or else we may try to use a released resource.\n    this.pollingLoop_.stop();\n\n    for (const observer of this.observers_) {\n      observer.release();\n    }\n\n    this.observers_.clear();\n  }\n\n  /**\n   * Have the playhead observer manager manage a new observer. This will ensure\n   * that observers are only tracked once within the manager. After this call,\n   * the manager will be responsible for the life cycle of |observer|.\n   *\n   * @param {!shaka.media.IPlayheadObserver} observer\n   */\n  manage(observer) {\n    this.observers_.add(observer);\n  }\n\n  /**\n   * Notify all the observers that we just seeked.\n   */\n  notifyOfSeek() {\n    this.pollAllObservers_(/* seeking= */ true);\n  }\n\n  /**\n   * @param {boolean} seeking\n   * @private\n   */\n  pollAllObservers_(seeking) {\n    for (const observer of this.observers_) {\n      observer.poll(\n          this.mediaElement_.currentTime,\n          seeking);\n    }\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.Periods');\n\n\n/**\n * This is a collection of period-focused utility methods.\n *\n * @final\n */\nshaka.util.Periods = class {\n  /**\n   * Get all the variants across all periods.\n   *\n   * @param {!Iterable.<shaka.extern.Period>} periods\n   * @return {!Array.<shaka.extern.Variant>}\n   */\n  static getAllVariantsFrom(periods) {\n    const found = [];\n\n    for (const period of periods) {\n      for (const variant of period.variants) {\n        found.push(variant);\n      }\n    }\n\n    return found;\n  }\n\n  /**\n   * Find our best guess at which period contains the given time. If\n   * |timeInSeconds| starts before the first period, then |null| will be\n   * returned.\n   *\n   * @param {!Iterable.<shaka.extern.Period>} periods\n   * @param {number} timeInSeconds\n   * @return {?shaka.extern.Period}\n   */\n  static findPeriodForTime(periods, timeInSeconds) {\n    let bestGuess = null;\n\n    // Go period-by-period and see if the period started before our current\n    // time. If so, we could be in that period. Since periods are supposed to be\n    // in order by start time, we can allow later periods to override our best\n    // guess.\n    for (const period of periods) {\n      if (timeInSeconds >= period.startTime) {\n        bestGuess = period;\n      }\n    }\n\n    return bestGuess;\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.PeriodObserver');\n\ngoog.require('shaka.media.IPlayheadObserver');\ngoog.require('shaka.util.Periods');\n\n\n/**\n * The period observer keeps track of which period we are in and calls the\n * |onPeriodChange| callback whenever we change periods.\n *\n * @implements {shaka.media.IPlayheadObserver}\n * @final\n */\nshaka.media.PeriodObserver = class {\n  /**\n   * The period observer needs an always-up-to-date collection of periods,\n   * and right now the only way to have that is to reference the manifest.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   */\n  constructor(manifest) {\n    /** @private {?shaka.extern.Manifest} */\n    this.manifest_ = manifest;\n\n    /**\n     * This will be which period we think the playhead is currently in. If it is\n     * |null|, it means we don't know. We say \"we think\" because this may become\n     * out-of-date between updates.\n     *\n     * @private {?shaka.extern.Period}\n     */\n    this.currentPeriod_ = null;\n\n    /**\n     * The callback for when we change periods. To avoid null-checks, assign it\n     * a no-op when there is no external callback assigned to it. When we move\n     * into a new period, this callback will be called with the new period.\n     *\n     * @private {function(shaka.extern.Period)}\n     */\n    this.onChangedPeriods_ = (period) => {};\n  }\n\n  /** @override */\n  release() {\n    // Break all internal references.\n    this.manifest_ = null;\n    this.currentPeriod_ = null;\n    this.onChangedPeriods_ = (period) => {};\n  }\n\n  /** @override */\n  poll(positionInSeconds, wasSeeking) {\n    // We detect changes in period by comparing where we think we are against\n    // where we actually are.\n    const expectedPeriod = this.currentPeriod_;\n    const actualPeriod = this.findCurrentPeriod_(positionInSeconds);\n    if (expectedPeriod != actualPeriod) {\n      this.onChangedPeriods_(actualPeriod);\n    }\n    // Make sure we are up-to-date.\n    this.currentPeriod_ = actualPeriod;\n  }\n\n  /**\n   * Set all callbacks. This will override any previous calls to |setListeners|.\n   *\n   * @param {function(shaka.extern.Period)} onChangedPeriods\n   *    The callback for when we move to a new period.\n   */\n  setListeners(onChangedPeriods) {\n    this.onChangedPeriods_ = onChangedPeriods;\n  }\n\n  /**\n   * Find which period we are most likely in based on the current manifest and\n   * current time. The value here may be different than |this.currentPeriod_|,\n   * if that is true, it means we changed periods since the last time we updated\n   * |this.currentPeriod_|.\n   *\n   * @param {number} currentTimeSeconds\n   * @return {shaka.extern.Period}\n   * @private\n   */\n  findCurrentPeriod_(currentTimeSeconds) {\n    const periods = this.manifest_.periods;\n\n    const found = shaka.util.Periods.findPeriodForTime(\n        periods,\n        currentTimeSeconds);\n\n    // Fallback to periods[0] so that it can never be null. If we join a live\n    // stream, periods[0].startTime may be non-zero. We can't guarantee that\n    // video.currentTime will always be inside the seek range so it may be\n    // possible to call findCurrentPeriod_(beforeFirstPeriod).\n    return found || periods[0];\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.PlayRateController');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n/**\n * The play rate controller controls the playback rate on the media element.\n * This provides some missing functionality (e.g. negative playback rate). If\n * the playback rate on the media element can change outside of the controller,\n * the playback controller will need to be updated to stay in-sync.\n *\n * TODO: Try not to manage buffering above the browser with playbackRate=0.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.PlayRateController = class {\n  /**\n   * @param {shaka.media.PlayRateController.Harness} harness\n   */\n  constructor(harness) {\n    /** @private {?shaka.media.PlayRateController.Harness} */\n    this.harness_ = harness;\n\n    /** @private {boolean} */\n    this.isBuffering_ = false;\n\n    /** @private {number} */\n    this.rate_ = this.harness_.getRate();\n\n    /** @private {number} */\n    this.pollRate_ = 0.25;\n\n    /** @private {shaka.util.Timer} */\n    this.timer_ = new shaka.util.Timer(() => {\n      this.harness_.movePlayhead(this.rate_ * this.pollRate_);\n    });\n  }\n\n  /** @override */\n  release() {\n    if (this.timer_) {\n      this.timer_.stop();\n      this.timer_ = null;\n    }\n\n    this.harness_ = null;\n  }\n\n  /**\n   * Sets the buffering flag, which controls the effective playback rate.\n   *\n   * @param {boolean} isBuffering If true, forces playback rate to 0 internally.\n   */\n  setBuffering(isBuffering) {\n    this.isBuffering_ = isBuffering;\n    this.apply_();\n  }\n\n  /**\n   * Set the playback rate. This rate will only be used as provided when the\n   * player is not buffering. You should never set the rate to 0.\n   *\n   * @param {number} rate\n   */\n  set(rate) {\n    goog.asserts.assert(rate != 0, 'Should never set rate of 0 explicitly!');\n    this.rate_ = rate;\n    this.apply_();\n  }\n\n  /**\n   * Get the rate that the user will experience. This means that if we are using\n   * trick play, this will report the trick play rate. If we are buffering, this\n   * will report zero. If playback is occurring as normal, this will report 1.\n   *\n   * @return {number}\n   */\n  getActiveRate() {\n    return this.calculateCurrentRate_();\n  }\n\n  /**\n   * Reapply the effects of |this.rate_| and |this.active_| to the media\n   * element. This will only update the rate via the harness if the desired rate\n   * has changed.\n   *\n   * @private\n   */\n  apply_() {\n    // Always stop the timer. We may not start it again.\n    this.timer_.stop();\n\n    /** @type {number} */\n    const rate = this.calculateCurrentRate_();\n\n    if (rate >= 0) {\n      try {\n        this.applyRate_(rate);\n        return;\n      } catch (e) {\n        // Fall through to the next clause.\n        //\n        // Fast forward is accomplished through setting video.playbackRate.\n        // If the play rate value is not supported by the browser (too big),\n        // the browsers will throw.\n        // Use this as a cue to fall back to fast forward through repeated\n        // seeking, which is what we do for rewind as well.\n      }\n    }\n\n    // When moving backwards or forwards in large steps,\n    // set the playback rate to 0 so that we can manually\n    // seek backwards with out fighting the playhead.\n    this.timer_.tickEvery(this.pollRate_);\n    this.applyRate_(0);\n  }\n\n  /**\n   * Calculate the rate that the controller wants the media element to have\n   * based on the current state of the controller.\n   *\n   * @return {number}\n   * @private\n   */\n  calculateCurrentRate_() {\n    return this.isBuffering_ ? 0 : this.rate_;\n  }\n\n  /**\n   * If the new rate is different than the media element's playback rate, this\n   * will change the playback rate. If the rate does not need to change, it will\n   * not be set. This will avoid unnecessary ratechange events.\n   *\n   * @param {number} newRate\n   * @return {boolean}\n   * @private\n   */\n  applyRate_(newRate) {\n    const oldRate = this.harness_.getRate();\n\n    if (oldRate != newRate) {\n      this.harness_.setRate(newRate);\n    }\n\n    return oldRate != newRate;\n  }\n};\n\n\n/**\n * @typedef {{\n *   getRate: function():number,\n *   setRate: function(number),\n *   movePlayhead: function(number)\n * }}\n *\n * @description\n *   A layer of abstraction between the controller and what it is controlling.\n *   In tests this will be implemented with spies. In production this will be\n *   implemented using a media element.\n *\n * @property {function():number} getRate\n *   Get the current playback rate being seen by the user.\n *\n * @property {function(number)} setRate\n *   Set the playback rate that the user should see.\n *\n * @property {function(number)} movePlayhead\n *   Move the playhead N seconds. If N is positive, the playhead will move\n *   forward abs(N) seconds. If N is negative, the playhead will move backwards\n *   abs(N) seconds.\n */\nshaka.media.PlayRateController.Harness;\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.VideoWrapper');\ngoog.provide('shaka.media.VideoWrapper.PlayheadMover');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * Creates a new VideoWrapper that manages setting current time and playback\n * rate.  This handles seeks before content is loaded and ensuring the video\n * time is set properly.  This doesn't handle repositioning within the\n * presentation window.\n *\n * @param {!HTMLMediaElement} video\n * @param {function()} onSeek Called when the video seeks.\n * @param {number} startTime The time to start at.\n *\n * @constructor\n * @struct\n * @implements {shaka.util.IReleasable}\n */\nshaka.media.VideoWrapper = function(video, onSeek, startTime) {\n  /** @private {HTMLMediaElement} */\n  this.video_ = video;\n\n  /** @private {function()} */\n  this.onSeek_ = onSeek;\n\n  /** @private {number} */\n  this.startTime_ = startTime;\n\n  /** @private {shaka.util.EventManager} */\n  this.eventManager_ = new shaka.util.EventManager();\n\n  /** @private {shaka.media.VideoWrapper.PlayheadMover} */\n  this.mover_ = new shaka.media.VideoWrapper.PlayheadMover(\n      /* mediaElement= */ video,\n      /* maxAttempts= */ 10);\n\n  // Before we can set the start time, we must check if the video element is\n  // ready. If the video element is not ready, we cannot set the time. To work\n  // around this, we will wait for the \"loadedmetadata\" event which tells us\n  // that the media element is now ready.\n  if (video.readyState > 0) {\n    this.setStartTime_(startTime);\n  } else {\n    this.delaySetStartTime_(startTime);\n  }\n};\n\n\n/** @override */\nshaka.media.VideoWrapper.prototype.release = function() {\n  if (this.eventManager_) {\n    this.eventManager_.release();\n    this.eventManager_ = null;\n  }\n\n  if (this.mover_ != null) {\n    this.mover_.release();\n    this.mover_ = null;\n  }\n\n  this.onSeek_ = () => {};\n  this.video_ = null;\n};\n\n\n/**\n * Gets the video's current (logical) position.\n *\n * @return {number}\n */\nshaka.media.VideoWrapper.prototype.getTime = function() {\n  return this.video_.readyState > 0 ?\n         this.video_.currentTime :\n         this.startTime_;\n};\n\n\n/**\n * Sets the current time of the video.\n *\n * @param {number} time\n */\nshaka.media.VideoWrapper.prototype.setTime = function(time) {\n  if (this.video_.readyState > 0) {\n    this.mover_.moveTo(time);\n  } else {\n    this.delaySetStartTime_(time);\n  }\n};\n\n/**\n * If the media element is not ready, we can't set |currentTime|. To work around\n * this we will listen for the \"loadedmetadata\" event so that we can set the\n * start time once the element is ready.\n *\n * @param {number} startTime\n */\nshaka.media.VideoWrapper.prototype.delaySetStartTime_ = function(startTime) {\n  const readyEvent = 'loadedmetadata';\n\n  // Since we are going to override what the start time should be, we need to\n  // save it so that |getTime| can return the most accurate start time possible.\n  this.startTime_ = startTime;\n\n  // The media element is not ready to accept changes to current time. We need\n  // to cache them and then execute them once the media element is ready.\n  this.eventManager_.unlisten(this.video_, readyEvent);\n\n  this.eventManager_.listenOnce(this.video_, readyEvent, () => {\n    this.setStartTime_(startTime);\n  });\n};\n\n\n/**\n * Set the start time for the content. The given start time will be ignored if\n * the content does not start at 0.\n *\n * @param {number} startTime\n * @private\n */\nshaka.media.VideoWrapper.prototype.setStartTime_ = function(startTime) {\n  // If we start close enough to our intended start time, then we won't do\n  // anything special.\n  if (Math.abs(this.video_.currentTime - startTime) < 0.001) {\n    this.startListeningToSeeks_();\n    return;\n  }\n\n  // We will need to delay adding our normal seeking listener until we have\n  // seen the first seek event. We will force the first seek event later in this\n  // method.\n  this.eventManager_.listenOnce(this.video_, 'seeking', () => {\n    this.startListeningToSeeks_();\n  });\n\n  // If the currentTime != 0, it indicates that the user has seeked after\n  // calling |Player.load|, meaning that |currentTime| is more meaningful than\n  // |startTime|.\n  //\n  // Seeking to the current time is a work around for Issue 1298. If we don't\n  // do this, the video may get stuck and not play.\n  //\n  // TODO: Need further investigation why it happens. Before and after\n  // setting the current time, video.readyState is 1, video.paused is true,\n  // and video.buffered's TimeRanges length is 0.\n  // See: https://github.com/google/shaka-player/issues/1298\n  this.mover_.moveTo(\n      this.video_.currentTime == 0 ?\n      startTime :\n      this.video_.currentTime);\n};\n\n\n/**\n * Add the listener for seek-events. This will call the externally-provided\n * |onSeek| callback whenever the media element seeks.\n *\n * @private\n */\nshaka.media.VideoWrapper.prototype.startListeningToSeeks_ = function() {\n  goog.asserts.assert(\n      this.video_.readyState > 0,\n      'The media element should be ready before we listen for seeking.');\n\n  this.eventManager_.listen(this.video_, 'seeking', () => this.onSeek_());\n};\n\n\n/**\n * A class used to move the playhead away from its current time.  Sometimes, IE\n * and Edge ignore re-seeks. After changing the current time, check every 100ms,\n * retrying if the change was not accepted.\n *\n * Delay stats over 100 runs of a re-seeking integration test:\n *   IE     -   0ms -  47%\n *   IE     - 100ms -  63%\n *   Edge   -   0ms -   2%\n *   Edge   - 100ms -  40%\n *   Edge   - 200ms -  32%\n *   Edge   - 300ms -  24%\n *   Edge   - 400ms -   2%\n *   Chrome -   0ms - 100%\n *\n * TODO: File a bug on IE/Edge about this.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.VideoWrapper.PlayheadMover = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   *    The media element that the mover can manipulate.\n   *\n   * @param {number} maxAttempts\n   *    To prevent us from infinitely trying to change the current time, the\n   *    mover accepts a max attempts value. At most, the mover will check if the\n   *    video moved |maxAttempts| times. If this is zero of negative, no\n   *    attempts will be made.\n   */\n  constructor(mediaElement, maxAttempts) {\n    /** @private {HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n\n    /** @private {number} */\n    this.maxAttempts_ = maxAttempts;\n\n    /** @private {number} */\n    this.remainingAttempts_ = 0;\n\n    /** @private {number} */\n    this.originTime_ = 0;\n\n    /** @private {number} */\n    this.targetTime_ = 0;\n\n    /** @private {shaka.util.Timer} */\n    this.timer_ = new shaka.util.Timer(() => this.onTick_());\n  }\n\n  /** @override */\n  release() {\n    if (this.timer_) {\n      this.timer_.stop();\n      this.timer_ = null;\n    }\n\n    this.mediaElement_ = null;\n  }\n\n  /**\n   * Try forcing the media element to move to |timeInSeconds|. If a previous\n   * call to |moveTo| is still in progress, this will override it.\n   *\n   * @param {number} timeInSeconds\n   */\n  moveTo(timeInSeconds) {\n    this.originTime_ = this.mediaElement_.currentTime;\n    this.targetTime_ = timeInSeconds;\n\n    this.remainingAttempts_ = this.maxAttempts_;\n\n    // Set the time and then start the timer. The timer will check if the set\n    // was successful, and retry if not.\n    this.mediaElement_.currentTime = timeInSeconds;\n    this.timer_.tickEvery(/* seconds= */ 0.1);\n  }\n\n  /**\n   * @private\n   */\n  onTick_() {\n    // Sigh... We ran out of retries...\n    if (this.remainingAttempts_ <= 0) {\n      shaka.log.warning([\n        'Failed to move playhead from', this.originTime_,\n        'to', this.targetTime_,\n      ].join(' '));\n\n      this.timer_.stop();\n      return;\n    }\n\n    // Yay! We were successful.\n    if (this.mediaElement_.currentTime != this.originTime_) {\n      this.timer_.stop();\n      return;\n    }\n\n    // Sigh... Try again...\n    this.mediaElement_.currentTime = this.targetTime_;\n    this.remainingAttempts_--;\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.MediaSourcePlayhead');\ngoog.provide('shaka.media.Playhead');\ngoog.provide('shaka.media.SrcEqualsPlayhead');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.GapJumpingController');\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.media.VideoWrapper');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * Creates a Playhead, which manages the video's current time.\n *\n * The Playhead provides mechanisms for setting the presentation's start time,\n * restricting seeking to valid time ranges, and stopping playback for startup\n * and re-buffering.\n *\n * @extends {shaka.util.IReleasable}\n * @interface\n */\nshaka.media.Playhead = class {\n  /**\n   * Set the start time. If the content has already started playback, this will\n   * be ignored.\n   *\n   * @param {number} startTime\n   */\n  setStartTime(startTime) {}\n\n  /**\n   * Get the current playhead position. The position will be restricted to valid\n   * time ranges.\n   *\n   * @return {number}\n   */\n  getTime() {}\n\n  /**\n   * Notify the playhead that the buffered ranges have changed.\n   */\n  notifyOfBufferingChange() {}\n};\n\n\n/**\n * A playhead implementation that only relies on the media element.\n *\n * @implements {shaka.media.Playhead}\n * @final\n */\nshaka.media.SrcEqualsPlayhead = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   */\n  constructor(mediaElement) {\n    /** @private {HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n    /** @private {boolean} */\n    this.started_ = false;\n    /** @private {?number} */\n    this.startTime_ = null;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    // We listen for the loaded-metadata-event so that we know when we can\n    // interact with |currentTime|.\n    const onLoaded = () => {\n      this.started_ = true;\n\n      if (this.startTime_ != null) {\n        this.mediaElement_.currentTime = this.startTime_;\n      }\n    };\n    if (this.mediaElement_.readyState == 0) {\n      this.eventManager_.listenOnce(\n          this.mediaElement_, 'loadedmetadata', onLoaded);\n    } else {\n      // It's already loaded.\n      onLoaded();\n    }\n  }\n\n  /** @override */\n  release() {\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    this.mediaElement_ = null;\n  }\n\n  /** @override */\n  setStartTime(startTime) {\n    // If we have already started playback, ignore updates to the start time.\n    // This is just to make things consistent.\n    this.startTime_ = this.started_ ? this.startTime_ : startTime;\n  }\n\n  /** @override */\n  getTime() {\n    // If we have not started playback yet, return the start time. However once\n    // we start playback we assume that we can always return the current time.\n    const time = this.started_ ?\n                 this.mediaElement_.currentTime :\n                 this.startTime_;\n\n    // In the case that we have not started playback, but the start time was\n    // never set, we don't know what the start time should be. To ensure we\n    // always return a number, we will default back to 0.\n    return time || 0;\n  }\n\n  /** @override */\n  notifyOfBufferingChange() {}\n};\n\n\n/**\n * A playhead implementation that relies on the media element and a manifest.\n * When provided with a manifest, we can provide more accurate control than\n * the SrcEqualsPlayhead.\n *\n * TODO: Clean up and simplify Playhead.  There are too many layers of, methods\n *       for, and conditions on timestamp adjustment.\n *\n * @implements {shaka.media.Playhead}\n * @final\n */\nshaka.media.MediaSourcePlayhead = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   * @param {shaka.extern.Manifest} manifest\n   * @param {shaka.extern.StreamingConfiguration} config\n   * @param {?number} startTime\n   *     The playhead's initial position in seconds. If null, defaults to the\n   *     start of the presentation for VOD and the live-edge for live.\n   * @param {function()} onSeek\n   *     Called when the user agent seeks to a time within the presentation\n   *     timeline.\n   * @param {function(!Event)} onEvent\n   *     Called when an event is raised to be sent to the application.\n   */\n  constructor(mediaElement, manifest, config, startTime, onSeek, onEvent) {\n    /**\n     * The seek range must be at least this number of seconds long. If it is\n     * smaller than this, change it to be this big so we don't repeatedly seek\n     * to keep within a zero-width window.\n     *\n     * This is 3s long, to account for the weaker hardware on platforms like\n     * Chromecast.\n     *\n     * @private {number}\n     */\n    this.minSeekRange_ = 3.0;\n\n    /** @private {HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n\n    /** @private {shaka.media.PresentationTimeline} */\n    this.timeline_ = manifest.presentationTimeline;\n\n    /** @private {number} */\n    this.minBufferTime_ = manifest.minBufferTime || 0;\n\n    /** @private {?shaka.extern.StreamingConfiguration} */\n    this.config_ = config;\n\n    /** @private {function()} */\n    this.onSeek_ = onSeek;\n\n    /** @private {?number} */\n    this.lastCorrectiveSeek_ = null;\n\n    /** @private {shaka.media.GapJumpingController} */\n    this.gapController_ = new shaka.media.GapJumpingController(\n        mediaElement,\n        manifest.presentationTimeline,\n        config,\n        this.createStallDetector_(mediaElement, config),\n        onEvent);\n\n    /** @private {shaka.media.VideoWrapper} */\n    this.videoWrapper_ = new shaka.media.VideoWrapper(\n        mediaElement,\n        () => this.onSeeking_(),\n        this.getStartTime_(startTime));\n\n    /** @type {shaka.util.Timer} */\n    this.checkWindowTimer_ = new shaka.util.Timer(() => {\n      this.onPollWindow_();\n    }).tickEvery(/* seconds= */ 0.25);\n  }\n\n  /** @override */\n  release() {\n    if (this.videoWrapper_) {\n      this.videoWrapper_.release();\n      this.videoWrapper_ = null;\n    }\n\n    if (this.gapController_) {\n      this.gapController_.release();\n      this.gapController_= null;\n    }\n\n    if (this.checkWindowTimer_) {\n      this.checkWindowTimer_.stop();\n      this.checkWindowTimer_ = null;\n    }\n\n    this.config_ = null;\n    this.timeline_ = null;\n    this.videoWrapper_ = null;\n    this.mediaElement_ = null;\n\n    this.onSeek_ = () => {};\n  }\n\n  /** @override */\n  setStartTime(startTime) {\n    this.videoWrapper_.setTime(startTime);\n  }\n\n  /** @override */\n  getTime() {\n    const time = this.videoWrapper_.getTime();\n\n    // Although we restrict the video's currentTime elsewhere, clamp it here to\n    // ensure timing issues don't cause us to return a time outside the segment\n    // availability window.  E.g., the user agent seeks and calls this function\n    // before we receive the 'seeking' event.\n    //\n    // We don't buffer when the livestream video is paused and the playhead time\n    // is out of the seek range; thus, we do not clamp the current time when the\n    // video is paused.\n    // https://github.com/google/shaka-player/issues/1121\n    if (this.mediaElement_.readyState > 0 && !this.mediaElement_.paused) {\n      return this.clampTime_(time);\n    }\n\n    return time;\n  }\n\n  /**\n   * Gets the playhead's initial position in seconds.\n   *\n   * @param {?number} startTime\n   * @return {number}\n   * @private\n   */\n  getStartTime_(startTime) {\n    if (startTime == null) {\n      if (this.timeline_.getDuration() < Infinity) {\n        // If the presentation is VOD, or if the presentation is live but has\n        // finished broadcasting, then start from the beginning.\n        startTime = this.timeline_.getSeekRangeStart();\n      } else {\n        // Otherwise, start near the live-edge.\n        startTime = this.timeline_.getSeekRangeEnd();\n      }\n    } else if (startTime < 0) {\n      // For live streams, if the startTime is negative, start from a certain\n      // offset time from the live edge.  If the offset from the live edge is\n      // not available, start from the current available segment start point\n      // instead, handled by clampTime_().\n      startTime = this.timeline_.getSeekRangeEnd() + startTime;\n    }\n\n    return this.clampSeekToDuration_(this.clampTime_(startTime));\n  }\n\n  /** @override */\n  notifyOfBufferingChange() {\n    this.gapController_.onSegmentAppended();\n  }\n\n  /**\n   * Called on a recurring timer to keep the playhead from falling outside the\n   * availability window.\n   *\n   * @private\n   */\n  onPollWindow_() {\n    // Don't catch up to the seek range when we are paused or empty.\n    // The definition of \"seeking\" says that we are seeking until the buffered\n    // data intersects with the playhead.  If we fall outside of the seek range,\n    // it doesn't matter if we are in a \"seeking\" state.  We can and should go\n    // ahead and catch up while seeking.\n    if (this.mediaElement_.readyState == 0 || this.mediaElement_.paused) {\n      return;\n    }\n\n    let currentTime = this.mediaElement_.currentTime;\n    let seekStart = this.timeline_.getSeekRangeStart();\n    let seekEnd = this.timeline_.getSeekRangeEnd();\n\n    if (seekEnd - seekStart < this.minSeekRange_) {\n      seekStart = seekEnd - this.minSeekRange_;\n    }\n\n    if (currentTime < seekStart) {\n      // The seek range has moved past the playhead.  Move ahead to catch up.\n      let targetTime = this.reposition_(currentTime);\n      shaka.log.info('Jumping forward ' + (targetTime - currentTime) +\n                     ' seconds to catch up with the seek range.');\n      this.mediaElement_.currentTime = targetTime;\n    }\n  }\n\n  /**\n   * Handles when a seek happens on the video.\n   *\n   * @private\n   */\n  onSeeking_() {\n    this.gapController_.onSeeking();\n    let currentTime = this.videoWrapper_.getTime();\n    let targetTime = this.reposition_(currentTime);\n\n    const gapLimit = shaka.media.GapJumpingController.BROWSER_GAP_TOLERANCE;\n    if (Math.abs(targetTime - currentTime) > gapLimit) {\n      // You can only seek like this every so often. This is to prevent an\n      // infinite loop on systems where changing currentTime takes a significant\n      // amount of time (e.g. Chromecast).\n      let time = new Date().getTime() / 1000;\n      if (!this.lastCorrectiveSeek_ || this.lastCorrectiveSeek_ < time - 1) {\n        this.lastCorrectiveSeek_ = time;\n        this.videoWrapper_.setTime(targetTime);\n        return;\n      }\n    }\n\n    shaka.log.v1('Seek to ' + currentTime);\n    this.onSeek_();\n  }\n\n  /**\n   * Clamp seek times and playback start times so that we never seek to the\n   * presentation duration.  Seeking to or starting at duration does not work\n   * consistently across browsers.\n   *\n   * @see https://github.com/google/shaka-player/issues/979\n   * @param {number} time\n   * @return {number} The adjusted seek time.\n   * @private\n   */\n  clampSeekToDuration_(time) {\n    let duration = this.timeline_.getDuration();\n    if (time >= duration) {\n      goog.asserts.assert(this.config_.durationBackoff >= 0,\n                          'Duration backoff must be non-negative!');\n      return duration - this.config_.durationBackoff;\n    }\n    return time;\n  }\n\n  /**\n   * Computes a new playhead position that's within the presentation timeline.\n   *\n   * @param {number} currentTime\n   * @return {number} The time to reposition the playhead to.\n   * @private\n   */\n  reposition_(currentTime) {\n    goog.asserts.assert(\n        this.config_,\n        'Cannot reposition playhead when it has beeen destroyed');\n\n    /** @type {function(number)} */\n    let isBuffered = shaka.media.TimeRangesUtils.isBuffered.bind(\n        null, this.mediaElement_.buffered);\n\n    let rebufferingGoal = Math.max(\n        this.minBufferTime_,\n        this.config_.rebufferingGoal);\n\n    const safeSeekOffset = this.config_.safeSeekOffset;\n\n    let start = this.timeline_.getSeekRangeStart();\n    let end = this.timeline_.getSeekRangeEnd();\n    let duration = this.timeline_.getDuration();\n\n    if (end - start < this.minSeekRange_) {\n      start = end - this.minSeekRange_;\n    }\n\n    // With live content, the beginning of the availability window is moving\n    // forward.  This means we cannot seek to it since we will \"fall\" outside\n    // the window while we buffer.  So we define a \"safe\" region that is far\n    // enough away.  For VOD, |safe == start|.\n    let safe = this.timeline_.getSafeSeekRangeStart(rebufferingGoal);\n\n    // These are the times to seek to rather than the exact destinations.  When\n    // we seek, we will get another event (after a slight delay) and these steps\n    // will run again.  So if we seeked directly to |start|, |start| would move\n    // on the next call and we would loop forever.\n    let seekStart = this.timeline_.getSafeSeekRangeStart(safeSeekOffset);\n    let seekSafe = this.timeline_.getSafeSeekRangeStart(\n        rebufferingGoal + safeSeekOffset);\n\n    if (currentTime >= duration) {\n      shaka.log.v1('Playhead past duration.');\n      return this.clampSeekToDuration_(currentTime);\n    }\n\n    if (currentTime > end) {\n      shaka.log.v1('Playhead past end.');\n      return end;\n    }\n\n    if (currentTime < start) {\n      if (isBuffered(seekStart)) {\n        shaka.log.v1('Playhead before start & start is buffered');\n        return seekStart;\n      } else {\n        shaka.log.v1('Playhead before start & start is unbuffered');\n        return seekSafe;\n      }\n    }\n\n    if (currentTime >= safe || isBuffered(currentTime)) {\n      shaka.log.v1('Playhead in safe region or in buffered region.');\n      return currentTime;\n    } else {\n      shaka.log.v1('Playhead outside safe region & in unbuffered region.');\n      return seekSafe;\n    }\n  }\n\n  /**\n   * Clamps the given time to the seek range.\n   *\n   * @param {number} time The time in seconds.\n   * @return {number} The clamped time in seconds.\n   * @private\n   */\n  clampTime_(time) {\n    let start = this.timeline_.getSeekRangeStart();\n    if (time < start) return start;\n\n    let end = this.timeline_.getSeekRangeEnd();\n    if (time > end) return end;\n\n    return time;\n  }\n\n  /**\n   * Create and configure a stall detector using the player's streaming\n   * configuration settings. If the player is configured to have no stall\n   * detector, this will return |null|.\n   *\n   * @param {!HTMLMediaElement} mediaElement\n   * @param {shaka.extern.StreamingConfiguration} config\n   * @return {shaka.media.StallDetector}\n   * @private\n   */\n  createStallDetector_(mediaElement, config) {\n    if (!config.stallEnabled) {\n      return null;\n    }\n\n    // Cache the values from the config so that changes to the config won't\n    // change the initialized behaviour.\n    const threshold = config.stallThreshold;\n    const skip = config.stallSkip;\n\n    // When we see a stall, we will try to \"jump-start\" playback by moving the\n    // playhead forward.\n    const detector = new shaka.media.StallDetector(\n        new shaka.media.StallDetector.MediaElementImplementation(mediaElement),\n        threshold);\n\n    detector.onStall((at, duration) => {\n      shaka.log.debug([\n        'Stall detected at', at, 'for', duration, 'seconds. Seeking forward',\n        skip, 'seconds.',\n      ].join(' '));\n\n      mediaElement.currentTime += skip;\n    });\n\n    return detector;\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.RegionTimeline');\n\ngoog.require('shaka.util.IReleasable');\n\n\n/**\n * The region timeline is a set of unique timeline region info entries. When\n * a new entry is added, the |onAddRegion| callback will be called.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.RegionTimeline = class {\n  constructor() {\n    /** @private {function(shaka.extern.TimelineRegionInfo)} */\n    this.onAddRegion_ = (region) => {};\n    /** @private {!Set.<shaka.extern.TimelineRegionInfo>} */\n    this.regions_ = new Set();\n  }\n\n  /** @override */\n  release() {\n    // Prevent us from holding onto any external references via the callback.\n    this.onAddRegion_ = (region) => {};\n    this.regions_.clear();\n  }\n\n  /**\n   * Set the callbacks for events. This will override any previous calls to\n   * |setListeners|.\n   *\n   * @param {function(shaka.extern.TimelineRegionInfo)} onAddRegion\n   *    Set the callback for when we add a new region. This callback will only\n   *    be called when a region is unique (we reject duplicate regions).\n   */\n  setListeners(onAddRegion) {\n    this.onAddRegion_ = onAddRegion;\n  }\n\n  /**\n   * @param {shaka.extern.TimelineRegionInfo} region\n   */\n  addRegion(region) {\n    const similarRegion = this.findSimilarRegion_(region);\n\n    // Make sure we don't add duplicate regions. We keep track of this here\n    // instead of making the parser track it.\n    if (similarRegion == null) {\n      this.regions_.add(region);\n      this.onAddRegion_(region);\n    }\n  }\n\n  /**\n   * Find a region in the timeline that has the same scheme id uri, start time,\n   * and end time. If these three parameters match, we assume it to be the same\n   * region. If no similar region can be found, |null| will be returned.\n   *\n   * @param {shaka.extern.TimelineRegionInfo} region\n   * @return {?shaka.extern.TimelineRegionInfo}\n   * @private\n   */\n  findSimilarRegion_(region) {\n    for (const existing of this.regions_) {\n      // The same scheme ID and time range means that it is similar-enough to\n      // be the same region.\n      const isSimilar = existing.schemeIdUri == region.schemeIdUri &&\n                        existing.startTime == region.startTime &&\n                        existing.endTime == region.endTime;\n\n      if (isSimilar) {\n        return existing;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get an iterable for all the regions in the timeline. This will allow\n   * others to see what regions are in the timeline while not being able to\n   * change the collection.\n   *\n   * @return {!Iterable.<shaka.extern.TimelineRegionInfo>}\n   */\n  regions() {\n    return this.regions_;\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.RegionObserver');\n\ngoog.require('shaka.media.RegionTimeline');\n\n\n/**\n * The region observer watches a region timeline and playhead, and fires events\n * (onEnter, onExit, and onSkip) as the playhead moves.\n *\n * @implements {shaka.media.IPlayheadObserver}\n * @final\n */\nshaka.media.RegionObserver = class {\n  /**\n   * Create a region observer for the given timeline. The observer does not\n   * own the timeline, only uses it. This means that the observer should NOT\n   * destroy the timeline.\n   *\n   * @param {!shaka.media.RegionTimeline} timeline\n   */\n  constructor(timeline) {\n    /** @private {shaka.media.RegionTimeline} */\n    this.timeline_ = timeline;\n\n    /**\n     * A mapping between a region and where we previously were relative to it.\n     * When the value here differs from what we calculate, it means we moved and\n     * should fire an event.\n     *\n     * @private {!Map.<shaka.extern.TimelineRegionInfo,\n     *                 shaka.media.RegionObserver.RelativePosition_>}\n     */\n    this.oldPosition_ = new Map();\n\n    /** @private {shaka.media.RegionObserver.EventListener} */\n    this.onEnter_ = (region, seeking) => {};\n    /** @private {shaka.media.RegionObserver.EventListener} */\n    this.onExit_ = (region, seeking) => {};\n    /** @private {shaka.media.RegionObserver.EventListener} */\n    this.onSkip_ = (region, seeking) => {};\n\n    // To make the rules easier to read, alias all the relative positions.\n    const RelativePosition = shaka.media.RegionObserver.RelativePosition_;\n    const BEFORE_THE_REGION = RelativePosition.BEFORE_THE_REGION;\n    const IN_THE_REGION = RelativePosition.IN_THE_REGION;\n    const AFTER_THE_REGION = RelativePosition.AFTER_THE_REGION;\n\n    /**\n     * A read-only collection of rules for what to do when we change position\n     * relative to a region.\n     *\n     * @private {!Iterable.<shaka.media.RegionObserver.Rule_>}\n     */\n    this.rules_ = [\n      {\n        weWere: null,\n        weAre: IN_THE_REGION,\n        invoke: (region, seeking) => this.onEnter_(region, seeking),\n      },\n      {\n        weWere: BEFORE_THE_REGION,\n        weAre: IN_THE_REGION,\n        invoke: (region, seeking) => this.onEnter_(region, seeking),\n      },\n      {\n        weWere: AFTER_THE_REGION,\n        weAre: IN_THE_REGION,\n        invoke: (region, seeking) => this.onEnter_(region, seeking),\n      },\n      {\n        weWere: IN_THE_REGION,\n        weAre: BEFORE_THE_REGION,\n        invoke: (region, seeking) => this.onExit_(region, seeking),\n      },\n      {\n        weWere: IN_THE_REGION,\n        weAre: AFTER_THE_REGION,\n        invoke: (region, seeking) => this.onExit_(region, seeking),\n      },\n      {\n        weWere: BEFORE_THE_REGION,\n        weAre: AFTER_THE_REGION,\n        invoke: (region, seeking) => this.onSkip_(region, seeking),\n      },\n      {\n        weWere: AFTER_THE_REGION,\n        weAre: BEFORE_THE_REGION,\n        invoke: (region, seeking) => this.onSkip_(region, seeking),\n      },\n    ];\n  }\n\n  /** @override */\n  release() {\n    this.timeline_ = null;\n\n    // Clear our maps so that we are not holding onto any more information than\n    // needed.\n    this.oldPosition_.clear();\n\n    // Clear the callbacks so that we don't hold onto any references external\n    // to this class.\n    this.onEnter_ = (region, seeking) => {};\n    this.onExit_ = (region, seeking) => {};\n    this.onSkip_ = (region, seeking) => {};\n  }\n\n  /** @override */\n  poll(positionInSeconds, wasSeeking) {\n    const RegionObserver = shaka.media.RegionObserver;\n\n    for (const region of this.timeline_.regions()) {\n      const previousPosition = this.oldPosition_.get(region);\n      const currentPosition = RegionObserver.determinePositionRelativeTo_(\n          region, positionInSeconds);\n\n      // We will only use |previousPosition| and |currentPosition|, so we can\n      // update our state now.\n      this.oldPosition_.set(region, currentPosition);\n\n      for (const rule of this.rules_) {\n        if (rule.weWere == previousPosition && rule.weAre == currentPosition) {\n          rule.invoke(region, wasSeeking);\n        }\n      }\n    }\n  }\n\n  /**\n   * Set all the listeners. This overrides any previous calls to |setListeners|.\n   *\n   * @param {shaka.media.RegionObserver.EventListener} onEnter\n   *    The callback for when we move from outside a region to inside a region.\n   * @param {shaka.media.RegionObserver.EventListener} onExit\n   *    The callback for when we move from inside a region to outside a region.\n   * @param {shaka.media.RegionObserver.EventListener} onSkip\n   *    The callback for when we move from before to after a region or from\n   *    after to before a region.\n   */\n  setListeners(onEnter, onExit, onSkip) {\n    this.onEnter_ = onEnter;\n    this.onExit_ = onExit;\n    this.onSkip_ = onSkip;\n  }\n\n  /**\n   * Get the relative position of the playhead to |region| when the playhead is\n   * at |seconds|. We treat the region's start and end times as inclusive\n   * bounds.\n   *\n   * @param {shaka.extern.TimelineRegionInfo} region\n   * @param {number} seconds\n   * @return {shaka.media.RegionObserver.RelativePosition_}\n   * @private\n   */\n  static determinePositionRelativeTo_(region, seconds) {\n    const RelativePosition = shaka.media.RegionObserver.RelativePosition_;\n\n    if (seconds < region.startTime) {\n      return RelativePosition.BEFORE_THE_REGION;\n    }\n\n    if (seconds > region.endTime) {\n      return RelativePosition.AFTER_THE_REGION;\n    }\n\n    return RelativePosition.IN_THE_REGION;\n  }\n};\n\n/**\n * An enum of relative positions between the playhead and a region. Each is\n * phrased so that it works in \"The playhead is X\" where \"X\" is any value in\n * the enum.\n *\n * @enum {number}\n * @private\n */\nshaka.media.RegionObserver.RelativePosition_ = {\n  BEFORE_THE_REGION: 1,\n  IN_THE_REGION: 2,\n  AFTER_THE_REGION: 3,\n};\n\n/**\n * All region observer events (onEnter, onExit, and onSkip) will be passed the\n * region that the playhead is interacting with and whether or not the playhead\n * moving is part of a seek event.\n *\n * @typedef {function(shaka.extern.TimelineRegionInfo, boolean)}\n */\nshaka.media.RegionObserver.EventListener;\n\n/**\n * @typedef {{\n *    weWere: ?shaka.media.RegionObserver.RelativePosition_,\n *    weAre: ?shaka.media.RegionObserver.RelativePosition_,\n *    invoke: shaka.media.RegionObserver.EventListener\n * }}\n *\n * @private\n */\nshaka.media.RegionObserver.Rule_;\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.StreamingEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.MediaSourceEngine');\ngoog.require('shaka.net.Backoff');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.DelayedTick');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.Networking');\ngoog.require('shaka.util.Periods');\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * Creates a StreamingEngine.\n *\n * The StreamingEngine is responsible for setting up the Manifest's Streams\n * (i.e., for calling each Stream's createSegmentIndex() function), for\n * downloading segments, for co-ordinating audio, video, and text buffering,\n * and for handling Period transitions. The StreamingEngine provides an\n * interface to switch between Streams, but it does not choose which Streams to\n * switch to.\n *\n * The StreamingEngine notifies its owner when it needs to buffer a new Period,\n * so its owner can choose which Streams within that Period to initially\n * buffer. Moreover, the StreamingEngine also notifies its owner when any\n * Stream within the current Period may be switched to, so its owner can switch\n * bitrates, resolutions, or languages.\n *\n * The StreamingEngine does not need to be notified about changes to the\n * Manifest's SegmentIndexes; however, it does need to be notified when new\n * Periods are added to the Manifest, so it can set up that Period's Streams.\n *\n * To start the StreamingEngine the owner must first call configure() followed\n * by init(). The StreamingEngine will then call onChooseStreams(p) when it\n * needs to buffer Period p; it will then switch to the Streams returned from\n * that function. The StreamingEngine will call onCanSwitch() when any\n * Stream within the current Period may be switched to.\n *\n * The owner must call seeked() each time the playhead moves to a new location\n * within the presentation timeline; however, the owner may forego calling\n * seeked() when the playhead moves outside the presentation timeline.\n *\n * @param {shaka.extern.Manifest} manifest\n * @param {shaka.media.StreamingEngine.PlayerInterface} playerInterface\n *\n * @constructor\n * @struct\n * @implements {shaka.util.IDestroyable}\n */\nshaka.media.StreamingEngine = function(manifest, playerInterface) {\n  /** @private {?shaka.media.StreamingEngine.PlayerInterface} */\n  this.playerInterface_ = playerInterface;\n\n  /** @private {?shaka.extern.Manifest} */\n  this.manifest_ = manifest;\n\n  /** @private {?shaka.extern.StreamingConfiguration} */\n  this.config_ = null;\n\n  /** @private {number} */\n  this.bufferingGoalScale_ = 1;\n\n  /** @private {Promise} */\n  this.setupPeriodPromise_ = Promise.resolve();\n\n  /**\n   * Maps a Period's index to an object that indicates that either\n   *   1. the Period has not been set up (undefined).\n   *   2. the Period is being set up ([a PublicPromise, false]).\n   *   3. the Period is set up (i.e., all Streams within the Period are set up)\n   *      and can be switched to ([a PublicPromise, true]).\n   *\n   * @private {Array.<?{promise: shaka.util.PublicPromise, resolved: boolean}>}\n   */\n  this.canSwitchPeriod_ = [];\n\n  /**\n   * Maps a Stream's ID to an object that indicates that either\n   *   1. the Stream has not been set up (undefined).\n   *   2. the Stream is being set up ([a Promise instance, false]).\n   *   3. the Stream is set up and can be switched to\n   *      ([a Promise instance, true]).\n   *\n   * @private {!Map.<number,\n   *                 ?{promise: shaka.util.PublicPromise, resolved: boolean}>}\n   */\n  this.canSwitchStream_ = new Map();\n\n  /**\n   * Maps a content type, e.g., 'audio', 'video', or 'text', to a MediaState.\n   *\n   * @private {!Map.<shaka.util.ManifestParserUtils.ContentType,\n                       !shaka.media.StreamingEngine.MediaState_>}\n   */\n  this.mediaStates_ = new Map();\n\n  /**\n   * Set to true once one segment of each content type has been buffered.\n   *\n   * @private {boolean}\n   */\n  this.startupComplete_ = false;\n\n  /**\n   * Used for delay and backoff of failure callbacks, so that apps do not retry\n   * instantly.\n   *\n   * @private {shaka.net.Backoff}\n   */\n  this.failureCallbackBackoff_ = null;\n\n  /**\n   * Set to true on fatal error.  Interrupts fetchAndAppend_().\n   *\n   * @private {boolean}\n   */\n  this.fatalError_ = false;\n\n  /** @private {boolean} */\n  this.destroyed_ = false;\n\n  /**\n   * Set to true when a request to unload text stream comes in. This is used\n   * since loading new text stream is async, the request of unloading text\n   * stream might come in before setting up new text stream is finished.\n   * @private {boolean}\n   */\n  this.unloadingTextStream_ = false;\n\n  /** @private {number} */\n  this.textStreamSequenceId_ = 0;\n};\n\n\n/**\n * @typedef {{\n *   variant: (?shaka.extern.Variant|undefined),\n *   text: ?shaka.extern.Stream\n * }}\n *\n * @property {(?shaka.extern.Variant|undefined)} variant\n *   The chosen variant.  May be omitted for text re-init.\n * @property {?shaka.extern.Stream} text\n *   The chosen text stream.\n */\nshaka.media.StreamingEngine.ChosenStreams;\n\n\n/**\n * @typedef {{\n *   getPresentationTime: function():number,\n *   getBandwidthEstimate: function():number,\n *   mediaSourceEngine: !shaka.media.MediaSourceEngine,\n *   netEngine: shaka.net.NetworkingEngine,\n *   onChooseStreams: function(!shaka.extern.Period):\n *                        shaka.media.StreamingEngine.ChosenStreams,\n *   onCanSwitch: function(),\n *   onError: function(!shaka.util.Error),\n *   onEvent: function(!Event),\n *   onManifestUpdate: function(),\n *   onSegmentAppended: function(),\n *   onInitialStreamsSetup: (function()|undefined),\n *   onStartupComplete: (function()|undefined)\n * }}\n *\n * @property {function():number} getPresentationTime\n *   Get the position in the presentation (in seconds) of the content that the\n *   viewer is seeing on screen right now.\n * @property {function():number} getBandwidthEstimate\n *   Get the estimated bandwidth in bits per second.\n * @property {!shaka.media.MediaSourceEngine} mediaSourceEngine\n *   The MediaSourceEngine. The caller retains ownership.\n * @property {shaka.net.NetworkingEngine} netEngine\n *   The NetworkingEngine instance to use. The caller retains ownership.\n * @property {function(!shaka.extern.Period):\n *                shaka.media.StreamingEngine.ChosenStreams} onChooseStreams\n *   Called by StreamingEngine when the given Period needs to be buffered.\n *   StreamingEngine will switch to the variant and text stream returned from\n *   this function.\n *   The owner cannot call switch() directly until the StreamingEngine calls\n *   onCanSwitch().\n * @property {function()} onCanSwitch\n *   Called by StreamingEngine when the Period is set up and switching is\n *   permitted.\n * @property {function(!shaka.util.Error)} onError\n *   Called when an error occurs. If the error is recoverable (see\n *   {@link shaka.util.Error}) then the caller may invoke either\n *   StreamingEngine.switch*() or StreamingEngine.seeked() to attempt recovery.\n * @property {function(!Event)} onEvent\n *   Called when an event occurs that should be sent to the app.\n * @property {function()} onManifestUpdate\n *   Called when an embedded 'emsg' box should trigger a manifest update.\n * @property {function()} onSegmentAppended\n *   Called after a segment is successfully appended to a MediaSource.\n * @property {(function()|undefined)} onInitialStreamsSetup\n *   Optional callback which is called when the initial set of Streams have been\n *   setup. Intended to be used by tests.\n * @property {(function()|undefined)} onStartupComplete\n *   Optional callback which is called when startup has completed. Intended to\n *   be used by tests.\n */\nshaka.media.StreamingEngine.PlayerInterface;\n\n\n/**\n * @typedef {{\n *   type: shaka.util.ManifestParserUtils.ContentType,\n *   stream: shaka.extern.Stream,\n *   lastStream: ?shaka.extern.Stream,\n *   lastSegmentReference: shaka.media.SegmentReference,\n *   restoreStreamAfterTrickPlay: ?shaka.extern.Stream,\n *   needInitSegment: boolean,\n *   needPeriodIndex: number,\n *   endOfStream: boolean,\n *   performingUpdate: boolean,\n *   updateTimer: shaka.util.DelayedTick,\n *   waitingToClearBuffer: boolean,\n *   waitingToFlushBuffer: boolean,\n *   clearBufferSafeMargin: number,\n *   clearingBuffer: boolean,\n *   recovering: boolean,\n *   hasError: boolean,\n *   resumeAt: number,\n *   operation: shaka.net.NetworkingEngine.PendingRequest\n * }}\n *\n * @description\n * Contains the state of a logical stream, i.e., a sequence of segmented data\n * for a particular content type. At any given time there is a Stream object\n * associated with the state of the logical stream.\n *\n * @property {shaka.util.ManifestParserUtils.ContentType} type\n *   The stream's content type, e.g., 'audio', 'video', or 'text'.\n * @property {shaka.extern.Stream} stream\n *   The current Stream.\n * @property {?shaka.extern.Stream} lastStream\n *   The Stream of the last segment that was appended.\n * @property {shaka.media.SegmentReference} lastSegmentReference\n *   The SegmentReference of the last segment that was appended.\n * @property {?shaka.extern.Stream} restoreStreamAfterTrickPlay\n *   The Stream to restore after trick play mode is turned off.\n * @property {boolean} needInitSegment\n *   True indicates that |stream|'s init segment must be inserted before the\n *   next media segment is appended.\n * @property {boolean} endOfStream\n *   True indicates that the end of the buffer has hit the end of the\n *   presentation.\n * @property {number} needPeriodIndex\n *   The index of the Period which needs to be buffered.\n * @property {boolean} performingUpdate\n *   True indicates that an update is in progress.\n * @property {shaka.util.DelayedTick} updateTimer\n *   A timer used to update the media state.\n * @property {boolean} waitingToClearBuffer\n *   True indicates that the buffer must be cleared after the current update\n *   finishes.\n * @property {boolean} waitingToFlushBuffer\n *   True indicates that the buffer must be flushed after it is cleared.\n * @property {number} clearBufferSafeMargin\n *   The amount of buffer to retain when clearing the buffer after the update.\n * @property {boolean} clearingBuffer\n *   True indicates that the buffer is being cleared.\n * @property {boolean} recovering\n *   True indicates that the last segment was not appended because it could not\n *   fit in the buffer.\n * @property {boolean} hasError\n *   True indicates that the stream has encountered an error and has stopped\n *   updating.\n * @property {number} resumeAt\n *   An override for the time to start performing updates at.  If the playhead\n *   is behind this time, update_() will still start fetching segments from\n *   this time.  If the playhead is ahead of the time, this field is ignored.\n * @property {shaka.net.NetworkingEngine.PendingRequest} operation\n *   Operation with the number of bytes to be downloaded.\n */\nshaka.media.StreamingEngine.MediaState_;\n\n\n/**\n * The fudge factor for appendWindowStart.  By adjusting the window backward, we\n * avoid rounding errors that could cause us to remove the keyframe at the start\n * of the Period.\n *\n * NOTE: This was increased as part of the solution to\n * https://github.com/google/shaka-player/issues/1281\n *\n * @const {number}\n * @private\n */\nshaka.media.StreamingEngine.APPEND_WINDOW_START_FUDGE_ = 0.1;\n\n\n/**\n * The fudge factor for appendWindowEnd.  By adjusting the window backward, we\n * avoid rounding errors that could cause us to remove the last few samples of\n * the Period.  This rounding error could then create an artificial gap and a\n * stutter when the gap-jumping logic takes over.\n *\n * https://github.com/google/shaka-player/issues/1597\n *\n * @const {number}\n * @private\n */\nshaka.media.StreamingEngine.APPEND_WINDOW_END_FUDGE_ = 0.01;\n\n\n/**\n * The maximum number of segments by which a stream can get ahead of other\n * streams.\n *\n * Introduced to keep StreamingEngine from letting one media type get too far\n * ahead of another.  For example, audio segments are typically much smaller\n * than video segments, so in the time it takes to fetch one video segment, we\n * could fetch many audio segments.  This doesn't help with buffering, though,\n * since the intersection of the two buffered ranges is what counts.\n *\n * @const {number}\n * @private\n */\nshaka.media.StreamingEngine.MAX_RUN_AHEAD_SEGMENTS_ = 1;\n\n\n/** @override */\nshaka.media.StreamingEngine.prototype.destroy = function() {\n  for (const state of this.mediaStates_.values()) {\n    this.cancelUpdate_(state);\n  }\n\n  this.mediaStates_.clear();\n  this.canSwitchStream_.clear();\n\n  this.playerInterface_ = null;\n  this.manifest_ = null;\n  this.setupPeriodPromise_ = null;\n  this.canSwitchPeriod_ = null;\n  this.config_ = null;\n\n  this.destroyed_ = true;\n\n  return Promise.resolve();\n};\n\n\n/**\n * Called by the Player to provide an updated configuration any time it changes.\n * Must be called at least once before init().\n *\n * @param {shaka.extern.StreamingConfiguration} config\n */\nshaka.media.StreamingEngine.prototype.configure = function(config) {\n  this.config_ = config;\n\n  // Create separate parameters for backoff during streaming failure.\n\n  /** @type {shaka.extern.RetryParameters} */\n  let failureRetryParams = {\n    // The term \"attempts\" includes the initial attempt, plus all retries.\n    // In order to see a delay, there would have to be at least 2 attempts.\n    maxAttempts: Math.max(config.retryParameters.maxAttempts, 2),\n    baseDelay: config.retryParameters.baseDelay,\n    backoffFactor: config.retryParameters.backoffFactor,\n    fuzzFactor: config.retryParameters.fuzzFactor,\n    timeout: 0,  // irrelevant\n  };\n\n  // We don't want to ever run out of attempts.  The application should be\n  // allowed to retry streaming infinitely if it wishes.\n  let autoReset = true;\n  this.failureCallbackBackoff_ =\n      new shaka.net.Backoff(failureRetryParams, autoReset);\n};\n\n\n/**\n * Initialize and start streaming.\n *\n * By calling this method, streaming engine will choose the initial streams by\n * calling out to |onChooseStreams| followed by |onCanSwitch|. When streaming\n * engine switches periods, it will call |onChooseStreams| followed by\n * |onCanSwitch|.\n *\n * Asking streaming engine to switch streams between |onChooseStreams| and\n * |onChangeSwitch| is not supported.\n *\n * After the StreamingEngine calls onChooseStreams(p) for the first time, it\n * will begin setting up the Streams returned from that function and\n * subsequently switch to them. However, the StreamingEngine will not begin\n * setting up any other Streams until at least one segment from each of the\n * initial set of Streams has been buffered (this reduces startup latency).\n *\n * After the StreamingEngine completes this startup phase it will begin setting\n * up each Period's Streams (while buffering in parrallel).\n *\n * When the StreamingEngine needs to buffer the next Period it will have\n * already set up that Period's Streams. So, when the StreamingEngine calls\n * onChooseStreams(p) after the first time, the StreamingEngine will\n * immediately switch to the Streams returned from that function.\n *\n * @return {!Promise}\n */\nshaka.media.StreamingEngine.prototype.start = async function() {\n  goog.asserts.assert(this.config_,\n      'StreamingEngine configure() must be called before init()!');\n\n  // Determine which Period we must buffer.\n  const presentationTime = this.playerInterface_.getPresentationTime();\n  const needPeriodIndex = this.findPeriodForTime_(presentationTime);\n\n  // Get the initial set of Streams.\n  const initialStreams = this.playerInterface_.onChooseStreams(\n      this.manifest_.periods[needPeriodIndex]);\n  if (!initialStreams.variant && !initialStreams.text) {\n    shaka.log.error('init: no Streams chosen');\n    return new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STREAMING,\n        shaka.util.Error.Code.INVALID_STREAMS_CHOSEN);\n  }\n\n  // Setup the initial set of Streams and then begin each update cycle. After\n  // startup completes onUpdate_() will set up the remaining Periods.\n  await this.initStreams_(\n      initialStreams.variant ? initialStreams.variant.audio : null,\n      initialStreams.variant ? initialStreams.variant.video : null,\n      initialStreams.text,\n      presentationTime);\n\n  if (this.destroyed_) {\n    return;\n  }\n\n  shaka.log.debug('init: completed initial Stream setup');\n\n  // Subtlety: onInitialStreamsSetup() may call switch() or seeked(), so we\n  // must schedule an update beforehand so |updateTimer| is set.\n  if (this.playerInterface_ && this.playerInterface_.onInitialStreamsSetup) {\n    shaka.log.v1('init: calling onInitialStreamsSetup()...');\n    this.playerInterface_.onInitialStreamsSetup();\n  }\n};\n\n\n/**\n * Gets the Period in which we are currently buffering.  This might be different\n * from the Period which contains the Playhead.\n * @return {?shaka.extern.Period}\n */\nshaka.media.StreamingEngine.prototype.getBufferingPeriod = function() {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  const video = this.mediaStates_.get(ContentType.VIDEO);\n  if (video) { return this.manifest_.periods[video.needPeriodIndex]; }\n\n  const audio = this.mediaStates_.get(ContentType.AUDIO);\n  if (audio) { return this.manifest_.periods[audio.needPeriodIndex]; }\n\n  return null;\n};\n\n\n/**\n * Get the audio stream which we are currently buffering.  Returns null if there\n * is no audio streaming.\n * @return {?shaka.extern.Stream}\n */\nshaka.media.StreamingEngine.prototype.getBufferingAudio = function() {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  return this.getStream_(ContentType.AUDIO);\n};\n\n\n/**\n * Get the video stream which we are currently buffering.  Returns null if there\n * is no video streaming.\n * @return {?shaka.extern.Stream}\n */\nshaka.media.StreamingEngine.prototype.getBufferingVideo = function() {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  return this.getStream_(ContentType.VIDEO);\n};\n\n\n/**\n * Get the text stream which we are currently buffering.  Returns null if there\n * is no text streaming.\n * @return {?shaka.extern.Stream}\n */\nshaka.media.StreamingEngine.prototype.getBufferingText = function() {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  return this.getStream_(ContentType.TEXT);\n};\n\n\n/**\n * Get the stream of the given type which we are currently buffering.  Returns\n * null if there is no stream for the given type.\n * @param {shaka.util.ManifestParserUtils.ContentType} type\n * @return {?shaka.extern.Stream}\n * @private\n*/\nshaka.media.StreamingEngine.prototype.getStream_ = function(type) {\n  const state = this.mediaStates_.get(type);\n\n  if (state) {\n    // Don't tell the caller about trick play streams.  If we're in trick\n    // play, return the stream we will go back to after we exit trick play.\n    return state.restoreStreamAfterTrickPlay || state.stream;\n  } else {\n    return null;\n  }\n};\n\n\n/**\n * Notifies StreamingEngine that a new text stream was added to the manifest.\n * This initializes the given stream. This returns a Promise that resolves when\n * the stream has been set up, and a media state has been created.\n *\n * @param {shaka.extern.Stream} stream\n * @return {!Promise}\n */\nshaka.media.StreamingEngine.prototype.loadNewTextStream = async function(\n    stream) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  // Clear MediaSource's buffered text, so that the new text stream will\n  // properly replace the old buffered text.\n  await this.playerInterface_.mediaSourceEngine.clear(ContentType.TEXT);\n\n  // Since setupStreams_() is async, if the user hides/shows captions quickly,\n  // there would be a race condition that a new text media state is created\n  // but the old media state is not yet deleted.\n  // The Sequence Id is to avoid that race condition.\n  this.textStreamSequenceId_++;\n  this.unloadingTextStream_ = false;\n  let currentSequenceId = this.textStreamSequenceId_;\n\n  let mediaSourceEngine = this.playerInterface_.mediaSourceEngine;\n\n  const streamMap = new Map();\n  const streamSet = new Set();\n\n  streamMap.set(ContentType.TEXT, stream);\n  streamSet.add(stream);\n\n  await mediaSourceEngine.init(streamMap, /** forceTansmuxTS */ false);\n  if (this.destroyed_) { return; }\n\n  await this.setupStreams_(streamSet);\n  if (this.destroyed_) { return; }\n\n  const showText = this.playerInterface_\n      .mediaSourceEngine\n      .getTextDisplayer()\n      .isTextVisible();\n\n  const streamText = showText || this.config_.alwaysStreamText;\n\n  if ((this.textStreamSequenceId_ == currentSequenceId) &&\n      !this.mediaStates_.has(ContentType.TEXT) &&\n      !this.unloadingTextStream_ && streamText) {\n    const presentationTime = this.playerInterface_.getPresentationTime();\n    const needPeriodIndex = this.findPeriodForTime_(presentationTime);\n\n    const state = this.createMediaState_(stream,\n                                         needPeriodIndex,\n                                         /* resumeAt= */ 0);\n\n    this.mediaStates_.set(ContentType.TEXT, state);\n    this.scheduleUpdate_(state, 0);\n  }\n};\n\n\n/**\n * Stop fetching text stream when the user chooses to hide the captions.\n */\nshaka.media.StreamingEngine.prototype.unloadTextStream = function() {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  this.unloadingTextStream_ = true;\n\n  const state = this.mediaStates_.get(ContentType.TEXT);\n  if (state) {\n    this.cancelUpdate_(state);\n    this.mediaStates_.delete(ContentType.TEXT);\n  }\n};\n\n\n/**\n * Set trick play on or off.\n * If trick play is on, related trick play streams will be used when possible.\n * @param {boolean} on\n */\nshaka.media.StreamingEngine.prototype.setTrickPlay = function(on) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  const mediaState = this.mediaStates_.get(ContentType.VIDEO);\n  if (!mediaState) return;\n\n  let stream = mediaState.stream;\n  if (!stream) return;\n\n  shaka.log.debug('setTrickPlay', on);\n  if (on) {\n    let trickModeVideo = stream.trickModeVideo;\n    if (!trickModeVideo) return;  // Can't engage trick play.\n\n    let normalVideo = mediaState.restoreStreamAfterTrickPlay;\n    if (normalVideo) return;  // Already in trick play.\n\n    shaka.log.debug('Engaging trick mode stream', trickModeVideo);\n    this.switchInternal_(trickModeVideo, /* clearBuffer= */ false,\n        /* safeMargin= */ 0, /* force= */ false);\n    mediaState.restoreStreamAfterTrickPlay = stream;\n  } else {\n    let normalVideo = mediaState.restoreStreamAfterTrickPlay;\n    if (!normalVideo) return;\n\n    shaka.log.debug('Restoring non-trick-mode stream', normalVideo);\n    mediaState.restoreStreamAfterTrickPlay = null;\n    this.switchInternal_(normalVideo, /* clearBuffer= */ true,\n        /* safeMargin= */ 0, /* force= */ false);\n  }\n};\n\n\n/**\n * @param {shaka.extern.Variant} variant\n * @param {boolean} clearBuffer\n * @param {number} safeMargin\n */\nshaka.media.StreamingEngine.prototype.switchVariant =\n    function(variant, clearBuffer, safeMargin) {\n  if (variant.video) {\n    this.switchInternal_(variant.video, /* clearBuffer= */ clearBuffer,\n        /* safeMargin= */ safeMargin, /* force= */ false);\n  }\n  if (variant.audio) {\n    this.switchInternal_(variant.audio, /* clearBuffer= */ clearBuffer,\n        /* safeMargin= */ safeMargin, /* force= */ false);\n  }\n};\n\n\n/**\n * @param {shaka.extern.Stream} textStream\n */\nshaka.media.StreamingEngine.prototype.switchTextStream = function(textStream) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  goog.asserts.assert(textStream && textStream.type == ContentType.TEXT,\n      'Wrong stream type passed to switchTextStream!');\n  this.switchInternal_(textStream, /* clearBuffer= */ true, /* safeMargin= */ 0,\n      /* force= */ false);\n};\n\n\n/** Reload the current text stream. */\nshaka.media.StreamingEngine.prototype.reloadTextStream = function() {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  const mediaState = this.mediaStates_.get(ContentType.TEXT);\n  if (mediaState) { // Don't reload if there's no text to begin with.\n    this.switchInternal_(mediaState.stream, /* clearBuffer= */ true,\n        /* safeMargin= */ 0, /* force= */ true);\n  }\n};\n\n\n/**\n * Switches to the given Stream. |stream| may be from any Variant or any Period.\n *\n * @param {shaka.extern.Stream} stream\n * @param {boolean} clearBuffer\n * @param {number} safeMargin\n * @param {boolean} force\n *   If true, reload the text stream even if it did not change.\n * @private\n */\nshaka.media.StreamingEngine.prototype.switchInternal_ = function(\n    stream, clearBuffer, safeMargin, force) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  const type = /** @type {!ContentType} */(stream.type);\n  const mediaState = this.mediaStates_.get(type);\n\n  if (!mediaState && stream.type == ContentType.TEXT &&\n      this.config_.ignoreTextStreamFailures) {\n    this.loadNewTextStream(stream);\n    return;\n  }\n  goog.asserts.assert(mediaState, 'switch: expected mediaState to exist');\n  if (!mediaState) return;\n\n  // If we are selecting a stream from a different Period, then we need to\n  // handle a Period transition. Simply ignore the given stream, assuming that\n  // Player will select the same track in onChooseStreams.\n  let periodIndex = this.findPeriodContainingStream_(stream);\n  const mediaStates = Array.from(this.mediaStates_.values());\n  const needSamePeriod = mediaStates.every((ms) => {\n    return ms.needPeriodIndex == mediaState.needPeriodIndex;\n  });\n  if (clearBuffer && periodIndex != mediaState.needPeriodIndex &&\n      needSamePeriod) {\n    shaka.log.debug('switch: switching to stream in another Period; clearing ' +\n                    'buffer and changing Periods');\n    // handlePeriodTransition_ will be called on the next update because the\n    // current Period won't match the playhead Period.\n    this.mediaStates_.forEach((mediaState) => {\n      this.forceClearBuffer_(mediaState);\n    });\n    return;\n  }\n\n  if (mediaState.restoreStreamAfterTrickPlay) {\n    shaka.log.debug('switch during trick play mode', stream);\n\n    // Already in trick play mode, so stick with trick mode tracks if possible.\n    if (stream.trickModeVideo) {\n      // Use the trick mode stream, but revert to the new selection later.\n      mediaState.restoreStreamAfterTrickPlay = stream;\n      stream = stream.trickModeVideo;\n      shaka.log.debug('switch found trick play stream', stream);\n    } else {\n      // There is no special trick mode video for this stream!\n      mediaState.restoreStreamAfterTrickPlay = null;\n      shaka.log.debug('switch found no special trick play stream');\n    }\n  }\n\n  // Ensure the Period is ready.\n  let canSwitchRecord = this.canSwitchPeriod_[periodIndex];\n  goog.asserts.assert(\n      canSwitchRecord && canSwitchRecord.resolved,\n      'switch: expected Period ' + periodIndex + ' to be ready');\n  if (!canSwitchRecord || !canSwitchRecord.resolved) return;\n\n  // Sanity check. If the Period is ready then the Stream should be ready too.\n  canSwitchRecord = this.canSwitchStream_.get(stream.id);\n  goog.asserts.assert(canSwitchRecord && canSwitchRecord.resolved,\n                      'switch: expected Stream ' + stream.id + ' to be ready');\n  if (!canSwitchRecord || !canSwitchRecord.resolved) return;\n\n  if (mediaState.stream == stream && !force) {\n    const streamTag = shaka.media.StreamingEngine.logPrefix_(mediaState);\n    shaka.log.debug('switch: Stream ' + streamTag + ' already active');\n    return;\n  }\n\n  if (stream.type == ContentType.TEXT) {\n    // Mime types are allowed to change for text streams.\n    // Reinitialize the text parser, but only if we are going to fetch the init\n    // segment again.\n    let fullMimeType = shaka.util.MimeUtils.getFullType(\n        stream.mimeType, stream.codecs);\n    this.playerInterface_.mediaSourceEngine.reinitText(fullMimeType);\n  }\n\n  mediaState.stream = stream;\n  mediaState.needInitSegment = true;\n\n  let streamTag = shaka.media.StreamingEngine.logPrefix_(mediaState);\n  shaka.log.debug('switch: switching to Stream ' + streamTag);\n\n  if (this.shouldAbortCurrentRequest_(mediaState, periodIndex)) {\n    shaka.log.info('Aborting current segment request to switch.');\n    mediaState.operation.abort();\n  }\n\n  if (clearBuffer) {\n    if (mediaState.clearingBuffer) {\n      // We are already going to clear the buffer, but make sure it is also\n      // flushed.\n      mediaState.waitingToFlushBuffer = true;\n    } else if (mediaState.performingUpdate) {\n      // We are performing an update, so we have to wait until it's finished.\n      // onUpdate_() will call clearBuffer_() when the update has finished.\n      // We need to save the safe margin because its value will be needed when\n      // clearing the buffer after the update.\n      mediaState.waitingToClearBuffer = true;\n      mediaState.clearBufferSafeMargin = safeMargin;\n      mediaState.waitingToFlushBuffer = true;\n    } else {\n      // Cancel the update timer, if any.\n      this.cancelUpdate_(mediaState);\n      // Clear right away.\n      this.clearBuffer_(mediaState, /* flush */ true, safeMargin)\n          .catch((error) => {\n            if (this.playerInterface_) {\n              this.playerInterface_.onError(\n                  /** @type {!shaka.util.Error} */ (error));\n            }\n          });\n    }\n  }\n};\n\n\n/**\n * Returns whether we should abort the current request.\n *\n * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} periodIndex\n * @return {boolean}\n */\nshaka.media.StreamingEngine.prototype.shouldAbortCurrentRequest_ =\n    function(mediaState, periodIndex) {\n  // If the operation is completed, it will be set to null, and there's no need\n  // to abort the request.\n  if (!mediaState.operation) {\n    return false;\n  }\n\n  const presentationTime = this.playerInterface_.getPresentationTime();\n  const bufferEnd =\n      this.playerInterface_.mediaSourceEngine.bufferEnd(mediaState.type);\n\n  // The next segment to append from the current stream.  This doesn't account\n  // for a pending network request and will likely be different from that since\n  // we just switched.\n  const newSegment = this.getSegmentReferenceNeeded_(\n      mediaState, presentationTime, bufferEnd, periodIndex);\n  let newSegmentSize = newSegment ? newSegment.getSize() : null;\n  if (newSegmentSize == null) {\n    return false;\n  }\n\n  // When switching, we'll need to download the init segment.\n  const init = mediaState.stream.initSegmentReference;\n  if (init) {\n    newSegmentSize += init.getSize() || 0;\n  }\n\n  const bandwidthEstimate = this.playerInterface_.getBandwidthEstimate();\n\n  // The estimate is in bits per second, and the size is in bytes.  The time\n  // remaining is in seconds after this calculation.\n  const timeToFetchNewSegment = (newSegmentSize * 8) / bandwidthEstimate;\n\n  // If the new segment can be finished in time without risking a buffer\n  // underflow, we should abort the old one and switch.\n  const bufferedAhead = bufferEnd - presentationTime;\n  const safetyBuffer = Math.max(\n      this.manifest_.minBufferTime || 0,\n      this.config_.rebufferingGoal);\n  const safeBufferedAhead = bufferedAhead - safetyBuffer;\n  if (timeToFetchNewSegment < safeBufferedAhead) {\n    return true;\n  }\n\n  // If the thing we want to switch to will be done more quickly than what\n  // we've got in progress, we should abort the old one and switch.\n  const bytesRemaining = mediaState.operation.getBytesRemaining();\n  if (bytesRemaining > newSegmentSize) {\n    return true;\n  }\n\n  // Otherwise, complete the operation in progress.\n  return false;\n};\n\n\n/**\n * Notifies the StreamingEngine that the playhead has moved to a valid time\n * within the presentation timeline.\n */\nshaka.media.StreamingEngine.prototype.seeked = function() {\n  const Iterables = shaka.util.Iterables;\n  const presentationTime = this.playerInterface_.getPresentationTime();\n  const smallGapLimit = this.config_.smallGapLimit;\n  const checkBuffered = (type) => {\n    return this.playerInterface_.mediaSourceEngine.isBuffered(\n        type, presentationTime, smallGapLimit);\n  };\n\n  let streamCleared = false;\n  const atPeriodIndex = this.findPeriodForTime_(presentationTime);\n  const allSeekingWithinSamePeriod = Iterables.every(\n      this.mediaStates_.values(),\n      (state) => state.needPeriodIndex == atPeriodIndex);\n  if (allSeekingWithinSamePeriod) {\n    // If seeking to the same period you were in before, clear buffers\n    // individually as desired.\n    for (const type of this.mediaStates_.keys()) {\n      if (!checkBuffered(type)) {\n        // This stream exists, and isn't buffered.\n        this.forceClearBuffer_(this.mediaStates_.get(type));\n        streamCleared = true;\n      }\n    }\n  } else {\n    // Only treat this as a buffered seek if every media state has a buffer.\n    // For example, if we have buffered text but not video, we should still\n    // clear every buffer so all media states need the same Period.\n    const isAllBuffered = Iterables.every(\n        this.mediaStates_.keys(), checkBuffered);\n    if (!isAllBuffered) {\n      // This was an unbuffered seek for at least one stream, so clear all\n      // buffers.\n      // Don't clear only some of the buffers because we can become stalled\n      // since the media states are waiting for different Periods.\n      shaka.log.debug('(all): seeked: unbuffered seek: clearing all buffers');\n      this.mediaStates_.forEach((mediaState) => {\n        this.forceClearBuffer_(mediaState);\n      });\n      streamCleared = true;\n    }\n  }\n\n  if (!streamCleared) {\n    shaka.log.debug(\n        '(all): seeked: buffered seek: presentationTime=' + presentationTime);\n  }\n};\n\n\n/**\n * Clear the buffer for a given stream.  Unlike clearBuffer_, this will handle\n * cases where a MediaState is performing an update.  After this runs, every\n * MediaState will have a pending update.\n * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n * @private\n */\nshaka.media.StreamingEngine.prototype.forceClearBuffer_ = function(\n    mediaState) {\n  const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n  if (mediaState.clearingBuffer) {\n    // We're already clearing the buffer, so we don't need to clear the\n    // buffer again.\n    shaka.log.debug(logPrefix, 'clear: already clearing the buffer');\n    return;\n  }\n\n  if (mediaState.waitingToClearBuffer) {\n    // May not be performing an update, but an update will still happen.\n    // See: https://github.com/google/shaka-player/issues/334\n    shaka.log.debug(logPrefix, 'clear: already waiting');\n    return;\n  }\n\n  if (mediaState.performingUpdate) {\n    // We are performing an update, so we have to wait until it's finished.\n    // onUpdate_() will call clearBuffer_() when the update has finished.\n    shaka.log.debug(logPrefix, 'clear: currently updating');\n    mediaState.waitingToClearBuffer = true;\n    // We can set the offset to zero to remember that this was a call to\n    // clearAllBuffers.\n    mediaState.clearBufferSafeMargin = 0;\n    return;\n  }\n\n  const type = mediaState.type;\n  if (this.playerInterface_.mediaSourceEngine.bufferStart(type) == null) {\n    // Nothing buffered.\n    shaka.log.debug(logPrefix, 'clear: nothing buffered');\n    if (mediaState.updateTimer == null) {\n      // Note: an update cycle stops when we buffer to the end of the\n      // presentation or Period, or when we raise an error.\n      this.scheduleUpdate_(mediaState, 0);\n    }\n    return;\n  }\n\n  // An update may be scheduled, but we can just cancel it and clear the\n  // buffer right away. Note: clearBuffer_() will schedule the next update.\n  shaka.log.debug(logPrefix, 'clear: handling right now');\n  this.cancelUpdate_(mediaState);\n  this.clearBuffer_(mediaState, /* flush */ false, 0).catch((error) => {\n    if (this.playerInterface_) {\n      this.playerInterface_.onError(/** @type {!shaka.util.Error} */ (error));\n    }\n  });\n};\n\n\n/**\n * Initializes the given streams and media states if required.  This will\n * schedule updates for the given types.\n *\n * @param {?shaka.extern.Stream} audio\n * @param {?shaka.extern.Stream} video\n * @param {?shaka.extern.Stream} text\n * @param {number} resumeAt\n * @return {!Promise}\n * @private\n */\nshaka.media.StreamingEngine.prototype.initStreams_ = async function(\n    audio, video, text, resumeAt) {\n  goog.asserts.assert(this.config_,\n      'StreamingEngine configure() must be called before init()!');\n\n  // Determine which Period we must buffer.\n  const presentationTime = this.playerInterface_.getPresentationTime();\n  const needPeriodIndex = this.findPeriodForTime_(presentationTime);\n\n  // Init/re-init MediaSourceEngine. Note that a re-init is only valid for text.\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  /**\n   * @type {!Map.<shaka.util.ManifestParserUtils.ContentType,\n   *              shaka.extern.Stream>}\n   */\n  const streamsByType = new Map();\n  /** @type {!Set.<shaka.extern.Stream>} */\n  const streams = new Set();\n\n  if (audio) {\n    streamsByType.set(ContentType.AUDIO, audio);\n    streams.add(audio);\n  }\n\n  if (video) {\n    streamsByType.set(ContentType.VIDEO, video);\n    streams.add(video);\n  }\n\n  if (text) {\n    streamsByType.set(ContentType.TEXT, text);\n    streams.add(text);\n  }\n\n  // Init MediaSourceEngine.\n  let mediaSourceEngine = this.playerInterface_.mediaSourceEngine;\n  let forceTransmuxTS = this.config_.forceTransmuxTS;\n\n  await mediaSourceEngine.init(streamsByType, forceTransmuxTS);\n  if (this.destroyed_) { return; }\n\n  this.setDuration_();\n\n  // Setup the initial set of Streams and then begin each update cycle. After\n  // startup completes onUpdate_() will set up the remaining Periods.\n  await this.setupStreams_(streams);\n  if (this.destroyed_) { return; }\n\n  streamsByType.forEach((stream, type) => {\n    if (!this.mediaStates_.has(type)) {\n      const state = this.createMediaState_(stream, needPeriodIndex, resumeAt);\n      this.mediaStates_.set(type, state);\n      this.scheduleUpdate_(state, 0);\n    }\n  });\n};\n\n\n/**\n * Creates a media state.\n *\n * @param {shaka.extern.Stream} stream\n * @param {number} needPeriodIndex\n * @param {number} resumeAt\n * @return {shaka.media.StreamingEngine.MediaState_}\n * @private\n */\nshaka.media.StreamingEngine.prototype.createMediaState_ = function(\n    stream, needPeriodIndex, resumeAt) {\n  return /** @type {shaka.media.StreamingEngine.MediaState_} */ ({\n    stream: stream,\n    type: stream.type,\n    lastStream: null,\n    lastSegmentReference: null,\n    restoreStreamAfterTrickPlay: null,\n    needInitSegment: true,\n    needPeriodIndex: needPeriodIndex,\n    endOfStream: false,\n    performingUpdate: false,\n    updateTimer: null,\n    waitingToClearBuffer: false,\n    clearBufferSafeMargin: 0,\n    waitingToFlushBuffer: false,\n    clearingBuffer: false,\n    recovering: false,\n    hasError: false,\n    resumeAt: resumeAt || 0,\n    operation: null,\n  });\n};\n\n\n/**\n * Sets up the given Period if necessary. Calls onError() if an error occurs.\n *\n * @param {number} periodIndex The Period's index.\n * @return {!Promise} A Promise which resolves when the given Period is set up.\n * @private\n */\nshaka.media.StreamingEngine.prototype.setupPeriod_ = function(periodIndex) {\n  let canSwitchRecord = this.canSwitchPeriod_[periodIndex];\n  if (canSwitchRecord) {\n    shaka.log.debug(\n        '(all) Period ' + periodIndex + ' is being or has been set up');\n    goog.asserts.assert(canSwitchRecord.promise, 'promise must not be null');\n    return canSwitchRecord.promise;\n  }\n\n  shaka.log.debug('(all) setting up Period ' + periodIndex);\n  canSwitchRecord = {\n    promise: new shaka.util.PublicPromise(),\n    resolved: false,\n  };\n  this.canSwitchPeriod_[periodIndex] = canSwitchRecord;\n\n  const streams = new Set();\n\n  // Add all video, trick video, and audio streams.\n  for (const variant of this.manifest_.periods[periodIndex].variants) {\n    if (variant.video) {\n      streams.add(variant.video);\n    }\n    if (variant.video && variant.video.trickModeVideo) {\n      streams.add(variant.video.trickModeVideo);\n    }\n    if (variant.audio) {\n      streams.add(variant.audio);\n    }\n  }\n\n  // Add text streams\n  for (const stream of this.manifest_.periods[periodIndex].textStreams) {\n    streams.add(stream);\n  }\n\n  // Serialize Period set up.\n  this.setupPeriodPromise_ = this.setupPeriodPromise_.then(function() {\n    if (this.destroyed_) return;\n    return this.setupStreams_(streams);\n  }.bind(this)).then(function() {\n    if (this.destroyed_) return;\n    this.canSwitchPeriod_[periodIndex].promise.resolve();\n    this.canSwitchPeriod_[periodIndex].resolved = true;\n    shaka.log.v1('(all) setup Period ' + periodIndex);\n  }.bind(this)).catch(function(error) {\n    if (this.destroyed_) return;\n    this.canSwitchPeriod_[periodIndex].promise.catch(() => {});\n    this.canSwitchPeriod_[periodIndex].promise.reject();\n    delete this.canSwitchPeriod_[periodIndex];\n    shaka.log.warning('(all) failed to setup Period ' + periodIndex);\n    this.playerInterface_.onError(error);\n    // Don't stop other Periods from being set up.\n  }.bind(this));\n\n  return canSwitchRecord.promise;\n};\n\n\n/**\n * Sets up the given Streams if necessary. Does NOT call onError() if an\n * error occurs.\n *\n * @param {!Set.<!shaka.extern.Stream>} streams\n *    Use a set instead of list because duplicate ids will cause the player to\n *    hang.\n * @return {!Promise}\n * @private\n */\nshaka.media.StreamingEngine.prototype.setupStreams_ = async function(streams) {\n  // Parallelize Stream set up.\n  const parallelWork = [];\n\n  for (const stream of streams) {\n    const canSwitchRecord = this.canSwitchStream_.get(stream.id);\n\n    if (canSwitchRecord) {\n      shaka.log.debug(\n          '(all) Stream ' + stream.id + ' is being or has been set up');\n      parallelWork.push(canSwitchRecord.promise);\n    } else {\n      shaka.log.v1('(all) setting up Stream ' + stream.id);\n      this.canSwitchStream_.set(stream.id, {\n        promise: new shaka.util.PublicPromise(),\n        resolved: false,\n      });\n      parallelWork.push(stream.createSegmentIndex());\n    }\n  }\n\n  try {\n    await Promise.all(parallelWork);\n    if (this.destroyed_) return;\n  } catch (error) {\n    if (this.destroyed_) return;\n\n    for (const stream of streams) {\n      this.canSwitchStream_.get(stream.id).promise.catch(() => {});\n      this.canSwitchStream_.get(stream.id).promise.reject();\n      this.canSwitchStream_.delete(stream.id);\n    }\n\n    throw error;\n  }\n\n  for (const stream of streams) {\n    const canSwitchRecord = this.canSwitchStream_.get(stream.id);\n    if (!canSwitchRecord.resolved) {\n      canSwitchRecord.promise.resolve();\n      canSwitchRecord.resolved = true;\n      shaka.log.v1('(all) setup Stream ' + stream.id);\n    }\n  }\n};\n\n\n/**\n * Sets the MediaSource's duration.\n * @private\n */\nshaka.media.StreamingEngine.prototype.setDuration_ = function() {\n  let duration = this.manifest_.presentationTimeline.getDuration();\n  if (duration < Infinity) {\n    this.playerInterface_.mediaSourceEngine.setDuration(duration);\n  } else {\n    // Not all platforms support infinite durations, so set a finite duration\n    // so we can append segments and so the user agent can seek.\n    this.playerInterface_.mediaSourceEngine.setDuration(Math.pow(2, 32));\n  }\n};\n\n\n/**\n * Called when |mediaState|'s update timer has expired.\n *\n * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n * @private\n */\nshaka.media.StreamingEngine.prototype.onUpdate_ = function(mediaState) {\n  if (this.destroyed_) return;\n\n  let logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n  // Sanity check.\n  goog.asserts.assert(\n      !mediaState.performingUpdate && (mediaState.updateTimer != null),\n      logPrefix + ' unexpected call to onUpdate_()');\n  if (mediaState.performingUpdate || (mediaState.updateTimer == null)) return;\n\n  goog.asserts.assert(\n      !mediaState.clearingBuffer,\n      logPrefix + ' onUpdate_() should not be called when clearing the buffer');\n  if (mediaState.clearingBuffer) return;\n\n  mediaState.updateTimer = null;\n\n  // Handle pending buffer clears.\n  if (mediaState.waitingToClearBuffer) {\n    // Note: clearBuffer_() will schedule the next update.\n    shaka.log.debug(logPrefix, 'skipping update and clearing the buffer');\n    this.clearBuffer_(\n        mediaState, mediaState.waitingToFlushBuffer,\n        mediaState.clearBufferSafeMargin);\n    return;\n  }\n\n  // Update the MediaState.\n  try {\n    let delay = this.update_(mediaState);\n    if (delay != null) {\n      this.scheduleUpdate_(mediaState, delay);\n      mediaState.hasError = false;\n    }\n  } catch (error) {\n    this.handleStreamingError_(error);\n    return;\n  }\n\n  const mediaStates = Array.from(this.mediaStates_.values());\n\n  // Check if we've buffered to the end of the Period.\n  this.handlePeriodTransition_(mediaState);\n\n  // Check if we've buffered to the end of the presentation.  We delay adding\n  // the audio and video media states, so it is possible for the text stream\n  // to be the only state and buffer to the end.  So we need to wait until we\n  // have completed startup to determine if we have reached the end.\n  if (this.startupComplete_ &&\n      mediaStates.every(function(ms) { return ms.endOfStream; })) {\n    shaka.log.v1(logPrefix, 'calling endOfStream()...');\n    this.playerInterface_.mediaSourceEngine.endOfStream().then(function() {\n      if (this.destroyed_) {\n        return;\n      }\n\n      // If the media segments don't reach the end, then we need to update the\n      // timeline duration to match the final media duration to avoid buffering\n      // forever at the end.  We should only do this if the duration needs to\n      // shrink.  Growing it by less than 1ms can actually cause buffering on\n      // replay, as in https://github.com/google/shaka-player/issues/979\n      // On some platforms, this can spuriously be 0, so ignore this case.\n      // https://github.com/google/shaka-player/issues/1967,\n      const duration = this.playerInterface_.mediaSourceEngine.getDuration();\n      if (duration != 0 &&\n          duration < this.manifest_.presentationTimeline.getDuration()) {\n        this.manifest_.presentationTimeline.setDuration(duration);\n      }\n    }.bind(this));\n  }\n};\n\n\n/**\n * Updates the given MediaState.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @return {?number} The number of seconds to wait until updating again or\n *   null if another update does not need to be scheduled.\n * @throws {!shaka.util.Error} if an error occurs.\n * @private\n */\nshaka.media.StreamingEngine.prototype.update_ = function(mediaState) {\n  goog.asserts.assert(this.manifest_, 'manifest_ should not be null');\n  goog.asserts.assert(this.config_, 'config_ should not be null');\n\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  // If it's a text stream and the original id starts with 'CC', it's CEA\n  // closed captions. Do not schedule update for closed captions text\n  // mediastate, since closed captions are embedded in video streams.\n  const isCaptionState = (state) => {\n    return state.type == ContentType.TEXT &&\n        state.stream.mimeType == shaka.util.MimeUtils.CLOSED_CAPTION_MIMETYPE;\n  };\n  if (isCaptionState(mediaState)) {\n    this.playerInterface_.mediaSourceEngine.setSelectedClosedCaptionId(\n        mediaState.stream.originalId || '');\n    return null;\n  }\n\n  let logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n  // Compute how far we've buffered ahead of the playhead.\n  const presentationTime = this.playerInterface_.getPresentationTime();\n\n  // Get the next timestamp we need.\n  let timeNeeded = this.getTimeNeeded_(mediaState, presentationTime);\n  shaka.log.v2(logPrefix, 'timeNeeded=' + timeNeeded);\n\n  let currentPeriodIndex = this.findPeriodContainingStream_(mediaState.stream);\n  const needPeriodIndex = this.findPeriodForTime_(timeNeeded);\n\n  // Get the amount of content we have buffered, accounting for drift.  This\n  // is only used to determine if we have meet the buffering goal.  This should\n  // be the same method that PlayheadObserver uses.\n  let bufferedAhead = this.playerInterface_.mediaSourceEngine.bufferedAheadOf(\n      mediaState.type, presentationTime);\n\n  shaka.log.v2(logPrefix,\n               'update_:',\n               'presentationTime=' + presentationTime,\n               'bufferedAhead=' + bufferedAhead);\n\n  let unscaledBufferingGoal = Math.max(\n      this.manifest_.minBufferTime || 0,\n      this.config_.rebufferingGoal,\n      this.config_.bufferingGoal);\n\n  let scaledBufferingGoal = unscaledBufferingGoal * this.bufferingGoalScale_;\n\n  // Check if we've buffered to the end of the presentation.\n  if (timeNeeded >= this.manifest_.presentationTimeline.getDuration()) {\n    // We shouldn't rebuffer if the playhead is close to the end of the\n    // presentation.\n    shaka.log.debug(logPrefix, 'buffered to end of presentation');\n    mediaState.endOfStream = true;\n\n    if (mediaState.type == ContentType.VIDEO) {\n      // Since the text stream of CEA closed captions doesn't have update timer,\n      // we have to set the text endOfStream based on the video stream's\n      // endOfStream state.\n      const textState = this.mediaStates_.get(ContentType.TEXT);\n      if (textState && textState.stream.mimeType ==\n            shaka.util.MimeUtils.CLOSED_CAPTION_MIMETYPE) {\n        textState.endOfStream = true;\n      }\n    }\n    return null;\n  }\n  mediaState.endOfStream = false;\n\n  // Check if we've buffered to the end of the Period. This should be done\n  // before checking segment availability because the new Period may become\n  // available once it's switched to. Note that we don't use the non-existence\n  // of SegmentReferences as an indicator to determine Period boundaries\n  // because a SegmentIndex can provide SegmentReferences outside its Period.\n  mediaState.needPeriodIndex = needPeriodIndex;\n  if (needPeriodIndex != currentPeriodIndex) {\n    shaka.log.debug(logPrefix,\n                    'need Period ' + needPeriodIndex,\n                    'presentationTime=' + presentationTime,\n                    'timeNeeded=' + timeNeeded,\n                    'currentPeriodIndex=' + currentPeriodIndex);\n    return null;\n  }\n\n  // If we've buffered to the buffering goal then schedule an update.\n  if (bufferedAhead >= scaledBufferingGoal) {\n    shaka.log.v2(logPrefix, 'buffering goal met');\n\n    // Do not try to predict the next update.  Just poll twice every second.\n    // The playback rate can change at any time, so any prediction we make now\n    // could be terribly invalid soon.\n    return 0.5;\n  }\n\n  let bufferEnd =\n      this.playerInterface_.mediaSourceEngine.bufferEnd(mediaState.type);\n  let reference = this.getSegmentReferenceNeeded_(\n      mediaState, presentationTime, bufferEnd, currentPeriodIndex);\n  if (!reference) {\n    // The segment could not be found, does not exist, or is not available.  In\n    // any case just try again... if the manifest is incomplete or is not being\n    // updated then we'll idle forever; otherwise, we'll end up getting a\n    // SegmentReference eventually.\n    return 1;\n  }\n\n  // Do not let any one stream get far ahead of any other.\n  let minTimeNeeded = Infinity;\n  const mediaStates = Array.from(this.mediaStates_.values());\n  mediaStates.forEach((otherState) => {\n    // Do not consider embedded captions in this calculation.  It could lead\n    // to hangs in streaming.\n    if (isCaptionState(otherState)) return;\n\n    const timeNeeded = this.getTimeNeeded_(otherState, presentationTime);\n    minTimeNeeded = Math.min(minTimeNeeded, timeNeeded);\n  });\n\n  const maxSegmentDuration =\n      this.manifest_.presentationTimeline.getMaxSegmentDuration();\n  const maxRunAhead =\n      maxSegmentDuration * shaka.media.StreamingEngine.MAX_RUN_AHEAD_SEGMENTS_;\n  if (timeNeeded >= minTimeNeeded + maxRunAhead) {\n    // Wait and give other media types time to catch up to this one.\n    // For example, let video buffering catch up to audio buffering before\n    // fetching another audio segment.\n    return 1;\n  }\n\n  mediaState.resumeAt = 0;\n  this.fetchAndAppend_(\n      mediaState,\n      presentationTime,\n      currentPeriodIndex,\n      reference);\n  return null;\n};\n\n\n/**\n * Gets the next timestamp needed. Returns the playhead's position if the\n * buffer is empty; otherwise, returns the time at which the last segment\n * appended ends.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} presentationTime\n * @return {number} The next timestamp needed.\n * @private\n */\nshaka.media.StreamingEngine.prototype.getTimeNeeded_ = function(\n    mediaState, presentationTime) {\n  // Get the next timestamp we need. We must use |lastSegmentReference|\n  // to determine this and not the actual buffer for two reasons:\n  //   1. Actual segments end slightly before their advertised end times, so\n  //      the next timestamp we need is actually larger than |bufferEnd|.\n  //   2. There may be drift (the timestamps in the segments are ahead/behind\n  //      of the timestamps in the manifest), but we need drift-free times when\n  //      comparing times against presentation and Period boundaries.\n  if (!mediaState.lastStream || !mediaState.lastSegmentReference) {\n    return Math.max(presentationTime, mediaState.resumeAt);\n  }\n\n  let lastPeriodIndex =\n      this.findPeriodContainingStream_(mediaState.lastStream);\n  let lastPeriod = this.manifest_.periods[lastPeriodIndex];\n  return lastPeriod.startTime + mediaState.lastSegmentReference.endTime;\n};\n\n\n/**\n * Gets the SegmentReference of the next segment needed.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} presentationTime\n * @param {?number} bufferEnd\n * @param {number} currentPeriodIndex\n * @return {shaka.media.SegmentReference} The SegmentReference of the\n *   next segment needed. Returns null if a segment could not be found, does not\n *   exist, or is not available.\n * @private\n */\nshaka.media.StreamingEngine.prototype.getSegmentReferenceNeeded_ = function(\n    mediaState, presentationTime, bufferEnd, currentPeriodIndex) {\n  let logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n  if (mediaState.lastSegmentReference &&\n      mediaState.stream == mediaState.lastStream) {\n    // Something is buffered from the same Stream.\n    let position = mediaState.lastSegmentReference.position + 1;\n    shaka.log.v2(logPrefix, 'next position known:', 'position=' + position);\n\n    return this.getSegmentReferenceIfAvailable_(\n        mediaState, currentPeriodIndex, position);\n  }\n\n  let position;\n\n  if (mediaState.lastSegmentReference) {\n    // Something is buffered from another Stream.\n    goog.asserts.assert(mediaState.lastStream, 'lastStream should not be null');\n    shaka.log.v1(logPrefix, 'next position unknown: another Stream buffered');\n    let lastPeriodIndex =\n        this.findPeriodContainingStream_(mediaState.lastStream);\n    let lastPeriod = this.manifest_.periods[lastPeriodIndex];\n    position = this.lookupSegmentPosition_(\n        mediaState,\n        lastPeriod.startTime + mediaState.lastSegmentReference.endTime,\n        currentPeriodIndex);\n  } else {\n    // Either nothing is buffered, or we have cleared part of the buffer.  If\n    // we still have some buffered, use that time to find the segment, otherwise\n    // start at the playhead time.\n    goog.asserts.assert(!mediaState.lastStream, 'lastStream should be null');\n    shaka.log.v1(logPrefix, 'next position unknown: nothing buffered');\n    position = this.lookupSegmentPosition_(\n        mediaState, bufferEnd || presentationTime, currentPeriodIndex);\n  }\n\n  if (position == null) {\n    return null;\n  }\n\n  let reference = null;\n  if (bufferEnd == null) {\n    // If there's positive drift then we need to get the previous segment;\n    // however, we don't actually know how much drift there is, so we must\n    // unconditionally get the previous segment. If it turns out that there's\n    // non-positive drift then we'll just end up buffering beind the playhead a\n    // little more than we needed.\n    let optimalPosition = Math.max(0, position - 1);\n    reference = this.getSegmentReferenceIfAvailable_(\n        mediaState, currentPeriodIndex, optimalPosition);\n  }\n  return reference ||\n      this.getSegmentReferenceIfAvailable_(\n          mediaState, currentPeriodIndex, position);\n};\n\n\n/**\n * Looks up the position of the segment containing the given timestamp.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} presentationTime The timestamp needed, relative to the\n *   start of the presentation.\n * @param {number} currentPeriodIndex\n * @return {?number} A segment position, or null if a segment was not be found.\n * @private\n */\nshaka.media.StreamingEngine.prototype.lookupSegmentPosition_ = function(\n    mediaState, presentationTime, currentPeriodIndex) {\n  let logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n  let currentPeriod = this.manifest_.periods[currentPeriodIndex];\n\n  shaka.log.debug(logPrefix,\n                  'looking up segment:',\n                  'presentationTime=' + presentationTime,\n                  'currentPeriod.startTime=' + currentPeriod.startTime);\n\n  let lookupTime = Math.max(0, presentationTime - currentPeriod.startTime);\n  let position = mediaState.stream.findSegmentPosition(lookupTime);\n\n  if (position == null) {\n    shaka.log.warning(logPrefix,\n                      'cannot find segment:',\n                      'currentPeriod.startTime=' + currentPeriod.startTime,\n                      'lookupTime=' + lookupTime);\n  }\n\n  return position;\n};\n\n\n/**\n * Gets the SegmentReference at the given position if it's available.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} currentPeriodIndex\n * @param {number} position\n * @return {shaka.media.SegmentReference}\n *\n * @private\n */\nshaka.media.StreamingEngine.prototype.getSegmentReferenceIfAvailable_ =\n    function(mediaState, currentPeriodIndex, position) {\n  let logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n  let currentPeriod = this.manifest_.periods[currentPeriodIndex];\n\n  let reference = mediaState.stream.getSegmentReference(position);\n  if (!reference) {\n    shaka.log.v1(logPrefix,\n                 'segment does not exist:',\n                 'currentPeriod.startTime=' + currentPeriod.startTime,\n                 'position=' + position);\n    return null;\n  }\n\n  let timeline = this.manifest_.presentationTimeline;\n  let availabilityStart = timeline.getSegmentAvailabilityStart();\n  let availabilityEnd = timeline.getSegmentAvailabilityEnd();\n\n  if ((currentPeriod.startTime + reference.endTime < availabilityStart) ||\n      (currentPeriod.startTime + reference.startTime > availabilityEnd)) {\n    shaka.log.v2(logPrefix,\n                 'segment is not available:',\n                 'currentPeriod.startTime=' + currentPeriod.startTime,\n                 'reference.startTime=' + reference.startTime,\n                 'reference.endTime=' + reference.endTime,\n                 'availabilityStart=' + availabilityStart,\n                 'availabilityEnd=' + availabilityEnd);\n    return null;\n  }\n\n  return reference;\n};\n\n\n/**\n * Fetches and appends the given segment. Sets up the given MediaState's\n * associated SourceBuffer and evicts segments if either are required\n * beforehand. Schedules another update after completing successfully.\n *\n * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} presentationTime\n * @param {number} currentPeriodIndex The index of the current Period.\n * @param {!shaka.media.SegmentReference} reference\n * @private\n */\nshaka.media.StreamingEngine.prototype.fetchAndAppend_ = function(\n    mediaState, presentationTime, currentPeriodIndex, reference) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  const StreamingEngine = shaka.media.StreamingEngine;\n  const logPrefix = StreamingEngine.logPrefix_(mediaState);\n  const currentPeriod = this.manifest_.periods[currentPeriodIndex];\n\n  shaka.log.v1(logPrefix,\n               'fetchAndAppend_:',\n               'presentationTime=' + presentationTime,\n               'currentPeriod.startTime=' + currentPeriod.startTime,\n               'reference.position=' + reference.position,\n               'reference.startTime=' + reference.startTime,\n               'reference.endTime=' + reference.endTime);\n\n  // Subtlety: The playhead may move while asynchronous update operations are\n  // in progress, so we should avoid calling playhead.getTime() in any\n  // callbacks. Furthermore, switch() may be called at any time, so we should\n  // also avoid using mediaState.stream or mediaState.needInitSegment in any\n  // callbacks.\n  let stream = mediaState.stream;\n\n  // Compute the append window.\n  let duration = this.manifest_.presentationTimeline.getDuration();\n  let followingPeriod = this.manifest_.periods[currentPeriodIndex + 1];\n\n  // Rounding issues can cause us to remove the first frame of the Period, so\n  // reduce the start time slightly.\n  const appendWindowStart = Math.max(0,\n      currentPeriod.startTime - StreamingEngine.APPEND_WINDOW_START_FUDGE_);\n  const appendWindowEnd = followingPeriod ?\n      followingPeriod.startTime + StreamingEngine.APPEND_WINDOW_END_FUDGE_ :\n      duration;\n\n  goog.asserts.assert(\n      reference.startTime <= appendWindowEnd,\n      logPrefix + ' segment should start before append window end');\n\n  let initSourceBuffer = this.initSourceBuffer_(\n      mediaState, currentPeriodIndex, appendWindowStart, appendWindowEnd);\n\n  mediaState.performingUpdate = true;\n\n  // We may set |needInitSegment| to true in switch(), so set it to false here,\n  // since we want it to remain true if switch() is called.\n  mediaState.needInitSegment = false;\n\n  shaka.log.v2(logPrefix, 'fetching segment');\n  let fetchSegment = this.fetch_(mediaState, reference);\n\n\n  Promise.all([initSourceBuffer, fetchSegment]).then(function(results) {\n    if (this.destroyed_ || this.fatalError_) return;\n    return this.append_(mediaState,\n                        presentationTime,\n                        currentPeriod,\n                        stream,\n                        reference,\n                        results[1]);\n  }.bind(this)).then(function() {\n    if (this.destroyed_ || this.fatalError_) return;\n\n    mediaState.performingUpdate = false;\n    mediaState.recovering = false;\n\n    if (!mediaState.waitingToClearBuffer) {\n      this.playerInterface_.onSegmentAppended();\n    }\n\n    // Update right away.\n    this.scheduleUpdate_(mediaState, 0);\n\n    // Subtlety: handleStartup_() calls onStartupComplete() which may call\n    // switch() or seeked(), so we must schedule an update beforehand so\n    // |updateTimer| is set.\n    this.handleStartup_(mediaState, stream);\n\n    shaka.log.v1(logPrefix, 'finished fetch and append');\n  }.bind(this)).catch(function(error) {\n    if (this.destroyed_ || this.fatalError_) return;\n    goog.asserts.assert(error instanceof shaka.util.Error,\n                        'Should only receive a Shaka error');\n\n    mediaState.performingUpdate = false;\n\n    if (mediaState.type == ContentType.TEXT &&\n        this.config_.ignoreTextStreamFailures) {\n      if (error.code == shaka.util.Error.Code.BAD_HTTP_STATUS) {\n        shaka.log.warning(logPrefix,\n            'Text stream failed to download. Proceeding without it.');\n      } else {\n        shaka.log.warning(logPrefix,\n            'Text stream failed to parse. Proceeding without it.');\n      }\n      this.mediaStates_.delete(ContentType.TEXT);\n    } else if (error.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n      // If the network slows down, abort the current fetch request and start a\n      // new one, and ignore the error message.\n      mediaState.performingUpdate = false;\n      mediaState.updateTimer = null;\n      this.scheduleUpdate_(mediaState, 0);\n    } else if (error.code == shaka.util.Error.Code.QUOTA_EXCEEDED_ERROR) {\n      this.handleQuotaExceeded_(mediaState, error);\n    } else {\n      shaka.log.error(logPrefix, 'failed fetch and append: code=' + error.code);\n      mediaState.hasError = true;\n\n      error.severity = shaka.util.Error.Severity.CRITICAL;\n      this.handleStreamingError_(error);\n    }\n  }.bind(this));\n};\n\n\n/**\n * Clear per-stream error states and retry any failed streams.\n * @return {boolean} False if unable to retry.\n */\nshaka.media.StreamingEngine.prototype.retry = function() {\n  if (this.destroyed_) {\n    shaka.log.error('Unable to retry after StreamingEngine is destroyed!');\n    return false;\n  }\n\n  if (this.fatalError_) {\n    shaka.log.error('Unable to retry after StreamingEngine encountered a ' +\n                    'fatal error!');\n    return false;\n  }\n\n  for (const mediaState of this.mediaStates_.values()) {\n    let logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n    if (mediaState.hasError) {\n      shaka.log.info(logPrefix, 'Retrying after failure...');\n      mediaState.hasError = false;\n      this.scheduleUpdate_(mediaState, 0.1);\n    }\n  }\n\n  return true;\n};\n\n\n/**\n * Handles a QUOTA_EXCEEDED_ERROR.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {!shaka.util.Error} error\n * @private\n */\nshaka.media.StreamingEngine.prototype.handleQuotaExceeded_ = function(\n    mediaState, error) {\n  let logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n  // The segment cannot fit into the SourceBuffer. Ideally, MediaSource would\n  // have evicted old data to accommodate the segment; however, it may have\n  // failed to do this if the segment is very large, or if it could not find\n  // a suitable time range to remove.\n  //\n  // We can overcome the latter by trying to append the segment again;\n  // however, to avoid continuous QuotaExceededErrors we must reduce the size\n  // of the buffer going forward.\n  //\n  // If we've recently reduced the buffering goals, wait until the stream\n  // which caused the first QuotaExceededError recovers. Doing this ensures\n  // we don't reduce the buffering goals too quickly.\n\n  const mediaStates = Array.from(this.mediaStates_.values());\n  let waitingForAnotherStreamToRecover = mediaStates.some(function(ms) {\n    return ms != mediaState && ms.recovering;\n  });\n\n  if (!waitingForAnotherStreamToRecover) {\n    // Reduction schedule: 80%, 60%, 40%, 20%, 16%, 12%, 8%, 4%, fail.\n    // Note: percentages are used for comparisons to avoid rounding errors.\n    let percentBefore = Math.round(100 * this.bufferingGoalScale_);\n    if (percentBefore > 20) {\n      this.bufferingGoalScale_ -= 0.2;\n    } else if (percentBefore > 4) {\n      this.bufferingGoalScale_ -= 0.04;\n    } else {\n      shaka.log.error(\n          logPrefix, 'MediaSource threw QuotaExceededError too many times');\n      mediaState.hasError = true;\n      this.fatalError_ = true;\n      this.playerInterface_.onError(error);\n      return;\n    }\n    let percentAfter = Math.round(100 * this.bufferingGoalScale_);\n    shaka.log.warning(\n        logPrefix,\n        'MediaSource threw QuotaExceededError:',\n        'reducing buffering goals by ' + (100 - percentAfter) + '%');\n    mediaState.recovering = true;\n  } else {\n    shaka.log.debug(\n        logPrefix,\n        'MediaSource threw QuotaExceededError:',\n        'waiting for another stream to recover...');\n  }\n\n  // QuotaExceededError gets thrown if evication didn't help to make room\n  // for a segment. We want to wait for a while (4 seconds is just an\n  // arbitrary number) before updating to give the playhead a chance to\n  // advance, so we don't immidiately throw again.\n  this.scheduleUpdate_(mediaState, 4);\n};\n\n\n/**\n * Sets the given MediaState's associated SourceBuffer's timestamp offset and\n * init segment if either are required. If an error occurs then neither the\n * timestamp offset or init segment are unset, since another call to switch()\n * will end up superseding them.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} currentPeriodIndex\n * @param {number} appendWindowStart\n * @param {number} appendWindowEnd\n * @return {!Promise}\n * @private\n */\nshaka.media.StreamingEngine.prototype.initSourceBuffer_ = function(\n    mediaState, currentPeriodIndex, appendWindowStart, appendWindowEnd) {\n  if (!mediaState.needInitSegment) {\n    return Promise.resolve();\n  }\n\n  let logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n  let currentPeriod = this.manifest_.periods[currentPeriodIndex];\n\n  // If we need an init segment then the Stream switched, so we've either\n  // changed bitrates, Periods, or both. If we've changed Periods then we must\n  // set a new timestamp offset and append window end. Note that by setting\n  // these values here, we avoid having to co-ordinate ongoing updates, which\n  // we would have to do if we instead set them in switch().\n  let timestampOffset =\n      currentPeriod.startTime - mediaState.stream.presentationTimeOffset;\n  shaka.log.v1(logPrefix, 'setting timestamp offset to ' + timestampOffset);\n  shaka.log.v1(logPrefix,\n               'setting append window start to ' + appendWindowStart);\n  shaka.log.v1(logPrefix, 'setting append window end to ' + appendWindowEnd);\n  let setStreamProperties =\n      this.playerInterface_.mediaSourceEngine.setStreamProperties(\n          mediaState.type, timestampOffset, appendWindowStart, appendWindowEnd);\n\n  if (!mediaState.stream.initSegmentReference) {\n    // The Stream is self initializing.\n    return setStreamProperties;\n  }\n\n  shaka.log.v1(logPrefix, 'fetching init segment');\n\n  let fetchInit =\n      this.fetch_(mediaState, mediaState.stream.initSegmentReference);\n  let appendInit = fetchInit.then(function(initSegment) {\n    if (this.destroyed_) return;\n    shaka.log.v1(logPrefix, 'appending init segment');\n    const hasClosedCaptions = mediaState.stream.closedCaptions &&\n        mediaState.stream.closedCaptions.size > 0;\n    return this.playerInterface_.mediaSourceEngine.appendBuffer(\n        mediaState.type, initSegment, null /* startTime */, null /* endTime */,\n        hasClosedCaptions);\n  }.bind(this)).catch(function(error) {\n    mediaState.needInitSegment = true;\n    return Promise.reject(error);\n  });\n\n  return Promise.all([setStreamProperties, appendInit]);\n};\n\n\n/**\n * Appends the given segment and evicts content if required to append.\n *\n * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} presentationTime\n * @param {shaka.extern.Period} period\n * @param {shaka.extern.Stream} stream\n * @param {!shaka.media.SegmentReference} reference\n * @param {!ArrayBuffer} segment\n * @return {!Promise}\n * @private\n */\nshaka.media.StreamingEngine.prototype.append_ = function(\n    mediaState, presentationTime, period, stream, reference, segment) {\n  let logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n  const hasClosedCaptions = stream.closedCaptions &&\n      stream.closedCaptions.size > 0;\n  if (stream.emsgSchemeIdUris != null && stream.emsgSchemeIdUris.length > 0) {\n    new shaka.util.Mp4Parser()\n        .fullBox(\n            'emsg',\n            this.parseEMSG_.bind(\n                this, period, reference, stream.emsgSchemeIdUris))\n        .parse(segment);\n  }\n\n  return this.evict_(mediaState, presentationTime).then(function() {\n    if (this.destroyed_) return;\n    shaka.log.v1(logPrefix, 'appending media segment');\n\n    // MediaSourceEngine expects times relative to the start of the\n    // presentation.  Reference times are relative to the start of the period.\n    const startTime = reference.startTime + period.startTime;\n    const endTime = reference.endTime + period.startTime;\n\n    return this.playerInterface_.mediaSourceEngine.appendBuffer(\n        mediaState.type, segment, startTime, endTime, hasClosedCaptions);\n  }.bind(this)).then(function() {\n    if (this.destroyed_) return;\n    shaka.log.v2(logPrefix, 'appended media segment');\n\n    // We must use |stream| because switch() may have been called.\n    mediaState.lastStream = stream;\n    mediaState.lastSegmentReference = reference;\n\n    return Promise.resolve();\n  }.bind(this));\n};\n\n\n/**\n * Parse the EMSG box from a MP4 container.\n *\n * @param {!shaka.extern.Period} period\n * @param {!shaka.media.SegmentReference} reference\n * @param {?Array.<string>} emsgSchemeIdUris Array of emsg\n *     scheme_id_uri for which emsg boxes should be parsed.\n * @param {!shaka.extern.ParsedBox} box\n * @private\n */\nshaka.media.StreamingEngine.prototype.parseEMSG_ = function(\n    period, reference, emsgSchemeIdUris, box) {\n  let schemeId = box.reader.readTerminatedString();\n  // Read the rest of the data.\n  let value = box.reader.readTerminatedString();\n  let timescale = box.reader.readUint32();\n  let presentationTimeDelta = box.reader.readUint32();\n  let eventDuration = box.reader.readUint32();\n  let id = box.reader.readUint32();\n  let messageData = box.reader.readBytes(\n      box.reader.getLength() - box.reader.getPosition());\n\n  let startTime = period.startTime + reference.startTime +\n      (presentationTimeDelta / timescale);\n\n  // See DASH sec. 5.10.3.3.1\n  // If a DASH client detects an event message box with a scheme that is not\n  // defined in MPD, the client is expected to ignore it.\n  if (emsgSchemeIdUris.includes(schemeId)) {\n    // See DASH sec. 5.10.4.1\n    // A special scheme in DASH used to signal manifest updates.\n    if (schemeId == 'urn:mpeg:dash:event:2012') {\n      this.playerInterface_.onManifestUpdate();\n    } else {\n      /** @type {shaka.extern.EmsgInfo} */\n      let emsg = {\n        startTime: startTime,\n        endTime: startTime + (eventDuration / timescale),\n        schemeIdUri: schemeId,\n        value: value,\n        timescale: timescale,\n        presentationTimeDelta: presentationTimeDelta,\n        eventDuration: eventDuration,\n        id: id,\n        messageData: messageData,\n      };\n\n      // Dispatch an event to notify the application about the emsg box.\n      let event = new shaka.util.FakeEvent('emsg', {'detail': emsg});\n      this.playerInterface_.onEvent(event);\n    }\n  }\n};\n\n\n/**\n * Evicts media to meet the max buffer behind limit.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} presentationTime\n * @return {!Promise}\n * @private\n */\nshaka.media.StreamingEngine.prototype.evict_ = function(\n    mediaState, presentationTime) {\n  let logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n  shaka.log.v2(logPrefix, 'checking buffer length');\n\n  // Use the max segment duration, if it is longer than the bufferBehind, to\n  // avoid accidentally clearing too much data when dealing with a manifest\n  // with a long keyframe interval.\n  let bufferBehind = Math.max(this.config_.bufferBehind,\n      this.manifest_.presentationTimeline.getMaxSegmentDuration());\n\n  let startTime =\n      this.playerInterface_.mediaSourceEngine.bufferStart(mediaState.type);\n  if (startTime == null) {\n    shaka.log.v2(logPrefix,\n                 'buffer behind okay because nothing buffered:',\n                 'presentationTime=' + presentationTime,\n                 'bufferBehind=' + bufferBehind);\n    return Promise.resolve();\n  }\n  let bufferedBehind = presentationTime - startTime;\n\n  let overflow = bufferedBehind - bufferBehind;\n  if (overflow <= 0) {\n    shaka.log.v2(logPrefix,\n                 'buffer behind okay:',\n                 'presentationTime=' + presentationTime,\n                 'bufferedBehind=' + bufferedBehind,\n                 'bufferBehind=' + bufferBehind,\n                 'underflow=' + (-overflow));\n    return Promise.resolve();\n  }\n\n  shaka.log.v1(logPrefix,\n               'buffer behind too large:',\n               'presentationTime=' + presentationTime,\n               'bufferedBehind=' + bufferedBehind,\n               'bufferBehind=' + bufferBehind,\n               'overflow=' + overflow);\n\n  return this.playerInterface_.mediaSourceEngine.remove(\n      mediaState.type, startTime, startTime + overflow).then(function() {\n    if (this.destroyed_) return;\n    shaka.log.v1(logPrefix, 'evicted ' + overflow + ' seconds');\n  }.bind(this));\n};\n\n\n/**\n * Sets up all known Periods when startup completes; otherwise, does nothing.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState The last\n *   MediaState updated.\n * @param {shaka.extern.Stream} stream\n * @private\n */\nshaka.media.StreamingEngine.prototype.handleStartup_ = function(\n    mediaState, stream) {\n  const Functional = shaka.util.Functional;\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n  if (this.startupComplete_) {\n    return;\n  }\n\n  let logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n  // If the only media state is text, then we may have loaded text before\n  // any media content.  Marking as complete early will break MediaSource.\n  // See #1696.\n  const mediaStates = Array.from(this.mediaStates_.values());\n  if (mediaStates.length != 1 || mediaStates[0].type != ContentType.TEXT) {\n    this.startupComplete_ = mediaStates.every(function(ms) {\n      // Startup completes once we have buffered at least one segment from each\n      // MediaState, not counting text.\n      if (ms.type == ContentType.TEXT) return true;\n      return !ms.waitingToClearBuffer &&\n             !ms.clearingBuffer &&\n             ms.lastSegmentReference;\n    });\n  }\n\n  if (!this.startupComplete_) {\n    return;\n  }\n\n  shaka.log.debug(logPrefix, 'startup complete');\n\n  // We must use |stream| because switch() may have been called.\n  let currentPeriodIndex = this.findPeriodContainingStream_(stream);\n\n  goog.asserts.assert(\n      mediaStates.every(function(ms) {\n        // It is possible for one stream (usually text) to buffer the whole\n        // Period and need the next one.\n        return ms.needPeriodIndex == currentPeriodIndex ||\n            ms.needPeriodIndex == currentPeriodIndex + 1;\n      }),\n      logPrefix + ' expected all MediaStates to need same Period');\n\n  // Setup the current Period if necessary, which is likely since the current\n  // Period is probably the initial one.\n  if (!this.canSwitchPeriod_[currentPeriodIndex]) {\n    this.setupPeriod_(currentPeriodIndex).then(function() {\n      if (this.destroyed_) {\n        return;\n      }\n\n      shaka.log.v1(logPrefix, 'calling onCanSwitch()...');\n      this.playerInterface_.onCanSwitch();\n    }.bind(this)).catch(Functional.noop);\n  }\n\n  // Now setup all known Periods.\n  for (let i = 0; i < this.manifest_.periods.length; ++i) {\n    this.setupPeriod_(i).catch(Functional.noop);\n  }\n\n  if (this.playerInterface_.onStartupComplete) {\n    shaka.log.v1(logPrefix, 'calling onStartupComplete()...');\n    this.playerInterface_.onStartupComplete();\n  }\n};\n\n\n/**\n * Calls onChooseStreams() when necessary.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState The last\n *   MediaState updated.\n * @private\n */\nshaka.media.StreamingEngine.prototype.handlePeriodTransition_ = function(\n    mediaState) {\n  const Functional = shaka.util.Functional;\n  let logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  let currentPeriodIndex = this.findPeriodContainingStream_(mediaState.stream);\n  if (mediaState.needPeriodIndex == currentPeriodIndex) {\n    return;\n  }\n\n  let needPeriodIndex = mediaState.needPeriodIndex;\n\n  const mediaStates = Array.from(this.mediaStates_.values());\n\n  // For a Period transition to work, all media states must need the same\n  // Period.  If a stream needs a different Period than the one it currently\n  // has, it will try to transition or stop updates assuming that another stream\n  // will handle it.  This only works when all streams either need the same\n  // Period or are still performing updates.\n  goog.asserts.assert(\n      mediaStates.every(function(ms) {\n        return ms.needPeriodIndex == needPeriodIndex || ms.hasError ||\n            !shaka.media.StreamingEngine.isIdle_(ms);\n      }),\n      'All MediaStates should need the same Period or be performing updates.');\n\n  // Only call onChooseStreams() when all MediaStates need the same Period.\n  let needSamePeriod = mediaStates.every(function(ms) {\n    return ms.needPeriodIndex == needPeriodIndex;\n  });\n  if (!needSamePeriod) {\n    shaka.log.debug(\n        logPrefix, 'not all MediaStates need Period ' + needPeriodIndex);\n    return;\n  }\n\n  // Only call onChooseStreams() once per Period transition.\n  let allAreIdle = mediaStates.every(shaka.media.StreamingEngine.isIdle_);\n  if (!allAreIdle) {\n    shaka.log.debug(\n        logPrefix,\n        'all MediaStates need Period ' + needPeriodIndex + ', ' +\n        'but not all MediaStates are idle');\n    return;\n  }\n\n  shaka.log.debug(logPrefix, 'all need Period ' + needPeriodIndex);\n\n  // Ensure the Period which we need to buffer is set up and then call\n  // onChooseStreams().\n  this.setupPeriod_(needPeriodIndex).then(function() {\n    if (this.destroyed_) return;\n\n    // If we seek during a Period transition, we can start another transition.\n    // So we need to verify that:\n    //  1. We are still in need of the same Period.\n    //  2. All streams are still idle.\n    //  3. The current stream is not in the needed Period (another transition\n    //     handled it).\n    let allReady = mediaStates.every(function(ms) {\n      let isIdle = shaka.media.StreamingEngine.isIdle_(ms);\n      let currentPeriodIndex = this.findPeriodContainingStream_(ms.stream);\n      return isIdle && ms.needPeriodIndex == needPeriodIndex &&\n          currentPeriodIndex != needPeriodIndex;\n    }.bind(this));\n    if (!allReady) {\n      // TODO: Write unit tests for this case.\n      shaka.log.debug(logPrefix, 'ignoring transition to Period',\n                      needPeriodIndex, 'since another is happening');\n      return;\n    }\n\n    let needPeriod = this.manifest_.periods[needPeriodIndex];\n\n    shaka.log.v1(logPrefix, 'calling onChooseStreams()...');\n    let chosenStreams = this.playerInterface_.onChooseStreams(needPeriod);\n\n    /** @type {!Map.<!ContentType, shaka.extern.Stream>} */\n    const streamsByType = new Map();\n    if (chosenStreams.variant && chosenStreams.variant.video) {\n      streamsByType.set(ContentType.VIDEO, chosenStreams.variant.video);\n    }\n    if (chosenStreams.variant && chosenStreams.variant.audio) {\n      streamsByType.set(ContentType.AUDIO, chosenStreams.variant.audio);\n    }\n    if (chosenStreams.text) {\n      streamsByType.set(ContentType.TEXT, chosenStreams.text);\n    }\n\n    // Vet |streamsByType| before switching.\n    for (const type of this.mediaStates_.keys()) {\n      if (streamsByType.has(type) || type == ContentType.TEXT) continue;\n\n      shaka.log.error(logPrefix,\n                      'invalid Streams chosen: missing ' + type + ' Stream');\n      this.playerInterface_.onError(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STREAMING,\n          shaka.util.Error.Code.INVALID_STREAMS_CHOSEN));\n      return;\n    }\n\n    // Because we are going to modify the map, we need to create a copy of the\n    // keys, so copy the iterable to an array first.\n    for (const type of Array.from(streamsByType.keys())) {\n      if (this.mediaStates_.has(type)) continue;\n\n      if (type == ContentType.TEXT) {\n        // initStreams_ will switch streams and schedule an update.\n        this.initStreams_(\n            /* audio= */ null,\n            /* video= */ null,\n            /* text= */ streamsByType.get(ContentType.TEXT),\n            needPeriod.startTime);\n        streamsByType.delete(type);\n        continue;\n      }\n\n      shaka.log.error(logPrefix,\n                      'invalid Streams chosen: unusable ' + type + ' Stream');\n      this.playerInterface_.onError(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STREAMING,\n          shaka.util.Error.Code.INVALID_STREAMS_CHOSEN));\n      return;\n    }\n\n    // Because we are going to modify the map, we need to create a copy of the\n    // keys, so copy the iterable to an array first.\n    for (const type of Array.from(this.mediaStates_.keys())) {\n      const stream = streamsByType.get(type);\n      if (stream) {\n        this.switchInternal_(stream, /* clearBuffer= */ false,\n            /* safeMargin= */ 0, /* force= */ false);\n        this.scheduleUpdate_(this.mediaStates_.get(type), 0);\n      } else {\n        goog.asserts.assert(type == ContentType.TEXT, 'Invalid streams chosen');\n        this.mediaStates_.delete(type);\n      }\n    }\n\n    // We've already set up the Period so call onCanSwitch() right now.\n    shaka.log.v1(logPrefix, 'calling onCanSwitch()...');\n    this.playerInterface_.onCanSwitch();\n  }.bind(this)).catch(Functional.noop);\n};\n\n\n/**\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @return {boolean} True if the given MediaState is idle; otherwise, return\n *   false.\n * @private\n */\nshaka.media.StreamingEngine.isIdle_ = function(mediaState) {\n  return !mediaState.performingUpdate &&\n         (mediaState.updateTimer == null) &&\n         !mediaState.waitingToClearBuffer &&\n         !mediaState.clearingBuffer;\n};\n\n\n/**\n * Get the index in the manifest of the period that contains the given\n * presentation time. If |time| is before all periods, this will default to\n * returning the first period.\n *\n * @param {number} time The presentation time in seconds.\n * @return {number}\n * @private\n */\nshaka.media.StreamingEngine.prototype.findPeriodForTime_ = function(time) {\n  const ManifestParserUtils = shaka.util.ManifestParserUtils;\n  const threshold = ManifestParserUtils.GAP_OVERLAP_TOLERANCE_SECONDS;\n\n  // The last segment may end right before the end of the Period because of\n  // rounding issues so we bias forward a little.\n  const adjustedTime = time + threshold;\n\n  const period = shaka.util.Periods.findPeriodForTime(\n      /* periods= */ this.manifest_.periods,\n      /* time= */ adjustedTime);\n\n  return period ? this.manifest_.periods.indexOf(period) : 0;\n};\n\n\n/**\n * See if |stream| can be found in our manifest and return the period index. If\n * |stream| cannot be found, -1 will be returned.\n *\n * @param {!shaka.extern.Stream} stream\n * @return {number}\n * @private\n */\nshaka.media.StreamingEngine.prototype.findPeriodContainingStream_ = function(\n    stream) {\n  goog.asserts.assert(this.manifest_, 'Must have a manifest to find a stream.');\n\n  const periods = this.manifest_.periods;\n  for (let i = 0; i < periods.length; i++) {\n    const period = periods[i];\n\n    // Collect all the streams in this period so that we can easily check\n    // if the stream is found (regardless of type).\n    const streams = new Set();\n\n    for (const variant of period.variants) {\n      if (variant.audio) {\n        streams.add(variant.audio);\n      }\n      if (variant.video) {\n        streams.add(variant.video);\n      }\n      if (variant.video && variant.video.trickModeVideo) {\n        streams.add(variant.video.trickModeVideo);\n      }\n    }\n\n    for (const text of period.textStreams) {\n      streams.add(text);\n    }\n\n    if (streams.has(stream)) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\n\n/**\n * Fetches the given segment.\n *\n * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {(!shaka.media.InitSegmentReference|!shaka.media.SegmentReference)}\n *   reference\n *\n * @return {!Promise.<!ArrayBuffer>}\n * @private\n */\nshaka.media.StreamingEngine.prototype.fetch_ = function(mediaState, reference) {\n  const requestType = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n  const request = shaka.util.Networking.createSegmentRequest(\n      reference.getUris(),\n      reference.startByte,\n      reference.endByte,\n      this.config_.retryParameters);\n\n  shaka.log.v2('fetching: reference=', reference);\n\n  const op = this.playerInterface_.netEngine.request(requestType, request);\n  mediaState.operation = op;\n  return op.promise.then(function(response) {\n    mediaState.operation = null;\n    return response.data;\n  });\n};\n\n\n/**\n * Clears the buffer and schedules another update.\n * The optional parameter safeMargin allows to retain a certain amount\n * of buffer, which can help avoiding rebuffering events.\n * The value of the safe margin should be provided by the ABR manager.\n *\n * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {boolean} flush\n * @param {number} safeMargin\n * @return {!Promise}\n * @private\n */\nshaka.media.StreamingEngine.prototype.clearBuffer_ =\n    async function(mediaState, flush, safeMargin) {\n  let logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n  goog.asserts.assert(\n      !mediaState.performingUpdate && (mediaState.updateTimer == null),\n      logPrefix + ' unexpected call to clearBuffer_()');\n\n  mediaState.waitingToClearBuffer = false;\n  mediaState.waitingToFlushBuffer = false;\n  mediaState.clearBufferSafeMargin = 0;\n  mediaState.clearingBuffer = true;\n\n  shaka.log.debug(logPrefix, 'clearing buffer');\n  let p;\n  if (safeMargin) {\n    const presentationTime = this.playerInterface_.getPresentationTime();\n    let duration = this.playerInterface_.mediaSourceEngine.getDuration();\n    p = this.playerInterface_.mediaSourceEngine.remove(\n        mediaState.type, presentationTime + safeMargin, duration);\n  } else {\n    p = this.playerInterface_.mediaSourceEngine.clear(mediaState.type).then(\n        function() {\n          if (!this.destroyed_ && flush) {\n            return this.playerInterface_.mediaSourceEngine.flush(\n                mediaState.type);\n          }\n        }.bind(this));\n  }\n\n  await p;\n  if (this.destroyed_) return;\n\n  shaka.log.debug(logPrefix, 'cleared buffer');\n  mediaState.lastStream = null;\n  mediaState.lastSegmentReference = null;\n  mediaState.clearingBuffer = false;\n  mediaState.endOfStream = false;\n  this.scheduleUpdate_(mediaState, 0);\n};\n\n\n/**\n * Schedules |mediaState|'s next update.\n *\n * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} delay The delay in seconds.\n * @private\n */\nshaka.media.StreamingEngine.prototype.scheduleUpdate_ = function(\n    mediaState, delay) {\n  let logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n  shaka.log.v2(logPrefix, 'updating in ' + delay + ' seconds');\n  goog.asserts.assert(mediaState.updateTimer == null,\n                      logPrefix + ' did not expect update to be scheduled');\n\n  mediaState.updateTimer = new shaka.util.DelayedTick(async () => {\n    try {\n      await this.onUpdate_(mediaState);\n    } catch (error) {\n      if (this.playerInterface_) {\n        this.playerInterface_.onError(error);\n      }\n    }\n  }).tickAfter(delay);\n};\n\n\n/**\n * If |mediaState| is scheduled to update, stop it.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @private\n */\nshaka.media.StreamingEngine.prototype.cancelUpdate_ = function(mediaState) {\n  if (mediaState.updateTimer == null) {\n    return;\n  }\n\n  mediaState.updateTimer.stop();\n  mediaState.updateTimer = null;\n};\n\n\n/**\n * Handle streaming errors by delaying, then notifying the application by error\n * callback and by streaming failure callback.\n *\n * @param {!shaka.util.Error} error\n * @private\n */\nshaka.media.StreamingEngine.prototype.handleStreamingError_ = function(error) {\n  // If we invoke the callback right away, the application could trigger a\n  // rapid retry cycle that could be very unkind to the server.  Instead,\n  // use the backoff system to delay and backoff the error handling.\n  this.failureCallbackBackoff_.attempt().then(function() {\n    if (this.destroyed_) {\n      return;\n    }\n\n    // First fire an error event.\n    this.playerInterface_.onError(error);\n\n    // If the error was not handled by the application, call the failure\n    // callback.\n    if (!error.handled) {\n      this.config_.failureCallback(error);\n    }\n  }.bind(this));\n};\n\n\n/**\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @return {string} A log prefix of the form ($CONTENT_TYPE:$STREAM_ID), e.g.,\n *   \"(audio:5)\" or \"(video:hd)\".\n * @private\n */\nshaka.media.StreamingEngine.logPrefix_ = function(mediaState) {\n  return '(' + mediaState.type + ':' + mediaState.stream.id + ')';\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.net.HttpPluginUtils');\n\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * @namespace shaka.net.HttpPluginUtils\n * @summary A set of http networking utility functions.\n * @exportDoc\n */\n\n\n/**\n * @param {!Object.<string,string>} headers\n * @param {?ArrayBuffer} data\n * @param {number} status\n * @param {string} uri\n * @param {string} responseURL\n * @param {shaka.net.NetworkingEngine.RequestType} requestType\n * @return {!shaka.extern.Response}\n */\nshaka.net.HttpPluginUtils.makeResponse =\n    function(headers, data, status, uri, responseURL, requestType) {\n  if (status >= 200 && status <= 299 && status != 202) {\n    // Most 2xx HTTP codes are success cases.\n    /** @type {shaka.extern.Response} */\n    let response = {\n      uri: responseURL || uri,\n      originalUri: uri,\n      data: data,\n      headers: headers,\n      fromCache: !!headers['x-shaka-from-cache'],\n    };\n    return response;\n  } else {\n    let responseText = null;\n    try {\n      responseText = shaka.util.StringUtils.fromBytesAutoDetect(data);\n    } catch (exception) {}\n    shaka.log.debug('HTTP error text:', responseText);\n\n    let severity = status == 401 || status == 403 ?\n        shaka.util.Error.Severity.CRITICAL :\n        shaka.util.Error.Severity.RECOVERABLE;\n    throw new shaka.util.Error(\n        severity,\n        shaka.util.Error.Category.NETWORK,\n        shaka.util.Error.Code.BAD_HTTP_STATUS,\n        uri,\n        status,\n        responseText,\n        headers,\n        requestType);\n  }\n};\n\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.net.HttpFetchPlugin');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.net.HttpPluginUtils');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.MapUtils');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * @namespace\n * @summary A networking plugin to handle http and https URIs via the Fetch API.\n * @param {string} uri\n * @param {shaka.extern.Request} request\n * @param {shaka.net.NetworkingEngine.RequestType} requestType\n * @param {shaka.extern.ProgressUpdated} progressUpdated Called when a progress\n *   event happened.\n * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n * @export\n */\nshaka.net.HttpFetchPlugin = function(\n    uri, request, requestType, progressUpdated) {\n  const headers = new shaka.net.HttpFetchPlugin.Headers_();\n  shaka.util.MapUtils.asMap(request.headers).forEach((value, key) => {\n    headers.append(key, value);\n  });\n\n  const controller = new shaka.net.HttpFetchPlugin.AbortController_();\n\n  /** @type {!RequestInit} */\n  const init = {\n    // Edge does not treat null as undefined for body; https://bit.ly/2luyE6x\n    body: request.body || undefined,\n    headers: headers,\n    method: request.method,\n    signal: controller.signal,\n    credentials: request.allowCrossSiteCredentials ? 'include' : undefined,\n  };\n\n  /** @type {shaka.net.HttpFetchPlugin.AbortStatus} */\n  const abortStatus = {\n    canceled: false,\n    timedOut: false,\n  };\n\n  const pendingRequest = shaka.net.HttpFetchPlugin.request_(\n      uri, requestType, init, abortStatus, progressUpdated);\n\n  /** @type {!shaka.util.AbortableOperation} */\n  const op = new shaka.util.AbortableOperation(pendingRequest, () => {\n    abortStatus.canceled = true;\n    controller.abort();\n    return Promise.resolve();\n  });\n\n  // The fetch API does not timeout natively, so do a timeout manually using the\n  // AbortController.\n  const timeoutMs = request.retryParameters.timeout;\n  if (timeoutMs) {\n    const timer = new shaka.util.Timer(() => {\n      abortStatus.timedOut = true;\n      controller.abort();\n    });\n\n    timer.tickAfter(timeoutMs / 1000);\n\n    // To avoid calling |abort| on the network request after it finished, we\n    // will stop the timer when the requests resolves/rejects.\n    op.finally(() => {\n      timer.stop();\n    });\n  }\n\n  return op;\n};\n\n/**\n * @param {string} uri\n * @param {shaka.net.NetworkingEngine.RequestType} requestType\n * @param {!RequestInit} init\n * @param {shaka.net.HttpFetchPlugin.AbortStatus} abortStatus\n * @param {shaka.extern.ProgressUpdated} progressUpdated\n * @return {!Promise<!shaka.extern.Response>}\n * @private\n */\nshaka.net.HttpFetchPlugin.request_ = async function(\n    uri, requestType, init, abortStatus, progressUpdated) {\n  const fetch = shaka.net.HttpFetchPlugin.fetch_;\n  const ReadableStream = shaka.net.HttpFetchPlugin.ReadableStream_;\n  let response;\n  let arrayBuffer;\n  let loaded = 0;\n  let lastLoaded = 0;\n\n  // Last time stamp when we got a progress event.\n  let lastTime = Date.now();\n\n  try {\n    // The promise returned by fetch resolves as soon as the HTTP response\n    // headers are available. The download itself isn't done until the promise\n    // for retrieving the data (arrayBuffer, blob, etc) has resolved.\n    response = await fetch(uri, init);\n    // Getting the reader in this way allows us to observe the process of\n    // downloading the body, instead of just waiting for an opaque promise to\n    // resolve.\n    // We first clone the response because calling getReader locks the body\n    // stream; if we didn't clone it here, we would be unable to get the\n    // response's arrayBuffer later.\n    const reader = response.clone().body.getReader();\n\n    const contentLengthRaw = response.headers.get('Content-Length');\n    const contentLength = contentLengthRaw ? parseInt(contentLengthRaw, 10) : 0;\n\n    let start = (controller) => {\n      let push = async () => {\n        let readObj;\n        try {\n          readObj = await reader.read();\n        } catch (e) {\n          // If we abort the request, we'll get an error here.  Just ignore it\n          // since real errors will be reported when we read the buffer below.\n          shaka.log.v1('error reading from stream', e.message);\n          return;\n        }\n\n        if (!readObj.done) {\n          loaded += readObj.value.byteLength;\n        }\n\n        let currentTime = Date.now();\n        // If the time between last time and this time we got progress event\n        // is long enough, or if a whole segment is downloaded, call\n        // progressUpdated().\n        if (currentTime - lastTime > 100 || readObj.done) {\n          progressUpdated(currentTime - lastTime, loaded - lastLoaded,\n              contentLength - loaded);\n          lastLoaded = loaded;\n          lastTime = currentTime;\n        }\n\n        if (readObj.done) {\n          goog.asserts.assert(!readObj.value,\n                              'readObj should be unset when \"done\" is true.');\n          controller.close();\n        } else {\n          controller.enqueue(readObj.value);\n          push();\n        }\n      };\n      push();\n    };\n    // Create a ReadableStream to use the reader. We don't need to use the\n    // actual stream for anything, though, as we are using the response's\n    // arrayBuffer method to get the body, so we don't store the ReadableStream.\n    new ReadableStream({start}); // eslint-disable-line no-new\n    arrayBuffer = await response.arrayBuffer();\n  } catch (error) {\n    if (abortStatus.canceled) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.OPERATION_ABORTED,\n          uri, requestType);\n    } else if (abortStatus.timedOut) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.TIMEOUT,\n          uri, requestType);\n    } else {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.HTTP_ERROR,\n          uri, error, requestType);\n    }\n  }\n\n  const headers = {};\n  /** @type {Headers} */\n  const responseHeaders = response.headers;\n  responseHeaders.forEach(function(value, key) {\n    // Since IE/Edge incorrectly return the header with a leading new line\n    // character ('\\n'), we trim the header here.\n    headers[key.trim()] = value;\n  });\n\n  return shaka.net.HttpPluginUtils.makeResponse(headers,\n      arrayBuffer, response.status, uri, response.url, requestType);\n};\n\n/**\n * @typedef {{\n *   canceled: boolean,\n *   timedOut: boolean\n * }}\n * @property {boolean} canceled\n *   Indicates if the request was canceled.\n * @property {boolean} timedOut\n *   Indicates if the request timed out.\n */\nshaka.net.HttpFetchPlugin.AbortStatus;\n\n\n/**\n * Determine if the Fetch API is supported in the browser. Note: this is\n * deliberately exposed as a method to allow the client app to use the same\n * logic as Shaka when determining support.\n * @return {boolean}\n * @export\n */\nshaka.net.HttpFetchPlugin.isSupported = function() {\n  // On Edge, ReadableStream exists, but attempting to construct it results in\n  // an error. See https://bit.ly/2zwaFLL\n  // So this has to check that ReadableStream is present AND usable.\n  if (window.ReadableStream) {\n    try {\n      new ReadableStream({}); // eslint-disable-line no-new\n    } catch (e) {\n      return false;\n    }\n  } else {\n    return false;\n  }\n  return !!(window.fetch && window.AbortController);\n};\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(string, !RequestInit)}\n * @private\n */\nshaka.net.HttpFetchPlugin.fetch_ = window.fetch;\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(new: AbortController)}\n * @private\n */\nshaka.net.HttpFetchPlugin.AbortController_ = window.AbortController;\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(new: ReadableStream, !Object)}\n * @private\n */\nshaka.net.HttpFetchPlugin.ReadableStream_ = window.ReadableStream;\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(new: Headers)}\n * @private\n */\nshaka.net.HttpFetchPlugin.Headers_ = window.Headers;\n\n\nif (shaka.net.HttpFetchPlugin.isSupported()) {\n  shaka.net.NetworkingEngine.registerScheme('http', shaka.net.HttpFetchPlugin,\n      shaka.net.NetworkingEngine.PluginPriority.PREFERRED);\n  shaka.net.NetworkingEngine.registerScheme('https', shaka.net.HttpFetchPlugin,\n      shaka.net.NetworkingEngine.PluginPriority.PREFERRED);\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.net.HttpXHRPlugin');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.net.HttpPluginUtils');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\n\n\n/**\n * @namespace\n * @summary A networking plugin to handle http and https URIs via XHR.\n * @param {string} uri\n * @param {shaka.extern.Request} request\n * @param {shaka.net.NetworkingEngine.RequestType} requestType\n * @param {shaka.extern.ProgressUpdated} progressUpdated Called when a\n *   progress event happened.\n * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n * @export\n */\nshaka.net.HttpXHRPlugin = function(uri, request, requestType, progressUpdated) {\n  let xhr = new shaka.net.HttpXHRPlugin.Xhr_();\n\n  // Last time stamp when we got a progress event.\n  let lastTime = Date.now();\n  // Last number of bytes loaded, from progress event.\n  let lastLoaded = 0;\n\n  let promise = new Promise(function(resolve, reject) {\n    xhr.open(request.method, uri, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.timeout = request.retryParameters.timeout;\n    xhr.withCredentials = request.allowCrossSiteCredentials;\n\n    xhr.onabort = function() {\n      reject(new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.OPERATION_ABORTED,\n          uri, requestType));\n    };\n    xhr.onload = function(event) {\n      let target = event.target;\n      goog.asserts.assert(target, 'XHR onload has no target!');\n      // Since IE and Edge incorrectly return the header with a leading new line\n      // character ('\\n'), we trim the header here.\n      const headerLines = target.getAllResponseHeaders().trim().split('\\r\\n');\n      const headers = {};\n      for (const header of headerLines) {\n        /** @type {!Array.<string>} */\n        const parts = header.split(': ');\n        headers[parts[0].toLowerCase()] = parts.slice(1).join(': ');\n      }\n\n      try {\n        let response = shaka.net.HttpPluginUtils.makeResponse(headers,\n          target.response, target.status, uri, target.responseURL,\n          requestType);\n        resolve(response);\n      } catch (error) {\n        goog.asserts.assert(error instanceof shaka.util.Error,\n            'Wrong error type!');\n        reject(error);\n      }\n    };\n    xhr.onerror = function(event) {\n      reject(new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.HTTP_ERROR,\n          uri, event, requestType));\n    };\n    xhr.ontimeout = function(event) {\n      reject(new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.TIMEOUT,\n          uri, requestType));\n    };\n    xhr.onprogress = function(event) {\n      let currentTime = Date.now();\n      // If the time between last time and this time we got progress event\n      // is long enough, or if a whole segment is downloaded, call\n      // progressUpdated().\n      if (currentTime - lastTime > 100 ||\n          (event.lengthComputable && event.loaded == event.total)) {\n        progressUpdated(currentTime - lastTime, event.loaded - lastLoaded,\n          event.total - event.loaded);\n        lastLoaded = event.loaded;\n        lastTime = currentTime;\n      }\n    };\n\n    for (let key in request.headers) {\n      // The Fetch API automatically normalizes outgoing header keys to\n      // lowercase. For consistency's sake, do it here too.\n      let lowercasedKey = key.toLowerCase();\n      xhr.setRequestHeader(lowercasedKey, request.headers[key]);\n    }\n    xhr.send(request.body);\n  });\n\n  return new shaka.util.AbortableOperation(\n    promise,\n    () => {\n      xhr.abort();\n      return Promise.resolve();\n    });\n};\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(new: XMLHttpRequest)}\n * @private\n */\nshaka.net.HttpXHRPlugin.Xhr_ = window.XMLHttpRequest;\n\n\nshaka.net.NetworkingEngine.registerScheme('http', shaka.net.HttpXHRPlugin,\n    shaka.net.NetworkingEngine.PluginPriority.FALLBACK);\nshaka.net.NetworkingEngine.registerScheme('https', shaka.net.HttpXHRPlugin,\n    shaka.net.NetworkingEngine.PluginPriority.FALLBACK);\n\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.DownloadProgressEstimator');\n\n\n/**\n * The download progress estimator class encapsulates all the logic for tracking\n * how much content has been downloaded and estimating its progress.\n *\n * @final\n */\nshaka.offline.DownloadProgressEstimator = class {\n  constructor() {\n    /**\n     * This is the sum of all estimates passed to |open|. This is used as the\n     * denominator when measuring progress.\n     *\n     * @private {number}\n     */\n    this.estimatedTotal_ = 0;\n\n    /**\n     * This is the sum of all estimates pass to |open| but only after |close|\n     * has been called. This is used as the numerator when measuring progress so\n     * that |estimatedTotal_ == estimatedDownloaded_| after everything is\n     * downloaded.\n     *\n     * @private {number}\n     */\n    this.estimatedDownloaded_ = 0;\n\n    /**\n     * This is the total number of bytes actually downloaded. This will most\n     * likely differ from |estimatedTotal_| after everything is downloaded since\n     * our estimates will be off.\n     *\n     * @private {number}\n     */\n    this.actualDownloaded_ = 0;\n\n    /**\n     * This is a map of all pending downloads. This maps their download id (an\n     * internal id) to the estimate. This will allow us to update\n     * |estimatedDownloaded_| when |close| is called.\n     *\n     * @private {!Map.<number, number>}\n     */\n    this.pending_ = new Map();\n\n    /**\n     * This number is used to provide unique (to estimator) ids for each\n     * download. This allows us to track each download in |pending_|.\n     *\n     * @private {number}\n     */\n    this.nextId_ = 0;\n  }\n\n  /**\n   * Open a new download in the progress estimator. This will create an entry so\n   * that we can track the download progress.\n   *\n   * This will return an id for the download. This id must be passed to |close|\n   * in order for the |close| to be paired with this call to |open|.\n   *\n   * @param {number} estimate\n   * @return {number}\n   */\n  open(estimate) {\n    this.estimatedTotal_ += estimate;\n\n    const id = this.nextId_;\n    this.nextId_++;\n\n    this.pending_.set(id, estimate);\n    return id;\n  }\n\n  /**\n   * Close a download in the estimator. This will signal that we have finished\n   * downloading a segment and we can update the progress estimate.\n   *\n   * @param {number} id\n   * @param {number} actual\n   */\n  close(id, actual) {\n    if (!this.pending_.has(id)) {\n      return;\n    }\n\n    const estimate = this.pending_.get(id);\n    this.pending_.delete(id);\n\n    this.estimatedDownloaded_ += estimate;\n    this.actualDownloaded_ += actual;\n  }\n\n  /**\n   * Get the current estimate for how much progress we've made downloading the\n   * content. Progress will be between 0 and 1.\n   *\n   * Depending on the order of calls to |open| and |close|,\n   * |getEstimatedProgress| will fluctuate and is not guaranteed to always be\n   * increasing.\n   *\n   * @return {number}\n   */\n  getEstimatedProgress() {\n    return this.estimatedTotal_ == 0 ?\n           0 :\n           this.estimatedDownloaded_ / this.estimatedTotal_;\n  }\n\n  /**\n   * Get the total number of bytes that were actually downloaded.\n   *\n   * @return {number}\n   */\n  getTotalDownloaded() {\n    return this.actualDownloaded_;\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.DownloadManager');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.offline.DownloadProgressEstimator');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\n\n\n/**\n * This manages downloading segments.\n *\n * @implements {shaka.util.IDestroyable}\n * @final\n */\nshaka.offline.DownloadManager = class {\n  /**\n   * Create a new download manager. It will use (but not own) |networkingEngine|\n   * and call |onProgress| after each download.\n   *\n   * @param {!shaka.net.NetworkingEngine} networkingEngine\n   * @param {function(number, number)} onProgress\n   */\n  constructor(networkingEngine, onProgress) {\n    /** @private {shaka.net.NetworkingEngine} */\n    this.networkingEngine_ = networkingEngine;\n\n    /**\n     * We group downloads. Within each group, the requests are executed in\n     * series. Between groups, the requests are executed in parallel. We store\n     * the promise chain that is doing the work.\n     *\n     * @private {!Map.<number, !Promise>}\n     */\n    this.groups_ = new Map();\n\n    /** @private {boolean} */\n    this.destroyed_ = false;\n\n    /**\n     * A callback for when a segment has been downloaded. The first parameter\n     * is the progress of all segments, a number between 0.0 (0% complete) and\n     * 1.0 (100% complete). The second parameter is the total number of bytes\n     * that have been downloaded.\n     *\n     * @private {function(number, number)}\n     */\n    this.onProgress_ = onProgress;\n\n    /** @private {shaka.offline.DownloadProgressEstimator} */\n    this.estimator_ = new shaka.offline.DownloadProgressEstimator();\n  }\n\n  /** @override */\n  destroy() {\n    // Setting this will cause the promise chains to stop.\n    this.destroyed_ = true;\n\n    // Append no-ops so that we ensure that no errors escape |destroy|.\n    return Promise.all(this.groups_.values()).then(() => {}, () => {});\n  }\n\n  /**\n   * Add a request to be downloaded as part of a group.\n   *\n   * @param {number} groupId\n   *    The group to add this segment to. If the group does not exist, a new\n   *    group will be created.\n   * @param {shaka.extern.Request} request\n   * @param {number} estimatedByteLength\n   * @param {function(!ArrayBuffer):!Promise} onDownloaded\n   *   The callback for when this request has been downloaded. Downloading for\n   *   |group| will pause until the promise returned by |onDownloaded| resolves.\n   */\n  queue(groupId, request, estimatedByteLength, onDownloaded) {\n    goog.asserts.assert(\n        !this.destroyed_,\n        'Do not call |queue| after |destroy|');\n\n    const id = this.estimator_.open(estimatedByteLength);\n\n    const group = this.groups_.get(groupId) || Promise.resolve();\n\n    // Add another download to the group.\n    this.groups_.set(groupId, group.then(async () => {\n      const response = await this.fetchSegment_(request);\n\n      // Make sure we stop downloading if we have been destroyed.\n      if (this.destroyed_) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.STORAGE,\n            shaka.util.Error.Code.OPERATION_ABORTED);\n      }\n\n      // Update all our internal stats.\n      this.estimator_.close(id, response.byteLength);\n      this.onProgress_(\n          this.estimator_.getEstimatedProgress(),\n          this.estimator_.getTotalDownloaded());\n\n      return onDownloaded(response);\n    }));\n  }\n\n  /**\n   * Get a promise that will resolve when all currently queued downloads have\n   * finished.\n   *\n   * @return {!Promise.<number>}\n   */\n  async waitToFinish() {\n    await Promise.all(this.groups_.values());\n    return this.estimator_.getTotalDownloaded();\n  }\n\n  /**\n   * Download a segment and return the data in the response.\n   *\n   * @param {shaka.extern.Request} request\n   * @return {!Promise.<!ArrayBuffer>}\n   * @private\n   */\n  async fetchSegment_(request) {\n    const type = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n    const action = this.networkingEngine_.request(type, request);\n    const response = await action.promise;\n\n    goog.asserts.assert(response.data, 'Response data should be non-null!');\n    return response.data;\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.indexeddb.DBOperation');\n\n\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * A DBOperation wraps an IndexedDB transaction in a promise.\n */\nshaka.offline.indexeddb.DBOperation = class {\n  /**\n   * @param {IDBTransaction} transaction\n   * @param {string} storeName\n   */\n  constructor(transaction, storeName) {\n    /** @private {IDBTransaction} */\n    this.transaction_ = transaction;\n    /** @private {IDBObjectStore} */\n    this.store_ = transaction.objectStore(storeName);\n    /** @private {!shaka.util.PublicPromise} */\n    this.promise_ = new shaka.util.PublicPromise();\n\n    // Connect the transaction and the promise together.\n    // |event.preventDefault()| is used on all non-successful callbacks to\n    // prevent Firefox from surfacing the error on the main thread.\n    transaction.onabort = (event) => {\n      event.preventDefault();\n      this.promise_.reject();\n    };\n    transaction.onerror = (event) => {\n      event.preventDefault();\n      this.promise_.reject();\n    };\n    transaction.oncomplete = (event) => {\n      this.promise_.resolve();\n    };\n  }\n\n  /**\n   * @return {!Promise}\n   */\n  abort() {\n    try {\n      this.transaction_.abort();\n    } catch (e) {\n      // Ignore any exceptions that may be thrown as a result of aborting\n      // the transaction.\n    }\n\n    // Wait for the promise to be rejected, but ignore the rejection error.\n    return this.promise_.catch(() => {});\n  }\n\n  /**\n   * Calls the given callback for each entry in the database.  The callback\n   * must be synchronous, but this operation happens asynchronously.\n   *\n   * @param {function(number, T, !IDBCursorWithValue=)} callback\n   * @return {!Promise}\n   * @template T\n   */\n  forEachEntry(callback) {\n    return new Promise((resolve, reject) => {\n      const req = this.store_.openCursor();\n      req.onerror = reject;\n      req.onsuccess = (event) => {\n        // When we reach the end of the data that the cursor is iterating\n        // over, |event.target.result| will be null to signal the end of the\n        // iteration.\n        // https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/continue\n        const cursor = event.target.result;\n        if (!cursor) {\n          return resolve();\n        }\n\n        callback(cursor.key, cursor.value, cursor);\n        cursor.continue();\n      };\n    });\n  }\n\n  /**\n   * Get the store that the operation can interact with. Requests can be made\n   * on the store. All requests made on the store will complete successfully\n   * before the operation's promise will resolve. If any request fails, the\n   * operation's promise will be rejected.\n   *\n   * @return {IDBObjectStore}\n   */\n  store() { return this.store_; }\n\n  /**\n   * Get the promise that wraps the transaction. This promise will resolve when\n   * all requests on the object store complete successfully and the transaction\n   * completes. If any request fails or the operation is aborted, the promise\n   * will be rejected.\n   *\n   * @return {!Promise}\n   */\n  promise() { return this.promise_; }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.indexeddb.DBConnection');\n\ngoog.require('shaka.offline.indexeddb.DBOperation');\ngoog.require('shaka.util.ArrayUtils');\n\n\n/**\n * DBConnection is used to manage an IndexedDB connection. It can create new\n * operations. If the connection is killed (via |destroy|) all pending\n * operations will be cancelled.\n */\nshaka.offline.indexeddb.DBConnection = class {\n  /**\n   * @param {IDBDatabase} connection A connection to an IndexedDB instance.\n   */\n  constructor(connection) {\n    /** @private {IDBDatabase} */\n    this.connection_ = connection;\n    /** @private {!Array.<shaka.offline.indexeddb.DBOperation>} */\n    this.pending_ = [];\n  }\n\n  /**\n   * @return {!Promise}\n   */\n  destroy() {\n    return Promise.all(this.pending_.map((op) => {\n      return op.abort();\n    }));\n  }\n\n  /**\n   * @param {string} store The name of the store that the operation should\n   *                       occur on.\n   * @return {!shaka.offline.indexeddb.DBOperation}\n   */\n  startReadOnlyOperation(store) {\n    return this.startOperation_(store, 'readonly');\n  }\n\n  /**\n   * @param {string} store The name of the store that the operation should\n   *                       occur on.\n   * @return {!shaka.offline.indexeddb.DBOperation}\n   */\n  startReadWriteOperation(store) {\n    return this.startOperation_(store, 'readwrite');\n  }\n\n  /**\n   * @param {string} store The name of the store that the operation should\n   *                       occur on.\n   * @param {string} type The type of operation being performed on the store.\n   *                      This determines what commands may be performed. This\n   *                      can either be \"readonly\" or \"readwrite\".\n   * @return {!shaka.offline.indexeddb.DBOperation}\n   * @private\n   */\n  startOperation_(store, type) {\n    let transaction = this.connection_.transaction([store], type);\n    let operation = new shaka.offline.indexeddb.DBOperation(transaction, store);\n\n    this.pending_.push(operation);\n\n    // Once the operation is done (regardless of outcome) stop tracking it.\n    operation.promise().then(\n        () => this.stopTracking_(operation),\n        () => this.stopTracking_(operation)\n    );\n\n    return operation;\n  }\n\n  /**\n   * @param {!shaka.offline.indexeddb.DBOperation} operation\n   * @private\n   */\n  stopTracking_(operation) {\n    shaka.util.ArrayUtils.remove(this.pending_, operation);\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.indexeddb.EmeSessionStorageCell');\n\ngoog.require('shaka.offline.indexeddb.DBConnection');\n\n\n/**\n * The implementation of the EME session storage cell.\n *\n * @implements {shaka.extern.EmeSessionStorageCell}\n */\nshaka.offline.indexeddb.EmeSessionStorageCell = class {\n  /**\n   * @param {IDBDatabase} connection\n   * @param {string} store\n   */\n  constructor(connection, store) {\n    /** @private {!shaka.offline.indexeddb.DBConnection} */\n    this.connection_ = new shaka.offline.indexeddb.DBConnection(connection);\n\n    /** @private {string} */\n    this.store_ = store;\n  }\n\n  /** @override */\n  destroy() { return this.connection_.destroy(); }\n\n  /** @override */\n  async getAll() {\n    /** @type {!shaka.offline.indexeddb.DBOperation} */\n    const op = this.connection_.startReadOnlyOperation(this.store_);\n    /** @type {!Array.<shaka.extern.EmeSessionDB>} */\n    const values = [];\n\n    await op.forEachEntry((key, value) => {\n      values.push(value);\n    });\n\n    await op.promise();\n    return values;\n  }\n\n  /** @override */\n  add(sessions) {\n    const op = this.connection_.startReadWriteOperation(this.store_);\n    const store = op.store();\n\n    for (const session of sessions) {\n      store.add(session);\n    }\n\n    return op.promise();\n  }\n\n  /** @override */\n  async remove(sessionIds) {\n    /** @type {!shaka.offline.indexeddb.DBOperation} */\n    const op = this.connection_.startReadWriteOperation(this.store_);\n\n    await op.forEachEntry((key, value, cursor) => {\n      if (sessionIds.indexOf(value.sessionId) >= 0) {\n        cursor.delete();\n      }\n    });\n\n    await op.promise();\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.StorageCellHandle');\ngoog.provide('shaka.offline.StorageCellPath');\ngoog.provide('shaka.offline.StorageMuxer');\n\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\n\n/**\n * @typedef {{\n *  mechanism: string,\n *  cell: string\n * }}\n *\n * @property {string} mechanism\n *  The name of the mechanism that holds the cell.\n * @property {string} cell\n *  The name of the cell in the mechanism.\n */\nshaka.offline.StorageCellPath;\n\n\n/**\n * @typedef {{\n *   path: shaka.offline.StorageCellPath,\n *   cell: !shaka.extern.StorageCell\n * }}\n *\n * @property {shaka.offline.StorageCellPath} path\n *   The path that maps to the cell.\n * @property {shaka.extern.StorageCell} cell\n *   The storage cell that the path points to within the storage muxer.\n */\nshaka.offline.StorageCellHandle;\n\n\n/**\n * StorageMuxer is responsible for managing StorageMechanisms and addressing\n * cells. The primary purpose of the muxer is to give the caller the correct\n * cell for the operations they want to perform.\n *\n * |findActive| will be used when the caller wants a cell that supports\n * add-operations. This will be used when saving new content to storage.\n *\n * |findAll| will be used when the caller want to look at all the content\n * in storage.\n *\n * |resolvePath| will be used to convert a path (from |findActive| and\n * |findAll|) into a cell, which it then returns.\n *\n * @implements {shaka.util.IDestroyable}\n */\nshaka.offline.StorageMuxer = class {\n  constructor() {\n    /**\n     * A key in this map is the name given when registering a StorageMechanism.\n     *\n     * @private {!Map.<string, !shaka.extern.StorageMechanism>}\n     */\n    this.mechanisms_ = new Map();\n  }\n\n  /**\n   * Free all resources used by the muxer, mechanisms, and cells. This should\n   * not affect the stored content.\n   *\n   * @override\n   */\n  destroy() {\n    /** @type {!Array.<!Promise>} */\n    const destroys = [];\n    for (const mechanism of this.mechanisms_.values()) {\n      destroys.push(mechanism.destroy());\n    }\n\n    // Empty the map so that subsequent calls will be no-ops.\n    this.mechanisms_.clear();\n\n    return Promise.all(destroys);\n  }\n\n  /**\n   * Initialize the storage muxer. This must be called before any other calls.\n   * This will initialize the muxer to use all mechanisms that have been\n   * registered with |StorageMuxer.register|.\n   *\n   * @return {!Promise}\n   */\n  init() {\n    // Add the new instance of each mechanism to the muxer.\n    const registry = shaka.offline.StorageMuxer.getRegistry_();\n    registry.forEach((factory, name) => {\n      const mech = factory();\n      if (mech) {\n        this.mechanisms_.set(name, mech);\n      } else {\n        shaka.log.info(\n            'Skipping ' + name + ' as it is not supported on this platform');\n      }\n    });\n\n    /** @type {!Array.<!Promise>} */\n    const initPromises = [];\n    for (const mechanism of this.mechanisms_.values()) {\n      initPromises.push(mechanism.init());\n    }\n\n    return Promise.all(initPromises);\n  }\n\n  /**\n   * Get a promise that will resolve with a storage cell that supports\n   * add-operations. If no cell can be found, the promise will be rejected.\n   *\n   * @return {shaka.offline.StorageCellHandle}\n   */\n  getActive() {\n    /** @type {?shaka.offline.StorageCellHandle} */\n    let handle = null;\n\n    this.mechanisms_.forEach((mechanism, mechanismName) => {\n      mechanism.getCells().forEach((cell, cellName) => {\n        // If this cell is not useful to us or we already have a handle, then\n        // we don't need to make a new handle.\n        if (cell.hasFixedKeySpace() || handle) { return; }\n\n        const path = {\n          mechanism: mechanismName,\n          cell: cellName,\n        };\n\n        handle = {\n          path: path,\n          cell: cell,\n        };\n      });\n    });\n\n    if (handle) {\n      return /** @type {shaka.offline.StorageCellHandle} */(handle);\n    }\n\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.MISSING_STORAGE_CELL,\n        'Could not find a cell that supports add-operations');\n  }\n\n  /**\n   * @param {function(!shaka.offline.StorageCellPath,\n   *                  !shaka.extern.StorageCell)} callback\n   */\n  forEachCell(callback) {\n    this.mechanisms_.forEach((mechanism, mechanismName) => {\n      mechanism.getCells().forEach((cell, cellName) => {\n        const path = {\n          mechanism: mechanismName,\n          cell: cellName,\n        };\n\n        callback(path, cell);\n      });\n    });\n  }\n\n  /**\n   * Get a specific storage cell. The promise will resolve with the storage\n   * cell if it is found. If the storage cell is not found, the promise will\n   * be rejected.\n   *\n   * @param {string} mechanismName\n   * @param {string} cellName\n   * @return {!shaka.extern.StorageCell}\n   */\n  getCell(mechanismName, cellName) {\n    const mechanism = this.mechanisms_.get(mechanismName);\n    if (!mechanism) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.MISSING_STORAGE_CELL,\n          'Could not find mechanism with name ' + mechanismName);\n    }\n\n    const cell = mechanism.getCells().get(cellName);\n    if (!cell) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.MISSING_STORAGE_CELL,\n          'Could not find cell with name ' + cellName);\n    }\n\n    return cell;\n  }\n\n  /**\n   * @param {function(!shaka.extern.EmeSessionStorageCell)} callback\n   */\n  forEachEmeSessionCell(callback) {\n    this.mechanisms_.forEach((mechanism) => {\n      callback(mechanism.getEmeSessionCell());\n    });\n  }\n\n  /**\n   * Gets an arbitrary EME session cell that can be used for storing new session\n   * info.\n   *\n   * @return {!shaka.extern.EmeSessionStorageCell}\n   */\n  getEmeSessionCell() {\n    const mechanisms = Array.from(this.mechanisms_.keys());\n    if (!mechanisms.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.STORAGE_NOT_SUPPORTED,\n          'No supported storage mechanisms found');\n    }\n\n    return this.mechanisms_.get(mechanisms[0]).getEmeSessionCell();\n  }\n\n  /**\n   * Find the cell that the path points to. A path is made up of a mount point\n   * and a cell id. If a cell can be found, the cell will be returned. If no\n   * cell is found, null will be returned.\n   *\n   * @param {shaka.offline.StorageCellPath} path\n   * @return {shaka.extern.StorageCell}\n   */\n  resolvePath(path) {\n    const mechanism = this.mechanisms_.get(path.mechanism);\n\n    if (!mechanism) { return null; }\n\n    return mechanism.getCells().get(path.cell);\n  }\n\n  /**\n   * This will erase all previous content from storage. Using paths obtained\n   * before calling |erase| is discouraged, as cells may have changed during a\n   * erase.\n   *\n   * @return {!Promise}\n   */\n  async erase() {\n    // If we have initialized, we will use the existing mechanism instances.\n    /** @type {!Array.<!shaka.extern.StorageMechanism>} */\n    const mechanisms = Array.from(this.mechanisms_.values());\n    const alreadyInitialized = mechanisms.length > 0;\n\n    // If we have not initialized, we should still be able to erase.  This is\n    // critical to our ability to wipe the DB in case of a version mismatch.\n    // If there are no instances, create temporary ones and destroy them later.\n    if (!alreadyInitialized) {\n      const registry = shaka.offline.StorageMuxer.getRegistry_();\n      registry.forEach((factory, name) => {\n        const mech = factory();\n        if (mech) {\n          mechanisms.push(mech);\n        }\n      });\n    }\n\n    // Erase all storage mechanisms.\n    await Promise.all(mechanisms.map((m) => m.erase()));\n\n    // If we were erasing temporary instances, destroy them, too.\n    if (!alreadyInitialized) {\n      await Promise.all(mechanisms.map((m) => m.destroy()));\n    }\n  }\n\n  /**\n   * Register a storage mechanism for use with the default storage muxer. This\n   * will have no effect on any storage muxer already in main memory.\n   *\n   * @param {string} name\n   * @param {function():shaka.extern.StorageMechanism} factory\n   * @export\n   */\n  static register(name, factory) {\n    shaka.offline.StorageMuxer.registry_.set(name, factory);\n  }\n\n\n  /**\n   * Unregister a storage mechanism for use with the default storage muxer. This\n   * will have no effect on any storage muxer already in main memory.\n   *\n   * @param {string} name The name that the storage mechanism was registered\n   *                      under.\n   * @export\n   */\n  static unregister(name) {\n    shaka.offline.StorageMuxer.registry_.delete(name);\n  }\n\n  /**\n   * Check if there is support for storage on this platform. It is assumed that\n   * if there are any mechanisms registered, it means that storage is supported\n   * on this platform. We do not check if the mechanisms have any cells.\n   *\n   * @return {boolean}\n   */\n  static support() {\n    const registry = shaka.offline.StorageMuxer.getRegistry_();\n    // Make sure that we will have SOME mechanisms created by creating a\n    // mechanism and immediately destroying it.\n    for (const create of registry.values()) {\n      const instance = create();\n\n      if (instance) {\n        instance.destroy();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Replace the mechanism map used by the muxer. This should only be used\n   * in testing.\n   *\n   * @param {Map.<string, function():shaka.extern.StorageMechanism>} map\n   */\n  static overrideSupport(map) {\n    shaka.offline.StorageMuxer.override_ = map;\n  }\n\n  /**\n   * Undo a previous call to |overrideSupport|.\n   */\n  static clearOverride() {\n    shaka.offline.StorageMuxer.override_ = null;\n  }\n\n  /**\n   * Get the registry. If the support has been disabled, this will always\n   * an empty registry. Reading should always be done via |getRegistry_|.\n   *\n   * @return {!Map.<string, function():shaka.extern.StorageMechanism>}\n   * @private\n   */\n  static getRegistry_() {\n    const override = shaka.offline.StorageMuxer.override_;\n    const registry = shaka.offline.StorageMuxer.registry_;\n\n    if (COMPILED) {\n      return registry;\n    } else {\n      return override || registry;\n    }\n  }\n};\n\n\n/**\n * @private {Map.<string, function():shaka.extern.StorageMechanism>}\n */\nshaka.offline.StorageMuxer.override_ = null;\n\n\n/**\n * @private {!Map.<string, function():shaka.extern.StorageMechanism>}\n */\nshaka.offline.StorageMuxer.registry_ = new Map();\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.indexeddb.StorageMechanism');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.offline.StorageMuxer');\ngoog.require('shaka.offline.indexeddb.EmeSessionStorageCell');\ngoog.require('shaka.offline.indexeddb.V1StorageCell');\ngoog.require('shaka.offline.indexeddb.V2StorageCell');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * A storage mechanism to manage storage cells for an indexed db instance.\n * The cells are just for interacting with the stores that are found in the\n * database instance. The mechanism is responsible for creating new stores\n * when opening the database. If the database is too old of a version, a\n * cell will be added for the old stores but the cell won't support add\n * operations. The mechanism will create the new versions of the stores and\n * will allow add operations for those stores.\n *\n * @implements {shaka.extern.StorageMechanism}\n */\nshaka.offline.indexeddb.StorageMechanism = class {\n  constructor() {\n    /** @private {IDBDatabase} */\n    this.db_ = null;\n\n    /** @private {shaka.extern.StorageCell} */\n    this.v1_ = null;\n    /** @private {shaka.extern.StorageCell} */\n    this.v2_ = null;\n    /** @private {shaka.extern.StorageCell} */\n    this.v3_ = null;\n    /** @private {shaka.extern.EmeSessionStorageCell} */\n    this.sessions_ = null;\n  }\n\n  /**\n   * @override\n   */\n  init() {\n    const name = shaka.offline.indexeddb.StorageMechanism.DB_NAME;\n    const version = shaka.offline.indexeddb.StorageMechanism.VERSION;\n\n    let p = new shaka.util.PublicPromise();\n    let open = window.indexedDB.open(name, version);\n    open.onsuccess = (event) => {\n      let db = event.target.result;\n      this.db_ = db;\n      this.v1_ = shaka.offline.indexeddb.StorageMechanism.createV1_(db);\n      this.v2_ = shaka.offline.indexeddb.StorageMechanism.createV2_(db);\n      this.v3_ = shaka.offline.indexeddb.StorageMechanism.createV3_(db);\n      this.sessions_ =\n          shaka.offline.indexeddb.StorageMechanism.createEmeSession_(db);\n      p.resolve();\n    };\n    open.onupgradeneeded = (event) => {\n      // Add object stores for the latest version only.\n      this.createStores_(event.target.result);\n    };\n    open.onerror = (event) => {\n      p.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.INDEXED_DB_ERROR,\n          open.error));\n\n      // Firefox will raise an error on the main thread unless we stop it here.\n      event.preventDefault();\n    };\n\n    return p;\n  }\n\n  /**\n   * @override\n   */\n  async destroy() {\n    if (this.v1_) { await this.v1_.destroy(); }\n    if (this.v2_) { await this.v2_.destroy(); }\n    if (this.v3_) { await this.v3_.destroy(); }\n    if (this.sessions_) { await this.sessions_.destroy(); }\n\n    // If we were never initialized, then |db_| will still be null.\n    if (this.db_) { this.db_.close(); }\n  }\n\n  /**\n   * @override\n   */\n  getCells() {\n    const map = new Map();\n\n    if (this.v1_) { map.set('v1', this.v1_); }\n    if (this.v2_) { map.set('v2', this.v2_); }\n    if (this.v3_) { map.set('v3', this.v3_); }\n\n    return map;\n  }\n\n  /**\n   * @override\n   */\n  getEmeSessionCell() {\n    goog.asserts.assert(this.sessions_, 'Cannot be destroyed.');\n    return this.sessions_;\n  }\n\n  /**\n   * @override\n   */\n  async erase() {\n    // Not all cells may have been created, so only destroy the ones that\n    // were created.\n    if (this.v1_) { await this.v1_.destroy(); }\n    if (this.v2_) { await this.v2_.destroy(); }\n    if (this.v3_) { await this.v3_.destroy(); }\n\n    // |db_| will only be null if the muxer was not initialized. We need to\n    // close the connection in order delete the database without it being\n    // blocked.\n    if (this.db_) { this.db_.close(); }\n\n    await shaka.offline.indexeddb.StorageMechanism.deleteAll_();\n\n    // Reset before initializing.\n    this.db_ = null;\n    this.v1_ = null;\n    this.v2_ = null;\n    this.v3_ = null;\n\n    await this.init();\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.StorageCell}\n   * @private\n   */\n  static createV1_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const segmentStore = StorageMechanism.V1_SEGMENT_STORE;\n    const manifestStore = StorageMechanism.V1_MANIFEST_STORE;\n    const stores = db.objectStoreNames;\n    if (stores.contains(manifestStore) && stores.contains(segmentStore)) {\n      shaka.log.debug('Mounting v1 idb storage cell');\n\n      return new shaka.offline.indexeddb.V1StorageCell(\n          db,\n          segmentStore,\n          manifestStore);\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.StorageCell}\n   * @private\n   */\n  static createV2_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const segmentStore = StorageMechanism.V2_SEGMENT_STORE;\n    const manifestStore = StorageMechanism.V2_MANIFEST_STORE;\n    const stores = db.objectStoreNames;\n    if (stores.contains(manifestStore) && stores.contains(segmentStore)) {\n      shaka.log.debug('Mounting v2 idb storage cell');\n\n      return new shaka.offline.indexeddb.V2StorageCell(\n          db,\n          segmentStore,\n          manifestStore,\n          true);  // Are keys locked? Yes, this means no new additions.\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.StorageCell}\n   * @private\n   */\n  static createV3_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const segmentStore = StorageMechanism.V3_SEGMENT_STORE;\n    const manifestStore = StorageMechanism.V3_MANIFEST_STORE;\n    const stores = db.objectStoreNames;\n    if (stores.contains(manifestStore) && stores.contains(segmentStore)) {\n      shaka.log.debug('Mounting v3 idb storage cell');\n\n      // Version 3 uses the same structure as version 2, so we can use the same\n      // cells but it can support new entries.\n      return new shaka.offline.indexeddb.V2StorageCell(\n          db,\n          segmentStore,\n          manifestStore,\n          false); // Are keys locked? No, this means we can add new entries.\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.EmeSessionStorageCell}\n   * @private\n   */\n  static createEmeSession_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const store = StorageMechanism.SESSION_ID_STORE;\n    if (db.objectStoreNames.contains(store)) {\n      shaka.log.debug('Mounting session ID idb storage cell');\n      return new shaka.offline.indexeddb.EmeSessionStorageCell(db, store);\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @private\n   */\n  createStores_(db) {\n    const storeNames = [\n      shaka.offline.indexeddb.StorageMechanism.V3_SEGMENT_STORE,\n      shaka.offline.indexeddb.StorageMechanism.V3_MANIFEST_STORE,\n      shaka.offline.indexeddb.StorageMechanism.SESSION_ID_STORE,\n    ];\n\n    for (const name of storeNames) {\n      if (!db.objectStoreNames.contains(name)) {\n        db.createObjectStore(name, {autoIncrement: true});\n      }\n    }\n  }\n\n  /**\n   * Delete the indexed db instance so that all stores are deleted and cleared.\n   * This will force the database to a like-new state next time it opens.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  static deleteAll_() {\n    const name = shaka.offline.indexeddb.StorageMechanism.DB_NAME;\n\n    let p = new shaka.util.PublicPromise();\n\n    let del = window.indexedDB.deleteDatabase(name);\n    del.onblocked = (event) => {\n      shaka.log.warning('Deleting', name, 'is being blocked');\n    };\n    del.onsuccess = (event) => {\n      p.resolve();\n    };\n    del.onerror = (event) => {\n      p.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.INDEXED_DB_ERROR,\n          del.error));\n\n      // Firefox will raise an error on the main thread unless we stop it here.\n      event.preventDefault();\n    };\n\n    return p;\n  }\n};\n\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.DB_NAME = 'shaka_offline_db';\n/** @const {number} */\nshaka.offline.indexeddb.StorageMechanism.VERSION = 4;\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V1_SEGMENT_STORE = 'segment';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V2_SEGMENT_STORE = 'segment-v2';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V3_SEGMENT_STORE = 'segment-v3';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V1_MANIFEST_STORE = 'manifest';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V2_MANIFEST_STORE = 'manifest-v2';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V3_MANIFEST_STORE = 'manifest-v3';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.SESSION_ID_STORE = 'session-ids';\n\n\n// Since this may be called before the polyfills remove indexeddb support from\n// some platforms (looking at you Chromecast), we need to check for support\n// when we create the mechanism.\n//\n// Thankfully the storage muxer api allows us to return a null mechanism\n// to indicate that the mechanism is not supported on this platform.\nshaka.offline.StorageMuxer.register(\n    'idb',\n    () => {\n      return window.indexedDB ?\n              new shaka.offline.indexeddb.StorageMechanism() :\n              null;\n    });\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.indexeddb.V1StorageCell');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.offline.indexeddb.DBConnection');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * The V1StorageCell is for all stores that follow the shaka.externs V2 offline\n * types. This storage cell will only work for version 1 indexed db database\n * schemes.\n *\n * @implements {shaka.extern.StorageCell}\n */\nshaka.offline.indexeddb.V1StorageCell = class {\n  /**\n   * @param {IDBDatabase} connection\n   * @param {string} segmentStore\n   * @param {string} manifestStore\n   */\n  constructor(connection, segmentStore, manifestStore) {\n    /** @private {!shaka.offline.indexeddb.DBConnection} */\n    this.connection_ = new shaka.offline.indexeddb.DBConnection(connection);\n\n    /** @private {string} */\n    this.segmentStore_ = segmentStore;\n    /** @private {string} */\n    this.manifestStore_ = manifestStore;\n  }\n\n  /**\n   * @override\n   */\n  destroy() { return this.connection_.destroy(); }\n\n  /**\n   * @override\n   */\n  hasFixedKeySpace() {\n    // We do not allow adding new values to V1 databases.\n    return true;\n  }\n\n  /**\n   * @override\n   */\n  addSegments(segments) { return this.rejectAdd_(this.segmentStore_); }\n\n  /**\n   * @override\n   */\n  removeSegments(keys, onRemove) {\n    return this.remove_(this.segmentStore_, keys, onRemove);\n  }\n\n  /**\n   * @override\n   */\n  getSegments(keys) {\n    const convertSegmentData =\n        shaka.offline.indexeddb.V1StorageCell.convertSegmentData_;\n\n    return this.get_(this.segmentStore_, keys).then((segments) => {\n      return segments.map(convertSegmentData);\n    });\n  }\n\n  /**\n   * @override\n   */\n  addManifests(manifests) { return this.rejectAdd_(this.manifestStore_); }\n\n  /**\n   * @override\n   */\n  updateManifestExpiration(key, newExpiration) {\n    let op = this.connection_.startReadWriteOperation(this.manifestStore_);\n    let store = op.store();\n\n    let p = new shaka.util.PublicPromise();\n\n    store.get(key).onsuccess = (event) => {\n      // Make sure a defined value was found. Indexeddb treats \"no value found\"\n      // as a success with an undefined result.\n      let manifest = event.target.result;\n\n      // Indexeddb does not fail when you get a value that is not in the\n      // database. It will return an undefined value. However, we expect\n      // the value to never be null, so something is wrong if we get a\n      // falsey value.\n      if (manifest) {\n        // Since this store's scheme uses in-line keys, we don't need to specify\n        // the key with |put|.\n        goog.asserts.assert(\n            manifest.key == key,\n            'With in-line keys, the keys should match');\n\n        manifest.expiration = newExpiration;\n        store.put(manifest);\n\n        p.resolve();\n      } else {\n        p.reject(new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.STORAGE,\n            shaka.util.Error.Code.KEY_NOT_FOUND,\n            'Could not find values for ' + key));\n      }\n    };\n\n    // Only return our promise after the operation completes.\n    return op.promise().then(() => p);\n  }\n\n  /**\n   * @override\n   */\n  removeManifests(keys, onRemove) {\n    return this.remove_(this.manifestStore_, keys, onRemove);\n  }\n\n  /**\n   * @override\n   */\n  getManifests(keys) {\n    const V1StorageCell = shaka.offline.indexeddb.V1StorageCell;\n\n    return this.get_(this.manifestStore_, keys).then((manifests) => {\n      return manifests.map(V1StorageCell.convertManifest_);\n    });\n  }\n\n  /**\n   * @override\n   */\n  async getAllManifests() {\n    const V1StorageCell = shaka.offline.indexeddb.V1StorageCell;\n\n    /** @type {!shaka.offline.indexeddb.DBOperation} */\n    const op = this.connection_.startReadOnlyOperation(this.manifestStore_);\n    /** @type {!Map.<number, shaka.extern.ManifestDB>} */\n    const values = new Map();\n\n    await op.forEachEntry((/** number */ key, /** !Object */ value) => {\n      values.set(key, V1StorageCell.convertManifest_(value));\n    });\n\n    await op.promise();\n    return values;\n  }\n\n  /**\n   * @param {string} storeName\n   * @return {!Promise}\n   * @private\n   */\n  rejectAdd_(storeName) {\n    return Promise.reject(new shaka.util.Error(\n      shaka.util.Error.Severity.CRITICAL,\n      shaka.util.Error.Category.STORAGE,\n      shaka.util.Error.Code.NEW_KEY_OPERATION_NOT_SUPPORTED,\n      'Cannot add new value to ' + storeName));\n  }\n\n  /**\n   * @param {string} storeName\n   * @param {!Array.<number>} keys\n   * @param {function(number)} onRemove\n   * @return {!Promise}\n   * @private\n   */\n  remove_(storeName, keys, onRemove) {\n    let op = this.connection_.startReadWriteOperation(storeName);\n    let store = op.store();\n\n    keys.forEach((key) => {\n      store.delete(key).onsuccess = () => onRemove(key);\n    });\n\n    return op.promise();\n  }\n\n  /**\n   * @param {string} storeName\n   * @param {!Array.<number>} keys\n   * @return {!Promise.<!Array.<T>>}\n   * @template T\n   * @private\n   */\n  get_(storeName, keys) {\n    let op = this.connection_.startReadOnlyOperation(storeName);\n    let store = op.store();\n\n    let values = {};\n    let missing = [];\n\n    // Use a map to store the objects so that we can reorder the results to\n    // match the order of |keys|.\n    keys.forEach((key) => {\n      store.get(key).onsuccess = (event) => {\n        let value = event.target.result;\n        // Make sure a defined value was found. Indexeddb treats no-value found\n        // as a success with an undefined result.\n        if (value == undefined) {\n          missing.push(key);\n        }\n\n        values[key] = value;\n      };\n    });\n\n    // Wait until the operation completes or else values may be missing from\n    // |values|. Use the original key list to convert the map to a list so that\n    // the order will match.\n    return op.promise().then(() => {\n      if (missing.length) {\n        return Promise.reject(new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.STORAGE,\n            shaka.util.Error.Code.KEY_NOT_FOUND,\n            'Could not find values for ' + missing\n        ));\n      }\n\n      return keys.map((key) => values[key]);\n    });\n  }\n\n  /**\n   * @param {!Object} old\n   * @return {shaka.extern.ManifestDB}\n   * @private\n   */\n  static convertManifest_(old) {\n    const V1StorageCell = shaka.offline.indexeddb.V1StorageCell;\n\n    // Old Manifest Format:\n    // {\n    //   key: number,\n    //   originalManifestUri: string,\n    //   duration: number,\n    //   size: number,\n    //   expiration: number,\n    //   periods: !Array.<shaka.extern.PeriodDB>,\n    //   sessionIds: !Array.<string>,\n    //   drmInfo: ?shaka.extern.DrmInfo,\n    //   appMetadata: Object\n    //  }\n\n    goog.asserts.assert(\n        old.originalManifestUri != null,\n        'Old manifest format should have an originalManifestUri field');\n    goog.asserts.assert(\n        old.duration != null,\n        'Old manifest format should have a duration field');\n    goog.asserts.assert(\n        old.size != null,\n        'Old manifest format should have a size field');\n    goog.asserts.assert(\n        old.periods != null,\n        'Old manifest format should have a periods field');\n    goog.asserts.assert(\n        old.sessionIds != null,\n        'Old manifest format should have a session ids field');\n    goog.asserts.assert(\n        old.appMetadata != null,\n        'Old manifest format should have an app metadata field');\n\n    return {\n      originalManifestUri: old.originalManifestUri,\n      duration: old.duration,\n      size: old.size,\n      expiration: old.expiration == null ? Infinity : old.expiration,\n      periods: old.periods.map(V1StorageCell.convertPeriod_),\n      sessionIds: old.sessionIds,\n      drmInfo: old.drmInfo,\n      appMetadata: old.appMetadata,\n    };\n  }\n\n  /**\n   * @param {!Object} old\n   * @return {shaka.extern.PeriodDB}\n   * @private\n   */\n  static convertPeriod_(old) {\n    const V1StorageCell = shaka.offline.indexeddb.V1StorageCell;\n\n    // Old Period Format:\n    // {\n    //   startTime: number,\n    //   streams: !Array.<shaka.extern.StreamDB>\n    // }\n\n    goog.asserts.assert(\n      old.startTime != null,\n      'Old period format should have a start time field');\n    goog.asserts.assert(\n      old.streams != null,\n      'Old period format should have a streams field');\n\n    // In the case that this is really old (like really old, like dinosaurs\n    // roaming the Earth old) there may be no variants, so we need to add those.\n    V1StorageCell.fillMissingVariants_(old);\n\n    old.streams.forEach((stream) => {\n      const message = 'After filling in missing variants, ' +\n                      'each stream should have variant ids';\n      goog.asserts.assert(stream.variantIds, message);\n    });\n\n    return {\n      startTime: old.startTime,\n      streams: old.streams.map(V1StorageCell.convertStream_),\n    };\n  }\n\n  /**\n   * @param {!Object} old\n   * @return {shaka.extern.StreamDB}\n   * @private\n   */\n  static convertStream_(old) {\n    const V1StorageCell = shaka.offline.indexeddb.V1StorageCell;\n\n    // Old Stream Format\n    // {\n    //   id: number,\n    //   primary: boolean,\n    //   presentationTimeOffset: number,\n    //   contentType: string,\n    //   mimeType: string,\n    //   codecs: string,\n    //   frameRate: (number|undefined),\n    //   kind: (string|undefined),\n    //   language: string,\n    //   label: ?string,\n    //   width: ?number,\n    //   height: ?number,\n    //   initSegmentUri: ?string,\n    //   encrypted: boolean,\n    //   keyId: ?string,\n    //   segments: !Array.<shaka.extern.SegmentDB>,\n    //   variantIds: ?Array.<number>\n    // }\n\n    goog.asserts.assert(\n        old.id != null,\n        'Old stream format should have an id field');\n    goog.asserts.assert(\n        old.primary != null,\n        'Old stream format should have a primary field');\n    goog.asserts.assert(\n        old.presentationTimeOffset != null,\n        'Old stream format should have a presentation time offset field');\n    goog.asserts.assert(\n        old.contentType != null,\n        'Old stream format should have a content type field');\n    goog.asserts.assert(\n        old.mimeType != null,\n        'Old stream format should have a mime type field');\n    goog.asserts.assert(\n        old.codecs != null,\n        'Old stream format should have a codecs field');\n    goog.asserts.assert(\n        old.language != null,\n        'Old stream format should have a language field');\n    goog.asserts.assert(\n        old.encrypted != null,\n        'Old stream format should have an encrypted field');\n    goog.asserts.assert(\n        old.segments != null,\n        'Old stream format should have a segments field');\n\n    const initSegmentKey = old.initSegmentUri ?\n        V1StorageCell.getKeyFromSegmentUri_(old.initSegmentUri) : null;\n\n    return {\n      id: old.id,\n      originalId: null,\n      primary: old.primary,\n      presentationTimeOffset: old.presentationTimeOffset,\n      contentType: old.contentType,\n      mimeType: old.mimeType,\n      codecs: old.codecs,\n      frameRate: old.frameRate,\n      kind: old.kind,\n      language: old.language,\n      label: old.label,\n      width: old.width,\n      height: old.height,\n      initSegmentKey: initSegmentKey,\n      encrypted: old.encrypted,\n      keyId: old.keyId,\n      segments: old.segments.map(V1StorageCell.convertSegment_),\n      variantIds: old.variantIds,\n    };\n  }\n\n  /**\n   * @param {!Object} old\n   * @return {shaka.extern.SegmentDB}\n   * @private\n   */\n  static convertSegment_(old) {\n    const V1StorageCell = shaka.offline.indexeddb.V1StorageCell;\n\n    // Old Segment Format\n    // {\n    //   startTime: number,\n    //   endTime: number,\n    //   uri: string\n    // }\n\n    goog.asserts.assert(\n        old.startTime != null,\n        'The old segment format should have a start time field');\n    goog.asserts.assert(\n        old.endTime != null,\n        'The old segment format should have an end time field');\n    goog.asserts.assert(\n        old.uri != null,\n        'The old segment format should have a uri field');\n\n    // Since we don't want to use the uri anymore, we need to parse the key\n    // from it.\n    const dataKey = V1StorageCell.getKeyFromSegmentUri_(old.uri);\n\n    return {\n      startTime: old.startTime,\n      endTime: old.endTime,\n      dataKey: dataKey,\n    };\n  }\n\n  /**\n   * @param {!Object} old\n   * @return {shaka.extern.SegmentDataDB}\n   * @private\n   */\n  static convertSegmentData_(old) {\n    // Old Segment Format:\n    // {\n    //   key: number,\n    //   data: ArrayBuffer\n    // }\n\n    goog.asserts.assert(\n        old.key != null,\n        'The old segment data format should have a key field');\n    goog.asserts.assert(\n        old.data != null,\n        'The old segment data format should have a data field');\n\n    return {data: old.data};\n  }\n\n  /**\n   * @param {string} uri\n   * @return {number}\n   * @private\n   */\n  static getKeyFromSegmentUri_(uri) {\n    let parts = null;\n\n    // Try parsing the uri as the original Shaka Player 2.0 uri.\n    parts = /^offline:[0-9]+\\/[0-9]+\\/([0-9]+)$/.exec(uri);\n    if (parts) {\n      return Number(parts[1]);\n    }\n\n    // Just before Shaka Player 2.3 the uri format was changed to remove some\n    // of the un-used information from the uri and make the segment uri and\n    // manifest uri follow a similar format. However the old storage system\n    // was still in place, so it is possible for Storage V1 Cells to have\n    // Storage V2 uris.\n    parts = /^offline:segment\\/([0-9]+)$/.exec(uri);\n    if (parts) {\n      return Number(parts[1]);\n    }\n\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.MALFORMED_OFFLINE_URI,\n        'Could not parse uri ' + uri);\n  }\n\n  /**\n   * Take a period and check if the streams need to have variants generated.\n   * Before Shaka Player moved to its variants model, there were no variants.\n   * This will fill missing variants into the given object.\n   *\n   * @param {!Object} period\n   * @private\n   */\n  static fillMissingVariants_(period) {\n    const AUDIO = shaka.util.ManifestParserUtils.ContentType.AUDIO;\n    const VIDEO = shaka.util.ManifestParserUtils.ContentType.VIDEO;\n\n    // There are three cases:\n    //  1. All streams' variant ids are null\n    //  2. All streams' variant ids are non-null\n    //  3. Some streams' variant ids are null and other are non-null\n    // Case 3 is invalid and should never happen in production.\n\n    let audio = period.streams.filter((s) => s.contentType == AUDIO);\n    let video = period.streams.filter((s) => s.contentType == VIDEO);\n\n    // Case 2 - There is nothing we need to do, so let's just get out of here.\n    if (audio.every((s) => s.variantIds) && video.every((s) => s.variantIds)) {\n      return;\n    }\n\n    // Case 3... We don't want to be in case three.\n    goog.asserts.assert(\n        audio.every((s) => !s.variantIds),\n        'Some audio streams have variant ids and some do not.');\n    goog.asserts.assert(\n        video.every((s) => !s.variantIds),\n        'Some video streams have variant ids and some do not.');\n\n    // Case 1 - Populate all the variant ids (putting us back to case 2).\n    // Since all the variant ids are null, we need to first make them into\n    // valid arrays.\n    audio.forEach((s) => { s.variantIds = []; });\n    video.forEach((s) => { s.variantIds = []; });\n\n    let nextId = 0;\n\n    // It is not possible in Shaka Player's pre-variant world to have audio-only\n    // and video-only content mixed in with audio-video content. So we can\n    // assume that there is only audio-only or video-only if one group is empty.\n\n    // Everything is video-only content - so each video stream gets to be its\n    // own variant.\n    if (video.length && !audio.length) {\n      shaka.log.debug('Found video-only content. Creating variants for video.');\n      let variantId = nextId++;\n      video.forEach((s) => { s.variantIds.push(variantId); });\n    }\n\n    // Everything is audio-only content - so each audio stream gets to be its\n    // own variant.\n    if (!video.length && audio.length) {\n      shaka.log.debug('Found audio-only content. Creating variants for audio.');\n      let variantId = nextId++;\n      audio.forEach((s) => { s.variantIds.push(variantId); });\n    }\n\n    // Everything is audio-video content.\n    if (video.length && audio.length) {\n      shaka.log.debug('Found audio-video content. Creating variants.');\n      audio.forEach((a) => {\n        video.forEach((v) => {\n          let variantId = nextId++;\n          a.variantIds.push(variantId);\n          v.variantIds.push(variantId);\n        });\n      });\n    }\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.indexeddb.V2StorageCell');\n\ngoog.require('shaka.offline.indexeddb.DBConnection');\ngoog.require('shaka.util.Error');\n\n\n/**\n * The V2StorageCell is for all stores that follow the shaka.externs V2 offline\n * types. This storage cell will work for both IndexedDB version 2 and 3 as\n * both used the shaka.externs V2 offline types.\n *\n * @implements {shaka.extern.StorageCell}\n */\nshaka.offline.indexeddb.V2StorageCell = class {\n  /**\n   * @param {IDBDatabase} connection\n   * @param {string} segmentStore\n   * @param {string} manifestStore\n   * @param {boolean} isFixedKey\n   */\n  constructor(connection,\n              segmentStore,\n              manifestStore,\n              isFixedKey) {\n    /** @private {!shaka.offline.indexeddb.DBConnection} */\n    this.connection_ = new shaka.offline.indexeddb.DBConnection(connection);\n\n    /** @private {string} */\n    this.segmentStore_ = segmentStore;\n    /** @private {string} */\n    this.manifestStore_ = manifestStore;\n\n    /** @private {boolean} */\n    this.isFixedKey_ = isFixedKey;\n  }\n\n  /**\n   * @override\n   */\n  destroy() { return this.connection_.destroy(); }\n\n  /**\n   * @override\n   */\n  hasFixedKeySpace() { return this.isFixedKey_; }\n\n  /**\n   * @override\n   */\n  addSegments(segments) { return this.add_(this.segmentStore_, segments); }\n\n  /**\n   * @override\n   */\n  removeSegments(keys, onRemove) {\n    return this.remove_(this.segmentStore_, keys, onRemove);\n  }\n\n  /**\n   * @override\n   */\n  getSegments(keys) { return this.get_(this.segmentStore_, keys); }\n\n  /**\n   * @override\n   */\n  addManifests(manifests) { return this.add_(this.manifestStore_, manifests); }\n\n  /**\n   * @override\n   */\n  updateManifestExpiration(key, newExpiration) {\n    let op = this.connection_.startReadWriteOperation(this.manifestStore_);\n    let store = op.store();\n    store.get(key).onsuccess = (e) => {\n      let found = e.target.result;\n      // If we can't find the value, then there is nothing for us to update.\n      if (found) {\n        found.expiration = newExpiration;\n        store.put(found, key);\n      }\n    };\n\n    return op.promise();\n  }\n\n  /**\n   * @override\n   */\n  removeManifests(keys, onRemove) {\n    return this.remove_(this.manifestStore_, keys, onRemove);\n  }\n\n  /**\n   * @override\n   */\n  getManifests(keys) { return this.get_(this.manifestStore_, keys); }\n\n  /**\n   * @override\n   */\n  async getAllManifests() {\n    /** @type {!shaka.offline.indexeddb.DBOperation} */\n    const op = this.connection_.startReadOnlyOperation(this.manifestStore_);\n    /** @type {!Map.<number, shaka.extern.ManifestDB>} */\n    const values = new Map();\n\n    await op.forEachEntry(\n        (/** number */ key, /** shaka.extern.ManifestDB */ value) => {\n          values.set(key, value);\n        });\n\n    await op.promise();\n    return values;\n  }\n\n  /**\n   * @param {string} storeName\n   * @param {!Array.<T>} values\n   * @return {!Promise.<!Array.<number>>}\n   * @template T\n   * @private\n   */\n  add_(storeName, values) {\n    // In the case that this storage cell does not support add-operations, just\n    // reject the request immediately instead of allowing it to try.\n    if (this.isFixedKey_) {\n      return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.RECOVERABLE,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.NEW_KEY_OPERATION_NOT_SUPPORTED,\n        'Cannot add new value to ' + storeName));\n    }\n\n    let op = this.connection_.startReadWriteOperation(storeName);\n    let store = op.store();\n\n    /** @type {!Array.<number>} */\n    let keys = [];\n\n    // Write each segment out. When each request completes, the key will\n    // be in |event.target.result| as can be seen in\n    // https://w3c.github.io/IndexedDB/#key-generator-construct.\n    values.forEach((value) => {\n      let request = store.add(value);\n      request.onsuccess = (event) => {\n        let key = event.target.result;\n        keys.push(key);\n      };\n    });\n\n    // Wait until the operation completes or else |keys| will not be fully\n    // populated.\n    return op.promise().then(() => keys);\n  }\n\n  /**\n   * @param {string} storeName\n   * @param {!Array.<number>} keys\n   * @param {function(number)} onRemove\n   * @return {!Promise}\n   * @private\n   */\n  remove_(storeName, keys, onRemove) {\n    let op = this.connection_.startReadWriteOperation(storeName);\n    let store = op.store();\n\n    keys.forEach((key) => {\n      store.delete(key).onsuccess = () => onRemove(key);\n    });\n\n    return op.promise();\n  }\n\n  /**\n   * @param {string} storeName\n   * @param {!Array.<number>} keys\n   * @return {!Promise.<!Array.<T>>}\n   * @template T\n   * @private\n   */\n  get_(storeName, keys) {\n    let op = this.connection_.startReadOnlyOperation(storeName);\n    let store = op.store();\n\n    let values = {};\n    let missing = [];\n\n    // Use a map to store the objects so that we can reorder the results to\n    // match the order of |keys|.\n    keys.forEach((key) => {\n      let request = store.get(key);\n      request.onsuccess = () => {\n        // Make sure a defined value was found. Indexeddb treats no-value found\n        // as a success with an undefined result.\n        if (request.result == undefined) {\n          missing.push(key);\n        }\n\n        values[key] = request.result;\n      };\n    });\n\n    // Wait until the operation completes or else values may be missing from\n    // |values|. Use the original key list to convert the map to a list so that\n    // the order will match.\n    return op.promise().then(() => {\n      if (missing.length) {\n        return Promise.reject(new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.STORAGE,\n            shaka.util.Error.Code.KEY_NOT_FOUND,\n            'Could not find values for ' + missing\n        ));\n      }\n\n      return keys.map((key) => values[key]);\n    });\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.OfflineUri');\n\n\n/**\n * The OfflineUri class contains all the components that make up the offline\n * uri. The components are:\n *    TYPE: Used to know what type of data the uri points to. It can either\n *          be \"manifest\" or \"segment\".\n *    MECHANISM: The name of the mechanism that manages the storage cell that\n *               holds the data.\n *    CELL: The name of the cell that holds the data.\n *    KEY: The key that the data is stored under in the cell.\n */\nshaka.offline.OfflineUri = class {\n  /**\n   * @param {string} type\n   * @param {string} mechanism\n   * @param {string} cell\n   * @param {number} key\n   */\n  constructor(type, mechanism, cell, key) {\n    /**\n     * @private {string}\n     * @const\n     */\n    this.type_ = type;\n    /**\n     * @private {string}\n     * @const\n     */\n    this.mechanism_ = mechanism;\n    /**\n     * @private {string}\n     * @const\n     */\n    this.cell_ = cell;\n    /**\n     * @private {number}\n     * @const\n     */\n    this.key_ = key;\n\n    /**\n     * @private {string}\n     * @const\n     */\n    this.asString_ = [\n      'offline:', type, '/', mechanism, '/', cell, '/', key,\n    ].join('');\n  }\n\n  /** @return {boolean} */\n  isManifest() { return this.type_ == 'manifest'; }\n\n  /** @return {boolean} */\n  isSegment() { return this.type_ == 'segment'; }\n\n  /** @return {string} */\n  mechanism() { return this.mechanism_; }\n\n  /** @return {string} */\n  cell() { return this.cell_; }\n\n  /** @return {number} */\n  key() { return this.key_; }\n\n  /** @override */\n  toString() { return this.asString_; }\n\n  /**\n   * @param {string} uri\n   * @return {?shaka.offline.OfflineUri}\n   */\n  static parse(uri) {\n    let parts = /^offline:([a-z]+)\\/([^/]+)\\/([^/]+)\\/([0-9]+)$/.exec(uri);\n    if (parts == null) { return null; }\n\n    let type = parts[1];\n    if (type != 'manifest' && type != 'segment') { return null; }\n\n    let mechanism = parts[2];\n    if (!mechanism) { return null; }\n\n    let cell = parts[3];\n    if (!cell) { return null; }\n\n    let key = Number(parts[4]);\n    if (type == null) { return null; }\n\n    return new shaka.offline.OfflineUri(type, mechanism, cell, key);\n  }\n\n  /**\n   * @param {string} mechanism\n   * @param {string} cell\n   * @param {number} key\n   * @return {!shaka.offline.OfflineUri}\n   */\n  static manifest(mechanism, cell, key) {\n    return new shaka.offline.OfflineUri('manifest', mechanism, cell, key);\n  }\n\n  /**\n   * @param {string} mechanism\n   * @param {string} cell\n   * @param {number} key\n   * @return {!shaka.offline.OfflineUri}\n   */\n  static segment(mechanism, cell, key) {\n    return new shaka.offline.OfflineUri('segment', mechanism, cell, key);\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.ManifestConverter');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.util.ManifestParserUtils');\n\n\n/**\n * Utility class for converting database manifest objects back to normal\n * player-ready objects. Used by the offline system to convert on-disk\n * objects back to the in-memory objects.\n */\nshaka.offline.ManifestConverter = class {\n  /**\n   * Create a new manifest converter. Need to know the mechanism and cell that\n   * the manifest is from so that all segments paths can be created.\n   *\n   * @param {string} mechanism\n   * @param {string} cell\n   */\n  constructor(mechanism, cell) {\n    /** @private {string} */\n    this.mechanism_ = mechanism;\n    /** @private {string} */\n    this.cell_ = cell;\n  }\n\n  /**\n   * Convert a |shaka.extern.ManifestDB| object to a |shaka.extern.Manifest|\n   * object.\n   *\n   * @param {shaka.extern.ManifestDB} manifestDB\n   * @return {shaka.extern.Manifest}\n   */\n  fromManifestDB(manifestDB) {\n    let timeline = new shaka.media.PresentationTimeline(null, 0);\n    timeline.setDuration(manifestDB.duration);\n\n    let periods = manifestDB.periods.map((period) =>\n        this.fromPeriodDB(period, timeline));\n\n    let drmInfos = manifestDB.drmInfo ? [manifestDB.drmInfo] : [];\n    if (manifestDB.drmInfo) {\n      periods.forEach((period) => {\n        period.variants.forEach((variant) => { variant.drmInfos = drmInfos; });\n      });\n    }\n\n    return {\n      presentationTimeline: timeline,\n      minBufferTime: 2,\n      offlineSessionIds: manifestDB.sessionIds,\n      periods: periods,\n    };\n  }\n\n  /**\n   * Create a period object from a database period.\n   *\n   * @param {shaka.extern.PeriodDB} period\n   * @param {shaka.media.PresentationTimeline} timeline\n   * @return {shaka.extern.Period}\n   */\n  fromPeriodDB(period, timeline) {\n    /** @type {!Array.<shaka.extern.StreamDB>} */\n    let audioStreams = period.streams.filter((stream) => this.isAudio_(stream));\n    /** @type {!Array.<shaka.extern.StreamDB>} */\n    let videoStreams = period.streams.filter((stream) => this.isVideo_(stream));\n\n    /** @type {!Map.<number, shaka.extern.Variant>} */\n    const variants = this.createVariants(audioStreams, videoStreams);\n\n    /** @type {!Array.<shaka.extern.Stream>} */\n    let textStreams = period.streams\n        .filter((stream) => this.isText_(stream))\n        .map((stream) => this.fromStreamDB_(stream));\n\n    period.streams.forEach((stream, i) => {\n      /** @type {!Array.<!shaka.media.SegmentReference>} */\n      let refs = stream.segments.map((segment, index) => {\n        return this.fromSegmentDB_(index, segment);\n      });\n\n      timeline.notifySegments(refs, period.startTime);\n    });\n\n    return {\n      startTime: period.startTime,\n      variants: Array.from(variants.values()),\n      textStreams: textStreams,\n    };\n  }\n\n  /**\n   * Recreates Variants from audio and video StreamDB collections.\n   *\n   * @param {!Array.<!shaka.extern.StreamDB>} audios\n   * @param {!Array.<!shaka.extern.StreamDB>} videos\n   * @return {!Map.<number, !shaka.extern.Variant>}\n   */\n  createVariants(audios, videos) {\n    // Get all the variant ids from all audio and video streams.\n    /** @type {!Set.<number>} */\n    const variantIds = new Set();\n    for (const stream of audios) {\n      for (const id of stream.variantIds) { variantIds.add(id); }\n    }\n    for (const stream of videos) {\n      for (const id of stream.variantIds) { variantIds.add(id); }\n    }\n\n    /** @type {!Map.<number, shaka.extern.Variant>} */\n    const variantMap = new Map();\n    for (const id of variantIds) {\n      variantMap.set(id, this.createEmptyVariant_(id));\n    }\n\n    // Assign each audio stream to its variants.\n    for (const audio of audios) {\n      /** @type {shaka.extern.Stream} */\n      const stream = this.fromStreamDB_(audio);\n\n      for (const variantId of audio.variantIds) {\n        const variant = variantMap.get(variantId);\n\n        goog.asserts.assert(\n            !variant.audio, 'A variant should only have one audio stream');\n\n        variant.language = stream.language;\n        variant.primary = variant.primary || stream.primary;\n        variant.audio = stream;\n      }\n    }\n\n    // Assign each video stream to its variants.\n    for (const video of videos) {\n      /** @type {shaka.extern.Stream} */\n      const stream = this.fromStreamDB_(video);\n\n      for (const variantId of video.variantIds) {\n        const variant = variantMap.get(variantId);\n\n        goog.asserts.assert(\n            !variant.video, 'A variant should only have one video stream');\n\n        variant.primary = variant.primary || stream.primary;\n        variant.video = stream;\n      }\n    }\n\n    return variantMap;\n  }\n\n  /**\n   * @param {shaka.extern.StreamDB} streamDB\n   * @return {shaka.extern.Stream}\n   * @private\n   */\n  fromStreamDB_(streamDB) {\n    /** @type {!Array.<!shaka.media.SegmentReference>} */\n    let segments = streamDB.segments.map((segment, index) =>\n        this.fromSegmentDB_(index, segment));\n\n    /** @type {!shaka.media.SegmentIndex} */\n    let segmentIndex = new shaka.media.SegmentIndex(segments);\n\n    /** @type {shaka.extern.Stream} */\n    let stream = {\n      id: streamDB.id,\n      originalId: streamDB.originalId,\n      createSegmentIndex: () => Promise.resolve(),\n      findSegmentPosition: (index) => segmentIndex.find(index),\n      getSegmentReference: (index) => segmentIndex.get(index),\n      initSegmentReference: null,\n      presentationTimeOffset: streamDB.presentationTimeOffset,\n      mimeType: streamDB.mimeType,\n      codecs: streamDB.codecs,\n      width: streamDB.width || undefined,\n      height: streamDB.height || undefined,\n      frameRate: streamDB.frameRate || undefined,\n      kind: streamDB.kind,\n      encrypted: streamDB.encrypted,\n      keyId: streamDB.keyId,\n      language: streamDB.language,\n      label: streamDB.label || null,\n      type: streamDB.contentType,\n      primary: streamDB.primary,\n      trickModeVideo: null,\n      // TODO(modmaker): Store offline?\n      emsgSchemeIdUris: null,\n      roles: [],\n      channelsCount: null,\n      closedCaptions: null,\n    };\n\n    if (streamDB.initSegmentKey != null) {\n      stream.initSegmentReference =\n          this.fromInitSegmentDB_(streamDB.initSegmentKey);\n    }\n\n    return stream;\n  }\n\n  /**\n   * @param {number} index\n   * @param {shaka.extern.SegmentDB} segmentDB\n   * @return {!shaka.media.SegmentReference}\n   * @private\n   */\n  fromSegmentDB_(index, segmentDB) {\n    /** @type {!shaka.offline.OfflineUri} */\n    let uri = shaka.offline.OfflineUri.segment(\n        this.mechanism_, this.cell_, segmentDB.dataKey);\n\n    return new shaka.media.SegmentReference(\n        index,\n        segmentDB.startTime,\n        segmentDB.endTime,\n        () => [uri.toString()],\n        0 /* startByte */,\n        null /*  endByte */);\n  }\n\n  /**\n   * @param {number} key\n   * @return {!shaka.media.InitSegmentReference}\n   * @private\n   */\n  fromInitSegmentDB_(key) {\n    /** @type {!shaka.offline.OfflineUri} */\n    let uri = shaka.offline.OfflineUri.segment(\n        this.mechanism_, this.cell_, key);\n\n    return new shaka.media.InitSegmentReference(\n        () => [uri.toString()],\n        0 /* startBytes*/,\n        null /* endBytes */);\n  }\n\n  /**\n   * @param {shaka.extern.StreamDB} stream\n   * @return {boolean}\n   * @private\n   */\n  isAudio_(stream) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return stream.contentType == ContentType.AUDIO;\n  }\n\n  /**\n   * @param {shaka.extern.StreamDB} stream\n   * @return {boolean}\n   * @private\n   */\n  isVideo_(stream) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return stream.contentType == ContentType.VIDEO;\n  }\n\n  /**\n   * @param {shaka.extern.StreamDB} stream\n   * @return {boolean}\n   * @private\n   */\n  isText_(stream) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return stream.contentType == ContentType.TEXT;\n  }\n\n  /**\n   * Creates an empty Variant.\n   *\n   * @param {number} id\n   * @return {!shaka.extern.Variant}\n   * @private\n   */\n  createEmptyVariant_(id) {\n    return {\n      id: id,\n      language: '',\n      primary: false,\n      audio: null,\n      video: null,\n      bandwidth: 0,\n      drmInfos: [],\n      allowedByApplication: true,\n      allowedByKeySystem: true,\n    };\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.OfflineManifestParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.offline.ManifestConverter');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.offline.StorageMuxer');\ngoog.require('shaka.util.Error');\n\n\n/**\n * Creates a new offline manifest parser.\n * @struct\n * @constructor\n * @implements {shaka.extern.ManifestParser}\n */\nshaka.offline.OfflineManifestParser = function() {\n  /** @private {shaka.offline.OfflineUri} */\n  this.uri_ = null;\n};\n\n\n/** @override */\nshaka.offline.OfflineManifestParser.prototype.configure = function(config) {\n  // No-op\n};\n\n\n/** @override */\nshaka.offline.OfflineManifestParser.prototype.start =\n    async function(uriString, playerInterface) {\n  /** @type {shaka.offline.OfflineUri} */\n  const uri = shaka.offline.OfflineUri.parse(uriString);\n  this.uri_ = uri;\n\n  if (uri == null || !uri.isManifest()) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.NETWORK,\n        shaka.util.Error.Code.MALFORMED_OFFLINE_URI,\n        uri));\n  }\n\n  /** @type {!shaka.offline.StorageMuxer} */\n  const muxer = new shaka.offline.StorageMuxer();\n\n  try {\n    await muxer.init();\n\n    const cell = await muxer.getCell(uri.mechanism(), uri.cell());\n\n    const manifests = await cell.getManifests([uri.key()]);\n    const manifest = manifests[0];\n\n    const converter = new shaka.offline.ManifestConverter(\n      uri.mechanism(), uri.cell());\n\n    return converter.fromManifestDB(manifest);\n  } finally {\n    await muxer.destroy();\n  }\n};\n\n\n/** @override */\nshaka.offline.OfflineManifestParser.prototype.stop = function() {\n  return Promise.resolve();\n};\n\n\n/** @override */\nshaka.offline.OfflineManifestParser.prototype.update = function() {\n  // No-op\n};\n\n\n/** @override */\nshaka.offline.OfflineManifestParser.prototype.onExpirationUpdated =\n    async function(sessionId, expiration) {\n  goog.asserts.assert(\n      this.uri_, 'Should not get update event before start has been called');\n\n  /** @type {!shaka.offline.OfflineUri} */\n  const uri = this.uri_;\n\n  /** @type {!shaka.offline.StorageMuxer} */\n  const muxer = new shaka.offline.StorageMuxer();\n\n  try {\n    await muxer.init();\n\n    const cell = await muxer.getCell(uri.mechanism(), uri.cell());\n\n    const manifests = await cell.getManifests([uri.key()]);\n    const manifest = manifests[0];\n\n    const foundSession = manifest.sessionIds.includes(sessionId);\n    const newExpiration = manifest.expiration == undefined ||\n                          manifest.expiration > expiration;\n\n    if (foundSession && newExpiration) {\n      shaka.log.debug('Updating expiration for stored content');\n      await cell.updateManifestExpiration(uri.key(), expiration);\n    }\n  } catch (e) {\n    // Ignore errors with update.\n    shaka.log.error('There was an error updating', uri, e);\n  } finally {\n    await muxer.destroy();\n  }\n};\n\n\nshaka.media.ManifestParser.registerParserByMime(\n    'application/x-offline-manifest', shaka.offline.OfflineManifestParser);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.OfflineScheme');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.offline.StorageMuxer');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\n\n\n/**\n * @namespace\n * @summary A plugin that handles requests for offline content.\n * @param {string} uri\n * @param {shaka.extern.Request} request\n * @param {shaka.net.NetworkingEngine.RequestType} requestType\n * @param {shaka.extern.ProgressUpdated} progressUpdated Called when a\n *   progress event happened.\n * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n * @export\n */\nshaka.offline.OfflineScheme = function(\n    uri, request, requestType, progressUpdated) {\n  let offlineUri = shaka.offline.OfflineUri.parse(uri);\n\n  if (offlineUri && offlineUri.isManifest()) {\n    return shaka.offline.OfflineScheme.getManifest_(uri);\n  }\n\n  if (offlineUri && offlineUri.isSegment()) {\n    return shaka.offline.OfflineScheme.getSegment_(\n        offlineUri.key(), offlineUri);\n  }\n\n  return shaka.util.AbortableOperation.failed(\n      new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.MALFORMED_OFFLINE_URI,\n          uri));\n};\n\n\n/**\n * @param {string} uri\n * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n * @private\n */\nshaka.offline.OfflineScheme.getManifest_ = function(uri) {\n  /** @type {shaka.extern.Response} */\n  let response = {\n    uri: uri,\n    originalUri: uri,\n    data: new ArrayBuffer(0),\n    headers: {'content-type': 'application/x-offline-manifest'},\n  };\n\n  return shaka.util.AbortableOperation.completed(response);\n};\n\n\n/**\n * @param {number} id\n * @param {!shaka.offline.OfflineUri} uri\n * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n * @private\n */\nshaka.offline.OfflineScheme.getSegment_ = function(id, uri) {\n  goog.asserts.assert(\n      uri.isSegment(),\n      'Only segment uri\\'s should be given to getSegment');\n\n  /** @type {!shaka.offline.StorageMuxer} */\n  const muxer = new shaka.offline.StorageMuxer();\n\n  return shaka.util.AbortableOperation.completed(undefined)\n      .chain(() => muxer.init())\n      .chain(() => muxer.getCell(uri.mechanism(), uri.cell()))\n      .chain((cell) => cell.getSegments([uri.key()]))\n      .chain((segments) => {\n        const segment = segments[0];\n\n        return {\n          uri: uri,\n          originalUri: uri,\n          data: segment.data,\n          headers: {},\n        };\n      })\n      .finally(() => muxer.destroy());\n};\n\n\nshaka.net.NetworkingEngine.registerScheme(\n    'offline', shaka.offline.OfflineScheme);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.SessionDeleter');\n\n\ngoog.require('shaka.log');\ngoog.require('shaka.util.ArrayUtils');\n\n\n/**\n * Contains a utility method to delete persistent EME sessions.\n */\nshaka.offline.SessionDeleter = class {\n  constructor() {}\n\n  /**\n   * Deletes the given sessions.  This never fails and instead logs the error.\n   *\n   * @param {shaka.extern.DrmConfiguration} config\n   * @param {!shaka.net.NetworkingEngine} netEngine\n   * @param {!Array.<shaka.extern.EmeSessionDB>} sessions\n   * @return {!Promise.<!Array.<string>>} The session IDs that were deleted.\n   */\n  async delete(config, netEngine, sessions) {\n    const SessionDeleter = shaka.offline.SessionDeleter;\n\n    let deleted = [];\n    for (const bucket of SessionDeleter.createBuckets_(sessions)) {\n      // Run these sequentially to avoid creating multiple CDM instances at one\n      // time.  Some embedded platforms may not support multiples.\n      const p = this.doDelete_(config, netEngine, bucket);\n      const cur = await p;  // eslint-disable-line no-await-in-loop\n      deleted = deleted.concat(cur);\n    }\n    return deleted;\n  }\n\n\n  /**\n   * Performs the deletion of the given session IDs.\n   *\n   * @param {shaka.extern.DrmConfiguration} config\n   * @param {!shaka.net.NetworkingEngine} netEngine\n   * @param {shaka.offline.SessionDeleter.Bucket_} bucket\n   * @return {!Promise.<!Array.<string>>} The sessions that were deleted\n   * @private\n   */\n  async doDelete_(config, netEngine, bucket) {\n    /** @type {!shaka.media.DrmEngine} */\n    const drmEngine = new shaka.media.DrmEngine({\n      netEngine: netEngine,\n      onError: () => {},\n      onKeyStatus: () => {},\n      onExpirationUpdated: () => {},\n      onEvent: () => {},\n    });\n\n    try {\n      drmEngine.configure(config);\n      await drmEngine.initForRemoval(\n          bucket.info.keySystem, bucket.info.licenseUri,\n          bucket.info.serverCertificate,\n          bucket.info.audioCapabilities, bucket.info.videoCapabilities);\n    } catch (e) {\n      shaka.log.warning('Error initializing EME', e);\n      await drmEngine.destroy();\n      return [];\n    }\n\n    try {\n      await drmEngine.setServerCertificate();\n    } catch (e) {\n      shaka.log.warning('Error setting server certificate', e);\n      await drmEngine.destroy();\n      return [];\n    }\n\n    /** @type {!Array.<string>} */\n    const sessionIds = [];\n    await Promise.all(bucket.sessionIds.map(async (sessionId) => {\n      // This method is in a .map(), so this starts multiple removes at once,\n      // so this removes the sessions in parallel.\n      try {\n        await drmEngine.removeSession(sessionId);\n        sessionIds.push(sessionId);\n      } catch (e) {\n        shaka.log.warning('Error deleting offline session', e);\n      }\n    }));\n    await drmEngine.destroy();\n    return sessionIds;\n  }\n\n\n  /**\n   * Collects the given sessions into buckets that can be done at the same time.\n   * Since querying with different parameters can give us back different CDMs,\n   * we can't just use one CDM instance to delete everything.\n   *\n   * @param {!Array.<shaka.extern.EmeSessionDB>} sessions\n   * @return {!Array.<shaka.offline.SessionDeleter.Bucket_>}\n   * @private\n   */\n  static createBuckets_(sessions) {\n    const SessionDeleter = shaka.offline.SessionDeleter;\n\n    /** @type {!Array.<shaka.offline.SessionDeleter.Bucket_>} */\n    const ret = [];\n    for (const session of sessions) {\n      let found = false;\n      for (const bucket of ret) {\n        if (SessionDeleter.isCompatible_(bucket.info, session)) {\n          bucket.sessionIds.push(session.sessionId);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        ret.push({info: session, sessionIds: [session.sessionId]});\n      }\n    }\n\n    return ret;\n  }\n\n\n  /**\n   * Returns whether the given session infos are compatible with each other.\n   * @param {shaka.extern.EmeSessionDB} a\n   * @param {shaka.extern.EmeSessionDB} b\n   * @return {boolean}\n   * @private\n   */\n  static isCompatible_(a, b) {\n    const ArrayUtils = shaka.util.ArrayUtils;\n\n    // TODO: Add a way to change the license server in DrmEngine to avoid\n    // resetting EME for different license servers.\n    const comp = (x, y) =>\n        x.robustness == y.robustness && x.contentType == y.contentType;\n    return a.keySystem == b.keySystem && a.licenseUri == b.licenseUri &&\n        ArrayUtils.hasSameElements(\n            a.audioCapabilities, b.audioCapabilities, comp) &&\n        ArrayUtils.hasSameElements(\n            a.videoCapabilities, b.videoCapabilities, comp);\n  }\n};\n\n\n/**\n * @typedef {{\n *   info: shaka.extern.EmeSessionDB,\n *   sessionIds: !Array.<string>\n * }}\n */\nshaka.offline.SessionDeleter.Bucket_;\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.routing.Walker');\ngoog.provide('shaka.routing.Walker.Implementation');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.routing.Node');\ngoog.require('shaka.routing.Payload');\ngoog.require('shaka.util.IDestroyable');\n\n\n/**\n * The walker moves through a graph node-by-node executing asynchronous work\n * as it enters each node.\n *\n * The walker accepts requests for where it should go next. Requests are queued\n * and executed in FIFO order. If the current request can be interrupted, it\n * will be cancelled and the next request started.\n *\n * A request says \"I want to change where we are going\". When the walker is\n * ready to change destinations, it will resolve the request, allowing the\n * destination to differ based on the current state and not the state when\n * the request was appended.\n *\n * Example (from shaka.Player):\n *  When we unload, we need to either go to the attached or detached state based\n *  on whether or not we have a video element.\n *\n *  When we are asked to unload, we don't know what other pending requests may\n *  be ahead of us (there could be attach requests or detach requests). We need\n *  to wait until its our turn to know if:\n *    - we should go to the attach state because we have a media element\n *    - we should go to the detach state because we don't have a media element\n *\n * The walker allows the caller to specify if a route can or cannot be\n * interrupted. This is to allow potentially dependent routes to wait until\n * other routes have finished.\n *\n * Example (from shaka.Player):\n *  A request to load content depends on an attach request finishing. We don't\n *  want load request to interrupt an attach request. By marking the attach\n *  request as non-interruptible we ensure that calling load before attach\n *  finishes will work.\n *\n * @implements {shaka.util.IDestroyable}\n * @final\n */\nshaka.routing.Walker = class {\n  /**\n   * Create a new walker that starts at |startingAt| and with |startingWith|.\n   * The instance of |startingWith| will be the one that the walker holds and\n   * uses for its life. No one else should reference it.\n   *\n   * The per-instance behaviour for the walker is provided via |implementation|\n   * which is used to connect this walker with the \"outside world\".\n   *\n   * @param {shaka.routing.Node} startingAt\n   * @param {shaka.routing.Payload} startingWith\n   * @param {shaka.routing.Walker.Implementation} implementation\n   */\n  constructor(startingAt, startingWith, implementation) {\n    /** @private {?shaka.routing.Walker.Implementation} */\n    this.implementation_ = implementation;\n\n    /** @private {shaka.routing.Node} */\n    this.currentlyAt_ = startingAt;\n\n    /** @private {shaka.routing.Payload} */\n    this.currentlyWith_ = startingWith;\n\n    /**\n     * When we run out of work to do, we will set this promise so that when\n     * new work is added (and this is not null) it can be resolved. The only\n     * time when this should be non-null is when we are waiting for more work.\n     *\n     * @private {shaka.util.PublicPromise}\n     */\n    this.waitForWork_ = null;\n\n    /** @private {!Array.<shaka.routing.Walker.Request_>} */\n    this.requests_ = [];\n\n    /** @private {?shaka.routing.Walker.ActiveRoute_} */\n    this.currentRoute_ = null;\n\n    /** @private {shaka.util.AbortableOperation} */\n    this.currentStep_ = null;\n\n    /**\n     * This flag is used by the main loop to know if it should keep doing work.\n     * It will be true from now until |destroy| is called.\n     *\n     * @private {boolean}\n     */\n    this.isAlive_ = true;\n\n    /**\n     * Hold a reference to the main loop's promise so that we know when it has\n     * exited. This will determine when |destroy| can resolve. Purposely make\n     * the main loop start next interpreter cycle so that the constructor will\n     * finish before it starts.\n     *\n     * @private {!Promise}\n     */\n    this.mainLoopPromise_ = Promise.resolve().then(() => this.mainLoop_());\n  }\n\n  /** @override */\n  async destroy() {\n    // By setting |isAlive_| to |false|, we are telling the main loop to exit.\n    // If the main loop is blocked waiting for new work, unblock it by\n    // notifying.\n    this.isAlive_ = false;\n\n    // If we are executing a current step, we want to interrupt it so that we\n    // can force the main loop to terminate.\n    if (this.currentStep_) {\n      this.currentStep_.abort();\n    }\n\n    // If we are waiting for more work, we want to wake-up the main loop so that\n    // it can exit on its own.\n    this.unblockMainLoop_();\n\n    // Wait for the main loop to terminate so that an async operation won't\n    // try and use state that we released.\n    await this.mainLoopPromise_;\n\n    // Any routes that we are not going to finish, we need to cancel. If we\n    // don't do this, those listening will be left hanging.\n    if (this.currentRoute_) {\n      this.currentRoute_.listeners.onCancel();\n    }\n    for (const request of this.requests_) {\n      request.listeners.onCancel();\n    }\n\n    // Release anything that could hold references to anything outside of this\n    // class.\n    this.currentRoute_ = null;\n    this.requests_ = [];\n    this.implementation_ = null;\n  }\n\n  /**\n   * Ask the walker to start a new route. When the walker is ready to start a\n   * new route, it will call |create| and |create| will provide the walker with\n   * a new route to execute.\n   *\n   * If any previous calls to |startNewRoute| created non-interruptible routes,\n   * |create| won't be called until all previous non-interruptible routes have\n   * finished.\n   *\n   * This method will return a collection of listeners that the caller can hook\n   * into. Any listener that the caller is interested should be assigned\n   * immediately after calling |startNewRoute| or else they could miss the event\n   * they want to listen for.\n   *\n   * @param {function(shaka.routing.Payload):?shaka.routing.Walker.Route} create\n   * @return {shaka.routing.Walker.Listeners}\n   */\n  startNewRoute(create) {\n    const listeners = {\n      onStart: () => {},\n      onEnd: () => {},\n      onCancel: () => {},\n      onError: (error) => {},\n      onSkip: () => {},\n      onEnter: () => {},\n    };\n\n    this.requests_.push({\n      create: create,\n      listeners: listeners,\n    });\n\n    // If we are in the middle of a step, try to abort it. If this is successful\n    // the main loop will error and the walker will enter recovery mode.\n    if (this.currentStep_) {\n      this.currentStep_.abort();\n    }\n\n    // Tell the main loop that new work is available. If the main loop was not\n    // blocked, this will be a no-op.\n    this.unblockMainLoop_();\n\n    return listeners;\n  }\n\n  /**\n   * @return {!Promise}\n   * @private\n   */\n  async mainLoop_() {\n    while (this.isAlive_) {\n      // eslint-disable-next-line no-await-in-loop\n      await this.doOneThing_();\n    }\n  }\n\n  /**\n   * Do one thing to move the walker closer to its destination. This can be:\n   *   1. Starting a new route.\n   *   2. Taking one more step/finishing a route.\n   *   3. Wait for a new route.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  doOneThing_() {\n    if (this.tryNewRoute_()) {\n      return Promise.resolve();\n    }\n\n    if (this.currentRoute_) {\n      return this.takeNextStep_();\n    }\n\n    goog.asserts.assert(this.waitForWork_ == null,\n                        'We should not have a promise yet.');\n\n    // We have no more work to do. We will wait until new work has been provided\n    // via request route or until we are destroyed.\n\n    this.implementation_.onIdle(this.currentlyAt_);\n\n    // Wait on a new promise so that we can be resolved by |waitForWork|. This\n    // avoids us acting like a busy-wait.\n    this.waitForWork_ = new shaka.util.PublicPromise();\n    return this.waitForWork_;\n  }\n\n  /**\n   * Check if the walker can start a new route. There are a couple ways this can\n   * happen:\n   *  1. We have a new request but no current route\n   *  2. We have a new request and our current route can be interrupted\n   *\n   * @return {boolean}\n   *    |true| when a new route was started (regardless of reason) and |false|\n   *    when no new route was started.\n   *\n   * @private\n   */\n  tryNewRoute_() {\n    goog.asserts.assert(\n        this.currentStep_ == null,\n        'We should never have a current step between taking steps.');\n\n    if (this.requests_.length == 0) {\n      return false;\n    }\n\n    // If the current route cannot be interrupted, we can't start a new route.\n    if (this.currentRoute_ && !this.currentRoute_.interruptible) {\n      return false;\n    }\n\n    // Stop any previously active routes. Even if we don't pick-up a new route,\n    // this route should stop.\n    if (this.currentRoute_) {\n      this.currentRoute_.listeners.onCancel();\n      this.currentRoute_ = null;\n    }\n\n    // Create and start the next route. We may not take any steps because it may\n    // be interrupted by the next request.\n    const request = this.requests_.shift();\n    const newRoute = request.create(this.currentlyWith_);\n\n    // Based on the current state of |payload|, a new route may not be\n    // possible. In these cases |create| will return |null| to signal that\n    // we should just stop the current route and move onto the next request\n    // (in the next main loop iteration).\n    if (newRoute) {\n      request.listeners.onStart();\n\n      // Convert the route created from the request's create method to an\n      // active route.\n      this.currentRoute_ = {\n        node: newRoute.node,\n        payload: newRoute.payload,\n        interruptible: newRoute.interruptible,\n        listeners: request.listeners,\n      };\n    } else {\n      request.listeners.onSkip();\n    }\n\n    return true;\n  }\n\n\n  /**\n   * Move forward one step on our current route. This assumes that we have a\n   * current route. A couple things can happen when moving forward:\n   *  1. An error - if an error occurs, it will signal an error occurred,\n   *     attempt to recover, and drop the route.\n   *  2. Move - if no error occurs, we will move forward. When we arrive at\n   *     our destination, it will signal the end and drop the route.\n   *\n   * In the event of an error or arriving at the destination, we drop the\n   * current route. This allows us to pick-up a new route next time the main\n   * loop iterates.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async takeNextStep_() {\n    goog.asserts.assert(\n        this.currentRoute_,\n        'We need a current route to take the next step.');\n\n    // Figure out where we are supposed to go next.\n    this.currentlyAt_ = this.implementation_.getNext(\n        this.currentlyAt_,\n        this.currentlyWith_,\n        this.currentRoute_.node,\n        this.currentRoute_.payload);\n\n    this.currentRoute_.listeners.onEnter(this.currentlyAt_);\n\n    // Enter the new node, this is where things can go wrong since it is\n    // possible for \"supported errors\" to occur - errors that the code using\n    // the walker can't predict but can recover from.\n    try {\n      this.currentStep_ = this.implementation_.enterNode(\n          /* node= */ this.currentlyAt_,\n          /* has= */ this.currentlyWith_,\n          /* wants= */ this.currentRoute_.payload);\n\n      await this.currentStep_.promise;\n      this.currentStep_ = null;\n\n      // If we are at the end of the route, we need to signal it and clear the\n      // route so that we will pick-up a new route next iteration.\n      if (this.currentlyAt_ == this.currentRoute_.node) {\n        this.currentRoute_.listeners.onEnd();\n        this.currentRoute_ = null;\n      }\n    } catch (error) {\n      if (error.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n        goog.asserts.assert(\n            this.currentRoute_.interruptible,\n            'Do not put abortable steps in non-interruptible routes!');\n        this.currentRoute_.listeners.onCancel();\n      } else {\n        // There was an error with this route, so we going to abandon it and\n        // resolve the error. We don't reset the payload because the payload may\n        // still contain useful information.\n        this.currentRoute_.listeners.onError(error);\n      }\n\n      // The route and step are done. Clear them before we handle the error or\n      // else we may attempt to abort |currrentStep_| when handling the error.\n      this.currentRoute_ = null;\n      this.currentStep_ = null;\n\n      // Still need to handle error because aborting an operation could leave us\n      // in an unexpected state.\n      this.currentlyAt_ = await this.implementation_.handleError(\n          this.currentlyWith_,\n          error);\n    }\n  }\n\n  /**\n   * If the main loop is blocked waiting for new work, then resolve the promise\n   * so that the next iteration of the main loop can execute.\n   *\n   * @private\n   */\n  unblockMainLoop_() {\n    if (this.waitForWork_) {\n      this.waitForWork_.resolve();\n      this.waitForWork_ = null;\n    }\n  }\n};\n\n/**\n * @typedef {{\n *   getNext: function(\n *       shaka.routing.Node,\n *       shaka.routing.Payload,\n *       shaka.routing.Node,\n *       shaka.routing.Payload):shaka.routing.Node,\n *   enterNode: function(\n *       shaka.routing.Node,\n *       shaka.routing.Payload,\n *       shaka.routing.Payload):!shaka.util.AbortableOperation,\n *   handleError: function(\n *       shaka.routing.Payload,\n *       !Error):!Promise.<shaka.routing.Node>,\n *   onIdle: function(shaka.routing.Node)\n * }}\n *\n * @description\n *   There are some parts of the walker that will be per-instance. This type\n *   provides those per-instance parts.\n *\n * @property {function(\n *     shaka.routing.Node,\n *     shaka.routing.Payload,\n *     shaka.routing.Node,\n *     shaka.routing.Payload):shaka.routing.Node getNext\n *   Get the next node that the walker should move to. This method will be\n *   passed (in this order) the current node, current payload, destination\n *   node, and destination payload.\n *\n * @property {function(\n *     shaka.routing.Node,\n *     shaka.routing.Payload,\n *     shaka.routing.Payload):!Promise} enterNode\n *   When the walker moves into a node, it will call |enterNode| and allow the\n *   implementation to change the current payload. This method will be passed\n *   (in this order) the node the walker is entering, the current payload, and\n *   the destination payload. This method should NOT modify the destination\n *   payload.\n *\n * @property {function(\n *     shaka.routing.Payload,\n *     !Error):!Promise.<shaka.routing.Node> handleError\n *   This is the callback for when |enterNode| fails. It is passed the current\n *   payload and the error. If a step is aborted, the error will be\n *   OPERATION_ABORTED. It should reset all external dependences, modify the\n *   payload, and return the new current node. Calls to |handleError| should\n *   always resolve and the walker should always be able to continue operating.\n *\n * @property {function(shaka.routing.Node)} onIdle\n *   This is the callback for when the walker has finished processing all route\n *   requests and needs to wait for more work. |onIdle| will be passed the\n *   current node.  After |onIdle| has been called, the walker will block until\n *   a new request is made, or the walker is destroyed.\n */\nshaka.routing.Walker.Implementation;\n\n/**\n * @typedef {{\n *   onStart: function(),\n *   onEnd: function(),\n *   onCancel: function(),\n *   onError: function(!Error),\n *   onSkip: function(),\n *   onEnter: function(shaka.routing.Node)\n * }}\n *\n * @description\n *   The collection of callbacks that the walker will call while executing a\n *   route. By setting these immediately after calling |startNewRoute|\n *   the user can react to route-specific events.\n *\n * @property {function()} onStart\n *   The callback for when the walker has accepted the route and will soon take\n *   the first step unless interrupted. Either |onStart| or |onSkip| will be\n *   called.\n *\n * @property {function()} onEnd\n *   The callback for when the walker has reached the end of the route. For\n *   every route that had |onStart| called, either |onEnd|, |onCancel|, or\n *   |onError| will be called.\n *\n * @property {function()} onCancel\n *   The callback for when the walker is stopping a route before getting to the\n *   end. This will be called either when a new route is interrupting the route,\n *   or the walker is being destroyed mid-route. |onCancel| will only be called\n *   when a route has been interrupted by another route or the walker is being\n *   destroyed.\n *\n * @property {function()} onError\n *   The callback for when the walker failed to execute the route because an\n *   unexpected error occurred. The walker will enter a recovery mode and the\n *   route will be abandoned.\n *\n * @property {function()} onSkip\n *   The callback for when the walker was ready to start the route, but the\n *   create-method returned |null|.\n *\n * @property {function()} onEnter\n *   The callback for when the walker enters a node. This will allow us to\n *   track the progress of the walker within a per-route scope.\n */\nshaka.routing.Walker.Listeners;\n\n/**\n * @typedef {{\n *   node: shaka.routing.Node,\n *   payload: shaka.routing.Payload,\n *   interruptible: boolean\n * }}\n *\n * @description\n *   The public description of where the walker should go. This is created\n *   when the callback given to |startNewRoute| is called by the walker.\n *\n * @property {shaka.routing.Node} node\n *   The node that the walker should move towards. This will be passed to\n *   |shaka.routing.Walker.Implementation.getNext| to help determine where to\n *   go next.\n *\n * @property {shaka.routing.Payload| payload\n *   The payload that the walker should have once it arrives at |node|. This\n *   will be passed to the |shaka.routing.Walker.Implementation.getNext| to\n *   help determine where to go next.\n *\n * @property {boolean} interruptible\n *   Whether or not this route can be interrupted by another request. When\n *   |true| this route will be interrupted so that a pending request can be\n *   resolved. When |false|, the route will be allowed to finished before\n *   resolving the next request.\n */\nshaka.routing.Walker.Route;\n\n/**\n * @typedef {{\n *   node: shaka.routing.Node,\n *   payload: shaka.routing.Payload,\n *   interruptible: boolean,\n *   listeners: shaka.routing.Walker.Listeners\n * }}\n *\n * @description\n *   The active route is the walker's internal representation of a route. It\n *   is the union of |shaka.routing.Walker.Request_| and the\n *   |shaka.routing.Walker.Route| created by |shaka.routing.Walker.Request_|.\n *\n * @property {shaka.routing.Node} node\n *   The node that the walker should move towards. This will be passed to\n *   |shaka.routing.Walker.Implementation.getNext| to help determine where to\n *   go next.\n *\n * @property {shaka.routing.Payload| payload\n *   The payload that the walker should have once it arrives at |node|. This\n *   will be passed to the |shaka.routing.Walker.Implementation.getNext| to\n *   help determine where to go next.\n *\n * @property {boolean} interruptible\n *   Whether or not this route can be interrupted by another request. When\n *   |true| this route will be interrupted so that a pending request can be\n *   resolved. When |false|, the route will be allowed to finished before\n *   resolving the next request.\n *\n * @property {shaka.routing.Walker.Listeners} listeners\n *   The listeners that the walker can used to communicate with whoever\n *   requested the route.\n *\n * @private\n */\nshaka.routing.Walker.ActiveRoute_;\n\n/**\n * @typedef {{\n *   create: function(shaka.routing.Payload):?shaka.routing.Walker.Route,\n *   listeners: shaka.routing.Walker.Listeners\n * }}\n *\n * @description\n *   The request is how users can talk to the walker. They can give the walker\n *   a request and when the walker is ready, it will resolve the request by\n *   calling |create|.\n *\n * @property {\n *     function(shaka.routing.Payload):?shaka.routing.Walker.Route} create\n *   The function called when the walker is ready to start a new route. This can\n *   return |null| to say that the request was not possible and should be\n *   skipped.\n *\n * @property {shaka.routing.Walker.Listeners} listeners\n *   The collection of callbacks that the walker will use to talk to whoever\n *   provided the request.\n *\n * @private\n */\nshaka.routing.Walker.Request_;\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.Player');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Deprecate');\ngoog.require('shaka.log');\ngoog.require('shaka.media.ActiveStreamMap');\ngoog.require('shaka.media.AdaptationSetCriteria');\ngoog.require('shaka.media.BufferingObserver');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.media.MediaSourceEngine');\ngoog.require('shaka.media.MuxJSClosedCaptionParser');\ngoog.require('shaka.media.NoopCaptionParser');\ngoog.require('shaka.media.PeriodObserver');\ngoog.require('shaka.media.PlayRateController');\ngoog.require('shaka.media.Playhead');\ngoog.require('shaka.media.PlayheadObserverManager');\ngoog.require('shaka.media.PreferenceBasedCriteria');\ngoog.require('shaka.media.RegionObserver');\ngoog.require('shaka.media.RegionTimeline');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.media.StreamingEngine');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.routing.Walker');\ngoog.require('shaka.text.SimpleTextDisplayer');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.MultiMap');\ngoog.require('shaka.util.Periods');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.PlayerConfiguration');\ngoog.require('shaka.util.Stats');\ngoog.require('shaka.util.StreamUtils');\n\n\n/**\n * Construct a Player.\n *\n * @param {HTMLMediaElement=} mediaElement\n *    When provided, the player will attach to |mediaElement|, similar to\n *    calling |attach|. When not provided, the player will remain detached.\n * @param {function(shaka.Player)=} dependencyInjector Optional callback\n *   which is called to inject mocks into the Player.  Used for testing.\n *\n * @constructor\n * @struct\n * @implements {shaka.util.IDestroyable}\n * @extends {shaka.util.FakeEventTarget}\n * @export\n */\nshaka.Player = function(mediaElement, dependencyInjector) {\n  shaka.util.FakeEventTarget.call(this);\n\n  /** @private {shaka.Player.LoadMode} */\n  this.loadMode_ = shaka.Player.LoadMode.NOT_LOADED;\n\n  /** @private {HTMLMediaElement} */\n  this.video_ = null;\n\n  /**\n   * Since we may not always have a text displayer created (e.g. before |load|\n   * is called), we need to track what text visibility SHOULD be so that we can\n   * ensure that when we create the text displayer. When we create our text\n   * displayer, we will use this to show (or not show) text as per the user's\n   * requests.\n   *\n   * @private {boolean}\n   */\n  this.isTextVisible_ = false;\n\n  /** @private {shaka.util.EventManager} */\n  this.eventManager_ = new shaka.util.EventManager();\n\n  /** @private {shaka.net.NetworkingEngine} */\n  this.networkingEngine_ = null;\n\n  /** @private {shaka.media.DrmEngine} */\n  this.drmEngine_ = null;\n\n  /** @private {shaka.media.MediaSourceEngine} */\n  this.mediaSourceEngine_ = null;\n\n  /** @private {shaka.media.Playhead} */\n  this.playhead_ = null;\n\n  /**\n   * The playhead observers are used to monitor the position of the playhead and\n   * some other source of data (e.g. buffered content), and raise events.\n   *\n   * @private {shaka.media.PlayheadObserverManager}\n   */\n  this.playheadObservers_ = null;\n\n  /**\n   * This is our control over the playback rate of the media element. This\n   * provides the missing functionality that we need to provide trick play, for\n   * example a negative playback rate.\n   *\n   * @private {shaka.media.PlayRateController}\n   */\n  this.playRateController_ = null;\n\n  // We use the buffering observer and timer to track when we move from having\n  // enough buffered content to not enough. They only exist when content has\n  // been loaded and are not re-used between loads.\n  /** @private {shaka.util.Timer} */\n  this.bufferPoller_ = null;\n\n  /** @private {shaka.media.BufferingObserver} */\n  this.bufferObserver_ = null;\n\n  /** @private {shaka.media.RegionTimeline} */\n  this.regionTimeline_ = null;\n\n  /** @private {shaka.media.StreamingEngine} */\n  this.streamingEngine_ = null;\n\n  /** @private {shaka.extern.ManifestParser} */\n  this.parser_ = null;\n\n  /** @private {?shaka.extern.Manifest} */\n  this.manifest_ = null;\n\n  /** @private {?string} */\n  this.assetUri_ = null;\n\n  /** @private {shaka.extern.AbrManager} */\n  this.abrManager_ = null;\n\n  /**\n   * The factory that was used to create the abrManager_ instance.\n   * @private {?shaka.extern.AbrManager.Factory}\n   */\n  this.abrManagerFactory_ = null;\n\n  /**\n   * Contains an ID for use with creating streams.  The manifest parser should\n   * start with small IDs, so this starts with a large one.\n   * @private {number}\n   */\n  this.nextExternalStreamId_ = 1e9;\n\n  /** @private {!Set.<shaka.extern.Stream>} */\n  this.loadingTextStreams_ = new Set();\n\n  /** @private {boolean} */\n  this.switchingPeriods_ = true;\n\n  /** @private {?shaka.extern.Variant} */\n  this.deferredVariant_ = null;\n\n  /** @private {boolean} */\n  this.deferredVariantClearBuffer_ = false;\n\n  /** @private {number} */\n  this.deferredVariantClearBufferSafeMargin_ = 0;\n\n  /** @private {?shaka.extern.Stream} */\n  this.deferredTextStream_ = null;\n\n  /**\n   * A mapping of which streams are/were active in each period. Used when the\n   * current period (the one containing playhead) differs from the active\n   * period (the one being streamed in by streaming engine).\n   *\n   * @private {!shaka.media.ActiveStreamMap}\n   */\n  this.activeStreams_ = new shaka.media.ActiveStreamMap();\n\n  /** @private {?shaka.extern.PlayerConfiguration} */\n  this.config_ = this.defaultConfig_();\n\n  /**\n   * The TextDisplayerFactory that was last used to make a text displayer.\n   * Stored so that we can tell if a new type of text displayer is desired.\n   * @private {?shaka.extern.TextDisplayer.Factory}\n   */\n  this.lastTextFactory_;\n\n  /** @private {{width: number, height: number}} */\n  this.maxHwRes_ = {width: Infinity, height: Infinity};\n\n  /** @private {shaka.util.Stats} */\n  this.stats_ = null;\n\n  /** @private {!shaka.media.AdaptationSetCriteria} */\n  this.currentAdaptationSetCriteria_ = new shaka.media.PreferenceBasedCriteria(\n      this.config_.preferredAudioLanguage,\n      this.config_.preferredVariantRole,\n      this.config_.preferredAudioChannelCount);\n\n  /** @private {string} */\n  this.currentTextLanguage_ = this.config_.preferredTextLanguage;\n\n  /** @private {string} */\n  this.currentTextRole_ = this.config_.preferredTextRole;\n\n  if (dependencyInjector) {\n    dependencyInjector(this);\n  }\n\n  this.networkingEngine_ = this.createNetworkingEngine();\n\n  // If the browser comes back online after being offline, then try to play\n  // again.\n  this.eventManager_.listen(window, 'online', () => {\n    this.retryStreaming();\n  });\n\n  /** @private {shaka.routing.Node} */\n  this.detachNode_ = {name: 'detach'};\n  /** @private {shaka.routing.Node} */\n  this.attachNode_ = {name: 'attach'};\n  /** @private {shaka.routing.Node} */\n  this.unloadNode_ = {name: 'unload'};\n  /** @private {shaka.routing.Node} */\n  this.parserNode_ = {name: 'manifest-parser'};\n  /** @private {shaka.routing.Node} */\n  this.manifestNode_ = {name: 'manifest'};\n  /** @private {shaka.routing.Node} */\n  this.mediaSourceNode_ = {name: 'media-source'};\n  /** @private {shaka.routing.Node} */\n  this.drmNode_ = {name: 'drm-engine'};\n  /** @private {shaka.routing.Node} */\n  this.loadNode_ = {name: 'load'};\n  /** @private {shaka.routing.Node} */\n  this.srcEqualsDrmNode_ = {name: 'src-equals-drm-engine'};\n  /** @private {shaka.routing.Node} */\n  this.srcEqualsNode_ = {name: 'src-equals'};\n\n  const AbortableOperation = shaka.util.AbortableOperation;\n\n  const actions = new Map();\n  actions.set(this.attachNode_, (has, wants) => {\n    return AbortableOperation.notAbortable(this.onAttach_(has, wants));\n  });\n  actions.set(this.detachNode_, (has, wants) => {\n    return AbortableOperation.notAbortable(this.onDetach_(has, wants));\n  });\n  actions.set(this.unloadNode_, (has, wants) => {\n    return AbortableOperation.notAbortable(this.onUnload_(has, wants));\n  });\n  actions.set(this.mediaSourceNode_, (has, wants) => {\n    const p = this.onInitializeMediaSourceEngine_(has, wants);\n    return AbortableOperation.notAbortable(p);\n  });\n  actions.set(this.parserNode_, (has, wants) => {\n    const p = this.onInitializeParser_(has, wants);\n    return AbortableOperation.notAbortable(p);\n  });\n  actions.set(this.manifestNode_, (has, wants) => {\n    // This action is actually abortable, so unlike the other callbacks, this\n    // one will return an abortable operation.\n    return this.onParseManifest_(has, wants);\n  });\n  actions.set(this.drmNode_, (has, wants) => {\n    const p = this.onInitializeDrm_(has, wants);\n    return AbortableOperation.notAbortable(p);\n  });\n  actions.set(this.loadNode_, (has, wants) => {\n    return AbortableOperation.notAbortable(this.onLoad_(has, wants));\n  });\n\n  actions.set(this.srcEqualsDrmNode_, (has, wants) => {\n    const p = this.onInitializeSrcEqualsDrm_(has, wants);\n    return AbortableOperation.notAbortable(p);\n  });\n  actions.set(this.srcEqualsNode_, (has, wants) => {\n    return this.onSrcEquals_(has, wants);\n  });\n\n  /** @private {shaka.routing.Walker.Implementation} */\n  const walkerImplementation = {\n    getNext: (at, has, goingTo, wants) => {\n      return this.getNextStep_(at, has, goingTo, wants);\n    },\n    enterNode: (node, has, wants) => {\n      this.dispatchEvent(new shaka.util.FakeEvent(\n          /* name= */ 'onstatechange',\n          /* data= */ {'state': node.name}));\n\n      const action = actions.get(node);\n      return action(has, wants);\n    },\n    handleError: async (has, error) => {\n      shaka.log.warning('The walker saw an error:');\n      if (error instanceof shaka.util.Error) {\n        shaka.log.warning('Error Code:', error.code);\n      } else {\n        shaka.log.warning('Error Message:', error.message);\n        shaka.log.warning('Error Stack:', error.stack);\n      }\n\n      // Regardless of what state we were in, if there is an error, we unload.\n      // This ensures that any initialized system will be torn-down and we will\n      // go back to a safe foundation. We assume that the media element is\n      // always safe to use after an error.\n      await this.onUnload_(has, this.createEmptyPayload_());\n\n      // There are only two nodes that come before we start loading content,\n      // attach and detach. If we have a media element, it means we were\n      // attached to the element, and we can safely return to the attach state\n      // (we assume that the video element is always re-usable). We favor\n      // returning to the attach node since it means that the app won't need to\n      // re-attach if it saw an error.\n      return has.mediaElement ? this.attachNode_ : this.detachNode_;\n    },\n    onIdle: (node) => {\n      this.dispatchEvent(new shaka.util.FakeEvent(\n          /* name= */ 'onstateidle',\n          /* data= */ {'state': node.name}));\n    },\n  };\n\n  /** @private {shaka.routing.Walker} */\n  this.walker_ = new shaka.routing.Walker(\n      this.detachNode_,\n      this.createEmptyPayload_(),\n      walkerImplementation);\n\n  // Even though |attach| will start in later interpreter cycles, it should be\n  // the LAST thing we do in the constructor because conceptually it relies on\n  // player having been initialized.\n  if (mediaElement) {\n    this.attach(mediaElement, /* initializeMediaSource= */ true);\n  }\n};\n\ngoog.inherits(shaka.Player, shaka.util.FakeEventTarget);\n\n\n/**\n * After destruction, a Player object cannot be used again.\n *\n * @override\n * @export\n */\nshaka.Player.prototype.destroy = async function() {\n  // Make sure we only execute the destroy logic once.\n  if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n    return;\n  }\n\n  // Mark as \"dead\". This should stop external-facing calls from changing our\n  // internal state any more. This will stop calls to |attach|, |detach|, etc.\n  // from interrupting our final move to the detached state.\n  this.loadMode_ = shaka.Player.LoadMode.DESTROYED;\n\n  // Because we have set |loadMode_| to |DESTROYED| we can't call |detach|. We\n  // must talk to |this.walker_| directly.\n  const events = this.walker_.startNewRoute((currentPayload) => {\n    return {\n      node: this.detachNode_,\n      payload: this.createEmptyPayload_(),\n      interruptible: false,\n    };\n  });\n\n  // Wait until the detach has finished so that we don't interrupt it by\n  // calling |destroy| on |this.walker_|. To avoid failing here, we always\n  // resolve the promise.\n  await new Promise((resolve) => {\n    events.onStart = () => {\n      shaka.log.info('Preparing to destroy walker...');\n    };\n    events.onEnd = () => {\n      resolve();\n    };\n    events.onCancel = () => {\n      goog.asserts.assert(false,\n                          'Our final detach call should never be cancelled.');\n      resolve();\n    };\n    events.onError = () => {\n      goog.asserts.assert(false,\n                          'Our final detach call should never see an error');\n      resolve();\n    };\n    events.onSkip = () => {\n      goog.asserts.assert(false,\n                          'Our final detach call should never be skipped');\n      resolve();\n    };\n  });\n  await this.walker_.destroy();\n\n  // Tear-down the event manager to ensure messages stop moving around.\n  if (this.eventManager_) {\n    this.eventManager_.release();\n    this.eventManager_ = null;\n  }\n\n  this.abrManagerFactory_ = null;\n  this.abrManager_ = null;\n  this.config_ = null;\n\n  if (this.networkingEngine_) {\n    await this.networkingEngine_.destroy();\n    this.networkingEngine_ = null;\n  }\n};\n\n\n/**\n * @define {string} A version number taken from git at compile time.\n * @export\n */\nshaka.Player.version = 'v2.5.4-uncompiled';\n\n// Initialize the deprecation system using the version string we just set\n// on the player.\nshaka.Deprecate.init(shaka.Player.version);\n\n/**\n * @event shaka.Player.ErrorEvent\n * @description Fired when a playback error occurs.\n * @property {string} type\n *   'error'\n * @property {!shaka.util.Error} detail\n *   An object which contains details on the error.  The error's 'category' and\n *   'code' properties will identify the specific error that occurred.  In an\n *   uncompiled build, you can also use the 'message' and 'stack' properties\n *   to debug.\n * @exportDoc\n */\n\n/**\n * @event shaka.Player.StateChangeEvent\n * @description Fired when the player changes load states.\n * @property {string} type\n *    'onstatechange'\n * @property {string} state\n *    The name of the state that the player just entered.\n * @exportDoc\n */\n\n/**\n * @event shaka.Player.StateIdleEvent\n * @description Fired when the player has stopped changing states and will\n *    remain idle until a new state change request (e.g. load, attach, etc.) is\n *    made.\n * @property {string} type\n *    'onstateidle'\n * @property {string} state\n *    The name of the state that the player stopped in.\n * @exportDoc\n */\n\n/**\n * @event shaka.Player.EmsgEvent\n * @description Fired when a non-typical emsg is found in a segment.\n * @property {string} type\n *   'emsg'\n * @property {shaka.extern.EmsgInfo} detail\n *   An object which contains the content of the emsg box.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.DrmSessionUpdateEvent\n * @description Fired when the CDM has accepted the license response.\n * @property {string} type\n *   'drmsessionupdate'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TimelineRegionAddedEvent\n * @description Fired when a media timeline region is added.\n * @property {string} type\n *   'timelineregionadded'\n * @property {shaka.extern.TimelineRegionInfo} detail\n *   An object which contains a description of the region.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TimelineRegionEnterEvent\n * @description Fired when the playhead enters a timeline region.\n * @property {string} type\n *   'timelineregionenter'\n * @property {shaka.extern.TimelineRegionInfo} detail\n *   An object which contains a description of the region.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TimelineRegionExitEvent\n * @description Fired when the playhead exits a timeline region.\n * @property {string} type\n *   'timelineregionexit'\n * @property {shaka.extern.TimelineRegionInfo} detail\n *   An object which contains a description of the region.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.BufferingEvent\n * @description Fired when the player's buffering state changes.\n * @property {string} type\n *   'buffering'\n * @property {boolean} buffering\n *   True when the Player enters the buffering state.\n *   False when the Player leaves the buffering state.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.LoadingEvent\n * @description Fired when the player begins loading. The start of loading is\n *   defined as when the user has communicated intent to load content (i.e.\n *   Player.load has been called).\n * @property {string} type\n *   'loading'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.UnloadingEvent\n * @description Fired when the player unloads or fails to load.\n *   Used by the Cast receiver to determine idle state.\n * @property {string} type\n *   'unloading'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TextTrackVisibilityEvent\n * @description Fired when text track visibility changes.\n * @property {string} type\n *   'texttrackvisibility'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TracksChangedEvent\n * @description Fired when the list of tracks changes.  For example, this will\n *   happen when changing periods or when track restrictions change.\n * @property {string} type\n *   'trackschanged'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.AdaptationEvent\n * @description Fired when an automatic adaptation causes the active tracks\n *   to change.  Does not fire when the application calls selectVariantTrack()\n *   selectTextTrack(), selectAudioLanguage() or selectTextLanguage().\n * @property {string} type\n *   'adaptation'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.VariantChangedEvent\n * @description Fired when a call from the application caused a variant change.\n *  Can be triggered by calls to selectVariantTrack() or selectAudioLanguage().\n *  Does not fire when an automatic adaptation causes a variant change.\n * @property {string} type\n *   'variantchanged'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TextChangedEvent\n * @description Fired when a call from the application caused a text stream\n *  change. Can be triggered by calls to selectTextTrack() or\n *  selectTextLanguage().\n * @property {string} type\n *   'textchanged'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.ExpirationUpdatedEvent\n * @description Fired when there is a change in the expiration times of an\n *   EME session.\n * @property {string} type\n *   'expirationupdated'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.LargeGapEvent\n * @description Fired when the playhead enters a large gap.  If\n *   |config.streaming.jumpLargeGaps| is set, the default action of this event\n *   is to jump the gap; this can be prevented by calling preventDefault() on\n *   the event object.\n * @property {string} type\n *   'largegap'\n * @property {number} currentTime\n *   The current time of the playhead.\n * @property {number} gapSize\n *   The size of the gap, in seconds.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.ManifestParsedEvent\n * @description Fired after the manifest has been parsed, but before anything\n *   else happens. The manifest may contain streams that will be filtered out,\n *   at this stage of the loading process.\n * @property {string} type\n *   'manifestparsed'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.StreamingEvent\n * @description Fired after the manifest has been parsed and track information\n *   is available, but before streams have been chosen and before any segments\n *   have been fetched.  You may use this event to configure the player based on\n *   information found in the manifest.\n * @property {string} type\n *   'streaming'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.AbrStatusChangedEvent\n * @description Fired when the state of abr has been changed.\n *    (Enabled or disabled).\n * @property {string} type\n *   'abrstatuschanged'\n * @property {boolean} newStatus\n *  The new status of the application. True for 'is enabled' and\n *  false otherwise.\n * @exportDoc\n */\n\n\n/**\n * These are the EME key statuses that represent restricted playback.\n * 'usable', 'released', 'output-downscaled', 'status-pending' are statuses\n * of the usable keys.  'expired' status is being handled separately in\n * DrmEngine.\n *\n * @const {!Array.<string>}\n * @private\n */\nshaka.Player.restrictedStatuses_ = ['output-restricted', 'internal-error'];\n\n\n/** @private {!Object.<string, function():*>} */\nshaka.Player.supportPlugins_ = {};\n\n\n/**\n * Registers a plugin callback that will be called with support().  The\n * callback will return the value that will be stored in the return value from\n * support().\n *\n * @param {string} name\n * @param {function():*} callback\n * @export\n */\nshaka.Player.registerSupportPlugin = function(name, callback) {\n  shaka.Player.supportPlugins_[name] = callback;\n};\n\n\n/**\n * Return whether the browser provides basic support.  If this returns false,\n * Shaka Player cannot be used at all.  In this case, do not construct a Player\n * instance and do not use the library.\n *\n * @return {boolean}\n * @export\n */\nshaka.Player.isBrowserSupported = function() {\n  // Basic features needed for the library to be usable.\n  const basicSupport = !!window.Promise && !!window.Uint8Array &&\n                       !!Array.prototype.forEach;\n  if (!basicSupport) return false;\n\n  // DRM support is not strictly necessary, but the APIs at least need to be\n  // there.  Our no-op DRM polyfill should handle that.\n  // TODO(#1017): Consider making even DrmEngine optional.\n  const drmSupport = shaka.media.DrmEngine.isBrowserSupported();\n  if (!drmSupport) return false;\n\n  // If we have MediaSource (MSE) support, we should be able to use Shaka.\n  if (shaka.util.Platform.supportsMediaSource()) return true;\n\n  // If we don't have MSE, we _may_ be able to use Shaka.  Look for native HLS\n  // support, and call this platform usable if we have it.\n  return shaka.util.Platform.supportsMediaType('application/x-mpegurl');\n};\n\n\n/**\n * Probes the browser to determine what features are supported.  This makes a\n * number of requests to EME/MSE/etc which may result in user prompts.  This\n * should only be used for diagnostics.\n *\n * NOTE: This may show a request to the user for permission.\n *\n * @see https://bit.ly/2ywccmH\n * @return {!Promise.<shaka.extern.SupportType>}\n * @export\n */\nshaka.Player.probeSupport = function() {\n  goog.asserts.assert(shaka.Player.isBrowserSupported(),\n                      'Must have basic support');\n  return shaka.media.DrmEngine.probeSupport().then(function(drm) {\n    let manifest = shaka.media.ManifestParser.probeSupport();\n    let media = shaka.media.MediaSourceEngine.probeSupport();\n    let ret = {\n      manifest: manifest,\n      media: media,\n      drm: drm,\n    };\n\n    let plugins = shaka.Player.supportPlugins_;\n    for (let name in plugins) {\n      ret[name] = plugins[name]();\n    }\n\n    return ret;\n  });\n};\n\n\n/**\n * Tell the player to use |mediaElement| for all |load| requests until |detach|\n * or |destroy| are called.\n *\n * Calling |attach| with |initializedMediaSource=true| will tell the player to\n * take the initial load step and initialize media source.\n *\n * Calls to |attach| will interrupt any in-progress calls to |load| but cannot\n * interrupt calls to |attach|, |detach|, or |unload|.\n *\n * @param {!HTMLMediaElement} mediaElement\n * @param {boolean=} initializeMediaSource\n * @return {!Promise}\n * @export\n */\nshaka.Player.prototype.attach = function(mediaElement,\n                                         initializeMediaSource = true) {\n  // Do not allow the player to be used after |destroy| is called.\n  if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n    return Promise.reject(this.createAbortLoadError_());\n  }\n\n  const payload = this.createEmptyPayload_();\n  payload.mediaElement = mediaElement;\n\n  // If the platform does not support media source, we will never want to\n  // initialize media source.\n  if (!shaka.util.Platform.supportsMediaSource()) {\n    initializeMediaSource = false;\n  }\n\n  const destination = initializeMediaSource ?\n                      this.mediaSourceNode_ :\n                      this.attachNode_;\n\n  // Do not allow this route to be interrupted because calls after this attach\n  // call will depend on the media element being attached.\n  const events = this.walker_.startNewRoute((currentPayload) => {\n    return {\n      node: destination,\n      payload: payload,\n      interruptible: false,\n    };\n  });\n\n  // List to the events that can occur with our request.\n  events.onStart = () => shaka.log.info('Starting attach...');\n  return this.wrapWalkerListenersWithPromise_(events);\n};\n\n\n/**\n * Tell the player to stop using its current media element. If the player is:\n *  - detached, this will do nothing,\n *  - attached, this will release the media element,\n *  - loading, this will abort loading, unload, and release the media element,\n *  - playing content, this will stop playback, unload, and release the media\n *    element.\n *\n * Calls to |detach| will interrupt any in-progress calls to |load| but cannot\n * interrupt calls to |attach|, |detach|, or |unload|.\n *\n * @return {!Promise}\n * @export\n */\nshaka.Player.prototype.detach = function() {\n  // Do not allow the player to be used after |destroy| is called.\n  if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n    return Promise.reject(this.createAbortLoadError_());\n  }\n\n  // Tell the walker to go \"detached\", but do not allow it to be interrupted. If\n  // it could be interrupted it means that our media element could fall out\n  // of sync.\n  const events = this.walker_.startNewRoute((currentPayload) => {\n    return {\n      node: this.detachNode_,\n      payload: this.createEmptyPayload_(),\n      interruptible: false,\n    };\n  });\n\n  events.onStart = () => shaka.log.info('Starting detach...');\n  return this.wrapWalkerListenersWithPromise_(events);\n};\n\n\n/**\n * Tell the player to either return to:\n *   - detached (when it does not have a media element),\n *   - attached (when it has a media element and |initializedMediaSource=false|)\n *   - media source initialized (when it has a media element and\n *     |initializedMediaSource=true|)\n *\n * Calls to |unload| will interrupt any in-progress calls to |load| but cannot\n * interrupt calls to |attach|, |detach|, or |unload|.\n *\n * @param {boolean=} initializeMediaSource\n * @return {!Promise}\n * @export\n */\nshaka.Player.prototype.unload = function(initializeMediaSource = true) {\n  // Do not allow the player to be used after |destroy| is called.\n  if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n    return Promise.reject(this.createAbortLoadError_());\n  }\n\n  // If the platform does not support media source, we will never want to\n  // initialize media source.\n  if (!shaka.util.Platform.supportsMediaSource()) {\n    initializeMediaSource = false;\n  }\n\n  // Since we are going either to attached or detached (through unloaded), we\n  // can't allow it to be interrupted or else we could lose track of what\n  // media element we are suppose to use.\n  //\n  // Using the current payload, we can determine which node we want to go to.\n  // If we have a media element, we want to go back to attached. If we have no\n  // media element, we want to go back to detached.\n  const payload = this.createEmptyPayload_();\n\n  const events = this.walker_.startNewRoute((currentPayload) => {\n    // When someone calls |unload| we can either be before attached or detached\n    // (there is nothing stopping someone from calling |detach| when we are\n    // already detached).\n    //\n    // If we are attached to the correct element, we can tear down the previous\n    // playback components and go to the attached media source node depending\n    // on whether or not the caller wants to pre-init media source.\n    //\n    // If we don't have a media element, we assume that we are already at the\n    // detached node - but only the walker knows that. To ensure we are actually\n    // there, we tell the walker to go to detach. While this is technically\n    // unnecessary, it ensures that we are in the state we want to be in and\n    // ready for the next request.\n    let destination = null;\n\n    if (currentPayload.mediaElement && initializeMediaSource) {\n      destination = this.mediaSourceNode_;\n    } else if (currentPayload.mediaElement) {\n      destination = this.attachNode_;\n    } else {\n      destination = this.detachNode_;\n    }\n\n    goog.asserts.assert(destination, 'We should have picked a destination.');\n\n    // Copy over the media element because we want to keep using the same\n    // element - the other values don't matter.\n    payload.mediaElement = currentPayload.mediaElement;\n\n    return {\n      node: destination,\n      payload: payload,\n      interruptible: false,\n    };\n  });\n\n  events.onStart = () => shaka.log.info('Starting unload...');\n  return this.wrapWalkerListenersWithPromise_(events);\n};\n\n\n/**\n * Tell the player to load the content at |assetUri| and start playback at\n * |startTime|. Before calling |load|, a call to |attach| must have succeeded.\n *\n * Calls to |load| will interrupt any in-progress calls to |load| but cannot\n * interrupt calls to |attach|, |detach|, or |unload|.\n *\n * @param {string} assetUri\n * @param {?number=} startTime\n *    When |startTime| is |null| or |undefined|, playback will start at the\n *    default start time (startTime=0 for VOD and startTime=liveEdge for LIVE).\n * @param {string|shaka.extern.ManifestParser.Factory=} mimeType\n * @return {!Promise}\n * @export\n */\nshaka.Player.prototype.load = function(assetUri, startTime, mimeType) {\n  // Do not allow the player to be used after |destroy| is called.\n  if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n    return Promise.reject(this.createAbortLoadError_());\n  }\n\n  // We dispatch the loading event when someone calls |load| because we want to\n  // surface the user intent.\n  this.dispatchEvent(new shaka.util.FakeEvent('loading'));\n\n  // Right away we know what the asset uri and start-of-load time are. We will\n  // fill-in the rest of the information later.\n  const payload = this.createEmptyPayload_();\n  payload.uri = assetUri;\n  payload.startTimeOfLoad = Date.now() / 1000;\n\n  if (mimeType && typeof mimeType != 'string') {\n    shaka.Deprecate.deprecateFeature(\n        2, 6,\n        'Loading with a manifest parser factory',\n        'Please register a manifest parser and for the mime-type.');\n    const Factory =\n        /** @type {shaka.extern.ManifestParser.Factory} */ (mimeType);\n    payload.factory = () => new Factory();\n  }\n\n  if (mimeType && typeof mimeType == 'string') {\n    payload.mimeType = /** @type {string} */ (mimeType);\n  }\n\n  // Because we allow |startTime| to be optional, it means that it will be\n  // |undefined| when not provided. This means that we need to re-map\n  // |undefined| to |null| while preserving |0| as a meaningful value.\n  if (startTime !== undefined) {\n    payload.startTime = startTime;\n  }\n\n  // TODO: Refactor to determine whether it's a manifest or not, and whether or\n  // not we can play it.  Then we could return a better error than\n  // UNABLE_TO_GUESS_MANIFEST_TYPE for WebM in Safari.\n  const useSrcEquals = this.shouldUseSrcEquals_(payload);\n  const destination = useSrcEquals ? this.srcEqualsNode_ : this.loadNode_;\n\n  // Allow this request to be interrupted, this will allow other requests to\n  // cancel a load and quickly start a new load.\n  const events = this.walker_.startNewRoute((currentPayload) => {\n    if (currentPayload.mediaElement == null) {\n      // Because we return null, this \"new route\" will not be used.\n      return null;\n    }\n\n    // Keep using whatever media element we have right now.\n    payload.mediaElement = currentPayload.mediaElement;\n\n    return {\n      node: destination,\n      payload: payload,\n      interruptible: true,\n    };\n  });\n\n  // Load's request is a little different, so we can't use our normal\n  // listeners-to-promise method. It is the only request where we may skip the\n  // request, so we need to set the on skip callback to reject with a specific\n  // error.\n  events.onStart = () => shaka.log.info('Starting load of ' + assetUri + '...');\n  return new Promise((resolve, reject) => {\n    events.onSkip = () => reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.NO_VIDEO_ELEMENT));\n\n    events.onEnd = () => resolve();\n    events.onCancel = () => reject(this.createAbortLoadError_());\n    events.onError = (e) => reject(e);\n  });\n};\n\n\n/**\n * Check if src= should be used to load the asset at |uri|. Assume that media\n * source is the default option, and that src= is for special cases.\n *\n * @param {shaka.routing.Payload} payload\n * @return {boolean}\n *    |true| if the content should be loaded with src=, |false| if the content\n *    should be loaded with MediaSource.\n * @private\n */\nshaka.Player.prototype.shouldUseSrcEquals_ = function(payload) {\n  const Platform = shaka.util.Platform;\n\n  // If an explicit ManifestParser factory has been given, we can't do src=.\n  if (payload.factory) {\n    return false;\n  }\n\n  // If we are using a platform that does not support media source, we will\n  // fall back to src= to handle all playback.\n  if (!Platform.supportsMediaSource()) {\n    return true;\n  }\n\n  // The most accurate way to tell the player how to load the content is via\n  // MIME type.  We can fall back to features of the URI if needed.\n  let mimeType = payload.mimeType;\n  const uri = payload.uri || '';\n\n  // If we don't have a MIME type, try to guess based on the file extension.\n  // TODO: Too generic to belong to ManifestParser now.  Refactor.\n  if (!mimeType) {\n    // Try using the uri extension.\n    const extension = shaka.media.ManifestParser.getExtension(uri);\n    mimeType = {\n      'mp4': 'video/mp4',\n      'm4v': 'video/mp4',\n      'm4a': 'audio/mp4',\n      'webm': 'video/webm',\n      'ts': 'video/mp2t',\n      'm3u8': 'application/x-mpegurl',\n      'mp3': 'audio/mpeg',\n      'aac': 'audio/aac',\n      'flac': 'audio/flac',\n    }[extension];\n  }\n\n  // TODO: The load graph system has a design limitation that requires routing\n  // destination to be chosen synchronously.  This means we can only make the\n  // right choice about src= consistently if we have a well-known file extension\n  // or API-provided MIME type.  Detection of MIME type from a HEAD request (as\n  // is done for manifest types) can't be done yet.\n\n  if (mimeType) {\n    // If we have a MIME type, check if the browser can play it natively.\n    // This will cover both single files and native HLS.\n    const canPlayNatively = Platform.supportsMediaType(mimeType);\n\n    // If we can't play natively, then src= isn't an option.\n    if (!canPlayNatively) {\n      return false;\n    }\n\n    const canPlayMediaSource =\n        shaka.media.ManifestParser.isSupported(uri, mimeType);\n\n    // If MediaSource isn't an option, the native option is our only chance.\n    if (!canPlayMediaSource) {\n      return true;\n    }\n\n    // If we land here, both are feasible.\n    goog.asserts.assert(canPlayNatively && canPlayMediaSource,\n                        'Both native and MSE playback should be possible!');\n\n    // We would prefer MediaSource in some cases, and src= in others.  For\n    // example, Android has native HLS, but we'd prefer our own MediaSource\n    // version there.  But for Safari desktop, we'd prefer the native one for\n    // now, because that's the only way we get FairPlay there.  So use src= over\n    // MSE on any Apple platform.\n    return Platform.isApple();\n  }\n\n  // Unless there are good reasons to use src= (single-file playback or native\n  // HLS), we prefer MediaSource.  So the final return value for choosing src=\n  // is false.\n  return false;\n};\n\n/**\n * This should only be called by the load graph when it is time to attach to\n * a media element. The only times this may be called are when we are being\n * asked to re-attach to the current media element, or attach to a new media\n * element while not attached to a media element.\n *\n * This method assumes that it is safe for it to execute, the load-graph is\n * responsible for ensuring all assumptions are true.\n *\n * Attaching to a media element is defined as:\n *  - Registering error listeners to the media element.\n *  - Caching the video element for use outside of the load graph.\n *\n * @param {shaka.routing.Payload} has\n * @param {shaka.routing.Payload} wants\n * @return {!Promise}\n * @private\n */\nshaka.Player.prototype.onAttach_ = function(has, wants) {\n  // If we don't have a media element yet, it means we are entering\n  // \"attach\" from another node.\n  //\n  // If we have a media element, it should match |wants.mediaElement|\n  // because it means we are going from \"attach\" to \"attach\".\n  //\n  // These constraints should be maintained and guaranteed by the routing\n  // logic in |getNextStep_|.\n  goog.asserts.assert(\n      has.mediaElement == null || has.mediaElement == wants.mediaElement,\n      'The routing logic failed. MediaElement requirement failed.');\n\n  if (has.mediaElement == null) {\n    has.mediaElement = wants.mediaElement;\n\n    const onError = (error) => this.onVideoError_(error);\n    this.eventManager_.listen(has.mediaElement, 'error', onError);\n  }\n\n  this.video_ = has.mediaElement;\n\n  return Promise.resolve();\n};\n\n/**\n * This should only be called by the load graph when it is time to detach from\n * a media element. The only times this may be called are when we are being\n * asked to detach from the current media element, or detach when we are already\n * detached.\n *\n * This method assumes that it is safe for it to execute, the load-graph is\n * responsible for ensuring all assumptions are true.\n *\n * Detaching from a media element is defined as:\n *  - Removing error listeners from the media element.\n *  - Dropping the cached reference to the video element.\n *\n * @param {shaka.routing.Payload} has\n * @param {shaka.routing.Payload} wants\n * @return {!Promise}\n * @private\n */\nshaka.Player.prototype.onDetach_ = function(has, wants) {\n  // If we are going from \"detached\" to \"detached\" we wouldn't have\n  // a media element to detach from.\n  if (has.mediaElement) {\n    this.eventManager_.unlisten(has.mediaElement, 'error');\n    has.mediaElement = null;\n  }\n\n  // Clear our cached copy of the media element.\n  this.video_ = null;\n\n  return Promise.resolve();\n};\n\n\n/**\n * This should only be called by the load graph when it is time to unload all\n * currently initialized playback components. Unlike the other load actions,\n * this action is built to be more general. We need to do this because we don't\n * know what state the player will be in before unloading (including after an\n * error occurred in the middle of a transition).\n *\n * This method assumes that any component could be |null| and should be safe to\n * call from any point in the load graph.\n *\n * @param {shaka.routing.Payload} has\n * @param {shaka.routing.Payload} wants\n * @return {!Promise}\n * @private\n */\nshaka.Player.prototype.onUnload_ = async function(has, wants) {\n  // Set the load mode to unload right away so that all the public methods will\n  // stop using the internal components. We need to make sure that we are not\n  // overriding the destroyed state because we will unload when we are\n  // destroying the player.\n  if (this.loadMode_ != shaka.Player.LoadMode.DESTROYED) {\n    this.loadMode_ = shaka.Player.LoadMode.NOT_LOADED;\n  }\n\n  this.dispatchEvent(new shaka.util.FakeEvent('unloading'));\n\n  // Remove everything that has to do with loading content from our payload\n  // since we are releasing everything that depended on it.\n  has.factory = null;\n  has.mimeType = null;\n  has.startTime = null;\n  has.uri = null;\n\n  // In most cases we should have a media element. The one exception would\n  // be if there was an error and we, by chance, did not have a media element.\n  if (has.mediaElement) {\n    this.eventManager_.unlisten(has.mediaElement, 'loadeddata');\n    this.eventManager_.unlisten(has.mediaElement, 'playing');\n    this.eventManager_.unlisten(has.mediaElement, 'pause');\n    this.eventManager_.unlisten(has.mediaElement, 'ended');\n    this.eventManager_.unlisten(has.mediaElement, 'ratechange');\n  }\n\n  // Some observers use some playback components, shutting down the observers\n  // first ensures that they don't try to use the playback components\n  // mid-destroy.\n  if (this.playheadObservers_) {\n    this.playheadObservers_.release();\n    this.playheadObservers_ = null;\n  }\n\n  if (this.bufferPoller_) {\n    this.bufferPoller_.stop();\n    this.bufferPoller_ = null;\n  }\n\n  // Stop the parser early. Since it is at the start of the pipeline, it should\n  // be start early to avoid is pushing new data downstream.\n  if (this.parser_) {\n    await this.parser_.stop();\n    this.parser_ = null;\n  }\n\n  // Abr Manager will tell streaming engine what to do, so we need to stop\n  // it before we destroy streaming engine. Unlike with the other components,\n  // we do not release the instance, we will reuse it in later loads.\n  if (this.abrManager_) {\n    await this.abrManager_.stop();\n  }\n\n  // Streaming engine will push new data to media source engine, so we need\n  // to shut it down before destroy media source engine.\n  if (this.streamingEngine_) {\n    await this.streamingEngine_.destroy();\n    this.streamingEngine_ = null;\n  }\n\n  // Playhead is used by StreamingEngine, so we can't destroy this until after\n  // StreamingEngine has stopped.\n  if (this.playhead_) {\n    this.playhead_.release();\n    this.playhead_ = null;\n  }\n\n  // Media source engine holds onto the media element, and in order to detach\n  // the media keys (with drm engine), we need to break the connection between\n  // media source engine and the media element.\n  if (this.mediaSourceEngine_) {\n    await this.mediaSourceEngine_.destroy();\n    this.mediaSourceEngine_ = null;\n  }\n\n  // In order to unload a media element, we need to remove the src attribute and\n  // and then load again. When we destroy media source engine, this will be done\n  // for us, but for src=, we need to do it here.\n  //\n  // DrmEngine requires this to be done before we destroy DrmEngine itself.\n  if (has.mediaElement && has.mediaElement.src) {\n    has.mediaElement.removeAttribute('src');\n    has.mediaElement.load();\n  }\n\n  if (this.drmEngine_) {\n    await this.drmEngine_.destroy();\n    this.drmEngine_ = null;\n  }\n\n  this.activeStreams_.clear();\n  this.assetUri_ = null;\n  this.bufferObserver_ = null;\n  this.loadingTextStreams_.clear();\n  this.manifest_ = null;\n  this.stats_ = null;\n  this.lastTextFactory_ = null;\n  this.switchingPeriods_ = true;\n\n  // Make sure that the app knows of the new buffering state.\n  this.updateBufferState_();\n};\n\n\n/**\n * This should only be called by the load graph when it is time to initialize\n * media source engine. The only time this may be called is when we are attached\n * to the same media element as in the request.\n *\n * This method assumes that it is safe for it to execute. The load-graph is\n * responsible for ensuring all assumptions are true.\n *\n * @param {shaka.routing.Payload} has\n * @param {shaka.routing.Payload} wants\n *\n * @return {!Promise}\n * @private\n */\nshaka.Player.prototype.onInitializeMediaSourceEngine_ = async function(\n    has, wants) {\n  goog.asserts.assert(\n      shaka.util.Platform.supportsMediaSource(),\n      'We should not be initializing media source on a platform that does ' +\n          'not support media source.');\n  goog.asserts.assert(\n      has.mediaElement,\n      'We should have a media element when initializing media source.');\n  goog.asserts.assert(\n      has.mediaElement == wants.mediaElement,\n      '|has| and |wants| should have the same media element when ' +\n          'initializing media source.');\n\n  goog.asserts.assert(\n      this.mediaSourceEngine_ == null,\n      'We should not have a media source engine yet.');\n\n  const closedCaptionsParser =\n      shaka.media.MuxJSClosedCaptionParser.isSupported() ?\n      new shaka.media.MuxJSClosedCaptionParser() :\n      new shaka.media.NoopCaptionParser();\n\n  // When changing text visibility we need to update both the text displayer\n  // and streaming engine because we don't always stream text. To ensure that\n  // text displayer and streaming engine are always in sync, wait until they are\n  // both initialized before setting the initial value.\n  const TextDisplayerFactory = this.config_.textDisplayFactory;\n  const textDisplayer = new TextDisplayerFactory();\n  this.lastTextFactory_ = TextDisplayerFactory;\n\n  const mediaSourceEngine = this.createMediaSourceEngine(\n      has.mediaElement, closedCaptionsParser, textDisplayer);\n\n  // Wait for media source engine to finish opening. This promise should\n  // NEVER be rejected as per the media source engine implementation.\n  await mediaSourceEngine.open();\n\n  // Wait until it is ready to actually store the reference.\n  this.mediaSourceEngine_ = mediaSourceEngine;\n};\n\n\n/**\n * Create the parser for the asset located at |wants.uri|. This should only be\n * called as part of the load graph.\n *\n * This method assumes that it is safe for it to execute, the load-graph is\n * responsible for ensuring all assumptions are true.\n *\n * @param {shaka.routing.Payload} has\n * @param {shaka.routing.Payload} wants\n * @return {!Promise}\n * @private\n */\nshaka.Player.prototype.onInitializeParser_ = async function(has, wants) {\n  goog.asserts.assert(\n      has.mediaElement,\n      'We should have a media element when initializing the parser.');\n  goog.asserts.assert(\n      has.mediaElement == wants.mediaElement,\n      '|has| and |wants| should have the same media element when ' +\n          'initializing the parser.');\n\n  goog.asserts.assert(\n      this.networkingEngine_,\n      'Need networking engine when initializing the parser.');\n  goog.asserts.assert(\n       this.config_,\n      'Need player config when initializing the parser.');\n\n  // We are going to \"lock-in\" the factory, mime type, and uri since they are\n  // what we are going to use to create our parser and parse the manifest.\n  has.factory = wants.factory;\n  has.mimeType = wants.mimeType;\n  has.uri = wants.uri;\n\n  goog.asserts.assert(\n      has.uri,\n      'We should have an asset uri when initializing the parsing.');\n\n  // Store references to things we asserted so that we don't need to reassert\n  // them again later.\n  const assetUri = has.uri;\n  const networkingEngine = this.networkingEngine_;\n\n  // Save the uri so that it can be used outside of the load-graph.\n  this.assetUri_ = assetUri;\n\n  // Create the parser that we will use to parse the manifest.\n  if (has.factory) {\n    this.parser_ = has.factory();\n  } else {\n    this.parser_ = await shaka.media.ManifestParser.create(\n        assetUri,\n        networkingEngine,\n        this.config_.manifest.retryParameters,\n        has.mimeType);\n  }\n\n  this.parser_.configure(this.config_.manifest);\n};\n\n\n/**\n * Parse the manifest at |has.uri| using the parser that should have already\n * been created. This should only be called as part of the load graph.\n *\n * This method assumes that it is safe for it to execute, the load-graph is\n * responsible for ensuring all assumptions are true.\n *\n * @param {shaka.routing.Payload} has\n * @param {shaka.routing.Payload} wants\n * @return {!shaka.util.AbortableOperation}\n * @private\n */\nshaka.Player.prototype.onParseManifest_ = function(has, wants) {\n  goog.asserts.assert(\n      has.factory == wants.factory,\n      '|has| and |wants| should have the same factory when parsing.');\n  goog.asserts.assert(\n      has.mimeType == wants.mimeType,\n      '|has| and |wants| should have the same mime type when parsing.');\n  goog.asserts.assert(\n      has.uri == wants.uri,\n      '|has| and |wants| should have the same uri when parsing.');\n\n  goog.asserts.assert(\n      has.uri,\n      '|has| should have a valid uri when parsing.');\n  goog.asserts.assert(\n      has.uri == this.assetUri_,\n      '|has.uri| should match the cached asset uri.');\n\n  goog.asserts.assert(\n      this.networkingEngine_,\n      'Need networking engine to parse manifest.');\n  goog.asserts.assert(\n       this.config_,\n      'Need player config to parse manifest.');\n\n  goog.asserts.assert(\n      this.parser_,\n      '|this.parser_| should have been set in an earlier step.');\n\n  // Store references to things we asserted so that we don't need to reassert\n  // them again later.\n  const assetUri = has.uri;\n  const networkingEngine = this.networkingEngine_;\n\n  // This will be needed by the parser once it starts parsing, so we will\n  // initialize it now even through it appears a little out-of-place.\n  this.regionTimeline_ = new shaka.media.RegionTimeline();\n  this.regionTimeline_.setListeners(/* onRegionAdded */ (region) => {\n    this.onRegionEvent_('timelineregionadded', region);\n  });\n\n  const playerInterface = {\n    networkingEngine: networkingEngine,\n    filterNewPeriod: (period) => this.filterNewPeriod_(period),\n    filterAllPeriods: (periods) => this.filterAllPeriods_(periods),\n\n    // Called when the parser finds a timeline region. This can be called\n    // before we start playback or during playback (live/in-progress manifest).\n    onTimelineRegionAdded: (region) => this.regionTimeline_.addRegion(region),\n\n    onEvent: (event) => this.dispatchEvent(event),\n    onError: (error) => this.onError_(error),\n  };\n\n  return new shaka.util.AbortableOperation(\n      /* promise= */ Promise.resolve().then(async () => {\n        this.manifest_ = await this.parser_.start(assetUri, playerInterface);\n\n        // This event is fired after the manifest is parsed, but before any\n        // filtering takes place.\n        this.dispatchEvent(new shaka.util.FakeEvent('manifestparsed'));\n\n        // We require all manifests to have already one period.\n        if (this.manifest_.periods.length == 0) {\n          throw new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.MANIFEST,\n              shaka.util.Error.Code.NO_PERIODS);\n        }\n\n        // Make sure that all periods are either: audio-only, video-only, or\n        // audio-video.\n        shaka.Player.filterForAVVariants_(this.manifest_.periods);\n      }),\n      /* onAbort= */ () => {\n        shaka.log.info('Aborting parser step...');\n        return this.parser_.stop();\n      });\n};\n\n\n/**\n * This should only be called by the load graph when it is time to initialize\n * drmEngine. The only time this may be called is when we are attached a\n * media element and have parsed a manifest.\n *\n * The load-graph is responsible for ensuring all assumptions made by this\n * method are valid before executing it.\n *\n * @param {shaka.routing.Payload} has\n * @param {shaka.routing.Payload} wants\n * @return {!Promise}\n */\nshaka.Player.prototype.onInitializeDrm_ = async function(has, wants) {\n  goog.asserts.assert(\n      has.factory == wants.factory,\n      'The load graph should have ensured the factories matched.');\n  goog.asserts.assert(\n      has.mimeType == wants.mimeType,\n      'The load graph should have ensured the mime types matched.');\n  goog.asserts.assert(\n      has.uri == wants.uri,\n      'The load graph should have ensured the uris matched');\n\n  goog.asserts.assert(\n      this.networkingEngine_,\n      '|onInitializeDrm_| should never be called after |destroy|');\n  goog.asserts.assert(\n      this.config_,\n      '|onInitializeDrm_| should never be called after |destroy|');\n  goog.asserts.assert(\n      this.manifest_,\n      '|this.manifest_| should have been set in an earlier step.');\n\n  this.drmEngine_ = this.createDrmEngine({\n    netEngine: this.networkingEngine_,\n    onError: (e) => {\n      this.onError_(e);\n    },\n    onKeyStatus: (map) => {\n      this.onKeyStatus_(map);\n    },\n    onExpirationUpdated: (id, expiration) => {\n      this.onExpirationUpdated_(id, expiration);\n    },\n    onEvent: (e) => {\n      this.dispatchEvent(e);\n    },\n  });\n\n  this.drmEngine_.configure(this.config_.drm);\n\n  await this.drmEngine_.initForPlayback(\n      shaka.util.Periods.getAllVariantsFrom(this.manifest_.periods),\n      this.manifest_.offlineSessionIds);\n\n  // Now that we have drm information, filter the manifest (again) so that we\n  // can ensure we only use variants with the selected key system.\n  this.filterAllPeriods_(this.manifest_.periods);\n};\n\n/**\n * This should only be called by the load graph when it is time to load all\n * playback components needed for playback. The only times this may be called\n * is when we are attached to the same media element as in the request.\n *\n * This method assumes that it is safe for it to execute, the load-graph is\n * responsible for ensuring all assumptions are true.\n *\n * Loading is defined as:\n *  - Attaching all playback-related listeners to the media element\n *  - Initializing playback and observers\n *  - Initializing ABR Manager\n *  - Initializing Streaming Engine\n *  - Starting playback at |wants.startTime|\n *\n * @param {shaka.routing.Payload} has\n * @param {shaka.routing.Payload} wants\n * @private\n */\nshaka.Player.prototype.onLoad_ = async function(has, wants) {\n  goog.asserts.assert(\n      has.factory == wants.factory,\n      '|has| and |wants| should have the same factory when loading.');\n  goog.asserts.assert(\n      has.mimeType == wants.mimeType,\n      '|has| and |wants| should have the same mime type when loading.');\n  goog.asserts.assert(\n      has.uri == wants.uri,\n      '|has| and |wants| should have the same uri when loading.');\n\n  goog.asserts.assert(\n      has.mediaElement,\n      'We should have a media element when loading.');\n  goog.asserts.assert(\n      wants.startTimeOfLoad,\n      '|wants| should tell us when the load was originally requested');\n\n  // Since we are about to start playback, we will lock in the start time as\n  // something we are now depending on.\n  has.startTime = wants.startTime;\n\n  // Store a reference to values in |has| after asserting so that closure will\n  // know that they will still be non-null between calls to await.\n  const mediaElement = has.mediaElement;\n  const assetUri = has.uri;\n\n  // Save the uri so that it can be used outside of the load-graph.\n  this.assetUri_ = assetUri;\n\n  // Stats are for a single playback/load session. Stats must be initialized\n  // before we allow calls to |updateStateHistory|.\n  this.stats_ = new shaka.util.Stats();\n\n  const updateStateHistory = () => this.updateStateHistory_();\n  const onRateChange = () => this.onRateChange_();\n  this.eventManager_.listen(mediaElement, 'playing', updateStateHistory);\n  this.eventManager_.listen(mediaElement, 'pause', updateStateHistory);\n  this.eventManager_.listen(mediaElement, 'ended', updateStateHistory);\n  this.eventManager_.listen(mediaElement, 'ratechange', onRateChange);\n\n  const AbrManagerFactory = this.config_.abrFactory;\n  if (!this.abrManager_ || this.abrManagerFactory_ != AbrManagerFactory) {\n    this.abrManagerFactory_ = AbrManagerFactory;\n    this.abrManager_ = new AbrManagerFactory();\n    this.abrManager_.configure(this.config_.abr);\n  }\n\n  // TODO: When a manifest update adds a new period, that period's closed\n  // captions should also be turned into text streams. This should be called\n  // for each new period as well.\n  this.createTextStreamsForClosedCaptions_(this.manifest_.periods);\n\n  // Copy preferred languages from the config again, in case the config was\n  // changed between construction and playback.\n  this.currentAdaptationSetCriteria_ =\n      new shaka.media.PreferenceBasedCriteria(\n          this.config_.preferredAudioLanguage,\n          this.config_.preferredVariantRole,\n          this.config_.preferredAudioChannelCount);\n\n  this.currentTextLanguage_ = this.config_.preferredTextLanguage;\n\n  shaka.Player.applyPlayRange_(this.manifest_.presentationTimeline,\n                               this.config_.playRangeStart,\n                               this.config_.playRangeEnd);\n\n  await this.drmEngine_.attach(mediaElement);\n\n  this.abrManager_.init((variant, clearBuffer, safeMargin) => {\n    return this.switch_(variant, clearBuffer, safeMargin);\n  });\n\n  this.playhead_ = this.createPlayhead(has.startTime);\n  this.playheadObservers_ = this.createPlayheadObserversForMSE_();\n\n  this.playRateController_ = new shaka.media.PlayRateController({\n    getRate: () => has.mediaElement.playbackRate,\n    setRate: (rate) => { has.mediaElement.playbackRate = rate; },\n    movePlayhead: (delta) => { has.mediaElement.currentTime += delta; },\n  });\n\n  // We need to start the buffer management code near the end because it will\n  // set the initial buffering state and that depends on other components being\n  // initialized.\n  const rebufferThreshold = Math.max(\n      this.manifest_.minBufferTime, this.config_.streaming.rebufferingGoal);\n  this.startBufferManagement_(rebufferThreshold);\n\n  this.streamingEngine_ = this.createStreamingEngine();\n  this.streamingEngine_.configure(this.config_.streaming);\n\n  // If the content is multi-codec and the browser can play more than one of\n  // them, choose codecs now before we initialize streaming.\n  this.chooseCodecsAndFilterManifest_();\n\n  // Set the load mode to \"loaded with media source\" as late as possible so that\n  // public methods won't try to access internal components until they're all\n  // initialized. We MUST switch to loaded before calling \"streaming\" so that\n  // they can access internal information.\n  this.loadMode_ = shaka.Player.LoadMode.MEDIA_SOURCE;\n\n  // The event must be fired after we filter by restrictions but before the\n  // active stream is picked to allow those listening for the \"streaming\" event\n  // to make changes before streaming starts.\n  this.dispatchEvent(new shaka.util.FakeEvent('streaming'));\n\n  // Start streaming content. This will start the flow of content down to media\n  // source, including picking the initial streams to play.\n  await this.streamingEngine_.start();\n\n  // We MUST wait until after we create streaming engine to adjust the start\n  // time because we rely on the active audio and video streams, which are\n  // selected in |StreamingEngine.init|.\n  if (this.config_.streaming.startAtSegmentBoundary) {\n    const startTime = this.playhead_.getTime();\n    const adjustedTime = this.adjustStartTime_(startTime);\n\n    this.playhead_.setStartTime(adjustedTime);\n  }\n\n  // Re-filter the manifest after streams have been chosen.\n  this.manifest_.periods.forEach(this.filterNewPeriod_.bind(this));\n  // Dispatch a 'trackschanged' event now that all initial filtering is done.\n  this.onTracksChanged_();\n  // Since the first streams just became active, send an adaptation event.\n  this.onAdaptation_();\n\n  // Now that we've filtered out variants that aren't compatible with the\n  // active one, update abr manager with filtered variants for the current\n  // period.\n  /** @type {shaka.extern.Period} */\n  const currentPeriod = this.getPresentationPeriod_();\n  const hasPrimary = currentPeriod.variants.some((v) => v.primary);\n\n  if (!this.config_.preferredAudioLanguage && !hasPrimary) {\n    shaka.log.warning('No preferred audio language set.  We will choose an ' +\n                      'arbitrary language initially');\n  }\n\n  this.chooseVariant_(currentPeriod.variants);\n\n  // Wait for the 'loadeddata' event to measure load() latency.\n  this.eventManager_.listenOnce(mediaElement, 'loadeddata', () => {\n    const now = Date.now() / 1000;\n    const delta = now - wants.startTimeOfLoad;\n\n    this.stats_.setLoadLatency(delta);\n  });\n};\n\n\n/**\n * This should only be called by the load graph when it is time to initialize\n * drmEngine for src= playbacks.\n *\n * The load-graph is responsible for ensuring all assumptions made by this\n * method are valid before executing it.\n *\n * @param {shaka.routing.Payload} has\n * @param {shaka.routing.Payload} wants\n * @return {!Promise}\n */\nshaka.Player.prototype.onInitializeSrcEqualsDrm_ = async function(has, wants) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  goog.asserts.assert(\n      this.networkingEngine_,\n      '|onInitializeSrcEqualsDrm_| should never be called after |destroy|');\n  goog.asserts.assert(\n      this.config_,\n      '|onInitializeSrcEqualsDrm_| should never be called after |destroy|');\n\n  this.drmEngine_ = this.createDrmEngine({\n    netEngine: this.networkingEngine_,\n    onError: (e) => {\n      this.onError_(e);\n    },\n    onKeyStatus: (map) => {\n      this.onKeyStatus_(map);\n    },\n    onExpirationUpdated: (id, expiration) => {\n      this.onExpirationUpdated_(id, expiration);\n    },\n    onEvent: (e) => {\n      this.dispatchEvent(e);\n    },\n  });\n\n  this.drmEngine_.configure(this.config_.drm);\n\n  // TODO: Instead of feeding DrmEngine with Variants, we should refactor\n  // DrmEngine so that it takes a minimal config derived from Variants.  In\n  // cases like this one or in removal of stored content, the details are\n  // largely unimportant.  We should have a saner way to initialize DrmEngine.\n  // That would also insulate DrmEngine from manifest changes in the future.\n  // For now, that is time-consuming and this synthetic Variant is easy, so I'm\n  // putting it off.  Since this is only expected to be used for native HLS in\n  // Safari, this should be safe. -JCP\n  /** @type {shaka.extern.Variant} */\n  const variant = {\n    id: 0,\n    language: 'und',\n    primary: false,\n    audio: null,\n    video: {\n      id: 0,\n      originalId: null,\n      createSegmentIndex: Promise.resolve.bind(Promise),\n      findSegmentPosition: (time) => null,\n      getSegmentReference: (ref) => null,\n      initSegmentReference: null,\n      presentationTimeOffset: 0,\n      mimeType: 'video/mp4',\n      codecs: '',\n      encrypted: true,\n      keyId: null,\n      language: 'und',\n      label: null,\n      type: ContentType.VIDEO,\n      primary: false,\n      trickModeVideo: null,\n      emsgSchemeIdUris: null,\n      roles: [],\n      channelsCount: null,\n      closedCaptions: null,\n    },\n    bandwidth: 100,\n    drmInfos: [],  // Filled in by DrmEngine config.\n    allowedByApplication: true,\n    allowedByKeySystem: true,\n  };\n\n  await this.drmEngine_.initForPlayback([variant], /* offlineSessionIds= */ []);\n  await this.drmEngine_.attach(has.mediaElement);\n};\n\n/**\n * This should only be called by the load graph when it is time to set-up the\n * media element to play content using src=. The only times this may be called\n * is when we are attached to the same media element as in the request.\n *\n * This method assumes that it is safe for it to execute, the load-graph is\n * responsible for ensuring all assumptions are true.\n *\n * @param {shaka.routing.Payload} has\n * @param {shaka.routing.Payload} wants\n * @return {!shaka.util.AbortableOperation}\n *\n * @private\n */\nshaka.Player.prototype.onSrcEquals_ = function(has, wants) {\n  goog.asserts.assert(\n      has.mediaElement,\n      'We should have a media element when loading.');\n  goog.asserts.assert(\n      wants.uri,\n      '|has| should have a valid uri when loading.');\n  goog.asserts.assert(\n      wants.startTimeOfLoad,\n      '|wants| should tell us when the load was originally requested');\n  goog.asserts.assert(\n      this.video_ == has.mediaElement,\n      'The video element should match our media element');\n\n  // Lock-in the values that we are using so that the routing logic knows what\n  // we have.\n  has.uri = wants.uri;\n  has.startTime = wants.startTime;\n\n  // Save the uri so that it can be used outside of the load-graph.\n  this.assetUri_ = has.uri;\n\n  // Stats are for a single playback/load session.\n  this.stats_ = new shaka.util.Stats();\n\n  this.playhead_ = new shaka.media.SrcEqualsPlayhead(has.mediaElement);\n\n  if (has.startTime != null) {\n    this.playhead_.setStartTime(has.startTime);\n  }\n\n  this.playRateController_ = new shaka.media.PlayRateController({\n    getRate: () => has.mediaElement.playbackRate,\n    setRate: (rate) => { has.mediaElement.playbackRate = rate; },\n    movePlayhead: (delta) => { has.mediaElement.currentTime += delta; },\n  });\n\n  // We need to start the buffer management code near the end because it will\n  // set the initial buffering state and that depends on other components being\n  // initialized.\n  const rebufferThreshold = this.config_.streaming.rebufferingGoal;\n  this.startBufferManagement_(rebufferThreshold);\n\n  // Add all media element listeners.\n  const updateStateHistory = () => this.updateStateHistory_();\n  this.eventManager_.listen(has.mediaElement, 'playing', updateStateHistory);\n  this.eventManager_.listen(has.mediaElement, 'pause', updateStateHistory);\n  this.eventManager_.listen(has.mediaElement, 'ended', updateStateHistory);\n\n  // Wait for the 'loadeddata' event to measure load() latency.\n  this.eventManager_.listenOnce(has.mediaElement, 'loadeddata', () => {\n    const now = Date.now() / 1000;\n    const delta = now - wants.startTimeOfLoad;\n\n    this.stats_.setLoadLatency(delta);\n  });\n\n  // The audio tracks are only available on Safari at the moment, but this\n  // drives the tracks API for Safari's native HLS. So when they change,\n  // fire the corresponding Shaka Player event.\n  if (this.video_.audioTracks) {\n    this.eventManager_.listen(\n        this.video_.audioTracks, 'addtrack', () => this.onTracksChanged_());\n    this.eventManager_.listen(\n        this.video_.audioTracks, 'removetrack', () => this.onTracksChanged_());\n  }\n  if (this.video_.textTracks) {\n    // This is a real EventTarget, but the compiler doesn't know that.\n    // TODO: File a bug or send a PR to the compiler externs to fix this.\n    const textTracks = /** @type {EventTarget} */(this.video_.textTracks);\n    this.eventManager_.listen(\n        textTracks, 'addtrack', () => this.onTracksChanged_());\n    this.eventManager_.listen(\n        textTracks, 'removetrack', () => this.onTracksChanged_());\n  }\n\n  // By setting |src| we are done \"loading\" with src=. We don't need to set the\n  // current time because |playhead| will do that for us.\n  has.mediaElement.src = has.uri;\n\n  // Set the load mode last so that we know that all our components are\n  // initialized.\n  this.loadMode_ = shaka.Player.LoadMode.SRC_EQUALS;\n\n  // The event doesn't mean as much for src= playback, since we don't control\n  // streaming.  But we should fire it in this path anyway since some\n  // applications may be expecting it as a life-cycle event.\n  this.dispatchEvent(new shaka.util.FakeEvent('streaming'));\n\n  // This is fully loaded when we have loaded the first frame.\n  const fullyLoaded = new shaka.util.PublicPromise();\n  if (this.video_.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA) {\n    // Already done!\n    fullyLoaded.resolve();\n  } else if (this.video_.error) {\n    // Already failed!\n    fullyLoaded.reject(this.videoErrorToShakaError_());\n  } else {\n    // Wait for success or failure.\n    this.eventManager_.listenOnce(this.video_, 'loadeddata', () => {\n      fullyLoaded.resolve();\n    });\n    this.eventManager_.listenOnce(this.video_, 'error', () => {\n      fullyLoaded.reject(this.videoErrorToShakaError_());\n    });\n  }\n  return new shaka.util.AbortableOperation(fullyLoaded, /* onAbort= */ () => {\n    const abortedError = new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.OPERATION_ABORTED);\n    fullyLoaded.reject(abortedError);\n    return Promise.resolve();  // Abort complete.\n  });\n};\n\n/**\n * Take a series of periods and ensure that they only contain one type of\n * variant. The different options are:\n *  1. Audio-Video\n *  2. Audio-Only\n *  3. Video-Only\n *\n * A manifest can only contain a single type because once we initialize media\n * source to expect specific streams, it must always have content for those\n * streams. If we were to start period 1 with audio+video but period 2 only had\n * audio, media source would block waiting for video content.\n *\n * @param {!Array.<shaka.extern.Period>} periods\n * @private\n */\nshaka.Player.filterForAVVariants_ = function(periods) {\n  const isAVVariant = (variant) => {\n    // Audio-video variants may include both streams separately or may be single\n    // multiplexed streams with multiple codecs.\n    return (variant.video && variant.audio) ||\n           (variant.video && variant.video.codecs.includes(','));\n  };\n  const hasAVVariant = periods.some((period) => {\n    return period.variants.some(isAVVariant);\n  });\n  if (hasAVVariant) {\n    shaka.log.debug('Found variant with audio and video content, ' +\n        'so filtering out audio-only content in all periods.');\n    periods.forEach((period) => {\n      period.variants = period.variants.filter(isAVVariant);\n    });\n  }\n};\n\n\n/**\n * In case of multiple usable codecs, choose one based on lowest average\n * bandwidth and filter out the rest.\n * @private\n */\nshaka.Player.prototype.chooseCodecsAndFilterManifest_ = function() {\n  // Collect a list of variants for all periods.\n  /** @type {!Array.<shaka.extern.Variant>} */\n  let variants = this.manifest_.periods.reduce(\n      (variants, period) => variants.concat(period.variants), []);\n\n  // To start, consider a subset of variants based on audio channel preferences.\n  // For some content (#1013), surround-sound variants will use a different\n  // codec than stereo variants, so it is important to choose codecs **after**\n  // considering the audio channel config.\n  variants = shaka.util.StreamUtils.filterVariantsByAudioChannelCount(\n      variants, this.config_.preferredAudioChannelCount);\n\n  function variantCodecs(variant) {\n    // Only consider the base of the codec string.  For example, these should\n    // both be considered the same codec: avc1.42c01e, avc1.4d401f\n    let baseVideoCodec = '';\n    if (variant.video) {\n      baseVideoCodec = shaka.util.MimeUtils.getCodecBase(variant.video.codecs);\n    }\n\n    let baseAudioCodec = '';\n    if (variant.audio) {\n      baseAudioCodec = shaka.util.MimeUtils.getCodecBase(variant.audio.codecs);\n    }\n\n    return baseVideoCodec + '-' + baseAudioCodec;\n  }\n\n  // Now organize variants into buckets by codecs.\n  /** @type {!shaka.util.MultiMap.<shaka.extern.Variant>} */\n  const variantsByCodecs = new shaka.util.MultiMap();\n  variants.forEach((variant) => {\n    const group = variantCodecs(variant);\n    variantsByCodecs.push(group, variant);\n  });\n\n  // Compute the average bandwidth for each group of variants.\n  // Choose the lowest-bandwidth codecs.\n  let bestCodecs = null;\n  let lowestAverageBandwidth = Infinity;\n  variantsByCodecs.forEach((codecs, variants) => {\n    let sum = 0;\n    let num = 0;\n    variants.forEach(function(variant) {\n      sum += variant.bandwidth || 0;\n      ++num;\n    });\n    let averageBandwidth = sum / num;\n    shaka.log.debug('codecs', codecs, 'avg bandwidth', averageBandwidth);\n\n    if (averageBandwidth < lowestAverageBandwidth) {\n      bestCodecs = codecs;\n      lowestAverageBandwidth = averageBandwidth;\n    }\n  });\n  goog.asserts.assert(bestCodecs != null, 'Should have chosen codecs!');\n  goog.asserts.assert(!isNaN(lowestAverageBandwidth),\n      'Bandwidth should be a number!');\n\n  // Filter out any variants that don't match, forcing AbrManager to choose from\n  // the most efficient variants possible.\n  this.manifest_.periods.forEach(function(period) {\n    period.variants = period.variants.filter(function(variant) {\n      let codecs = variantCodecs(variant);\n      if (codecs == bestCodecs) return true;\n\n      shaka.log.debug('Dropping Variant (better codec available)', variant);\n      return false;\n    });\n  });\n};\n\n\n/**\n * Create a new DrmEngine instance. This may be replaced by tests to create fake\n * instances. Configuration and initialization will be handled after\n * |createDrmEngine|.\n *\n * @param {shaka.media.DrmEngine.PlayerInterface} playerInterface\n * @return {!shaka.media.DrmEngine}\n */\nshaka.Player.prototype.createDrmEngine = function(playerInterface) {\n  return new shaka.media.DrmEngine(playerInterface);\n};\n\n\n/**\n * Creates a new instance of NetworkingEngine.  This can be replaced by tests\n * to create fake instances instead.\n *\n * @return {!shaka.net.NetworkingEngine}\n */\nshaka.Player.prototype.createNetworkingEngine = function() {\n  /** @type {function(number, number)} */\n  const onProgressUpdated_ = (deltaTimeMs, bytesDownloaded) => {\n    // In some situations, such as during offline storage, the abr manager might\n    // not yet exist. Therefore, we need to check if abr manager has been\n    // initialized before using it.\n    if (this.abrManager_) {\n      this.abrManager_.segmentDownloaded(deltaTimeMs, bytesDownloaded);\n    }\n  };\n\n  return new shaka.net.NetworkingEngine(onProgressUpdated_);\n};\n\n\n/**\n * Creates a new instance of Playhead.  This can be replaced by tests to create\n * fake instances instead.\n *\n * @param {?number} startTime\n * @return {!shaka.media.Playhead}\n */\nshaka.Player.prototype.createPlayhead = function(startTime) {\n  goog.asserts.assert(this.manifest_, 'Must have manifest');\n  goog.asserts.assert(this.video_, 'Must have video');\n  return new shaka.media.MediaSourcePlayhead(\n      this.video_,\n      this.manifest_,\n      this.config_.streaming,\n      startTime,\n      () => this.onSeek_(),\n      (event) => this.dispatchEvent(event));\n};\n\n\n/**\n * Create the observers for MSE playback. These observers are responsible for\n * notifying the app and player of specific events during MSE playback.\n *\n * @return {!shaka.media.PlayheadObserverManager}\n * @private\n */\nshaka.Player.prototype.createPlayheadObserversForMSE_ = function() {\n  goog.asserts.assert(this.manifest_, 'Must have manifest');\n  goog.asserts.assert(this.regionTimeline_, 'Must have region timeline');\n  goog.asserts.assert(this.video_, 'Must have video element');\n\n  // Create the period observer. This will allow us to notify the app when we\n  // transition between periods.\n  const periodObserver = new shaka.media.PeriodObserver(this.manifest_);\n  periodObserver.setListeners((period) => this.onChangePeriod_());\n\n  // Create the region observer. This will allow us to notify the app when we\n  // move in and out of timeline regions.\n  const regionObserver = new shaka.media.RegionObserver(this.regionTimeline_);\n  const onEnterRegion = (region, seeking) => {\n    this.onRegionEvent_('timelineregionenter', region);\n  };\n  const onExitRegion = (region, seeking) => {\n    this.onRegionEvent_('timelineregionexit', region);\n  };\n  const onSkipRegion = (region, seeking) => {\n    // If we are seeking, we don't want to surface the enter/exit events since\n    // they didn't play through them.\n    if (!seeking) {\n      this.onRegionEvent_('timelineregionenter', region);\n      this.onRegionEvent_('timelineregionexit', region);\n    }\n  };\n  regionObserver.setListeners(onEnterRegion, onExitRegion, onSkipRegion);\n\n  // Now that we have all our observers, create a manager for them.\n  const manager = new shaka.media.PlayheadObserverManager(this.video_);\n  manager.manage(periodObserver);\n  manager.manage(regionObserver);\n\n  return manager;\n};\n\n\n/**\n * Initialize and start the buffering system (observer and timer) so that we can\n * monitor our buffer lead during playback.\n *\n * @param {number} rebufferingGoal\n */\nshaka.Player.prototype.startBufferManagement_ = function(rebufferingGoal) {\n  goog.asserts.assert(\n      !this.bufferObserver_,\n      'No buffering observer should exist before initialization.');\n\n  goog.asserts.assert(\n      !this.bufferPoller_,\n      'No buffer timer should exist before initialization.');\n\n  // The threshold to transition back to satisfied when starving.\n  const starvingThreshold = rebufferingGoal;\n  // The threshold to transition into starving when satisfied.\n  // We use a \"typical\" threshold, unless the rebufferingGoal is unusually low.\n  // Then we force the value down to half the rebufferingGoal, since\n  // starvingThreshold must be strictly larger than satisfiedThreshold for the\n  // logic in BufferingObserver to work correctly.\n  const satisfiedThreshold =\n      Math.min(shaka.Player.TYPICAL_BUFFERING_THRESHOLD_, rebufferingGoal / 2);\n\n  this.bufferObserver_ = new shaka.media.BufferingObserver(\n        starvingThreshold, satisfiedThreshold);\n\n  // Force us back to a buffering state. This ensure everything is starting in\n  // the same state.\n  this.bufferObserver_.setState(shaka.media.BufferingObserver.State.STARVING);\n  this.updateBufferState_();\n\n  // TODO: We should take some time to look into the effects of our\n  //       quarter-second refresh practice. We often use a quarter-second\n  //       but we have no documentation about why.\n  this.bufferPoller_ = new shaka.util.Timer(() => {\n    this.pollBufferState_();\n  }).tickEvery(/* seconds= */ 0.25);\n};\n\n\n/**\n * This method is called periodically to check what the buffering observer says\n * so that we can update the rest of the buffering behaviours.\n *\n * @private\n */\nshaka.Player.prototype.pollBufferState_ = function() {\n  goog.asserts.assert(\n      this.video_,\n      'Need a media element to update the buffering observer');\n\n  goog.asserts.assert(\n      this.bufferObserver_,\n      'Need a buffering observer to update');\n\n  let bufferedToEnd;\n  switch (this.loadMode_) {\n    case shaka.Player.LoadMode.SRC_EQUALS:\n      bufferedToEnd = this.isBufferedToEndSrc_();\n      break;\n    case shaka.Player.LoadMode.MEDIA_SOURCE:\n      bufferedToEnd = this.isBufferedToEndMS_();\n      break;\n    default:\n      bufferedToEnd = false;\n      break;\n  }\n\n  const bufferLead = shaka.media.TimeRangesUtils.bufferedAheadOf(\n      this.video_.buffered,\n      this.video_.currentTime);\n\n  const stateChanged = this.bufferObserver_.update(bufferLead, bufferedToEnd);\n\n  // If the state changed, we need to surface the event.\n  if (stateChanged) {\n    this.updateBufferState_();\n  }\n};\n\n\n/**\n * Create a new media source engine. This will ONLY be replaced by tests as a\n * way to inject fake media source engine instances.\n *\n * @param {!HTMLMediaElement} mediaElement\n * @param {!shaka.media.IClosedCaptionParser} closedCaptionsParser\n * @param {!shaka.extern.TextDisplayer} textDisplayer\n *\n * @return {!shaka.media.MediaSourceEngine}\n */\nshaka.Player.prototype.createMediaSourceEngine = function(\n    mediaElement, closedCaptionsParser, textDisplayer) {\n  return new shaka.media.MediaSourceEngine(\n      mediaElement, closedCaptionsParser, textDisplayer);\n};\n\n\n/**\n * Creates a new instance of StreamingEngine.  This can be replaced by tests\n * to create fake instances instead.\n *\n * @return {!shaka.media.StreamingEngine}\n */\nshaka.Player.prototype.createStreamingEngine = function() {\n  goog.asserts.assert(\n      this.playhead_ && this.abrManager_ && this.mediaSourceEngine_ &&\n      this.manifest_,\n      'Must not be destroyed');\n\n  /** @type {shaka.media.StreamingEngine.PlayerInterface} */\n  let playerInterface = {\n    getPresentationTime: () => this.playhead_.getTime(),\n    getBandwidthEstimate: () => this.abrManager_.getBandwidthEstimate(),\n    mediaSourceEngine: this.mediaSourceEngine_,\n    netEngine: this.networkingEngine_,\n    onChooseStreams: this.onChooseStreams_.bind(this),\n    onCanSwitch: this.canSwitch_.bind(this),\n    onError: this.onError_.bind(this),\n    onEvent: (event) => this.dispatchEvent(event),\n    onManifestUpdate: this.onManifestUpdate_.bind(this),\n    onSegmentAppended: this.onSegmentAppended_.bind(this),\n  };\n\n  return new shaka.media.StreamingEngine(this.manifest_, playerInterface);\n};\n\n\n/**\n * Configure the Player instance.\n *\n * The config object passed in need not be complete.  It will be merged with\n * the existing Player configuration.\n *\n * Config keys and types will be checked.  If any problems with the config\n * object are found, errors will be reported through logs and this returns\n * false.  If there are errors, valid config objects are still set.\n *\n * @param {string|!Object} config This should either be a field name or an\n *   object following the form of {@link shaka.extern.PlayerConfiguration},\n *   where you may omit any field you do not wish to change.\n * @param {*=} value This should be provided if the previous parameter\n *   was a string field name.\n * @return {boolean} True if the passed config object was valid, false if there\n *   were invalid entries.\n * @export\n */\nshaka.Player.prototype.configure = function(config, value) {\n  goog.asserts.assert(this.config_, 'Config must not be null!');\n  goog.asserts.assert(typeof(config) == 'object' || arguments.length == 2,\n                      'String configs should have values!');\n\n  // ('fieldName', value) format\n  if (arguments.length == 2 && typeof(config) == 'string') {\n    config = shaka.util.ConfigUtils.convertToConfigObject(config, value);\n  }\n\n  goog.asserts.assert(typeof(config) == 'object', 'Should be an object!');\n\n  let ret = shaka.util.PlayerConfiguration.mergeConfigObjects(\n      this.config_, config, this.defaultConfig_());\n\n  this.applyConfig_();\n  return ret;\n};\n\n\n/**\n * Apply config changes.\n * @private\n */\nshaka.Player.prototype.applyConfig_ = function() {\n  if (this.parser_) {\n    this.parser_.configure(this.config_.manifest);\n  }\n  if (this.drmEngine_) {\n    this.drmEngine_.configure(this.config_.drm);\n  }\n  if (this.streamingEngine_) {\n    this.streamingEngine_.configure(this.config_.streaming);\n\n    // Need to apply the restrictions to every period.\n    try {\n      // this.filterNewPeriod_() may throw.\n      this.manifest_.periods.forEach(this.filterNewPeriod_.bind(this));\n    } catch (error) {\n      this.onError_(error);\n    }\n\n    // If the stream we are playing is restricted, we need to switch.\n    let activeAudio = this.streamingEngine_.getBufferingAudio();\n    let activeVideo = this.streamingEngine_.getBufferingVideo();\n    /** @type {shaka.extern.Period} */\n    let period = this.getPresentationPeriod_();\n    let activeVariant = shaka.util.StreamUtils.getVariantByStreams(\n        activeAudio, activeVideo, period.variants);\n    if (this.abrManager_ && activeVariant &&\n        activeVariant.allowedByApplication &&\n        activeVariant.allowedByKeySystem) {\n      // Update AbrManager variants to match these new settings.\n      this.chooseVariant_(period.variants);\n    } else {\n      shaka.log.debug('Choosing new streams after changing configuration');\n      this.chooseStreamsAndSwitch_(period);\n    }\n  }\n  if (this.mediaSourceEngine_) {\n    const TextDisplayerFactory = this.config_.textDisplayFactory;\n    if (this.lastTextFactory_ != TextDisplayerFactory) {\n      const displayer = new TextDisplayerFactory();\n      this.mediaSourceEngine_.setTextDisplayer(displayer);\n      this.lastTextFactory_ = TextDisplayerFactory;\n\n      if (this.streamingEngine_) {\n        // Reload the text stream, so the cues will load again.\n        this.streamingEngine_.reloadTextStream();\n      }\n    }\n  }\n  if (this.abrManager_) {\n    this.abrManager_.configure(this.config_.abr);\n    // Simply enable/disable ABR with each call, since multiple calls to these\n    // methods have no effect.\n    if (this.config_.abr.enabled && !this.switchingPeriods_) {\n      this.abrManager_.enable();\n    } else {\n      this.abrManager_.disable();\n    }\n\n    this.onAbrStatusChanged_();\n  }\n};\n\n\n/**\n * Return a copy of the current configuration.  Modifications of the returned\n * value will not affect the Player's active configuration.  You must call\n * player.configure() to make changes.\n *\n * @return {shaka.extern.PlayerConfiguration}\n * @export\n */\nshaka.Player.prototype.getConfiguration = function() {\n  goog.asserts.assert(this.config_, 'Config must not be null!');\n\n  let ret = this.defaultConfig_();\n  shaka.util.PlayerConfiguration.mergeConfigObjects(\n      ret, this.config_, this.defaultConfig_());\n  return ret;\n};\n\n\n/**\n * Return a reference to the current configuration. Modifications to the\n * returned value will affect the Player's active configuration. This method\n * is not exported as sharing configuration with external objects is not\n * supported.\n *\n * @return {shaka.extern.PlayerConfiguration}\n */\nshaka.Player.prototype.getSharedConfiguration = function() {\n  goog.asserts.assert(\n      this.config_, 'Cannot call getSharedConfiguration after call destroy!');\n  return this.config_;\n};\n\n\n/**\n * Reset configuration to default.\n * @export\n */\nshaka.Player.prototype.resetConfiguration = function() {\n  goog.asserts.assert(this.config_, 'Cannot be destroyed');\n  // Remove the old keys so we remove open-ended dictionaries like drm.servers\n  // but keeps the same object reference.\n  for (const key in this.config_) {\n    delete this.config_[key];\n  }\n\n  shaka.util.PlayerConfiguration.mergeConfigObjects(\n      this.config_, this.defaultConfig_(), this.defaultConfig_());\n  this.applyConfig_();\n};\n\n\n/**\n * Get the current load mode.\n *\n * @return {shaka.Player.LoadMode}\n * @export\n */\nshaka.Player.prototype.getLoadMode = function() {\n  return this.loadMode_;\n};\n\n\n/**\n * Get the media element that the player is currently using to play loaded\n * content. If the player has not loaded content, this will return |null|.\n *\n * @return {HTMLMediaElement}\n * @export\n */\nshaka.Player.prototype.getMediaElement = function() {\n  return this.video_;\n};\n\n\n/**\n * @return {shaka.net.NetworkingEngine} A reference to the Player's networking\n *     engine.  Applications may use this to make requests through Shaka's\n *     networking plugins.\n * @export\n */\nshaka.Player.prototype.getNetworkingEngine = function() {\n  return this.networkingEngine_;\n};\n\n\n/**\n * Get the uri to the asset that the player has loaded. If the player has not\n * loaded content, this will return |null|.\n *\n * @return {?string}\n * @export\n */\nshaka.Player.prototype.getAssetUri = function() {\n  return this.assetUri_;\n};\n\n\n/**\n * Get the uri to the asset that the player has loaded. If the player has not\n * loaded content, this will return |null|.\n *\n * @deprecated\n * @return {?string}\n * @export\n */\nshaka.Player.prototype.getManifestUri = function() {\n  shaka.Deprecate.deprecateFeature(\n    2, 6, 'getManifestUri', 'Please use \"getAssetUri\" instead.');\n\n  return this.getAssetUri();\n};\n\n\n/**\n * Get if the player is playing live content. If the player has not loaded\n * content, this will return |false|.\n *\n * @return {boolean}\n * @export\n */\nshaka.Player.prototype.isLive = function() {\n  if (this.manifest_) {\n    return this.manifest_.presentationTimeline.isLive();\n  }\n\n  // For native HLS, the duration for live streams seems to be Infinity.\n  if (this.video_ && this.video_.src) {\n    return this.video_.duration == Infinity;\n  }\n\n  return false;\n};\n\n\n/**\n * Get if the player is playing in-progress content. If the player has not\n * loaded content, this will return |false|.\n *\n * @return {boolean}\n * @export\n */\nshaka.Player.prototype.isInProgress = function() {\n  return this.manifest_ ?\n         this.manifest_.presentationTimeline.isInProgress() :\n         false;\n};\n\n\n/**\n * Check if the manifest contains only audio-only content. If the player has not\n * loaded content, this will return |false|.\n *\n * The player does not support content that contain more than one type of\n * variants (i.e. mixing audio-only, video-only, audio-video). Content will be\n * filtered to only contain one type of variant.\n *\n * @return {boolean}\n * @export\n */\nshaka.Player.prototype.isAudioOnly = function() {\n  if (this.manifest_) {\n    const periods = this.manifest_.periods;\n    if (!periods.length) { return false; }\n\n    const variants = this.manifest_.periods[0].variants;\n    if (!variants.length) { return false; }\n\n    // Note that if there are some audio-only variants and some audio-video\n    // variants, the audio-only variants are removed during filtering.\n    // Therefore if the first variant has no video, that's sufficient to say it\n    // is audio-only content.\n    return !variants[0].video;\n  } else if (this.video_ && this.video_.src) {\n    // If we have video track info, use that.  It will be the least error-prone\n    // way with native HLS.  In contrast, videoHeight might be unset until\n    // the first frame is loaded.  Since isAudioOnly is queried by the UI on\n    // the 'trackschanged' event, the videoTracks info should be up-to-date.\n    if (this.video_.videoTracks) {\n      return this.video_.videoTracks.length == 0;\n    }\n\n    // We cast to the more specific HTMLVideoElement to access videoHeight.\n    // This might be an audio element, though, in which case videoHeight will\n    // be undefined at runtime.  For audio elements, this will always return\n    // true.\n    const video = /** @type {HTMLVideoElement} */(this.video_);\n    return video.videoHeight == 0;\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * Get the range of time (in seconds) that seeking is allowed. If the player has\n * not loaded content, this will return a range from 0 to 0.\n *\n * @return {{start: number, end: number}}\n * @export\n */\nshaka.Player.prototype.seekRange = function() {\n  if (this.manifest_) {\n    const timeline = this.manifest_.presentationTimeline;\n\n    return {\n      'start': timeline.getSeekRangeStart(),\n      'end': timeline.getSeekRangeEnd(),\n    };\n  }\n\n  // If we have loaded content with src=, we ask the video element for its\n  // seekable range.  This covers both plain mp4s and native HLS playbacks.\n  if (this.video_ && this.video_.src) {\n    const seekable = this.video_.seekable;\n    if (seekable.length) {\n      return {\n        'start': seekable.start(0),\n        'end': seekable.end(seekable.length - 1),\n      };\n    }\n  }\n\n  return {'start': 0, 'end': 0};\n};\n\n\n/**\n * Get the key system currently used by EME. If EME is not being used, this will\n * return an empty string. If the player has not loaded content, this will\n * return an empty string.\n *\n * @return {string}\n * @export\n */\nshaka.Player.prototype.keySystem = function() {\n  return this.drmEngine_ ? this.drmEngine_.keySystem() : '';\n};\n\n\n/**\n * Get the drm info used to initialize EME. If EME is not being used, this will\n * return |null|. If the player is idle or has not initialized EME yet, this\n * will return |null|.\n *\n * @return {?shaka.extern.DrmInfo}\n * @export\n */\nshaka.Player.prototype.drmInfo = function() {\n  return this.drmEngine_ ? this.drmEngine_.getDrmInfo() : null;\n};\n\n\n/**\n * Get the next known expiration time for any EME session. If the session never\n * expires, this will return |Infinity|. If there are no EME sessions, this will\n * return |Infinity|. If the player has not loaded content, this will return\n * |Infinity|.\n *\n * @return {number}\n * @export\n */\nshaka.Player.prototype.getExpiration = function() {\n  return this.drmEngine_ ? this.drmEngine_.getExpiration() : Infinity;\n};\n\n\n/**\n * Check if the player is currently in a buffering state (has too little content\n * to play smoothly). If the player has not loaded content, this will return\n * |false|.\n *\n * @return {boolean}\n * @export\n */\nshaka.Player.prototype.isBuffering = function() {\n  const State = shaka.media.BufferingObserver.State;\n  return this.bufferObserver_ ?\n         this.bufferObserver_.getState() == State.STARVING :\n         false;\n};\n\n\n/**\n * Get the playback rate of what is playing right now. If we are using trick\n * play, this will return the trick play rate. If no content is playing, this\n * will return 0. If content is buffering, this will return 0.\n *\n * If the player has not loaded content, this will return a playback rate of\n * |0|.\n *\n * @return {number}\n * @export\n */\nshaka.Player.prototype.getPlaybackRate = function() {\n  return this.playRateController_ ?\n         this.playRateController_.getActiveRate() :\n         0;\n};\n\n\n/**\n * Enable trick play to skip through content without playing by repeatedly\n * seeking. For example, a rate of 2.5 would result in 2.5 seconds of content\n * being skipped every second. A negative rate will result in moving backwards.\n *\n * If the player has not loaded content or is still loading content this will be\n * a no-op. Wait until |load| has completed before calling.\n *\n * Trick play will be canceled automatically if the playhead hits the beginning\n * or end of the seekable range for the content.\n *\n * @param {number} rate\n * @export\n */\nshaka.Player.prototype.trickPlay = function(rate) {\n  // A playbackRate of 0 is used internally when we are in a buffering state,\n  // and doesn't make sense for trick play.  If you set a rate of 0 for trick\n  // play, we will reject it and issue a warning.  If it happens during a test,\n  // we will fail the test through this assertion.\n  goog.asserts.assert(rate != 0, 'Should never set a trick play rate of 0!');\n  if (rate == 0) {\n    shaka.log.alwaysWarn('A trick play rate of 0 is unsupported!');\n    return;\n  }\n\n  if (this.video_.paused) {\n    // Our fast forward is implemented with playbackRate and needs the video to\n    // be playing (to not be paused) to take immediate effect.\n    // If the video is paused, \"unpause\" it.\n    this.video_.play();\n  }\n  this.playRateController_.set(rate);\n\n  if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n    this.streamingEngine_.setTrickPlay(Math.abs(rate) > 1);\n  }\n};\n\n\n/**\n * Cancel trick-play. If the player has not loaded content or is still loading\n * content this will be a no-op.\n *\n * @export\n */\nshaka.Player.prototype.cancelTrickPlay = function() {\n  if (this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS) {\n    this.playRateController_.set(1);\n  }\n\n  if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n    this.playRateController_.set(1);\n    this.streamingEngine_.setTrickPlay(false);\n  }\n};\n\n\n/**\n * Return a list of variant tracks that can be switched to in the current\n * period. If there are multiple periods, you must seek to the period in order\n * to get variants from that period.\n *\n * If the player has not loaded content, this will return an empty list.\n *\n * @return {!Array.<shaka.extern.Track>}\n * @export\n */\nshaka.Player.prototype.getVariantTracks = function() {\n  if (this.manifest_ && this.playhead_) {\n    const currentVariant = this.getPresentationVariant_();\n\n    const tracks = [];\n\n    // Convert each variant to a track.\n    for (const variant of this.getSelectableVariants_()) {\n      const track = shaka.util.StreamUtils.variantToTrack(variant);\n      track.active = variant == currentVariant;\n\n      tracks.push(track);\n    }\n\n    return tracks;\n  } else if (this.video_ && this.video_.audioTracks) {\n    // Safari's native HLS always shows a single element in videoTracks.\n    // You can't use that API to change resolutions.  But we can use audioTracks\n    // to generate a variant list that is usable for changing languages.\n    const audioTracks = Array.from(this.video_.audioTracks);\n    return audioTracks.map((audio) =>\n        shaka.util.StreamUtils.html5AudioTrackToTrack(audio));\n  } else {\n    return [];\n  }\n};\n\n\n/**\n * Return a list of text tracks that can be switched to in the current period.\n * If there are multiple periods, you must seek to a period in order to get\n * text tracks from that period.\n *\n * If the player has not loaded content, this will return an empty list.\n *\n * @return {!Array.<shaka.extern.Track>}\n * @export\n */\nshaka.Player.prototype.getTextTracks = function() {\n  if (this.manifest_ && this.playhead_) {\n    const currentText = this.getPresentationText_();\n    const tracks = [];\n\n    // Convert all selectable text streams to tracks.\n    for (const text of this.getSelectableText_()) {\n      const track = shaka.util.StreamUtils.textStreamToTrack(text);\n      track.active = text == currentText;\n\n      tracks.push(track);\n    }\n\n    return tracks;\n  } else if (this.video_ && this.video_.src && this.video_.textTracks) {\n    const textTracks = Array.from(this.video_.textTracks);\n    const StreamUtils = shaka.util.StreamUtils;\n    return textTracks.map((text) => StreamUtils.html5TextTrackToTrack(text));\n  } else {\n    return [];\n  }\n};\n\n\n/**\n * Select a specific text track from the current period. |track| should come\n * from a call to |getTextTracks|. If the track is not found in the current\n * period, this will be a no-op. If the player has not loaded content, this will\n * be a no-op.\n *\n * Note that AdaptationEvents are not fired for manual track selections.\n *\n * @param {shaka.extern.Track} track\n * @export\n */\nshaka.Player.prototype.selectTextTrack = function(track) {\n  if (this.manifest_ && this.streamingEngine_) {\n    /** @type {shaka.extern.Period} */\n    const period = this.getPresentationPeriod_();\n    const stream = period.textStreams.find((stream) => stream.id == track.id);\n\n    if (!stream) {\n      shaka.log.error('No stream with id', track.id);\n      return;\n    }\n\n    // Add entries to the history.\n    this.addTextStreamToSwitchHistory_(\n        period, stream, /* fromAdaptation= */ false);\n\n    this.switchTextStream_(stream);\n\n    // Workaround for https://github.com/google/shaka-player/issues/1299\n    // When track is selected, back-propogate the language to\n    // currentTextLanguage_.\n    this.currentTextLanguage_ = stream.language;\n  } else if (this.video_ && this.video_.src && this.video_.textTracks) {\n    const textTracks = Array.from(this.video_.textTracks);\n    for (const textTrack of textTracks) {\n      if (shaka.util.StreamUtils.html5TrackId(textTrack) == track.id) {\n        // Leave the track in 'hidden' if it's selected but not showing.\n        textTrack.mode = this.isTextVisible_ ? 'showing' : 'hidden';\n      } else {\n        // Safari allows multiple text tracks to have mode == 'showing', so be\n        // explicit in resetting the others.\n        textTrack.mode = 'disabled';\n      }\n    }\n    this.onTextChanged_();\n  }\n};\n\n\n/**\n * Find the CEA 608/708 text stream embedded in video, and switch to it.\n *\n * @deprecated\n * @export\n */\nshaka.Player.prototype.selectEmbeddedTextTrack = function() {\n  shaka.Deprecate.deprecateFeature(\n      2, 6,\n      'selectEmbeddedTextTrack',\n      [\n        'If closed captions are signaled in the manifest, a text stream will',\n        'be created to represent them. Please use SelectTextTrack.',\n      ].join(' '));\n\n  const tracks = this.getTextTracks().filter((track) => {\n    return track.mimeType == shaka.util.MimeUtils.CLOSED_CAPTION_MIMETYPE;\n  });\n\n  if (tracks.length > 0) {\n    this.selectTextTrack(tracks[0]);\n  } else {\n    shaka.log.warning('Unable to find the text track embedded in the video.');\n  }\n};\n\n\n/**\n * @return {boolean} True if we are using any embedded text tracks present.\n *\n * @deprecated\n * @export\n */\nshaka.Player.prototype.usingEmbeddedTextTrack = function() {\n  shaka.Deprecate.deprecateFeature(\n      2, 6,\n      'usingEmbeddedTextTrack',\n      [\n        'If closed captions are signaled in the manifest, a text stream will',\n        'be created to represent them. There should be no reason to know if',\n        'the player is playing embedded text.',\n      ].join(' '));\n\n  const activeTrack = this.getTextTracks().filter((track) => {\n    return track.active;\n  })[0];\n\n  if (activeTrack) {\n    return activeTrack.mimeType == shaka.util.MimeUtils.CLOSED_CAPTION_MIMETYPE;\n  }\n\n  return false;\n};\n\n\n/**\n * Select a specific variant track to play from the current period. |track|\n * should come from a call to |getVariantTracks|. If |track| cannot be found\n * in the current variant, this will be a no-op. If the player has not loaded\n * content, this will be a no-op.\n *\n * Changing variants will take effect once the currently buffered content has\n * been played. To force the change to happen sooner, use |clearBuffer| with\n * |safeMargin|. Setting |clearBuffer| to |true| will clear all buffered content\n * after |safeMargin|, allowing the new variant to start playing sooner.\n *\n * Note that AdaptationEvents are not fired for manual track selections.\n *\n * @param {shaka.extern.Track} track\n * @param {boolean=} clearBuffer\n * @param {number=} safeMargin Optional amount of buffer (in seconds) to retain\n *   when clearing the buffer. Useful for switching variant quickly without\n *   causing a buffering event. Defaults to 0 if not provided. Ignored if\n *   clearBuffer is false. Can cause hiccups on some browsers if chosen too\n *   small, e.g. The amount of two segments is a fair minimum to consider as\n *   safeMargin value.\n * @export\n */\nshaka.Player.prototype.selectVariantTrack = function(\n    track, clearBuffer, safeMargin = 0) {\n  if (this.manifest_ && this.streamingEngine_) {\n    /** @type {shaka.extern.Period} */\n    const period = this.getPresentationPeriod_();\n\n    if (this.config_.abr.enabled) {\n      shaka.log.alwaysWarn('Changing tracks while abr manager is enabled ' +\n                           'will likely result in the selected track being ' +\n                           'overriden. Consider disabling abr before calling ' +\n                           'selectVariantTrack().');\n    }\n\n    const variant = period.variants.find((variant) => variant.id == track.id);\n    if (!variant) {\n      shaka.log.error('No variant with id', track.id);\n      return;\n    }\n\n    // Double check that the track is allowed to be played. The track list\n    // should only contain playable variants, but if restrictions change and\n    // |selectVariantTrack| is called before the track list is updated, we could\n    // get a now-restricted variant.\n    if (!shaka.util.StreamUtils.isPlayable(variant)) {\n      shaka.log.error('Unable to switch to restricted track', track.id);\n      return;\n    }\n\n    // Add entries to the history.\n    this.addVariantToSwitchHistory_(period, variant,\n                                    /* fromAdaptation= */ false);\n    this.switchVariant_(variant, clearBuffer, safeMargin);\n\n    // Workaround for https://github.com/google/shaka-player/issues/1299\n    // When track is selected, back-propogate the language to\n    // currentAudioLanguage_.\n    this.currentAdaptationSetCriteria_ = new shaka.media.ExampleBasedCriteria(\n        variant);\n\n    // Update AbrManager variants to match these new settings.\n    this.chooseVariant_(period.variants);\n  } else if (this.video_ && this.video_.audioTracks) {\n    // Safari's native HLS won't let you choose an explicit variant, though you\n    // can choose audio languages this way.\n    const audioTracks = Array.from(this.video_.audioTracks);\n    for (const audioTrack of audioTracks) {\n      if (shaka.util.StreamUtils.html5TrackId(audioTrack) == track.id) {\n        // This will reset the \"enabled\" of other tracks to false.\n        audioTrack.enabled = true;\n      }\n    }\n    this.onVariantChanged_();\n  }\n};\n\n\n/**\n * Return a list of audio language-role combinations available for the current\n * period. If the player has not loaded any content, this will return an empty\n * list.\n *\n * @return {!Array.<shaka.extern.LanguageRole>}\n * @export\n */\nshaka.Player.prototype.getAudioLanguagesAndRoles = function() {\n  return shaka.Player.getLanguageAndRolesFrom_(this.getVariantTracks());\n};\n\n\n/**\n * Return a list of text language-role combinations available for the current\n * period. If the player has not loaded any content, this will be return an\n * empty list.\n *\n * @return {!Array.<shaka.extern.LanguageRole>}\n * @export\n */\nshaka.Player.prototype.getTextLanguagesAndRoles = function() {\n  return shaka.Player.getLanguageAndRolesFrom_(this.getTextTracks());\n};\n\n\n/**\n * Return a list of audio languages available for the current period. If the\n * player has not loaded any content, this will return an empty list.\n *\n * @return {!Array.<string>}\n * @export\n */\nshaka.Player.prototype.getAudioLanguages = function() {\n  return Array.from(shaka.Player.getLanguagesFrom_(this.getVariantTracks()));\n};\n\n\n/**\n * Return a list of text languages available for the current period. If the\n * player has not loaded any content, this will return an empty list.\n *\n * @return {!Array.<string>}\n * @export\n */\nshaka.Player.prototype.getTextLanguages = function() {\n  return Array.from(shaka.Player.getLanguagesFrom_(this.getTextTracks()));\n};\n\n\n/**\n * Sets currentAudioLanguage and currentVariantRole to the selected language and\n * role, and chooses a new variant if need be. If the player has not loaded any\n * content, this will be a no-op.\n *\n * @param {string} language\n * @param {string=} role\n * @export\n */\nshaka.Player.prototype.selectAudioLanguage = function(language, role) {\n  if (this.manifest_ && this.playhead_) {\n    /** @type {shaka.extern.Period} */\n    const period = this.getPresentationPeriod_();\n\n    this.currentAdaptationSetCriteria_ =\n        new shaka.media.PreferenceBasedCriteria(language, role || '', 0);\n\n    // TODO: Refactor to only change audio and not affect text.\n    this.chooseStreamsAndSwitch_(period);\n  } else if (this.video_ && this.video_.audioTracks) {\n    const audioTracks = Array.from(this.video_.audioTracks);\n    for (const audioTrack of audioTracks) {\n      if (audioTrack.language == language) {\n        // This will reset the \"enabled\" of other tracks to false.\n        audioTrack.enabled = true;\n      }\n    }\n    this.onVariantChanged_();\n  }\n};\n\n\n/**\n * Sets currentTextLanguage and currentTextRole to the selected language and\n * role, and chooses a new variant if need be. If the player has not loaded any\n * content, this will be a no-op.\n *\n * @param {string} language\n * @param {string=} role\n * @export\n */\nshaka.Player.prototype.selectTextLanguage = function(language, role) {\n  if (this.manifest_ && this.playhead_) {\n    /** @type {shaka.extern.Period} */\n    const period = this.getPresentationPeriod_();\n\n    this.currentTextLanguage_ = language;\n    this.currentTextRole_ = role || '';\n\n    const chosenText = this.chooseTextStream_(period.textStreams);\n    if (chosenText) {\n      this.addTextStreamToSwitchHistory_(\n          period, chosenText, /* fromAdaptation= */ false);\n      if (this.shouldStreamText_()) {\n        this.switchTextStream_(chosenText);\n      }\n    }\n  } else {\n    const track = this.getTextTracks().filter((t) => t.language == language)[0];\n    if (track) {\n      this.selectTextTrack(track);\n    }\n  }\n};\n\n\n/**\n * Check if the text displayer is enabled.\n *\n * @return {boolean}\n * @export\n */\nshaka.Player.prototype.isTextTrackVisible = function() {\n  const expected = this.isTextVisible_;\n\n  if (this.manifest_) {\n    // Make sure our values are still in-sync.\n    const actual = this.mediaSourceEngine_.getTextDisplayer().isTextVisible();\n    goog.asserts.assert(\n        actual == expected, 'text visibility has fallen out of sync');\n\n    // Always return the actual value so that the app has the most accurate\n    // information (in the case that the values come out of sync in prod).\n    return actual;\n  } else if (this.video_ && this.video_.src && this.video_.textTracks) {\n    const textTracks = Array.from(this.video_.textTracks);\n    return textTracks.some((t) => t.mode == 'showing');\n  }\n\n  return expected;\n};\n\n\n/**\n * Enable or disable the text displayer.  If the player is in an unloaded state,\n * the request will be applied next time content is loaded.\n *\n * @param {boolean} isVisible\n * @return {!Promise}\n * @export\n */\nshaka.Player.prototype.setTextTrackVisibility = async function(isVisible) {\n  const oldVisibilty = this.isTextVisible_;\n  const newVisibility = isVisible;\n\n  if (oldVisibilty == newVisibility) {\n    return;\n  }\n\n  this.isTextVisible_ = newVisibility;\n\n  // Hold of on setting the text visibility until we have all the components we\n  // need. This ensures that they stay in-sync.\n  if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n    this.mediaSourceEngine_.getTextDisplayer().setTextVisibility(isVisible);\n\n    // When the user wants to see captions, we stream captions. When the user\n    // doesn't want to see captions, we don't stream captions. This is to avoid\n    // bandwidth consumption by an unused resource. The app developer can\n    // override this and configure us to always stream captions.\n    if (!this.config_.streaming.alwaysStreamText) {\n      if (isVisible) {\n        // Find the text stream that best matches the user's preferences.\n        /** @type {shaka.extern.Period} */\n        const period = this.getPresentationPeriod_();\n        const streams = shaka.util.StreamUtils.filterStreamsByLanguageAndRole(\n            period.textStreams, this.currentTextLanguage_,\n            this.currentTextRole_);\n\n        // It is possible that there are no streams to play.\n        if (streams.length > 0) {\n          await this.streamingEngine_.loadNewTextStream(streams[0]);\n        }\n      } else {\n        this.streamingEngine_.unloadTextStream();\n      }\n    }\n  } else if (this.video_ && this.video_.src && this.video_.textTracks) {\n    const textTracks = Array.from(this.video_.textTracks);\n\n    // Find the active track by looking for one which is not disabled.  This is\n    // the only way to identify the track which is currently displayed.\n    // Set it to 'showing' or 'hidden' based on isVisible.\n    for (const textTrack of textTracks) {\n      if (textTrack.mode != 'disabled') {\n        textTrack.mode = isVisible ? 'showing' : 'hidden';\n      }\n    }\n  }\n\n  // We need to fire the event after we have updated everything so that\n  // everything will be in a stable state when the app responds to the\n  // event.\n  this.onTextTrackVisibility_();\n};\n\n\n/**\n * Get the current playhead position as a date. This should only be called when\n * the player has loaded a live stream. If the player has not loaded a live\n * stream, this will return |null|.\n *\n * @return {Date}\n * @export\n */\nshaka.Player.prototype.getPlayheadTimeAsDate = function() {\n  if (!this.isLive()) {\n    shaka.log.warning('getPlayheadTimeAsDate is for live streams!');\n    return null;\n  }\n\n  if (this.manifest_) {\n    const timeline = this.manifest_.presentationTimeline;\n    const startTime = timeline.getPresentationStartTime();\n    const presentationTime = this.video_.currentTime;\n    return new Date(/* ms= */ (startTime + presentationTime) * 1000);\n  } else if (this.video_ && this.video_.getStartDate) {\n    // Apple's native HLS gives us getStartDate(), which is only available if\n    // EXT-X-PROGRAM-DATETIME is in the playlist.\n    const startDate = this.video_.getStartDate();\n    if (isNaN(startDate.getTime())) {\n      shaka.log.warning(\n          'EXT-X-PROGRAM-DATETIME required to get playhead time as Date!');\n      return null;\n    }\n    return new Date(startDate.getTime() + (this.video_.currentTime * 1000));\n  } else {\n    shaka.log.warning('No way to get playhead time as Date!');\n    return null;\n  }\n};\n\n\n/**\n * Get the presentation start time as a date. This should only be called when\n * the player has loaded a live stream. If the player has not loaded a live\n * stream, this will return |null|.\n *\n * @return {Date}\n * @export\n */\nshaka.Player.prototype.getPresentationStartTimeAsDate = function() {\n  if (!this.isLive()) {\n    shaka.log.warning('getPresentationStartTimeAsDate is for live streams!');\n    return null;\n  }\n\n  if (this.manifest_) {\n    const timeline = this.manifest_.presentationTimeline;\n    const startTime = timeline.getPresentationStartTime();\n    return new Date(/* ms= */ startTime * 1000);\n  } else if (this.video_ && this.video_.getStartDate) {\n    // Apple's native HLS gives us getStartDate(), which is only available if\n    // EXT-X-PROGRAM-DATETIME is in the playlist.\n    const startDate = this.video_.getStartDate();\n    if (isNaN(startDate.getTime())) {\n      shaka.log.warning(\n          'EXT-X-PROGRAM-DATETIME required to get presentation start time as ' +\n          'Date!');\n      return null;\n    }\n    return startDate;\n  } else {\n    shaka.log.warning('No way to get presentation start time as Date!');\n    return null;\n  }\n};\n\n\n/**\n * Get information about what the player has buffered. If the player has not\n * loaded content or is currently loading content, the buffered content will be\n * empty.\n *\n * @return {shaka.extern.BufferedInfo}\n * @export\n */\nshaka.Player.prototype.getBufferedInfo = function() {\n  const info = {\n    total: [],\n    audio: [],\n    video: [],\n    text: [],\n  };\n\n  if (this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS) {\n    const TimeRangesUtils = shaka.media.TimeRangesUtils;\n    info.total = TimeRangesUtils.getBufferedInfo(this.video_.buffered);\n  }\n\n  if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n    this.mediaSourceEngine_.getBufferedInfo(info);\n  }\n\n  return info;\n};\n\n\n/**\n * Get statistics for the current playback session. If the player is not playing\n * content, this will return an empty stats object.\n *\n * @return {shaka.extern.Stats}\n * @export\n */\nshaka.Player.prototype.getStats = function() {\n  // If the Player is not in a fully-loaded state, then return an empty stats\n  // blob so that this call will never fail.\n  const loaded = this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE ||\n                 this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS;\n  if (!loaded) {\n    return shaka.util.Stats.getEmptyBlob();\n  }\n\n  this.updateStateHistory_();\n\n  goog.asserts.assert(this.video_, 'If we have stats, we should have video_');\n  const element = /** @type {!HTMLVideoElement} */ (this.video_);\n\n  if (element.getVideoPlaybackQuality) {\n    const info = element.getVideoPlaybackQuality();\n\n    this.stats_.setDroppedFrames(\n        Number(info.droppedVideoFrames),\n        Number(info.totalVideoFrames));\n  }\n\n  if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n    // Event through we are loaded, it is still possible that we don't have a\n    // presentation variant yet because we set the load mode before we select\n    // the first variant to stream.\n    const variant = this.getPresentationVariant_();\n\n    if (variant) {\n      this.stats_.setVariantBandwidth(variant.bandwidth);\n    }\n\n    if (variant && variant.video) {\n      this.stats_.setResolution(\n          /* width= */ variant.video.width || NaN,\n          /* height= */ variant.video.height || NaN);\n    }\n\n    const estimate = this.abrManager_.getBandwidthEstimate();\n    this.stats_.setBandwidthEstimate(estimate);\n  }\n\n  return this.stats_.getBlob();\n};\n\n\n/**\n * Adds the given text track to the current Period.  load() must resolve before\n * calling.  The current Period or the presentation must have a duration.  This\n * returns a Promise that will resolve with the track that was created, when\n * that track can be switched to.\n *\n * @param {string} uri\n * @param {string} language\n * @param {string} kind\n * @param {string} mime\n * @param {string=} codec\n * @param {string=} label\n * @return {!Promise.<shaka.extern.Track>}\n * @export\n */\nshaka.Player.prototype.addTextTrack = async function(\n    uri, language, kind, mime, codec, label) {\n  // TODO: Add an actual error for this.\n  if (this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS) {\n    shaka.log.error('Cannot add text when loaded with src=');\n    throw new Error('State error!');\n  }\n  if (this.loadMode_ != shaka.Player.LoadMode.MEDIA_SOURCE) {\n    shaka.log.error(\n        'Must call load() and wait for it to resolve before adding text ' +\n        'tracks.');\n    throw new Error('State error!');\n  }\n\n  /** @type {shaka.extern.Period} */\n  const period = this.getPresentationPeriod_();\n\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  // Get the Period duration.\n  /** @type {number} */\n  const periodIndex = this.manifest_.periods.indexOf(period);\n  /** @type {number} */\n  const nextPeriodIndex = periodIndex + 1;\n  /** @type {number} */\n  const nextPeriodStart = nextPeriodIndex >= this.manifest_.periods.length ?\n                          this.manifest_.presentationTimeline.getDuration() :\n                          this.manifest_.periods[nextPeriodIndex].startTime;\n  /** @type {number} */\n  const periodDuration = nextPeriodStart - period.startTime;\n  if (periodDuration == Infinity) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.RECOVERABLE,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_TEXT_TO_LIVE_STREAM);\n  }\n\n  /** @type {!shaka.media.SegmentReference} */\n  const segmentReference = new shaka.media.SegmentReference(\n      1, 0, periodDuration, () => [uri], 0, null);\n\n  /** @type {shaka.extern.Stream} */\n  const stream = {\n    id: this.nextExternalStreamId_++,\n    originalId: null,\n    createSegmentIndex: Promise.resolve.bind(Promise),\n    findSegmentPosition: (time) => 1,\n    getSegmentReference: (ref) => {\n      return ref == 1 ? segmentReference : null;\n    },\n    initSegmentReference: null,\n    presentationTimeOffset: 0,\n    mimeType: mime,\n    codecs: codec || '',\n    kind: kind,\n    encrypted: false,\n    keyId: null,\n    language: language,\n    label: label || null,\n    type: ContentType.TEXT,\n    primary: false,\n    trickModeVideo: null,\n    emsgSchemeIdUris: null,\n    roles: [],\n    channelsCount: null,\n    closedCaptions: null,\n  };\n\n  // Add the stream to the loading list to ensure it isn't switched to while it\n  // is initializing.\n  this.loadingTextStreams_.add(stream);\n  period.textStreams.push(stream);\n\n  await this.streamingEngine_.loadNewTextStream(stream);\n  goog.asserts.assert(period, 'The period should still be non-null here.');\n\n  const activeText = this.streamingEngine_.getBufferingText();\n  if (activeText) {\n    // If this was the first text stream, StreamingEngine will start streaming\n    // it in loadNewTextStream.  To reflect this, update the active stream.\n    this.activeStreams_.useText(period, activeText);\n  }\n\n  // Remove the stream from the loading list.\n  this.loadingTextStreams_.delete(stream);\n\n  shaka.log.debug('Choosing new streams after adding a text stream');\n  this.chooseStreamsAndSwitch_(period);\n  this.onTracksChanged_();\n\n  return shaka.util.StreamUtils.textStreamToTrack(stream);\n};\n\n\n/**\n * Set the maximum resolution that the platform's hardware can handle.\n * This will be called automatically by shaka.cast.CastReceiver to enforce\n * limitations of the Chromecast hardware.\n *\n * @param {number} width\n * @param {number} height\n * @export\n */\nshaka.Player.prototype.setMaxHardwareResolution = function(width, height) {\n  this.maxHwRes_.width = width;\n  this.maxHwRes_.height = height;\n};\n\n\n/**\n * Retry streaming after a streaming failure has occurred. When the player has\n * not loaded content or is loading content, this will be a no-op and will\n * return |false|.\n *\n * If the player has loaded content, and streaming has not seen an error, this\n * will return |false|.\n *\n * if the player has loaded content, and streaming seen an error, but the could\n * not resume streaming, this will return |false|.\n *\n * @return {boolean}\n * @export\n */\nshaka.Player.prototype.retryStreaming = function() {\n  return this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE ?\n         this.streamingEngine_.retry() :\n         false;\n};\n\n\n/**\n * Get the manifest that the player has loaded. If the player has not loaded any\n * content, this will return |null|.\n *\n * @return {?shaka.extern.Manifest}\n * @export\n */\nshaka.Player.prototype.getManifest = function() {\n  return this.manifest_;\n};\n\n\n/**\n * Get the type of manifest parser that the player is using. If the player has\n * not loaded any content, this will return |null|.\n *\n * @return {?shaka.extern.ManifestParser.Factory}\n * @export\n */\nshaka.Player.prototype.getManifestParserFactory = function() {\n  return this.parser_ ? this.parser_.constructor : null;\n};\n\n\n/**\n * @param {shaka.extern.Period} period\n * @param {shaka.extern.Variant} variant\n * @param {boolean} fromAdaptation\n * @private\n */\nshaka.Player.prototype.addVariantToSwitchHistory_ = function(\n    period, variant, fromAdaptation) {\n  this.activeStreams_.useVariant(period, variant);\n  this.stats_.getSwitchHistory().updateCurrentVariant(variant, fromAdaptation);\n};\n\n\n/**\n * @param {shaka.extern.Period} period\n * @param {shaka.extern.Stream} textStream\n * @param {boolean} fromAdaptation\n * @private\n */\nshaka.Player.prototype.addTextStreamToSwitchHistory_ = function(\n    period, textStream, fromAdaptation) {\n  this.activeStreams_.useText(period, textStream);\n  this.stats_.getSwitchHistory().updateCurrentText(textStream, fromAdaptation);\n};\n\n\n/**\n * @return {shaka.extern.PlayerConfiguration}\n * @private\n */\nshaka.Player.prototype.defaultConfig_ = function() {\n  const config = shaka.util.PlayerConfiguration.createDefault();\n\n  config.streaming.failureCallback = (error) => {\n    this.defaultStreamingFailureCallback_(error);\n  };\n\n  // Because this.video_ may not be set when the config is built, the default\n  // TextDisplay factory must capture a reference to \"this\" as \"self\" to use at\n  // the time we call the factory.  Bind can't be used here because we call the\n  // factory with \"new\", effectively removing any binding to \"this\".\n  const self = this;\n  config.textDisplayFactory = function() {\n    return new shaka.text.SimpleTextDisplayer(self.video_);\n  };\n\n  return config;\n};\n\n\n/**\n * @param {!shaka.util.Error} error\n * @private\n */\nshaka.Player.prototype.defaultStreamingFailureCallback_ = function(error) {\n  let retryErrorCodes = [\n    shaka.util.Error.Code.BAD_HTTP_STATUS,\n    shaka.util.Error.Code.HTTP_ERROR,\n    shaka.util.Error.Code.TIMEOUT,\n  ];\n\n  if (this.isLive() && retryErrorCodes.includes(error.code)) {\n    error.severity = shaka.util.Error.Severity.RECOVERABLE;\n\n    shaka.log.warning('Live streaming error.  Retrying automatically...');\n    this.retryStreaming();\n  }\n};\n\n\n/**\n * For CEA closed captions embedded in the video streams, create dummy text\n * stream.\n * @param {!Array.<!shaka.extern.Period>} periods\n * @private\n */\nshaka.Player.prototype.createTextStreamsForClosedCaptions_ = function(periods) {\n  const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n  for (let periodIndex = 0; periodIndex < periods.length; periodIndex++) {\n    const period = periods[periodIndex];\n    // A map of the closed captions id and the new dummy text stream.\n    let closedCaptionsMap = new Map();\n    for (let variant of period.variants) {\n      if (variant.video && variant.video.closedCaptions) {\n        let video = variant.video;\n        for (const id of video.closedCaptions.keys()) {\n          if (!closedCaptionsMap.has(id)) {\n            let textStream = {\n              id: this.nextExternalStreamId_++,  // A globally unique ID.\n              originalId: id, // The CC ID string, like 'CC1', 'CC3', etc.\n              createSegmentIndex: Promise.resolve.bind(Promise),\n              findSegmentPosition: (time) => { return null; },\n              getSegmentReference: (ref) => { return null; },\n              initSegmentReference: null,\n              presentationTimeOffset: 0,\n              mimeType: shaka.util.MimeUtils.CLOSED_CAPTION_MIMETYPE,\n              codecs: '',\n              kind:\n                  shaka.util.ManifestParserUtils.TextStreamKind.CLOSED_CAPTION,\n              encrypted: false,\n              keyId: null,\n              language: video.closedCaptions.get(id),\n              label: null,\n              type: ContentType.TEXT,\n              primary: false,\n              trickModeVideo: null,\n              emsgSchemeIdUris: null,\n              roles: video.roles,\n              channelsCount: null,\n              closedCaptions: null,\n            };\n            closedCaptionsMap.set(id, textStream);\n          }\n        }\n      }\n    }\n    for (const textStream of closedCaptionsMap.values()) {\n      period.textStreams.push(textStream);\n    }\n  }\n};\n\n\n/**\n * Filters a list of periods.\n * @param {!Array.<!shaka.extern.Period>} periods\n * @private\n */\nshaka.Player.prototype.filterAllPeriods_ = function(periods) {\n  goog.asserts.assert(this.video_, 'Must not be destroyed');\n  const ArrayUtils = shaka.util.ArrayUtils;\n  const StreamUtils = shaka.util.StreamUtils;\n\n  /** @type {?shaka.extern.Stream} */\n  let activeAudio =\n      this.streamingEngine_ ? this.streamingEngine_.getBufferingAudio() : null;\n  /** @type {?shaka.extern.Stream} */\n  let activeVideo =\n      this.streamingEngine_ ? this.streamingEngine_.getBufferingVideo() : null;\n\n  let filterPeriod = StreamUtils.filterNewPeriod.bind(\n      null, this.drmEngine_, activeAudio, activeVideo);\n  periods.forEach(filterPeriod);\n\n  let validPeriodsCount = ArrayUtils.count(periods, function(period) {\n    return period.variants.some(StreamUtils.isPlayable);\n  });\n\n  // If none of the periods are playable, throw CONTENT_UNSUPPORTED_BY_BROWSER.\n  if (validPeriodsCount == 0) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.CONTENT_UNSUPPORTED_BY_BROWSER);\n  }\n\n  // If only some of the periods are playable, throw UNPLAYABLE_PERIOD.\n  if (validPeriodsCount < periods.length) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.UNPLAYABLE_PERIOD);\n  }\n\n  periods.forEach(function(period) {\n    let tracksChanged = shaka.util.StreamUtils.applyRestrictions(\n        period.variants, this.config_.restrictions, this.maxHwRes_);\n    if (tracksChanged && this.streamingEngine_ &&\n        this.getPresentationPeriod_() == period) {\n      this.onTracksChanged_();\n    }\n\n    this.checkRestrictedVariants_(period.variants);\n  }.bind(this));\n};\n\n\n/**\n * Filters a new period.\n * @param {shaka.extern.Period} period\n * @private\n */\nshaka.Player.prototype.filterNewPeriod_ = function(period) {\n  goog.asserts.assert(this.video_, 'Must not be destroyed');\n  const StreamUtils = shaka.util.StreamUtils;\n\n  /** @type {?shaka.extern.Stream} */\n  let activeAudio =\n      this.streamingEngine_ ? this.streamingEngine_.getBufferingAudio() : null;\n  /** @type {?shaka.extern.Stream} */\n  let activeVideo =\n      this.streamingEngine_ ? this.streamingEngine_.getBufferingVideo() : null;\n\n  StreamUtils.filterNewPeriod(\n      this.drmEngine_, activeAudio, activeVideo, period);\n\n  /** @type {!Array.<shaka.extern.Variant>} */\n  let variants = period.variants;\n\n  // Check for playable variants before restrictions, so that we can give a\n  // special error when there were tracks but they were all filtered.\n  const hasPlayableVariant = variants.some(StreamUtils.isPlayable);\n  if (!hasPlayableVariant) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.UNPLAYABLE_PERIOD);\n  }\n\n  this.checkRestrictedVariants_(period.variants);\n\n  const tracksChanged = shaka.util.StreamUtils.applyRestrictions(\n      variants, this.config_.restrictions, this.maxHwRes_);\n\n  // Trigger the track change event if the restrictions now prevent use from\n  // using a variant that we previously thought we could use.\n  if (tracksChanged && this.streamingEngine_ &&\n      this.getPresentationPeriod_() == period) {\n    this.onTracksChanged_();\n  }\n\n  // For new Periods, we may need to create new sessions for any new init data.\n  const curDrmInfo = this.drmEngine_ ? this.drmEngine_.getDrmInfo() : null;\n  if (curDrmInfo) {\n    for (const variant of variants) {\n      for (const drmInfo of variant.drmInfos) {\n        // Ignore any data for different key systems.\n        if (drmInfo.keySystem == curDrmInfo.keySystem) {\n          for (const initData of (drmInfo.initData || [])) {\n            this.drmEngine_.newInitData(\n                initData.initDataType, initData.initData);\n          }\n        }\n      }\n    }\n  }\n};\n\n\n/**\n * Switches to the given variant, deferring if needed.\n * @param {shaka.extern.Variant} variant\n * @param {boolean=} clearBuffer\n * @param {number=} safeMargin\n * @private\n */\nshaka.Player.prototype.switchVariant_ =\n    function(variant, clearBuffer = false, safeMargin = 0) {\n  if (this.switchingPeriods_) {\n    // Store this action for later.\n    this.deferredVariant_ = variant;\n    this.deferredVariantClearBuffer_ = clearBuffer;\n    this.deferredVariantClearBufferSafeMargin_ = safeMargin;\n  } else {\n    // Act now.\n    this.streamingEngine_.switchVariant(variant, clearBuffer, safeMargin);\n    // Dispatch a 'variantchanged' event\n    this.onVariantChanged_();\n  }\n};\n\n\n/**\n * Switches to the given text stream, deferring if needed.\n * @param {shaka.extern.Stream} textStream\n * @private\n */\nshaka.Player.prototype.switchTextStream_ = function(textStream) {\n  if (this.switchingPeriods_) {\n    // Store this action for later.\n    this.deferredTextStream_ = textStream;\n  } else {\n    // Act now.\n    this.streamingEngine_.switchTextStream(textStream);\n    this.onTextChanged_();\n  }\n};\n\n\n/**\n * Verifies that the active streams according to the player match those in\n * StreamingEngine.\n * @private\n */\nshaka.Player.prototype.assertCorrectActiveStreams_ = function() {\n  if (!this.streamingEngine_ || !this.manifest_ || !goog.DEBUG) return;\n\n  const activePeriod = this.streamingEngine_.getBufferingPeriod();\n  /** @type {shaka.extern.Period} */\n  const currentPeriod = this.getPresentationPeriod_();\n  if (activePeriod == null || activePeriod != currentPeriod) {\n    return;\n  }\n\n  let activeAudio = this.streamingEngine_.getBufferingAudio();\n  let activeVideo = this.streamingEngine_.getBufferingVideo();\n  let activeText = this.streamingEngine_.getBufferingText();\n\n  // If we have deferred variants/text we want to compare against those rather\n  // than what we are actually streaming.\n  const expectedAudio = this.deferredVariant_ ?\n                        this.deferredVariant_.audio :\n                        activeAudio;\n\n  const expectedVideo = this.deferredVariant_ ?\n                        this.deferredVariant_.video :\n                        activeVideo;\n\n  const expectedText = this.deferredTextStream_ || activeText;\n\n  const actualVariant = this.activeStreams_.getVariant(currentPeriod);\n  const actualText = this.activeStreams_.getText(currentPeriod);\n\n  goog.asserts.assert(\n      actualVariant.audio == expectedAudio,\n      'Inconsistent active audio stream');\n  goog.asserts.assert(\n      actualVariant.video == expectedVideo,\n      'Inconsistent active video stream');\n\n  // Because we always set a text stream to be active in the active stream map,\n  // regardless of whether or not we are actually streaming text, it is possible\n  // for these to be out of line.\n  goog.asserts.assert(\n      expectedText == null || actualText == expectedText,\n      'Inconsistent active text stream');\n};\n\n\n/**\n * @param {number} time\n * @return {number}\n * @private\n */\nshaka.Player.prototype.adjustStartTime_ = function(time) {\n  /** @type {?shaka.extern.Stream} */\n  let activeAudio = this.streamingEngine_.getBufferingAudio();\n  /** @type {?shaka.extern.Stream} */\n  let activeVideo = this.streamingEngine_.getBufferingVideo();\n  /** @type {shaka.extern.Period} */\n  let period = this.getPresentationPeriod_();\n\n  // This method is called after StreamingEngine.init resolves, which means that\n  // all the active streams have had createSegmentIndex called.\n  function getAdjustedTime(stream, time) {\n    if (!stream) return null;\n    let idx = stream.findSegmentPosition(time - period.startTime);\n    if (idx == null) return null;\n    let ref = stream.getSegmentReference(idx);\n    if (!ref) return null;\n    let refTime = ref.startTime + period.startTime;\n    goog.asserts.assert(refTime <= time, 'Segment should start before time');\n    return refTime;\n  }\n\n  let audioStartTime = getAdjustedTime(activeAudio, time);\n  let videoStartTime = getAdjustedTime(activeVideo, time);\n\n  // If we have both video and audio times, pick the larger one.  If we picked\n  // the smaller one, that one will download an entire segment to buffer the\n  // difference.\n  if (videoStartTime != null && audioStartTime != null) {\n    return Math.max(videoStartTime, audioStartTime);\n  } else if (videoStartTime != null) {\n    return videoStartTime;\n  } else if (audioStartTime != null) {\n    return audioStartTime;\n  } else {\n    return time;\n  }\n};\n\n\n/**\n * Update the buffering state to be either \"we are buffering\" or \"we are not\n * buffering\", firing events to the app as needed.\n *\n * @private\n */\nshaka.Player.prototype.updateBufferState_ = function() {\n  const isBuffering = this.isBuffering();\n\n  // Make sure we have all the components we need before we consider ourselves\n  // as being loaded.\n  // TODO: Make the check for \"loaded\" simpler.\n  const loaded = this.stats_ && this.bufferObserver_ && this.playhead_;\n\n  if (loaded) {\n    this.playRateController_.setBuffering(isBuffering);\n    this.updateStateHistory_();\n  }\n\n  // Surface the buffering event so that the app knows if/when we are buffering.\n  let event = new shaka.util.FakeEvent('buffering', {'buffering': isBuffering});\n  this.dispatchEvent(event);\n};\n\n\n/**\n * Callback from PlayheadObserver.\n * @private\n */\nshaka.Player.prototype.onChangePeriod_ = function() {\n  this.onTracksChanged_();\n};\n\n\n/**\n * A callback for when the playback rate changes. We need to watch the playback\n * rate so that if the playback rate on the media element changes (that was not\n * caused by our play rate controller) we can notify the controller so that it\n * can stay in-sync with the change.\n *\n * @private\n */\nshaka.Player.prototype.onRateChange_ = function() {\n  /** @type {number} */\n  const newRate = this.video_.playbackRate;\n\n  // On Edge, when someone seeks using the native controls, it will set the\n  // playback rate to zero until they finish seeking, after which it will\n  // return the playback rate.\n  //\n  // If the playback rate changes while seeking, Edge will cache the playback\n  // rate and use it after seeking.\n  //\n  // https://github.com/google/shaka-player/issues/951\n  if (newRate == 0) {\n    return;\n  }\n\n  // The playback rate has changed. This could be us or someone else.\n  // If this was us, setting the rate again will be a no-op.\n  this.playRateController_.set(newRate);\n};\n\n\n/**\n * Try updating the state history. If the player has not finished initializing,\n * this will be a no-op.\n *\n * @private\n */\nshaka.Player.prototype.updateStateHistory_ = function() {\n  // If we have not finish initializing, this will be a no-op.\n  if (!this.stats_) { return; }\n  if (!this.bufferObserver_) { return; }\n\n  const State = shaka.media.BufferingObserver.State;\n\n  const history = this.stats_.getStateHistory();\n\n  if (this.bufferObserver_.getState() == State.STARVING) {\n    history.update('buffering');\n  } else if (this.video_.paused) {\n    history.update('paused');\n  } else if (this.video_.ended) {\n    history.update('ended');\n  } else {\n    history.update('playing');\n  }\n};\n\n\n/**\n * Callback from Playhead.\n *\n * @private\n */\nshaka.Player.prototype.onSeek_ = function() {\n  if (this.playheadObservers_) {\n    this.playheadObservers_.notifyOfSeek();\n  }\n  if (this.streamingEngine_) {\n    this.streamingEngine_.seeked();\n  }\n};\n\n\n/**\n * Chooses a variant from all possible variants while taking into account\n * restrictions, preferences, and ABR.\n *\n * On error, this dispatches an error event and returns null.\n *\n * @param {!Array.<shaka.extern.Variant>} allVariants\n * @return {?shaka.extern.Variant}\n * @private\n */\nshaka.Player.prototype.chooseVariant_ = function(allVariants) {\n  goog.asserts.assert(this.config_, 'Must not be destroyed');\n\n  try {\n    // |variants| are the filtered variants, use |period.variants| so we know\n    // why they we restricted.\n    this.checkRestrictedVariants_(allVariants);\n  } catch (e) {\n    this.onError_(e);\n    return null;\n  }\n\n  goog.asserts.assert(\n      allVariants.length, 'Should have thrown for no Variants.');\n\n  const playableVariants = allVariants.filter((variant) => {\n    return shaka.util.StreamUtils.isPlayable(variant);\n  });\n\n  // Update the abr manager with newly filtered variants.\n  const adaptationSet = this.currentAdaptationSetCriteria_.create(\n      playableVariants);\n  this.abrManager_.setVariants(Array.from(adaptationSet.values()));\n  return this.abrManager_.chooseVariant();\n};\n\n\n/**\n * Choose a text stream from all possible text streams while taking into\n * account user preference.\n *\n * @param {!Array.<shaka.extern.Stream>} textStreams\n * @return {?shaka.extern.Stream}\n * @private\n */\nshaka.Player.prototype.chooseTextStream_ = function(textStreams) {\n  const subset = shaka.util.StreamUtils.filterStreamsByLanguageAndRole(\n      textStreams,\n      this.currentTextLanguage_,\n      this.currentTextRole_);\n\n  return subset[0] || null;\n};\n\n\n/**\n * Chooses streams from the given Period and switches to them.\n * Called after a config change, a new text stream, a key status event, or an\n * explicit language change.\n *\n * @param {!shaka.extern.Period} period\n * @private\n */\nshaka.Player.prototype.chooseStreamsAndSwitch_ = function(period) {\n  goog.asserts.assert(this.config_, 'Must not be destroyed');\n\n  // Because we're running this after a config change (manual language change),\n  // a new text stream, or a key status event, and because switching to an\n  // active stream is a no-op, it is always okay to clear the buffer here.\n  const chosenVariant = this.chooseVariant_(period.variants);\n  if (chosenVariant) {\n    this.addVariantToSwitchHistory_(\n        period, chosenVariant, /* fromAdaptation= */ true);\n    this.switchVariant_(chosenVariant, /* clearBuffers */ true);\n  }\n\n  // Only switch text if we should be streaming text right now.\n  const chosenText = this.chooseTextStream_(period.textStreams);\n  if (chosenText && this.shouldStreamText_()) {\n    this.addTextStreamToSwitchHistory_(\n      period, chosenText, /* fromAdaptation= */ true);\n    this.switchTextStream_(chosenText);\n  }\n\n  // Send an adaptation event so that the UI can show the new language/tracks.\n  this.onAdaptation_();\n};\n\n\n/**\n * Callback from StreamingEngine, invoked when a period starts. This method\n * must always \"succeed\" so it may not throw an error. Any errors must be\n * routed to |onError|.\n *\n * @param {!shaka.extern.Period} period\n * @return {shaka.media.StreamingEngine.ChosenStreams}\n *    An object containing the chosen variant and text stream.\n * @private\n */\nshaka.Player.prototype.onChooseStreams_ = function(period) {\n  shaka.log.debug('onChooseStreams_', period);\n\n  goog.asserts.assert(this.config_, 'Must not be destroyed');\n\n  try {\n    shaka.log.v2('onChooseStreams_, choosing variant from ', period.variants);\n    shaka.log.v2('onChooseStreams_, choosing text from ', period.textStreams);\n\n    const chosen = this.chooseStreams_(period);\n\n    shaka.log.v2('onChooseStreams_, chose variant ', chosen.variant);\n    shaka.log.v2('onChooseStreams_, chose text ', chosen.text);\n\n    return chosen;\n  } catch (e) {\n    this.onError_(e);\n    return {variant: null, text: null};\n  }\n};\n\n\n/**\n * This is the internal logic for |onChooseStreams_|. This separation is done\n * to allow this implementation to throw errors without consequence.\n *\n * @param {shaka.extern.Period} period\n *    The period that we are selecting streams from.\n * @return {shaka.media.StreamingEngine.ChosenStreams}\n *    An object containing the chosen variant and text stream.\n * @private\n */\nshaka.Player.prototype.chooseStreams_ = function(period) {\n  // We are switching Periods, so the AbrManager will be disabled.  But if we\n  // want to abr.enabled, we do not want to call AbrManager.enable before\n  // canSwitch_ is called.\n  this.switchingPeriods_ = true;\n  this.abrManager_.disable();\n  this.onAbrStatusChanged_();\n\n  shaka.log.debug('Choosing new streams after period changed');\n\n  let chosenVariant = this.chooseVariant_(period.variants);\n  let chosenText = this.chooseTextStream_(period.textStreams);\n\n  // Ignore deferred variant or text streams only if we are starting a new\n  // period.  In this case, any deferred switches were from an older period, so\n  // they do not apply.  We can still have deferred switches from the current\n  // period in the case of an early call to select*Track while we are setting up\n  // the first period.  This can happen with the 'streaming' event.\n  if (this.deferredVariant_) {\n    if (period.variants.includes(this.deferredVariant_)) {\n      chosenVariant = this.deferredVariant_;\n    }\n    this.deferredVariant_ = null;\n  }\n\n  if (this.deferredTextStream_) {\n    if (period.textStreams.includes(this.deferredTextStream_)) {\n      chosenText = this.deferredTextStream_;\n    }\n    this.deferredTextStream_ = null;\n  }\n\n  if (chosenVariant) {\n    this.addVariantToSwitchHistory_(\n        period, chosenVariant, /* fromAdaptation= */ true);\n  }\n\n  if (chosenText) {\n    this.addTextStreamToSwitchHistory_(\n        period, chosenText, /* fromAdaptation= */ true);\n  }\n\n  // Check if we should show text (based on difference between audio and text\n  // languages). Only check this during startup so we don't \"pop-up\" captions\n  // mid playback.\n  const startingUp = !this.streamingEngine_.getBufferingPeriod();\n  const chosenAudio = chosenVariant ? chosenVariant.audio : null;\n  if (startingUp && chosenText) {\n    if (chosenAudio && this.shouldShowText_(chosenAudio, chosenText)) {\n      this.isTextVisible_ = true;\n    }\n    if (this.isTextVisible_) {\n      // If the cached value says to show text, then update the text displayer\n      // since it defaults to not shown.  Note that returning the |chosenText|\n      // below will make StreamingEngine stream the text.\n      this.mediaSourceEngine_.getTextDisplayer().setTextVisibility(true);\n      goog.asserts.assert(this.shouldStreamText_(), 'Should be streaming text');\n    }\n    this.onTextTrackVisibility_();\n  }\n\n  // Don't fire a tracks-changed event since we aren't inside the new Period\n  // yet.\n  // Don't initialize with a text stream unless we should be streaming text.\n  if (this.shouldStreamText_()) {\n    return {variant: chosenVariant, text: chosenText};\n  } else {\n    return {variant: chosenVariant, text: null};\n  }\n};\n\n\n/**\n * Check if we should show text on screen automatically.\n *\n * The text should automatically be shown if the text is language-compatible\n * with the user's text language preference, but not compatible with the audio.\n *\n * For example:\n *   preferred | chosen | chosen |\n *   text      | text   | audio  | show\n *   -----------------------------------\n *   en-CA     | en     | jp     | true\n *   en        | en-US  | fr     | true\n *   fr-CA     | en-US  | jp     | false\n *   en-CA     | en-US  | en-US  | false\n *\n * @param {shaka.extern.Stream} audioStream\n * @param {shaka.extern.Stream} textStream\n * @return {boolean}\n * @private\n */\nshaka.Player.prototype.shouldShowText_ = function(audioStream, textStream) {\n  const LanguageUtils = shaka.util.LanguageUtils;\n\n  /** @type {string} */\n  const preferredTextLocale =\n      LanguageUtils.normalize(this.config_.preferredTextLanguage);\n  /** @type {string} */\n  const audioLocale = LanguageUtils.normalize(audioStream.language);\n  /** @type {string} */\n  const textLocale = LanguageUtils.normalize(textStream.language);\n\n  return LanguageUtils.areLanguageCompatible(textLocale, preferredTextLocale) &&\n         !LanguageUtils.areLanguageCompatible(audioLocale, textLocale);\n};\n\n\n/**\n * Callback from StreamingEngine, invoked when the period is set up.\n *\n * @private\n */\nshaka.Player.prototype.canSwitch_ = function() {\n  shaka.log.debug('canSwitch_');\n  goog.asserts.assert(this.config_, 'Must not be destroyed');\n\n  this.switchingPeriods_ = false;\n\n  if (this.config_.abr.enabled) {\n    this.abrManager_.enable();\n    this.onAbrStatusChanged_();\n  }\n\n  // If we still have deferred switches, switch now.\n  if (this.deferredVariant_) {\n    this.streamingEngine_.switchVariant(\n        this.deferredVariant_, this.deferredVariantClearBuffer_,\n        this.deferredVariantClearBufferSafeMargin_);\n    this.onVariantChanged_();\n    this.deferredVariant_ = null;\n  }\n  if (this.deferredTextStream_) {\n    this.streamingEngine_.switchTextStream(this.deferredTextStream_);\n    this.onTextChanged_();\n    this.deferredTextStream_ = null;\n  }\n};\n\n\n/**\n * Callback from StreamingEngine.\n *\n * @private\n */\nshaka.Player.prototype.onManifestUpdate_ = function() {\n  if (this.parser_ && this.parser_.update) {\n    this.parser_.update();\n  }\n};\n\n\n/**\n * Callback from StreamingEngine.\n *\n * @private\n */\nshaka.Player.prototype.onSegmentAppended_ = function() {\n  // When we append a segment to media source (via streaming engine) we are\n  // changing what data we have buffered, so notify the playhead of the change.\n  if (this.playhead_) {\n    this.playhead_.notifyOfBufferingChange();\n  }\n};\n\n\n/**\n * Callback from AbrManager.\n *\n * @param {shaka.extern.Variant} variant\n * @param {boolean=} clearBuffer\n * @param {number=} safeMargin Optional amount of buffer (in seconds) to retain\n *   when clearing the buffer.\n *   Defaults to 0 if not provided. Ignored if clearBuffer is false.\n * @private\n */\nshaka.Player.prototype.switch_ = function(\n    variant, clearBuffer = false, safeMargin = 0) {\n  shaka.log.debug('switch_');\n  goog.asserts.assert(this.config_.abr.enabled,\n      'AbrManager should not call switch while disabled!');\n  goog.asserts.assert(!this.switchingPeriods_,\n      'AbrManager should not call switch while transitioning between Periods!');\n  goog.asserts.assert(this.manifest_, 'We need a manifest to switch variants.');\n\n  const period = this.findPeriodWithVariant_(variant);\n  goog.asserts.assert(period, 'A period should contain the variant.');\n\n  this.addVariantToSwitchHistory_(period, variant, /* fromAdaptation */ true);\n\n  if (!this.streamingEngine_) {\n    // There's no way to change it.\n    return;\n  }\n\n  this.streamingEngine_.switchVariant(variant, clearBuffer, safeMargin);\n  this.onAdaptation_();\n};\n\n\n/**\n * Dispatches an 'adaptation' event.\n * @private\n */\nshaka.Player.prototype.onAdaptation_ = function() {\n  // Delay the 'adaptation' event so that StreamingEngine has time to absorb\n  // the changes before the user tries to query it.\n  this.delayDispatchEvent_(new shaka.util.FakeEvent('adaptation'));\n};\n\n\n/**\n * Dispatches a 'trackschanged' event.\n * @private\n */\nshaka.Player.prototype.onTracksChanged_ = function() {\n  // Delay the 'trackschanged' event so StreamingEngine has time to absorb the\n  // changes before the user tries to query it.\n  this.delayDispatchEvent_(new shaka.util.FakeEvent('trackschanged'));\n};\n\n\n/**\n * Dispatches a 'variantchanged' event.\n * @private\n */\nshaka.Player.prototype.onVariantChanged_ = function() {\n  // Delay the 'variantchanged' event so StreamingEngine has time to absorb the\n  // changes before the user tries to query it.\n  this.delayDispatchEvent_(new shaka.util.FakeEvent('variantchanged'));\n};\n\n\n/**\n * Dispatches a 'textchanged' event.\n * @private\n */\nshaka.Player.prototype.onTextChanged_ = function() {\n  // Delay the 'textchanged' event so StreamingEngine time to absorb the\n  // changes before the user tries to query it.\n  this.delayDispatchEvent_(new shaka.util.FakeEvent('textchanged'));\n};\n\n\n/** @private */\nshaka.Player.prototype.onTextTrackVisibility_ = function() {\n  this.delayDispatchEvent_(new shaka.util.FakeEvent('texttrackvisibility'));\n};\n\n\n/** @private */\nshaka.Player.prototype.onAbrStatusChanged_ = function() {\n  this.delayDispatchEvent_(new shaka.util.FakeEvent('abrstatuschanged', {\n    newStatus: this.config_.abr.enabled,\n  }));\n};\n\n\n/**\n * @param {!shaka.util.Error} error\n * @private\n */\nshaka.Player.prototype.onError_ = function(error) {\n  goog.asserts.assert(error instanceof shaka.util.Error, 'Wrong error type!');\n\n  // Errors dispatched after |destroy| is called are not meaningful and should\n  // be safe to ignore.\n  if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) { return; }\n\n  let event = new shaka.util.FakeEvent('error', {'detail': error});\n  this.dispatchEvent(event);\n  if (event.defaultPrevented) {\n    error.handled = true;\n  }\n};\n\n\n/**\n * When we fire region events, we need to copy the information out of the region\n * to break the connection with the player's internal data. We do the copy here\n * because this is the transition point between the player and the app.\n *\n * @param {string} eventName\n * @param {shaka.extern.TimelineRegionInfo} region\n *\n * @private\n */\nshaka.Player.prototype.onRegionEvent_ = function(eventName, region) {\n  // Always make a copy to avoid exposing our internal data to the app.\n  const clone = {\n    schemeIdUri: region.schemeIdUri,\n    value: region.value,\n    startTime: region.startTime,\n    endTime: region.endTime,\n    id: region.id,\n    eventElement: region.eventElement,\n  };\n\n  this.dispatchEvent(new shaka.util.FakeEvent(eventName, {detail: clone}));\n};\n\n\n/**\n * Turn the media element's error object into a Shaka Player error object.\n *\n * @return {shaka.util.Error}\n * @private\n */\nshaka.Player.prototype.videoErrorToShakaError_ = function() {\n  goog.asserts.assert(this.video_.error, 'Video error expected, but missing!');\n  if (!this.video_.error) {\n    return null;\n  }\n\n  const code = this.video_.error.code;\n  if (code == 1 /* MEDIA_ERR_ABORTED */) {\n    // Ignore this error code, which should only occur when navigating away or\n    // deliberately stopping playback of HTTP content.\n    return null;\n  }\n\n  // Extra error information from MS Edge and IE11:\n  let extended = this.video_.error.msExtendedCode;\n  if (extended) {\n    // Convert to unsigned:\n    if (extended < 0) {\n      extended += Math.pow(2, 32);\n    }\n    // Format as hex:\n    extended = extended.toString(16);\n  }\n\n  // Extra error information from Chrome:\n  const message = this.video_.error.message;\n\n  return new shaka.util.Error(\n      shaka.util.Error.Severity.CRITICAL,\n      shaka.util.Error.Category.MEDIA,\n      shaka.util.Error.Code.VIDEO_ERROR,\n      code, extended, message);\n};\n\n\n/**\n * @param {!Event} event\n * @private\n */\nshaka.Player.prototype.onVideoError_ = function(event) {\n  const error = this.videoErrorToShakaError_();\n  if (!error) {\n    return;\n  }\n  this.onError_(error);\n};\n\n\n/**\n * @param {!Object.<string, string>} keyStatusMap A map of hex key IDs to\n *   statuses.\n * @private\n */\nshaka.Player.prototype.onKeyStatus_ = function(keyStatusMap) {\n  if (!this.streamingEngine_) {\n    // We can't use this info to manage restrictions in src= mode, so ignore it.\n    return;\n  }\n\n  const restrictedStatuses = shaka.Player.restrictedStatuses_;\n\n  /** @type {shaka.extern.Period} */\n  const period = this.getPresentationPeriod_();\n  let tracksChanged = false;\n\n  let keyIds = Object.keys(keyStatusMap);\n  if (keyIds.length == 0) {\n    shaka.log.warning(\n        'Got a key status event without any key statuses, so we don\\'t know ' +\n        'the real key statuses. If we don\\'t have all the keys, you\\'ll need ' +\n        'to set restrictions so we don\\'t select those tracks.');\n  }\n\n  // If EME is using a synthetic key ID, the only key ID is '00' (a single 0\n  // byte).  In this case, it is only used to report global success/failure.\n  // See note about old platforms in: https://bit.ly/2tpez5Z\n  let isGlobalStatus = keyIds.length == 1 && keyIds[0] == '00';\n\n  if (isGlobalStatus) {\n    shaka.log.warning(\n        'Got a synthetic key status event, so we don\\'t know the real key ' +\n        'statuses. If we don\\'t have all the keys, you\\'ll need to set ' +\n        'restrictions so we don\\'t select those tracks.');\n  }\n\n  // Only filter tracks for keys if we have some key statuses to look at.\n  if (keyIds.length) {\n    period.variants.forEach(function(variant) {\n      const streams = shaka.util.StreamUtils.getVariantStreams(variant);\n\n      streams.forEach(function(stream) {\n        let originalAllowed = variant.allowedByKeySystem;\n\n        // Only update if we have a key ID for the stream.\n        // If the key isn't present, then we don't have that key and the track\n        // should be restricted.\n        if (stream.keyId) {\n          let keyStatus = keyStatusMap[isGlobalStatus ? '00' : stream.keyId];\n          variant.allowedByKeySystem =\n              !!keyStatus && !restrictedStatuses.includes(keyStatus);\n        }\n\n        if (originalAllowed != variant.allowedByKeySystem) {\n          tracksChanged = true;\n        }\n      });  // streams.forEach\n    });  // period.variants.forEach\n  }  // if (keyIds.length)\n\n  // TODO: Get StreamingEngine to track variants and create\n  // getBufferingVariant()\n  let activeAudio = this.streamingEngine_.getBufferingAudio();\n  let activeVideo = this.streamingEngine_.getBufferingVideo();\n  let activeVariant = shaka.util.StreamUtils.getVariantByStreams(\n      activeAudio, activeVideo, period.variants);\n\n  if (activeVariant && !activeVariant.allowedByKeySystem) {\n    shaka.log.debug('Choosing new streams after key status changed');\n    this.chooseStreamsAndSwitch_(period);\n  }\n\n  if (tracksChanged) {\n    this.onTracksChanged_();\n    this.chooseVariant_(period.variants);\n  }\n};\n\n\n/**\n * Callback from DrmEngine\n * @param {string} keyId\n * @param {number} expiration\n * @private\n */\nshaka.Player.prototype.onExpirationUpdated_ = function(keyId, expiration) {\n  if (this.parser_ && this.parser_.onExpirationUpdated) {\n    this.parser_.onExpirationUpdated(keyId, expiration);\n  }\n\n  let event = new shaka.util.FakeEvent('expirationupdated');\n  this.dispatchEvent(event);\n};\n\n/**\n * @return {boolean} true if we should stream text right now.\n * @private\n */\nshaka.Player.prototype.shouldStreamText_ = function() {\n  return this.config_.streaming.alwaysStreamText || this.isTextTrackVisible();\n};\n\n\n/**\n * Applies playRangeStart and playRangeEnd to the given timeline. This will\n * only affect non-live content.\n *\n * @param {shaka.media.PresentationTimeline} timeline\n * @param {number} playRangeStart\n * @param {number} playRangeEnd\n *\n * @private\n */\nshaka.Player.applyPlayRange_ = function(timeline,\n                                        playRangeStart,\n                                        playRangeEnd) {\n  if (playRangeStart > 0) {\n    if (timeline.isLive()) {\n      shaka.log.warning(\n          '|playRangeStart| has been configured for live content. ' +\n          'Ignoring the setting.');\n    } else {\n      timeline.setUserSeekStart(playRangeStart);\n    }\n  }\n\n  // If the playback has been configured to end before the end of the\n  // presentation, update the duration unless it's live content.\n  const fullDuration = timeline.getDuration();\n  if (playRangeEnd < fullDuration) {\n    if (timeline.isLive()) {\n      shaka.log.warning(\n          '|playRangeEnd| has been configured for live content. ' +\n          'Ignoring the setting.');\n    } else {\n      timeline.setDuration(playRangeEnd);\n    }\n  }\n};\n\n\n/**\n * Checks the given variants and if they are all restricted, throw an\n * appropriate exception.\n *\n * @param {!Array.<shaka.extern.Variant>} variants\n * @private\n */\nshaka.Player.prototype.checkRestrictedVariants_ = function(variants) {\n  const restrictedStatuses = shaka.Player.restrictedStatuses_;\n  const keyStatusMap = this.drmEngine_ ? this.drmEngine_.getKeyStatuses() : {};\n  const keyIds = Object.keys(keyStatusMap);\n  const isGlobalStatus = keyIds.length && keyIds[0] == '00';\n\n  let hasPlayable = false;\n  let hasAppRestrict = false;\n  let missingKeys = [];\n  let badKeyStatuses = [];\n\n  for (let variant of variants) {\n    // TODO: Combine with onKeyStatus_.\n    let streams = [];\n    if (variant.audio) streams.push(variant.audio);\n    if (variant.video) streams.push(variant.video);\n\n    for (let stream of streams) {\n      if (stream.keyId) {\n        let keyStatus = keyStatusMap[isGlobalStatus ? '00' : stream.keyId];\n        if (!keyStatus) {\n          if (!missingKeys.includes(stream.keyId)) {\n            missingKeys.push(stream.keyId);\n          }\n        } else if (restrictedStatuses.includes(keyStatus)) {\n          if (!badKeyStatuses.includes(keyStatus)) {\n            badKeyStatuses.push(keyStatus);\n          }\n        }\n      }\n    }\n\n    if (!variant.allowedByApplication) {\n      hasAppRestrict = true;\n    } else if (variant.allowedByKeySystem) {\n      hasPlayable = true;\n    }\n  }\n\n  if (!hasPlayable) {\n    /** @type {shaka.extern.RestrictionInfo} */\n    let data = {\n      hasAppRestrictions: hasAppRestrict,\n      missingKeys: missingKeys,\n      restrictedKeyStatuses: badKeyStatuses,\n    };\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.RESTRICTIONS_CANNOT_BE_MET,\n        data);\n  }\n};\n\n\n/**\n * Fire an event, but wait a little bit so that the immediate execution can\n * complete before the event is handled.\n *\n * @param {!shaka.util.FakeEvent} event\n * @private\n */\nshaka.Player.prototype.delayDispatchEvent_ = async function(event) {\n  // Wait until the next interpreter cycle.\n  await Promise.resolve();\n\n  // Only dispatch the event if we are still alive.\n  if (this.loadMode_ != shaka.Player.LoadMode.DESTROYED) {\n    this.dispatchEvent(event);\n  }\n};\n\n/**\n * Get the normalized languages for a group of tracks.\n *\n * @param {!Array.<?shaka.extern.Track>} tracks\n * @return {!Set.<string>}\n * @private\n */\nshaka.Player.getLanguagesFrom_ = function(tracks) {\n  const languages = new Set();\n\n  for (const track of tracks) {\n    if (track.language) {\n      languages.add(shaka.util.LanguageUtils.normalize(track.language));\n    } else {\n      languages.add('und');\n    }\n  }\n\n  return languages;\n};\n\n\n/**\n * Get all permutations of normalized languages and role for a group of tracks.\n *\n * @param {!Array.<?shaka.extern.Track>} tracks\n * @return {!Array.<shaka.extern.LanguageRole>}\n * @private\n */\nshaka.Player.getLanguageAndRolesFrom_ = function(tracks) {\n  /** @type {!Map.<string, !Set>} */\n  const languageToRoles = new Map();\n\n  for (const track of tracks) {\n    let language = 'und';\n    let roles = [];\n\n    if (track.language) {\n      language = shaka.util.LanguageUtils.normalize(track.language);\n    }\n\n    if (track.type == 'variant') {\n      roles = track.audioRoles;\n    } else {\n      roles = track.roles;\n    }\n\n    if (!roles || !roles.length) {\n      // We must have an empty role so that we will still get a language-role\n      // entry from our Map.\n      roles = [''];\n    }\n\n    if (!languageToRoles.has(language)) {\n      languageToRoles.set(language, new Set());\n    }\n\n    for (const role of roles) {\n      languageToRoles.get(language).add(role);\n    }\n  }\n\n  // Flatten our map to an array of language-role pairs.\n  const pairings = [];\n  languageToRoles.forEach((roles, language) => {\n    for (const role of roles) {\n      pairings.push({\n        language: language,\n        role: role,\n      });\n    }\n  });\n  return pairings;\n};\n\n\n/**\n * Get the variants that the user can select. The variants will be based on\n * the period that the playhead is in and what variants are playable.\n *\n * @return {!Array.<shaka.extern.Variant>}\n * @private\n */\nshaka.Player.prototype.getSelectableVariants_ = function() {\n  // Use the period that is currently playing, allowing the change to affect\n  // the \"now\".\n  /** @type {shaka.extern.Period} */\n  const currentPeriod = this.getPresentationPeriod_();\n\n  // If we have been called before we load content or after we have unloaded\n  // content, then we should return no variants.\n  if (currentPeriod == null) { return []; }\n\n  this.assertCorrectActiveStreams_();\n\n  return currentPeriod.variants.filter((variant) => {\n    return shaka.util.StreamUtils.isPlayable(variant);\n  });\n};\n\n\n/**\n * Get the text streams that the user can select. The streams will be based on\n * the period that the playhead is in and what streams have finished loading.\n *\n * @return {!Array.<shaka.extern.Stream>}\n * @private\n */\nshaka.Player.prototype.getSelectableText_ = function() {\n  // Use the period that is currently playing, allowing the change to affect\n  // the \"now\".\n  /** @type {shaka.extern.Period} */\n  const currentPeriod = this.getPresentationPeriod_();\n\n  // If we have been called before we load content or after we have unloaded\n  // content, then we should return no streams.\n  if (currentPeriod == null) { return []; }\n\n  this.assertCorrectActiveStreams_();\n\n  // Don't show return streams that are still loading.\n  return currentPeriod.textStreams.filter((stream) => {\n    return !this.loadingTextStreams_.has(stream);\n  });\n};\n\n/**\n * Get the period that is on the screen. This will return |null| if nothing\n * is loaded.\n *\n * @return {shaka.extern.Period}\n * @private\n */\nshaka.Player.prototype.getPresentationPeriod_ = function() {\n  goog.asserts.assert(this.manifest_ && this.playhead_,\n      'Only ask for the presentation period when loaded with media source.');\n\n  const presentationTime = this.playhead_.getTime();\n\n  let lastPeriod = null;\n\n  // Periods are ordered by |startTime|. If we always keep the last period that\n  // started before our presentation time, it means we will have the best guess\n  // at which period we are presenting.\n  for (const period of this.manifest_.periods) {\n    if (period.startTime <= presentationTime) {\n      lastPeriod = period;\n    }\n  }\n\n  goog.asserts.assert(lastPeriod, 'Should have found a period.');\n  return lastPeriod;\n};\n\n\n/**\n * Get the variant that we are currently presenting to the user. If we are not\n * showing anything, then we will return |null|.\n *\n * @return {?shaka.extern.Variant}\n * @private\n */\nshaka.Player.prototype.getPresentationVariant_ = function() {\n  /** @type {shaka.extern.Period} */\n  const currentPeriod = this.getPresentationPeriod_();\n  return this.activeStreams_.getVariant(currentPeriod);\n};\n\n\n/**\n * Get the text stream that we are either currently presenting to the user or\n * will be presenting will captions are enabled. If we have no text to display,\n * this will return |null|.\n *\n * @return {?shaka.extern.Stream}\n * @private\n */\nshaka.Player.prototype.getPresentationText_ = function() {\n  /** @type {shaka.extern.Period} */\n  const currentPeriod = this.getPresentationPeriod_();\n\n  // Can't have a text stream when there is no period.\n  if (currentPeriod == null) { return null; }\n\n  // This is a workaround for the demo page to be able to display the list of\n  // text tracks. If no text track is currently active, pick  the one that's\\\n  // going to be streamed when captions are enabled and mark it as active.\n  if (!this.activeStreams_.getText(currentPeriod)) {\n    const textStreams = shaka.util.StreamUtils.filterStreamsByLanguageAndRole(\n        currentPeriod.textStreams,\n        this.currentTextLanguage_,\n        this.currentTextRole_);\n\n    if (textStreams.length) {\n      this.activeStreams_.useText(currentPeriod, textStreams[0]);\n    }\n  }\n\n  return this.activeStreams_.getText(currentPeriod);\n};\n\n\n/**\n * Assuming the player is playing content with media source, check if the player\n * has buffered enough content to make it to the end of the presentation.\n *\n * @return {boolean}\n * @private\n */\nshaka.Player.prototype.isBufferedToEndMS_ = function() {\n  goog.asserts.assert(\n      this.video_,\n      'We need a video element to get buffering information');\n  goog.asserts.assert(\n      this.mediaSourceEngine_,\n      'We need a media source engine to get buffering information');\n  goog.asserts.assert(\n      this.manifest_,\n      'We need a manifest to get buffering information');\n\n  // This is a strong guarantee that we are buffered to the end, because it\n  // means the playhead is already at that end.\n  if (this.video_.ended) {\n    return true;\n  }\n\n  // This means that MediaSource has buffered the final segment in all\n  // SourceBuffers and is no longer accepting additional segments.\n  if (this.mediaSourceEngine_.ended()) {\n    return true;\n  }\n\n  // Live streams are \"buffered to the end\" when they have buffered to the live\n  // edge or beyond (into the region covered by the presentation delay).\n  if (this.manifest_.presentationTimeline.isLive()) {\n    const liveEdge =\n        this.manifest_.presentationTimeline.getSegmentAvailabilityEnd();\n    const bufferEnd =\n        shaka.media.TimeRangesUtils.bufferEnd(this.video_.buffered);\n\n    if (bufferEnd >= liveEdge) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n\n/**\n * Assuming the player is playing content with src=, check if the player has\n * buffered enough content to make it to the end of the presentation.\n *\n * @return {boolean}\n * @private\n */\nshaka.Player.prototype.isBufferedToEndSrc_ = function() {\n  goog.asserts.assert(\n      this.video_,\n      'We need a video element to get buffering information');\n\n  // This is a strong guarantee that we are buffered to the end, because it\n  // means the playhead is already at that end.\n  if (this.video_.ended) {\n    return true;\n  }\n\n  // If we have buffered to the duration of the content, it means we will have\n  // enough content to buffer to the end of the presentation.\n  const bufferEnd = shaka.media.TimeRangesUtils.bufferEnd(this.video_.buffered);\n\n  // Because Safari's native HLS reports slightly inaccurate values for\n  // bufferEnd here, we use a fudge factor.  Without this, we can end up in a\n  // buffering state at the end of the stream.\n  // TODO: Try to remove the fudge here once we no longer manage buffering state\n  // above the browser with playbackRate=0.\n  const fudge = 0.1;  // 100 ms\n  return bufferEnd >= this.video_.duration - fudge;\n};\n\n\n/**\n * Find the period in |this.manifest_| that contains |variant|. If no period\n * contains |variant| this will return |null|.\n *\n * @param {shaka.extern.Variant} variant\n * @return {?shaka.extern.Period}\n * @private\n */\nshaka.Player.prototype.findPeriodWithVariant_ = function(variant) {\n  for (const period of this.manifest_.periods) {\n    if (period.variants.includes(variant)) {\n      return period;\n    }\n  }\n\n  return null;\n};\n\n\n/**\n * Create an error for when we purposely interrupt a load operation.\n *\n * @return {!shaka.util.Error}\n * @private\n */\nshaka.Player.prototype.createAbortLoadError_ = function() {\n  return new shaka.util.Error(\n      shaka.util.Error.Severity.CRITICAL,\n      shaka.util.Error.Category.PLAYER,\n      shaka.util.Error.Code.LOAD_INTERRUPTED);\n};\n\n\n/**\n * Key\n * ----------------------\n * D   : Detach Node\n * A   : Attach Node\n * MS  : Media Source Node\n * P   : Manifest Parser Node\n * M   : Manifest Node\n * DRM : Drm Engine Node\n * L   : Load Node\n * U   : Unloading Node\n * SRC : Src Equals Node\n *\n * Graph Topology\n * ----------------------\n *\n *        [SRC]-----+\n *         ^        |\n *         |        v\n * [D]<-->[A]<-----[U]\n *         |        ^\n *         v        |\n *        [MS]------+\n *         |        |\n *         v        |\n *        [P]-------+\n *         |        |\n *         v        |\n *        [M]-------+\n *         |        |\n *         v        |\n *        [DRM]-----+\n *         |        |\n *         v        |\n *        [L]-------+\n *\n * @param {!shaka.routing.Node} currentlyAt\n * @param {shaka.routing.Payload} currentlyWith\n * @param {!shaka.routing.Node} wantsToBeAt\n * @param {shaka.routing.Payload} wantsToHave\n * @return {?shaka.routing.Node}\n * @private\n */\nshaka.Player.prototype.getNextStep_ = function(\n    currentlyAt, currentlyWith, wantsToBeAt, wantsToHave) {\n  let next = null;\n\n  // Detach is very simple, either stay in detach (because |detach| was called\n  // while in detached) or go somewhere that requires us to attach to an\n  // element.\n  if (currentlyAt == this.detachNode_) {\n    next = wantsToBeAt == this.detachNode_ ?\n           this.detachNode_ :\n           this.attachNode_;\n  }\n\n  if (currentlyAt == this.attachNode_) {\n    next = this.getNextAfterAttach_(wantsToBeAt, currentlyWith, wantsToHave);\n  }\n\n  if (currentlyAt == this.mediaSourceNode_) {\n    next = this.getNextAfterMediaSource_(\n        wantsToBeAt, currentlyWith, wantsToHave);\n  }\n\n  if (currentlyAt == this.parserNode_) {\n    next = this.getNextMatchingAllDependencies_(\n        /* destination= */ this.loadNode_,\n        /* next= */ this.manifestNode_,\n        /* reset= */ this.unloadNode_,\n        /* goingTo= */ wantsToBeAt,\n        /* has= */ currentlyWith,\n        /* wants= */ wantsToHave);\n  }\n\n  if (currentlyAt == this.manifestNode_) {\n    next = this.getNextMatchingAllDependencies_(\n        /* destination= */ this.loadNode_,\n        /* next= */ this.drmNode_,\n        /* reset= */ this.unloadNode_,\n        /* goingTo= */ wantsToBeAt,\n        /* has= */ currentlyWith,\n        /* wants= */ wantsToHave);\n  }\n\n  // For DRM, we have two options \"load\" or \"unload\". If all our constraints are\n  // met, we can go to \"load\". If anything is off, we must go back to \"unload\"\n  // to reset.\n  if (currentlyAt == this.drmNode_) {\n    next = this.getNextMatchingAllDependencies_(\n        /* destination= */ this.loadNode_,\n        /* next= */ this.loadNode_,\n        /* reset= */ this.unloadNode_,\n        /* goingTo= */ wantsToBeAt,\n        /* has= */ currentlyWith,\n        /* wants= */ wantsToHave);\n  }\n\n  // For DRM w/ src= playback, we only care about destination and media element.\n  if (currentlyAt == this.srcEqualsDrmNode_) {\n    if (wantsToBeAt == this.srcEqualsNode_ &&\n        currentlyWith.mediaElement == wantsToHave.mediaElement) {\n      next = this.srcEqualsNode_;\n    } else {\n      next = this.unloadNode_;\n    }\n  }\n\n  // After we load content, always go through unload because we can't safely\n  // use components after we have started playback.\n  if (currentlyAt == this.loadNode_ || currentlyAt == this.srcEqualsNode_) {\n    next = this.unloadNode_;\n  }\n\n  if (currentlyAt == this.unloadNode_) {\n    next = this.getNextAfterUnload_(wantsToBeAt, currentlyWith, wantsToHave);\n  }\n\n  goog.asserts.assert(next, 'Missing next step!');\n  return next;\n};\n\n\n/**\n * @param {!shaka.routing.Node} goingTo\n * @param {shaka.routing.Payload} has\n * @param {shaka.routing.Payload} wants\n * @return {?shaka.routing.Node}\n * @private\n */\nshaka.Player.prototype.getNextAfterAttach_ = function(goingTo, has, wants) {\n  // Attach and detach are the only two nodes that we can directly go\n  // back-and-forth between.\n  if (goingTo == this.detachNode_) { return this.detachNode_; }\n\n  // If we are going anywhere other than detach, then we need the media element\n  // to match, if they don't match, we need to go through detach first.\n  if (has.mediaElement != wants.mediaElement) { return this.detachNode_; }\n\n  // If we are already in attached, and someone calls |attach| again (to the\n  // same video element), we can handle the redundant request by re-entering\n  // our current state.\n  if (goingTo == this.attachNode_) { return this.attachNode_; }\n\n  // The next step from attached to loaded is through media source.\n  if (goingTo == this.mediaSourceNode_ || goingTo == this.loadNode_) {\n    return this.mediaSourceNode_;\n  }\n\n  // If we are going to src=, then we should set up DRM first.  This will\n  // support cases like FairPlay HLS on Safari.\n  if (goingTo == this.srcEqualsNode_) {\n    return this.srcEqualsDrmNode_;\n  }\n\n  // We are missing a rule, the null will get caught by a common check in\n  // the routing system.\n  return null;\n};\n\n\n/**\n * @param {!shaka.routing.Node} goingTo\n * @param {shaka.routing.Payload} has\n * @param {shaka.routing.Payload} wants\n * @return {?shaka.routing.Node}\n * @private\n */\nshaka.Player.prototype.getNextAfterMediaSource_ = function(\n    goingTo, has, wants) {\n  // We can only go to parse manifest or unload. If we want to go to load and\n  // we have the right media element, we can go to parse manifest. If we don't,\n  // no matter where we want to go, we must go through unload.\n  if (goingTo == this.loadNode_ && has.mediaElement == wants.mediaElement) {\n    return this.parserNode_;\n  }\n\n  // Right now the unload node is responsible for tearing down all playback\n  // components (including media source). So since we have created media\n  // source, we need to unload since our dependencies are not compatible.\n  //\n  // TODO: We are structured this way to maintain a historic structure. Going\n  //       forward, there is no reason to restrict ourselves to this. Going\n  //       forward we should explore breaking apart |onUnload| and develop\n  //       more meaningful terminology around tearing down playback resources.\n  return this.unloadNode_;\n};\n\n\n/**\n * After unload there are only two options, attached or detached. This choice is\n * based on whether or not we have a media element. If we have a media element,\n * then we go to attach. If we don't have a media element, we go to detach.\n *\n * @param {!shaka.routing.Node} goingTo\n * @param {shaka.routing.Payload} has\n * @param {shaka.routing.Payload} wants\n * @return {?shaka.routing.Node}\n * @private\n */\nshaka.Player.prototype.getNextAfterUnload_ = function(goingTo, has, wants) {\n  // If we don't want a media element, detach.\n  // If we have the wrong media element, detach.\n  // Otherwise it means we want to attach to a media element and it is safe to\n  // do so.\n  return !wants.mediaElement || has.mediaElement != wants.mediaElement ?\n         this.detachNode_ :\n         this.attachNode_;\n};\n\n\n/**\n * A general method used to handle routing when we can either than one step\n * toward our destination (while all our dependencies match) or go to a node\n * that will reset us so we can try again.\n *\n * @param {!shaka.routing.Node} destinationNode\n *   What |goingTo| must be for us to step toward |nextNode|. Otherwise we will\n *   go to |resetNode|.\n * @param {!shaka.routing.Node} nextNode\n *   The node we will go to next if |goingTo == destinationNode| and all\n *   dependencies match.\n * @param {!shaka.routing.Node} resetNode\n *   The node we will go to next if |goingTo != destinationNode| or any\n *   dependency does not match.\n * @param {!shaka.routing.Node} goingTo\n *   The node that the walker is trying to go to.\n * @param {shaka.routing.Payload} has\n *   The payload that the walker currently has.\n * @param {shaka.routing.Payload} wants\n *   The payload that the walker wants to have when iy gets to |goingTo|.\n * @return {shaka.routing.Node}\n * @private\n */\nshaka.Player.prototype.getNextMatchingAllDependencies_ = function(\n        destinationNode, nextNode, resetNode, goingTo, has, wants) {\n  if (goingTo == destinationNode &&\n      has.mediaElement == wants.mediaElement &&\n      has.uri == wants.uri &&\n      has.mimeType == wants.mimeType &&\n      has.factory == wants.factory) {\n    return nextNode;\n  }\n\n  return resetNode;\n};\n\n\n/**\n * @return {shaka.routing.Payload}\n * @private\n */\nshaka.Player.prototype.createEmptyPayload_ = function() {\n  return {\n    factory: null,\n    mediaElement: null,\n    mimeType: null,\n    startTime: null,\n    startTimeOfLoad: null,\n    uri: null,\n  };\n};\n\n\n/**\n * Using a promise, wrap the listeners returned by |Walker.startNewRoute|. This\n * will work for most usages in |Player| but should not be used for special\n * cases.\n *\n * This will connect |onCancel|, |onEnd|, |onError|, and |onSkip| with |resolve|\n * and |reject| but will leave |onStart| unset.\n *\n * @param {shaka.routing.Walker.Listeners} listeners\n * @return {!Promise}\n * @private\n */\nshaka.Player.prototype.wrapWalkerListenersWithPromise_ = function(listeners) {\n  return new Promise((resolve, reject) => {\n    listeners.onCancel = () => reject(this.createAbortLoadError_());\n    listeners.onEnd = () => resolve();\n    listeners.onError = (e) => reject(e);\n    listeners.onSkip = () => reject(this.createAbortLoadError_());\n  });\n};\n\n/**\n * In order to know what method of loading the player used for some content, we\n * have this enum. It lets us know if content has not been loaded, loaded with\n * media source, or loaded with src equals.\n *\n * This enum has a low resolution, because it is only meant to express the\n * outer limits of the various states that the player is in. For example, when\n * someone calls a public method on player, it should not matter if they have\n * initialized drm engine, it should only matter if they finished loading\n * content.\n *\n * @enum {number}\n * @export\n */\nshaka.Player.LoadMode = {\n  'DESTROYED': 0,\n  'NOT_LOADED': 1,\n  'MEDIA_SOURCE': 2,\n  'SRC_EQUALS': 3,\n};\n\n/**\n * The typical buffering threshold.  When we have less than this buffered (in\n * seconds), we enter a buffering state.  This specific value is based on manual\n * testing and evaluation across a variety of platforms.\n *\n * To make the buffering logic work in all cases, this \"typical\" threshold will\n * be overridden if the rebufferingGoal configuration is too low.\n *\n * @const {number}\n * @private\n */\nshaka.Player.TYPICAL_BUFFERING_THRESHOLD_ = 0.5;\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.text.SimpleTextDisplayer');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\n\n\n/**\n * <p>\n * This defines the default text displayer plugin. An instance of this\n * class is used when no custom displayer is given.\n * </p>\n * <p>\n * This class simply converts shaka.text.Cue objects to\n * TextTrackCues and feeds them to the browser.\n * </p>\n *\n * @param {HTMLMediaElement} video\n * @constructor\n * @struct\n * @implements {shaka.extern.TextDisplayer}\n * @export\n */\nshaka.text.SimpleTextDisplayer = function(video) {\n  /** @private {TextTrack} */\n  this.textTrack_ = null;\n\n  // TODO: Test that in all cases, the built-in CC controls in the video element\n  // are toggling our TextTrack.\n\n  // If the video element has TextTracks, disable them.  If we see one that\n  // was created by a previous instance of Shaka Player, reuse it.\n  for (let i = 0; i < video.textTracks.length; ++i) {\n    let track = video.textTracks[i];\n    track.mode = 'disabled';\n\n    if (track.label == shaka.text.SimpleTextDisplayer.TextTrackLabel_) {\n      this.textTrack_ = track;\n    }\n  }\n\n  if (!this.textTrack_) {\n    // As far as I can tell, there is no observable difference between setting\n    // kind to 'subtitles' or 'captions' when creating the TextTrack object.\n    // The individual text tracks from the manifest will still have their own\n    // kinds which can be displayed in the app's UI.\n    this.textTrack_ = video.addTextTrack(\n        'subtitles', shaka.text.SimpleTextDisplayer.TextTrackLabel_);\n  }\n  this.textTrack_.mode = 'hidden';\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.text.SimpleTextDisplayer.prototype.remove = function(start, end) {\n  // Check that the displayer hasn't been destroyed.\n  if (!this.textTrack_) return false;\n\n  let removeInRange = (cue) => {\n    const inside = cue.startTime < end && cue.endTime > start;\n    return inside;\n  };\n\n  shaka.text.SimpleTextDisplayer.removeWhere_(this.textTrack_, removeInRange);\n\n  return true;\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.text.SimpleTextDisplayer.prototype.append = function(cues) {\n  const convertToTextTrackCue =\n      shaka.text.SimpleTextDisplayer.convertToTextTrackCue_;\n\n  // Convert cues.\n  let textTrackCues = [];\n  for (let i = 0; i < cues.length; i++) {\n    let cue = convertToTextTrackCue(cues[i]);\n    if (cue) {\n      textTrackCues.push(cue);\n    }\n  }\n\n  // Sort the cues based on start/end times.  Make a copy of the array so\n  // we can get the index in the original ordering.  Out of order cues are\n  // rejected by IE/Edge.  See https://bit.ly/2K9VX3s\n  let sortedCues = textTrackCues.slice().sort(function(a, b) {\n    if (a.startTime != b.startTime) {\n      return a.startTime - b.startTime;\n    } else if (a.endTime != b.endTime) {\n      return a.endTime - b.startTime;\n    } else {\n      // The browser will display cues with identical time ranges from the\n      // bottom up.  Reversing the order of equal cues means the first one\n      // parsed will be at the top, as you would expect.\n      // See https://github.com/google/shaka-player/issues/848 for more info.\n      return textTrackCues.indexOf(b) - textTrackCues.indexOf(a);\n    }\n  });\n\n  sortedCues.forEach(function(cue) {\n    this.textTrack_.addCue(cue);\n  }.bind(this));\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.text.SimpleTextDisplayer.prototype.destroy = function() {\n  if (this.textTrack_) {\n    let removeIt = (cue) => true;\n    shaka.text.SimpleTextDisplayer.removeWhere_(this.textTrack_, removeIt);\n  }\n\n  this.textTrack_ = null;\n  return Promise.resolve();\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.text.SimpleTextDisplayer.prototype.isTextVisible = function() {\n  return this.textTrack_.mode == 'showing';\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.text.SimpleTextDisplayer.prototype.setTextVisibility = function(on) {\n  this.textTrack_.mode = on ? 'showing' : 'hidden';\n};\n\n\n/**\n * @param {!shaka.extern.Cue} shakaCue\n * @return {TextTrackCue}\n * @private\n */\nshaka.text.SimpleTextDisplayer.convertToTextTrackCue_ = function(shakaCue) {\n  if (shakaCue.startTime >= shakaCue.endTime) {\n    // IE/Edge will throw in this case.\n    // See issue #501\n    shaka.log.warning('Invalid cue times: ' + shakaCue.startTime +\n                      ' - ' + shakaCue.endTime);\n    return null;\n  }\n\n  const Cue = shaka.text.Cue;\n  /** @type {VTTCue} */\n  let vttCue = new VTTCue(shakaCue.startTime,\n                          shakaCue.endTime,\n                          shakaCue.payload);\n\n  // NOTE: positionAlign and lineAlign settings are not supported by Chrome\n  // at the moment, so setting them will have no effect.\n  // The bug on chromium to implement them:\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=633690\n\n  vttCue.lineAlign = shakaCue.lineAlign;\n  vttCue.positionAlign = shakaCue.positionAlign;\n  vttCue.size = shakaCue.size;\n  try {\n    // Safari 10 seems to throw on align='center'.\n    vttCue.align = shakaCue.textAlign;\n  } catch (exception) {}\n\n  if (shakaCue.textAlign == 'center' && vttCue.align != 'center') {\n    // We want vttCue.position = 'auto'. By default, |position| is set to\n    // \"auto\". If we set it to \"auto\" safari will throw an exception, so we\n    // must rely on the default value.\n    vttCue.align = 'middle';\n  }\n\n  if (shakaCue.writingMode ==\n          Cue.writingMode.VERTICAL_LEFT_TO_RIGHT) {\n    vttCue.vertical = 'lr';\n  } else if (shakaCue.writingMode ==\n           Cue.writingMode.VERTICAL_RIGHT_TO_LEFT) {\n    vttCue.vertical = 'rl';\n  }\n\n  // snapToLines flag is true by default\n  if (shakaCue.lineInterpretation == Cue.lineInterpretation.PERCENTAGE) {\n    vttCue.snapToLines = false;\n  }\n\n  if (shakaCue.line != null) {\n    vttCue.line = shakaCue.line;\n  }\n\n  if (shakaCue.position != null) {\n    vttCue.position = shakaCue.position;\n  }\n\n  return vttCue;\n};\n\n\n/**\n * Iterate over all the cues in a text track and remove all those for which\n * |predicate(cue)| returns true.\n *\n * @param {!TextTrack} track\n * @param {function(!TextTrackCue):boolean} predicate\n * @private\n */\nshaka.text.SimpleTextDisplayer.removeWhere_ = function(track, predicate) {\n  // Since |track.cues| can be null if |track.mode| is \"disabled\", force it to\n  // something other than \"disabled\".\n  //\n  // If the track is already showing, then we should keep it as showing. But if\n  // it something else, we will use hidden so that we don't \"flash\" cues on the\n  // screen.\n  let oldState = track.mode;\n  let tempState = oldState == 'showing' ? 'showing' : 'hidden';\n\n  track.mode = tempState;\n\n  goog.asserts.assert(\n      track.cues,\n      'Cues should be accessible when mode is set to \"' + tempState + '\".');\n\n  // Go backward so that if a removal is done, it should not cause problems\n  // with future indexing. In the case that the underlying implementation\n  // returns a copy (and not a shared instance) cache a copy of the tracks.\n  let cues = track.cues;\n  for (let i = cues.length - 1; i >= 0; i--) {\n    let cue = cues[i];\n    if (cue && predicate(cue)) {\n      track.removeCue(cue);\n    }\n  }\n\n  track.mode = oldState;\n};\n\n\n/**\n * @const {string}\n * @private\n */\nshaka.text.SimpleTextDisplayer.TextTrackLabel_ = 'Shaka Player TextTrack';\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.ConfigUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\n\n\n/**\n * @param {!Object} destination\n * @param {!Object} source\n * @param {!Object} template supplies default values\n * @param {!Object} overrides\n *   Supplies override type checking.  When the current path matches the key in\n *   this object, each sub-value must match the type in this object.  If this\n *   contains an Object, it is used as the template.\n * @param {string} path to this part of the config\n * @return {boolean}\n * @export\n */\nshaka.util.ConfigUtils.mergeConfigObjects =\n    function(destination, source, template, overrides, path) {\n  goog.asserts.assert(destination, 'Destination config must not be null!');\n\n  /**\n   * @type {boolean}\n   * If true, don't validate the keys in the next level.\n   */\n  let ignoreKeys = path in overrides;\n\n  let isValid = true;\n\n  for (let k in source) {\n    let subPath = path + '.' + k;\n    let subTemplate = ignoreKeys ? overrides[path] : template[k];\n\n    // The order of these checks is important.\n    if (!ignoreKeys && !(k in template)) {\n      shaka.log.error('Invalid config, unrecognized key ' + subPath);\n      isValid = false;\n    } else if (source[k] === undefined) {\n      // An explicit 'undefined' value causes the key to be deleted from the\n      // destination config and replaced with a default from the template if\n      // possible.\n      if (subTemplate === undefined || ignoreKeys) {\n        // There is nothing in the template, so delete.\n        delete destination[k];\n      } else {\n        // There is something in the template, so go back to that.\n        destination[k] = shaka.util.ObjectUtils.cloneObject(subTemplate);\n      }\n    } else if (subTemplate.constructor == Object &&\n               source[k] &&\n               source[k].constructor == Object) {\n      // These are plain Objects with no other constructor.\n\n      if (!destination[k]) {\n        // Initialize the destination with the template so that normal merging\n        // and type-checking can happen.\n        destination[k] = shaka.util.ObjectUtils.cloneObject(subTemplate);\n      }\n\n      let subMergeValid = shaka.util.ConfigUtils.mergeConfigObjects(\n          destination[k], source[k], subTemplate, overrides, subPath);\n      isValid = isValid && subMergeValid;\n    } else if (typeof source[k] != typeof subTemplate ||\n               source[k] == null ||\n               source[k].constructor != subTemplate.constructor) {\n      // The source is the wrong type.  This check allows objects to be nulled,\n      // but does not allow null for any non-object fields.\n      shaka.log.error('Invalid config, wrong type for ' + subPath);\n      isValid = false;\n    } else if (typeof template[k] == 'function' &&\n               template[k].length != source[k].length) {\n      shaka.log.warning(\n          'Invalid config, wrong number of arguments for ' + subPath);\n      destination[k] = source[k];\n    } else {\n      destination[k] = source[k];\n    }\n  }\n\n  return isValid;\n};\n\n\n/**\n * Convert config from ('fieldName', value) format to a partial config object.\n *\n * E. g. from ('manifest.retryParameters.maxAttempts', 1) to\n * { manifest: { retryParameters: { maxAttempts: 1 }}}.\n *\n * @param {string} fieldName\n * @param {*} value\n * @return {!Object}\n * @export\n */\nshaka.util.ConfigUtils.convertToConfigObject = function(fieldName, value) {\n  const configObject = {};\n  let last = configObject;\n  let searchIndex = 0;\n  let nameStart = 0;\n  while (true) {  // eslint-disable-line no-constant-condition\n    const idx = fieldName.indexOf('.', searchIndex);\n    if (idx < 0) {\n      break;\n    }\n    if (idx == 0 || fieldName[idx - 1] != '\\\\') {\n      const part = fieldName.substring(nameStart, idx).replace(/\\\\\\./g, '.');\n      last[part] = {};\n      last = last[part];\n      nameStart = idx + 1;\n    }\n    searchIndex = idx + 1;\n  }\n\n  last[fieldName.substring(nameStart).replace(/\\\\\\./g, '.')] = value;\n  return configObject;\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.PlayerConfiguration');\n\ngoog.require('shaka.abr.SimpleAbrManager');\ngoog.require('shaka.util.ConfigUtils');\n\n\n// TODO(vaage): Many times in our configs, we need to create an empty\n//  implementation of a method, but to avoid closure from removing unused\n//  parameters (and breaking our merge config code) we need to use each\n//  parameter. Is there a better solution to this problem than what we are\n//  doing now?\n//\n//  NOTE: Chrome App Content Security Policy prohibits usage of new Function()\n\n/**\n * @final\n * @export\n */\nshaka.util.PlayerConfiguration = class {\n  /** @return {shaka.extern.PlayerConfiguration} */\n  static createDefault() {\n    // This is a relatively safe default, since 3G cell connections\n    // are faster than this.  For slower connections, such as 2G,\n    // the default estimate may be too high.\n    let bandwidthEstimate = 500e3; // 500kbps\n\n    let abrMaxHeight = Infinity;\n\n    // Some browsers implement the Network Information API, which allows\n    // retrieving information about a user's network connection.\n    if (navigator.connection) {\n      // If it's available, get the bandwidth estimate from the browser (in\n      // megabits per second) and use it as defaultBandwidthEstimate.\n      bandwidthEstimate = navigator.connection.downlink * 1e6;\n      // TODO: Move this into AbrManager, where changes to the estimate can be\n      // observed and absorbed.\n\n      // If the user has checked a box in the browser to ask it to use less\n      // data, the browser will expose this intent via connection.saveData.\n      // When that is true, we will default the max ABR height to 360p. Apps\n      // can override this if they wish.\n      //\n      // The decision to use 360p was somewhat arbitrary. We needed a default\n      // limit, and rather than restrict to a certain bandwidth, we decided to\n      // restrict resolution. This will implicitly restrict bandwidth and\n      // therefore save data. We (Shaka+Chrome) judged that:\n      //   - HD would be inappropriate\n      //   - If a user is asking their browser to save data, 360p it reasonable\n      //   - 360p would not look terrible on small mobile device screen\n      // We also found that:\n      //   - YouTube's website on mobile defaults to 360p (as of 2018)\n      //   - iPhone 6, in portrait mode, has a physical resolution big enough\n      //     for 360p widescreen, but a little smaller than 480p widescreen\n      //     (https://apple.co/2yze4es)\n      // If the content's lowest resolution is above 360p, AbrManager will use\n      // the lowest resolution.\n      if (navigator.connection.saveData) {\n        abrMaxHeight = 360;\n      }\n    }\n\n    const drm = {\n      retryParameters: shaka.net.NetworkingEngine.defaultRetryParameters(),\n      // These will all be verified by special cases in mergeConfigObjects_():\n      servers: {},    // key is arbitrary key system ID, value must be string\n      clearKeys: {},  // key is arbitrary key system ID, value must be string\n      advanced: {},    // key is arbitrary key system ID, value is a record type\n      delayLicenseRequestUntilPlayed: false,\n    };\n\n    const manifest = {\n      retryParameters: shaka.net.NetworkingEngine.defaultRetryParameters(),\n      availabilityWindowOverride: NaN,\n      dash: {\n        // Reference node to keep closure from removing it.\n        // If the argument is removed, it breaks our function length check\n        // in mergeConfigObjects_().\n        customScheme: (node) => {\n          if (node) return null;\n        },\n        clockSyncUri: '',\n        ignoreDrmInfo: false,\n        xlinkFailGracefully: false,\n        defaultPresentationDelay: 10,\n        ignoreMinBufferTime: false,\n        autoCorrectDrift: true,\n      },\n    };\n\n    const streaming = {\n      retryParameters: shaka.net.NetworkingEngine.defaultRetryParameters(),\n      // Need some operation in the callback or else closure may remove calls\n      // to the function as it would be a no-op.\n      failureCallback: (error) => {\n        shaka.log.error('Unhandled streaming error', error);\n      },\n      rebufferingGoal: 2,\n      bufferingGoal: 10,\n      bufferBehind: 30,\n      ignoreTextStreamFailures: false,\n      alwaysStreamText: false,\n      startAtSegmentBoundary: false,\n      smallGapLimit: 0.5,\n      jumpLargeGaps: false,\n      durationBackoff: 1,\n      forceTransmuxTS: false,\n      // Offset by 5 seconds since Chromecast takes a few seconds to start\n      // playing after a seek, even when buffered.\n      safeSeekOffset: 5,\n      stallEnabled: true,\n      stallThreshold: 1 /* seconds */,\n      stallSkip: 0.1 /* seconds */,\n    };\n\n    // WebOS has a long hardware pipeline that responds slowly, making it easy\n    // to misidentify stalls. To avoid this, by default disable stall detection\n    // on WebOS.\n    if (shaka.util.Platform.isWebOS()) {\n      streaming.stallEnabled = false;\n    }\n\n    const offline = {\n      // We need to set this to a throw-away implementation for now as our\n      // default implementation will need to reference other fields in the\n      // config. We will set it to our intended implementation after we have\n      // the top-level object created.\n      trackSelectionCallback: (tracks) => tracks,\n\n      // Need some operation in the callback or else closure may remove calls\n      // to the function as it would be a no-op.\n      progressCallback: (content, progress) => {\n        shaka.log.v2('Offline operation on',\n                     content.originalManifestUri,\n                     'progress at',\n                     progress);\n      },\n\n      // By default we use persistent licenses as forces errors to surface if\n      // a platform does not support offline licenses rather than causing\n      // unexpected behaviours when someone tries to plays downloaded content\n      // without a persistent license.\n      usePersistentLicense: true,\n    };\n\n    const abr = {\n      enabled: true,\n      defaultBandwidthEstimate: bandwidthEstimate,\n      switchInterval: 8,\n      bandwidthUpgradeTarget: 0.85,\n      bandwidthDowngradeTarget: 0.95,\n      restrictions: {\n        minWidth: 0,\n        maxWidth: Infinity,\n        minHeight: 0,\n        maxHeight: abrMaxHeight,\n        minPixels: 0,\n        maxPixels: Infinity,\n        minBandwidth: 0,\n        maxBandwidth: Infinity,\n      },\n    };\n\n    /** @type {shaka.extern.PlayerConfiguration} */\n    const config = {\n      drm: drm,\n      manifest: manifest,\n      streaming: streaming,\n      offline: offline,\n      abrFactory: shaka.abr.SimpleAbrManager,\n      abr: abr,\n      preferredAudioLanguage: '',\n      preferredTextLanguage: '',\n      preferredVariantRole: '',\n      preferredTextRole: '',\n      preferredAudioChannelCount: 2,\n      restrictions: {\n        minWidth: 0,\n        maxWidth: Infinity,\n        minHeight: 0,\n        maxHeight: Infinity,\n        minPixels: 0,\n        maxPixels: Infinity,\n        minBandwidth: 0,\n        maxBandwidth: Infinity,\n      },\n      playRangeStart: 0,\n      playRangeEnd: Infinity,\n      textDisplayFactory: () => null,\n    };\n\n    // Add this callback so that we can reference the preferred audio language\n    // through the config object so that if it gets updated, we have the\n    // updated value.\n    offline.trackSelectionCallback = (tracks) => {\n      return shaka.util.PlayerConfiguration.defaultTrackSelect(\n          tracks, config.preferredAudioLanguage);\n    };\n\n    return config;\n  }\n\n  /**\n   * Merges the given configuration changes into the given destination.  This\n   * uses the default Player configurations as the template.\n   *\n   * @param {shaka.extern.PlayerConfiguration} destination\n   * @param {!Object} updates\n   * @param {shaka.extern.PlayerConfiguration=} template\n   * @return {boolean}\n   * @export\n   */\n  static mergeConfigObjects(destination, updates, template) {\n    const overrides = {\n      '.drm.servers': '',\n      '.drm.clearKeys': '',\n      '.drm.advanced': {\n        distinctiveIdentifierRequired: false,\n        persistentStateRequired: false,\n        videoRobustness: '',\n        audioRobustness: '',\n        serverCertificate: new Uint8Array(0),\n        individualizationServer: '',\n      },\n    };\n    return shaka.util.ConfigUtils.mergeConfigObjects(\n        destination, updates,\n        template || shaka.util.PlayerConfiguration.createDefault(), overrides,\n        '');\n  }\n\n  /**\n   * @param {!Array.<shaka.extern.Track>} tracks\n   * @param {string} preferredAudioLanguage\n   * @return {!Array.<shaka.extern.Track>}\n   */\n  static defaultTrackSelect(tracks, preferredAudioLanguage) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    const allVariants = tracks.filter((track) => track.type == 'variant');\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    let selectedVariants = [];\n\n    // Find the locale that best matches our preferred audio locale.\n    const closestLocale = LanguageUtils.findClosestLocale(\n        preferredAudioLanguage,\n        allVariants.map((variant) => variant.language));\n    // If we found a locale that was close to our preference, then only use\n    // variants that use that locale.\n    if (closestLocale) {\n      selectedVariants = allVariants.filter((variant) => {\n        const locale = LanguageUtils.normalize(variant.language);\n        return locale == closestLocale;\n      });\n    }\n\n    // If we failed to get a language match, go with primary.\n    if (selectedVariants.length == 0) {\n      selectedVariants = allVariants.filter((variant) => {\n        return variant.primary;\n      });\n    }\n\n    // Otherwise, there is no good way to choose the language, so we don't\n    // choose a language at all.\n    if (selectedVariants.length == 0) {\n      // Issue a warning, but only if the content has multiple languages.\n      // Otherwise, this warning would just be noise.\n      const languages = new Set(allVariants.map((track) => {\n        return track.language;\n      }));\n\n      if (languages.size > 1) {\n        shaka.log.warning('Could not choose a good audio track based on ' +\n                          'language preferences or primary tracks.  An ' +\n                          'arbitrary language will be stored!');\n      }\n\n      // Default back to all variants.\n      selectedVariants = allVariants;\n    }\n\n    // From previously selected variants, choose the SD ones (height <= 480).\n    const tracksByHeight = selectedVariants.filter((track) => {\n      return track.height && track.height <= 480;\n    });\n\n    // If variants don't have video or no video with height <= 480 was\n    // found, proceed with the previously selected tracks.\n    if (tracksByHeight.length) {\n      // Sort by resolution, then select all variants which match the height\n      // of the highest SD res.  There may be multiple audio bitrates for the\n      // same video resolution.\n      tracksByHeight.sort((a, b) => b.height - a.height);\n      selectedVariants = tracksByHeight.filter((track) => {\n        return track.height == tracksByHeight[0].height;\n      });\n    }\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    const selectedTracks = [];\n\n    // If there are multiple matches at different audio bitrates, select the\n    // middle bandwidth one.\n    if (selectedVariants.length) {\n      const middleIndex = Math.floor(selectedVariants.length / 2);\n      selectedVariants.sort((a, b) => a.bandwidth - b.bandwidth);\n      selectedTracks.push(selectedVariants[middleIndex]);\n    }\n\n    // Since this default callback is used primarily by our own demo app and by\n    // app developers who haven't thought about which tracks they want, we\n    // should select all text tracks, regardless of language.  This makes for a\n    // better demo for us, and does not rely on user preferences for the\n    // unconfigured app.\n    for (const track of tracks) {\n      if (track.type == ContentType.TEXT) { selectedTracks.push(track); }\n    }\n\n    return selectedTracks;\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.StateHistory');\n\ngoog.require('goog.asserts');\n\n\n/**\n * This class is used to track the time spent in arbitrary states. When told of\n * a state, it will assume that state was active until a new state is provided.\n * When provided with identical states back-to-back, the existing entry will be\n * updated.\n *\n * @final\n */\nshaka.util.StateHistory = class {\n  constructor() {\n    /**\n     * The state that we think is still the current change. It is \"open\" for\n     * updating.\n     *\n     * @private {?shaka.extern.StateChange}\n     */\n    this.open_ = null;\n\n    /**\n     * The stats that are \"closed\" for updating. The \"open\" state becomes closed\n     * once we move to a new state.\n     *\n     * @private {!Array.<shaka.extern.StateChange>}\n     */\n    this.closed_ = [];\n  }\n\n  /**\n   * @param {string} state\n   */\n  update(state) {\n    // |open_| will only be |null| when we first call |update|.\n    if (this.open_ == null) {\n      this.start_(state);\n    } else {\n      this.update_(state);\n    }\n  }\n\n  /**\n   * Go through all entries in the history and count how much time was spend in\n   * the given state.\n   *\n   * @param {string} state\n   * @return {number}\n   */\n  getTimeSpentIn(state) {\n    let sum = 0;\n\n    if (this.open_ && this.open_.state == state) {\n      sum += this.open_.duration;\n    }\n\n    for (const entry of this.closed_) {\n      sum += entry.state == state ? entry.duration : 0;\n    }\n\n    return sum;\n  }\n\n  /**\n   * Get a copy of each state change entry in the history. A copy of each entry\n   * is created to break the reference to the internal data.\n   *\n   * @return {!Array.<shaka.extern.StateChange>}\n   */\n  getCopy() {\n    const clone = (entry) => {\n      return {\n        timestamp: entry.timestamp,\n        state: entry.state,\n        duration: entry.duration,\n      };\n    };\n\n    const copy = [];\n    for (const entry of this.closed_) {\n      copy.push(clone(entry));\n    }\n    if (this.open_) {\n      copy.push(clone(this.open_));\n    }\n\n    return copy;\n  }\n\n  /**\n   * @param {string} state\n   * @private\n   */\n  start_(state) {\n    goog.asserts.assert(\n        this.open_ == null,\n        'There must be no open entry in order when we start');\n\n    this.open_ = {\n      timestamp: this.getNowInSeconds_(),\n      state: state,\n      duration: 0,\n    };\n  }\n\n  /**\n   * @param {string} state\n   * @private\n   */\n  update_(state) {\n    goog.asserts.assert(\n        this.open_,\n        'There must be an open entry in order to update it');\n\n    const currentTimeSeconds = this.getNowInSeconds_();\n\n    // Always update the duration so that it can always be as accurate as\n    // possible.\n    this.open_.duration = currentTimeSeconds - this.open_.timestamp;\n\n    // If the state has not changed, there is no need to add a new entry.\n    if (this.open_.state == state) {\n      return;\n    }\n\n    // We have changed states, so \"close\" the open state.\n    this.closed_.push(this.open_);\n    this.open_ = {\n      timestamp: currentTimeSeconds,\n      state: state,\n      duration: 0,\n    };\n  }\n\n  /**\n   * Get the system time in seconds.\n   *\n   * @return {number}\n   * @private\n   */\n  getNowInSeconds_() {\n    return Date.now() / 1000;\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.SwitchHistory');\n\n\n/**\n * This class is used to track changes in variant and text selections. This\n * class will make sure that redundant switches are not recorded in the history.\n *\n * @final\n */\nshaka.util.SwitchHistory = class {\n  constructor() {\n    /** @private {?shaka.extern.Variant} */\n    this.currentVariant_ = null;\n\n    /** @private {?shaka.extern.Stream} */\n    this.currentText_ = null;\n\n    /** @private {!Array.<shaka.extern.TrackChoice>} */\n    this.history_ = [];\n  }\n\n  /**\n   * Update the history to show that we are currently playing |newVariant|. If\n   * we are already playing |newVariant|, this update will be ignored.\n   *\n   * @param {shaka.extern.Variant} newVariant\n   * @param {boolean} fromAdaptation\n   */\n  updateCurrentVariant(newVariant, fromAdaptation) {\n    if (this.currentVariant_ == newVariant) { return; }\n\n    this.currentVariant_ = newVariant;\n    this.history_.push({\n      timestamp: this.getNowInSeconds_(),\n      id: newVariant.id,\n      type: 'variant',\n      fromAdaptation: fromAdaptation,\n      bandwidth: newVariant.bandwidth,\n    });\n  }\n\n  /**\n   * Update the history to show that we are currently playing |newText|. If we\n   * are already playing |newText|, this update will be ignored.\n   *\n   * @param {shaka.extern.Stream} newText\n   * @param {boolean} fromAdaptation\n   */\n  updateCurrentText(newText, fromAdaptation) {\n    if (this.currentText_ == newText) { return; }\n\n    this.currentText_ = newText;\n    this.history_.push({\n      timestamp: this.getNowInSeconds_(),\n      id: newText.id,\n      type: 'text',\n      fromAdaptation: fromAdaptation,\n      bandwidth: null,\n    });\n  }\n\n  /**\n   * Get a copy of the switch history. This will make sure to expose no internal\n   * references.\n   *\n   * @return {!Array.<shaka.extern.TrackChoice>}\n   */\n  getCopy() {\n    const copy = [];\n\n    for (const entry of this.history_) {\n      copy.push(this.clone_(entry));\n    }\n\n    return copy;\n  }\n\n  /**\n   * Get the system time in seconds.\n   *\n   * @return {number}\n   * @private\n   */\n  getNowInSeconds_() {\n    return Date.now() / 1000;\n  }\n\n  /**\n   * @param {shaka.extern.TrackChoice} entry\n   * @return {shaka.extern.TrackChoice}\n   * @private\n   */\n  clone_(entry) {\n    return {\n      timestamp: entry.timestamp,\n      id: entry.id,\n      type: entry.type,\n      fromAdaptation: entry.fromAdaptation,\n      bandwidth: entry.bandwidth,\n    };\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.Stats');\n\ngoog.require('shaka.util.StateHistory');\ngoog.require('shaka.util.SwitchHistory');\n\n\n/**\n * This class tracks all the various components (some optional) that are used to\n * populate |shaka.extern.Stats| which is passed to the app.\n *\n * @final\n */\nshaka.util.Stats = class {\n  constructor() {\n    /** @private {number} */\n    this.width_ = NaN;\n    /** @private {number} */\n    this.height_ = NaN;\n\n    /** @private {number} */\n    this.totalDroppedFrames_ = NaN;\n    /** @private {number} */\n    this.totalDecodedFrames_ = NaN;\n\n    /** @private {number} */\n    this.loadLatencySeconds_ = NaN;\n\n    /** @private {number} */\n    this.variantBandwidth_ = NaN;\n    /** @private {number} */\n    this.bandwidthEstimate_ = NaN;\n\n    /** @private {!shaka.util.StateHistory} */\n    this.stateHistory_ = new shaka.util.StateHistory();\n\n    /** @private {!shaka.util.SwitchHistory} */\n    this.switchHistory_ = new shaka.util.SwitchHistory();\n  }\n\n  /**\n   * Update the ratio of dropped frames to total frames. This will replace the\n   * previous values.\n   *\n   * @param {number} dropped\n   * @param {number} decoded\n   */\n  setDroppedFrames(dropped, decoded) {\n    this.totalDroppedFrames_ = dropped;\n    this.totalDecodedFrames_ = decoded;\n  }\n\n  /**\n   * Set the width and height of the video we are currently playing.\n   *\n   * @param {number} width\n   * @param {number} height\n   */\n  setResolution(width, height) {\n    this.width_ = width;\n    this.height_ = height;\n  }\n\n  /**\n   * Record the time it took between the user signalling \"I want to play this\"\n   * to \"I am now seeing this\".\n   *\n   * @param {number} seconds\n   */\n  setLoadLatency(seconds) {\n    this.loadLatencySeconds_ = seconds;\n  }\n\n  /**\n   * @param {number} bandwidth\n   */\n  setVariantBandwidth(bandwidth) {\n    this.variantBandwidth_ = bandwidth;\n  }\n\n  /**\n   * @param {number} bandwidth\n   */\n  setBandwidthEstimate(bandwidth) {\n    this.bandwidthEstimate_ = bandwidth;\n  }\n\n  /**\n   * @return {!shaka.util.StateHistory}\n   */\n  getStateHistory() {\n    return this.stateHistory_;\n  }\n\n  /**\n   * @return {!shaka.util.SwitchHistory}\n   */\n  getSwitchHistory() {\n    return this.switchHistory_;\n  }\n\n  /**\n   * Create a stats blob that we can pass up to the app. This blob will not\n   * reference any internal data.\n   *\n   * @return {shaka.extern.Stats}\n   */\n  getBlob() {\n    return {\n      width: this.width_,\n      height: this.height_,\n      streamBandwidth: this.variantBandwidth_,\n      decodedFrames: this.totalDecodedFrames_,\n      droppedFrames: this.totalDroppedFrames_,\n      estimatedBandwidth: this.bandwidthEstimate_,\n      loadLatency: this.loadLatencySeconds_,\n      playTime: this.stateHistory_.getTimeSpentIn('playing'),\n      pauseTime: this.stateHistory_.getTimeSpentIn('paused'),\n      bufferingTime: this.stateHistory_.getTimeSpentIn('buffering'),\n      stateHistory: this.stateHistory_.getCopy(),\n      switchHistory: this.switchHistory_.getCopy(),\n    };\n  }\n\n  /**\n   * Create an empty stats blob. This resembles the stats when we are not\n   * playing any content.\n   *\n   * @return {shaka.extern.Stats}\n   */\n  static getEmptyBlob() {\n    return {\n      width: NaN,\n      height: NaN,\n      streamBandwidth: NaN,\n      decodedFrames: NaN,\n      droppedFrames: NaN,\n      estimatedBandwidth: NaN,\n      loadLatency: NaN,\n      playTime: NaN,\n      pauseTime: NaN,\n      bufferingTime: NaN,\n      switchHistory: [],\n      stateHistory: [],\n    };\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.StoredContentUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.offline.ManifestConverter');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.util.StreamUtils');\n\n\n/**\n * A utility class used to create |shaka.extern.StoredContent| from different\n * types of input.\n */\nshaka.offline.StoredContentUtils = class {\n  /**\n   * @param {string} originalUri\n   * @param {shaka.extern.Manifest} manifest\n   * @param {number} size\n   * @param {!Object} metadata\n   * @return {shaka.extern.StoredContent}\n   */\n  static fromManifest(originalUri, manifest, size, metadata) {\n    goog.asserts.assert(\n        manifest.periods.length,\n        'Cannot create stored content from manifest with no periods.');\n\n    /** @type {number} */\n    let expiration = manifest.expiration == undefined ?\n                     Infinity :\n                     manifest.expiration;\n\n    /** @type {number} */\n    let duration = manifest.presentationTimeline.getDuration();\n\n    /** @type {shaka.extern.Period} */\n    let firstPeriod = manifest.periods[0];\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    let tracks = shaka.offline.StoredContentUtils.getTracks_(firstPeriod);\n\n    /** @type {shaka.extern.StoredContent} */\n    let content = {\n      offlineUri: null,\n      originalManifestUri: originalUri,\n      duration: duration,\n      size: size,\n      expiration: expiration,\n      tracks: tracks,\n      appMetadata: metadata,\n    };\n\n    return content;\n  }\n\n\n  /**\n   * @param {!shaka.offline.OfflineUri} offlineUri\n   * @param {shaka.extern.ManifestDB} manifestDB\n   * @return {shaka.extern.StoredContent}\n   */\n  static fromManifestDB(offlineUri, manifestDB) {\n    goog.asserts.assert(\n        manifestDB.periods.length,\n        'Cannot create stored content from manifestDB with no periods.');\n\n    let converter = new shaka.offline.ManifestConverter(\n        offlineUri.mechanism(), offlineUri.cell());\n\n    /** @type {shaka.extern.PeriodDB} */\n    let firstPeriodDB = manifestDB.periods[0];\n    /** @type {!shaka.media.PresentationTimeline} */\n    let timeline = new shaka.media.PresentationTimeline(null, 0);\n\n\n    /** @type {shaka.extern.Period} */\n    let firstPeriod = converter.fromPeriodDB(firstPeriodDB, timeline);\n\n    /** @type {!Object} */\n    let metadata = manifestDB.appMetadata || {};\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    let tracks = shaka.offline.StoredContentUtils.getTracks_(firstPeriod);\n\n    /** @type {shaka.extern.StoredContent} */\n    let content = {\n      offlineUri: offlineUri.toString(),\n      originalManifestUri: manifestDB.originalManifestUri,\n      duration: manifestDB.duration,\n      size: manifestDB.size,\n      expiration: manifestDB.expiration,\n      tracks: tracks,\n      appMetadata: metadata,\n    };\n\n    return content;\n  }\n\n\n  /**\n   * Gets track representations of all playable variants and all text streams.\n   *\n   * @param {shaka.extern.Period} period\n   * @return {!Array.<shaka.extern.Track>}\n   * @private\n   */\n  static getTracks_(period) {\n    const StreamUtils = shaka.util.StreamUtils;\n\n    const tracks = [];\n\n    const variants = StreamUtils.getPlayableVariants(period.variants);\n    for (const variant of variants) {\n      tracks.push(StreamUtils.variantToTrack(variant));\n    }\n\n    const textStreams = period.textStreams;\n    for (const stream of textStreams) {\n      tracks.push(StreamUtils.textStreamToTrack(stream));\n    }\n\n    return tracks;\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.StreamBandwidthEstimator');\n\ngoog.require('shaka.log');\n\n\n/**\n * A utility class to help estimate the size of streams based on stream and\n * variant bandwidths. This class's main purpose is to isolate the logic in\n * creating non-zero bandwidth estimates for all streams so that each stream\n * will have some influence over the progress of the download.\n */\nshaka.offline.StreamBandwidthEstimator = class {\n  constructor() {\n    /** @private {!Object.<number, number>} */\n    this.estimateByStreamId_ = {};\n  }\n\n  /**\n   * Add a new variant to the estimator. This will update the estimates for all\n   * streams in the variant.\n   *\n   * @param {shaka.extern.Variant} variant\n   */\n  addVariant(variant) {\n    // Three cases:\n    //  1 - Only Audio\n    //  2 - Only Video\n    //  3 - Audio and Video\n\n    let audio = variant.audio;\n    let video = variant.video;\n\n    // Case 1\n    if (audio && !video) {\n      let audioBitRate = audio.bandwidth || variant.bandwidth;\n      this.setBitrate_(audio.id, audioBitRate);\n    }\n\n    // Case 2\n    if (!audio && video) {\n      let videoBitRate = video.bandwidth || variant.bandwidth;\n      this.setBitrate_(video.id, videoBitRate);\n    }\n\n    // Case 3\n    if (audio && video) {\n      // Get the audio's bandwidth. If it is missing, default to our default\n      // audio bandwidth.\n      let audioBitRate =\n          audio.bandwidth ||\n          shaka.offline.StreamBandwidthEstimator.DEFAULT_AUDIO_BITRATE_;\n\n      // Get the video's bandwidth. If it is missing, use the variant bandwidth\n      // less the audio. If we get a negative bit rate, fall back to our\n      // default video bandwidth.\n      let videoBitRate = video.bandwidth || (variant.bandwidth - audioBitRate);\n      if (videoBitRate <= 0) {\n        shaka.log.warning(\n            'Audio bit rate consumes variants bandwidth. Setting video ' +\n            'bandwidth to match variant\\'s bandwidth.');\n        videoBitRate = variant.bandwidth;\n      }\n\n      this.setBitrate_(audio.id, audioBitRate);\n      this.setBitrate_(video.id, videoBitRate);\n    }\n  }\n\n  /**\n   * @param {number} stream\n   * @param {number} bitRate\n   * @private\n   */\n  setBitrate_(stream, bitRate) {\n    this.estimateByStreamId_[stream] = bitRate;\n  }\n\n  /**\n   * Create an estimate for the text stream.\n   *\n   * @param {shaka.extern.Stream} text\n   */\n  addText(text) {\n    this.estimateByStreamId_[text.id] =\n        shaka.offline.StreamBandwidthEstimator.DEFAULT_TEXT_BITRATE_;\n  }\n\n  /**\n   * Get the estimate for a segment that is part of a stream that has already\n   * added to the estimator.\n   *\n   * @param {number} id\n   * @param {!shaka.media.SegmentReference} segment\n   * @return {number}\n   */\n  getSegmentEstimate(id, segment) {\n    let duration = segment.endTime - segment.startTime;\n    return this.getEstimate_(id) * duration;\n  }\n\n  /**\n   * Get the estimate for an init segment for a stream that has already\n   * added to the estimator.\n   *\n   * @param {number} id\n   * @return {number}\n   */\n  getInitSegmentEstimate(id) {\n    // Assume that the init segment is worth approximately half a second of\n    // content.\n    let duration = 0.5;\n    return this.getEstimate_(id) * duration;\n  }\n\n  /**\n   * @param {number} id\n   * @return {number}\n   * @private\n   */\n  getEstimate_(id) {\n    let bitRate = this.estimateByStreamId_[id];\n\n    if (bitRate == null) {\n      bitRate = 0;\n      shaka.log.error(\n          'Asking for bitrate of stream not given to the estimator');\n    }\n\n    if (bitRate == 0) {\n      shaka.log.warning(\n          'Using bitrate of 0, this stream won\\'t affect progress');\n    }\n\n    return bitRate;\n  }\n};\n\n\n/**\n * Since audio bandwidth does not vary much, we are going to use a constant\n * approximation for audio bit rate allowing use to more accurately guess at\n * the video bitrate.\n *\n * YouTube's suggested bitrate for stereo audio is 384 kbps so we are going to\n * assume that: https://support.google.com/youtube/answer/1722171?hl=en\n *\n * @const {number}\n * @private\n */\nshaka.offline.StreamBandwidthEstimator.DEFAULT_AUDIO_BITRATE_ = 393216;\n\n\n/**\n * Since we don't normally get the bitrate for text, we still want to create\n * some approximation so that it can influence progress. This will use the\n * bitrate from \"Tears of Steal\" to give some kind of data-driven result.\n *\n * The file size for English subtitles is 4.7 KB. The video is 12:14 long,\n * which means that the text's bit rate is around 52 bps.\n *\n * @const {number}\n * @private\n */\nshaka.offline.StreamBandwidthEstimator.DEFAULT_TEXT_BITRATE_ = 52;\n\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.Destroyer');\n\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * A utility class to help work with |shaka.util.IDestroyable| objects.\n *\n * @final\n */\nshaka.util.Destroyer = class {\n  /**\n   * @param {function():!Promise} callback\n   *    A callback to destroy an object. This callback will only be called once\n   *    regardless of how many times |destroy| is called.\n   */\n  constructor(callback) {\n    /** @private {boolean} */\n    this.destroyed_ = false;\n\n    /** @private {!shaka.util.PublicPromise} */\n    this.waitOnDestroy_ = new shaka.util.PublicPromise();\n\n    /** @private {function():!Promise} */\n    this.onDestroy_ = callback;\n  }\n\n  /**\n   * Check if |destroy| has been called. This returning |true| does not mean\n   * that the promise returned by |destroy| has resolved yet.\n   *\n   * @return {boolean}\n   * @final\n   */\n  destroyed() {\n    return this.destroyed_;\n  }\n\n  /**\n   * Request that the destroy callback be called. Will return a promise that\n   * will resolve once the callback terminates. The promise will never be\n   * rejected.\n   *\n   * @return {!Promise}\n   * @final\n   */\n  destroy() {\n    if (this.destroyed_) {\n      return this.waitOnDestroy_;\n    }\n\n    // We have started destroying this object, so we should never get here\n    // again.\n    this.destroyed_ = true;\n\n    return this.onDestroy_().then(\n        () => { this.waitOnDestroy_.resolve(); },\n        () => { this.waitOnDestroy_.resolve(); });\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.ManifestFilter');\n\ngoog.require('goog.asserts');\n\n\n/**\n * This utility class contains all the functions used to filter manifests\n * before playback and before storage.\n */\nshaka.util.ManifestFilter = class {\n  /**\n   * Filter the variants in |manifest| to only include the variants that meet\n   * the given restrictions.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @param {shaka.extern.Restrictions} restrictions\n   * @param {{width: number, height:number}} maxHwResolution\n   */\n  static filterByRestrictions(manifest, restrictions, maxHwResolution) {\n    for (const period of manifest.periods) {\n      period.variants = period.variants.filter((variant) => {\n        return shaka.util.StreamUtils.meetsRestrictions(\n            variant, restrictions, maxHwResolution);\n      });\n    }\n  }\n\n\n  /**\n   * Filter the variants in the |manifest| to only include those that are\n   * supported by media source.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   */\n  static filterByMediaSourceSupport(manifest) {\n    const MediaSourceEngine = shaka.media.MediaSourceEngine;\n\n    for (const period of manifest.periods) {\n      period.variants = period.variants.filter((variant) => {\n        let supported = true;\n        if (variant.audio) {\n          supported =\n              supported && MediaSourceEngine.isStreamSupported(variant.audio);\n        }\n        if (variant.video) {\n          supported =\n              supported && MediaSourceEngine.isStreamSupported(variant.video);\n        }\n        return supported;\n      });\n    }\n  }\n\n  /**\n   * Filter the variants in |manifest| to only include those that are supported\n   * by |drm|.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @param {!shaka.media.DrmEngine} drmEngine\n   */\n  static filterByDrmSupport(manifest, drmEngine) {\n    for (const period of manifest.periods) {\n      period.variants = period.variants.filter((variant) => {\n        return drmEngine.supportsVariant(variant);\n      });\n    }\n  }\n\n  /**\n   * Filter the variants in |manifest| to only include those that use codecs\n   * that will be supported in each variant. This ensures playback from the\n   * first period to the last period by \"jumping between\" compatible variants.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   */\n  static filterByCommonCodecs(manifest) {\n    goog.asserts.assert(manifest.periods.length > 0,\n                        'There should be at least be one period');\n\n    const ManifestFilter = shaka.util.ManifestFilter;\n\n    // Create a set of summaries that occur in each period.\n    /** @type {!shaka.util.ManifestFilter.VariantCodecSummarySet} */\n    const common = new shaka.util.ManifestFilter.VariantCodecSummarySet();\n\n    manifest.periods.forEach((period, index) => {\n      /** @type {!shaka.util.ManifestFilter.VariantCodecSummarySet} */\n      const next = ManifestFilter.VariantCodecSummarySet.fromVariants(\n          period.variants);\n\n      if (index == 0) {\n        common.includeAll(next);\n      } else {\n        common.onlyKeep(next);\n      }\n    });\n\n    // Filter the variants in the period by whether they match a summary that\n    // occurs in every period.\n    for (const period of manifest.periods) {\n      period.variants = period.variants.filter((variant) => {\n        const summary = new ManifestFilter.VariantCodecSummary(variant);\n        return common.contains(summary);\n      });\n    }\n  }\n\n  /**\n   * Go through each period and apply the filter to the set of variants.\n   * |filter| will only be given the set of variants in the current period that\n   * are compatible with at least one variant in the previous period.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @param {function(shaka.extern.Period)} filter\n   */\n  static rollingFilter(manifest, filter) {\n    const ManifestFilter = shaka.util.ManifestFilter;\n\n    // Store a reference to the variants so that the next period can easily\n    // reference them too.\n    /** @type {!shaka.util.ManifestFilter.VariantCodecSummarySet} */\n    let previous = new ManifestFilter.VariantCodecSummarySet();\n\n    manifest.periods.forEach((period, index) => {\n      // Remove all variants that don't have a compatible variant in the\n      // previous period. If we were to only use the first variant, we would\n      // risk a variant being removed from a later period that would break that\n      // path across all periods.\n      if (index > 0) {\n        period.variants = period.variants.filter((variant) => {\n          const summary = new ManifestFilter.VariantCodecSummary(variant);\n          return previous.contains(summary);\n        });\n      }\n\n      filter(period);\n\n      // Use the results of filtering this period as the \"previous\" for the\n      // next period.\n      previous =\n          ManifestFilter.VariantCodecSummarySet.fromVariants(period.variants);\n    });\n  }\n};\n\n\n/**\n * The variant codec summary is a summary of the codec information for a given\n * codec. This can be used to test the compatibility between variants by\n * checking that their summaries contain the same information.\n *\n * @final\n */\nshaka.util.ManifestFilter.VariantCodecSummary = class {\n  /**\n   * @param {shaka.extern.Variant} variant\n   */\n  constructor(variant) {\n    // We summarize a variant based on the basic mime type and the basic\n    // codec because they must match for two variants to be compatible. For\n    // example, we can't adapt between WebM and MP4, nor can we adapt between\n    // mp4a.* to ec-3.\n\n    const audio = variant.audio;\n    const video = variant.video;\n\n    /** @private {?string} */\n    this.audioMime_ = audio ? audio.mimeType : null;\n    /** @private {?string} */\n    this.audioCodec_ = audio ? audio.codecs.split('.')[0] : null;\n    /** @private {?string} */\n    this.videoMime_ = video ? video.mimeType : null;\n    /** @private {?string} */\n    this.videoCodec_ = video ? video.codecs.split('.')[0] : null;\n  }\n\n  /**\n   * Check if this summaries is equal to another.\n   *\n   * @param {!shaka.util.ManifestFilter.VariantCodecSummary} other\n   * @return {boolean}\n   */\n  equals(other) {\n    return this.audioMime_ == other.audioMime_ &&\n           this.audioCodec_ == other.audioCodec_ &&\n           this.videoMime_ == other.videoMime_ &&\n           this.videoCodec_ == other.videoCodec_;\n  }\n};\n\n\n/**\n * @final\n */\nshaka.util.ManifestFilter.VariantCodecSummarySet = class {\n  constructor() {\n    /** @private {!Array.<!shaka.util.ManifestFilter.VariantCodecSummary>} */\n    this.all_ = [];\n  }\n\n  /**\n   * @param {!shaka.util.ManifestFilter.VariantCodecSummary} summary\n   */\n  add(summary) {\n    if (!this.contains(summary)) {\n      this.all_.push(summary);\n    }\n  }\n\n  /**\n   * Add all items from |other| to |this|.\n   * @param {!shaka.util.ManifestFilter.VariantCodecSummarySet} other\n   */\n  includeAll(other) {\n    for (const item of other.all_) {\n      this.add(item);\n    }\n  }\n\n  /**\n   * Remove all items from |this| that are not in |other|.\n   * @param {!shaka.util.ManifestFilter.VariantCodecSummarySet} other\n   */\n  onlyKeep(other) {\n    this.all_ = this.all_.filter((x) => other.contains(x));\n  }\n\n  /**\n   * @param {!shaka.util.ManifestFilter.VariantCodecSummary} summary\n   * @return {boolean}\n   */\n  contains(summary) {\n    return this.all_.some((x) => summary.equals(x));\n  }\n\n  /**\n   * Create a set of variant codec summaries for a list of variants. The set\n   * may have fewer elements than the list if there are variants with similar\n   * codecs.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @return {!shaka.util.ManifestFilter.VariantCodecSummarySet}\n   */\n  static fromVariants(variants) {\n    const set = new shaka.util.ManifestFilter.VariantCodecSummarySet();\n    for (const variant of variants) {\n      set.add(new shaka.util.ManifestFilter.VariantCodecSummary(variant));\n    }\n    return set;\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.Storage');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Deprecate');\ngoog.require('shaka.Player');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.offline.DownloadManager');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.offline.SessionDeleter');\ngoog.require('shaka.offline.StorageMuxer');\ngoog.require('shaka.offline.StoredContentUtils');\ngoog.require('shaka.offline.StreamBandwidthEstimator');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.ManifestFilter');\ngoog.require('shaka.util.Networking');\ngoog.require('shaka.util.Periods');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.PlayerConfiguration');\ngoog.require('shaka.util.StreamUtils');\n\n\n/**\n * This manages persistent offline data including storage, listing, and deleting\n * stored manifests.  Playback of offline manifests are done through the Player\n * using a special URI (see shaka.offline.OfflineUri).\n *\n * First, check support() to see if offline is supported by the platform.\n * Second, configure() the storage object with callbacks to your application.\n * Third, call store(), remove(), or list() as needed.\n * When done, call destroy().\n *\n * @param {!shaka.Player=} player\n *    A player instance to share a networking engine and configuration with.\n *    When initializing with a player, storage is only valid as long as\n *    |destroy| has not been called on the player instance. When omitted,\n *    storage will manage its own networking engine and configuration.\n *\n * @struct\n * @constructor\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.offline.Storage = function(player) {\n  // It is an easy mistake to make to pass a Player proxy from CastProxy.\n  // Rather than throw a vague exception later, throw an explicit and clear one\n  // now.\n  //\n  // TODO(vaage): After we decide whether or not we want to support\n  //  initializing storage with a player proxy, we should either remove\n  //  this error or rename the error.\n  if (player && player.constructor != shaka.Player) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.LOCAL_PLAYER_INSTANCE_REQUIRED);\n  }\n\n  /** @private {?shaka.extern.PlayerConfiguration} */\n  this.config_ = null;\n\n  /** @private {shaka.net.NetworkingEngine} */\n  this.networkingEngine_ = null;\n\n  // Initialize |config_| and |networkingEngine_| based on whether or not\n  // we were given a player instance.\n  if (player) {\n    this.config_ = player.getSharedConfiguration();\n    this.networkingEngine_ = player.getNetworkingEngine();\n\n    goog.asserts.assert(\n        this.networkingEngine_,\n        'Storage should not be initialized with a player that had |destroy| ' +\n            'called on it.');\n  } else {\n    this.config_ = shaka.util.PlayerConfiguration.createDefault();\n    this.networkingEngine_ = new shaka.net.NetworkingEngine();\n  }\n\n  /** @private {boolean} */\n  this.storeInProgress_ = false;\n\n  /**\n   * A list of segment ids for all the segments that were added during the\n   * current store. If the store fails or is aborted, these need to be\n   * removed from storage.\n   * @private {!Array.<number>}\n   */\n  this.segmentsFromStore_ = [];\n\n  /**\n   * A list of open operations that are being performed by this instance of\n   * |shaka.offline.Storage|.\n   *\n   * @private {!Array.<!Promise>}\n   */\n  this.openOperations_ = [];\n\n  /**\n   * Storage should only destroy the networking engine if it was initialized\n   * without a player instance. Store this as a flag here to avoid including\n   * the player object in the destoyer's closure.\n   *\n   * @type {boolean}\n   */\n  const destroyNetworkingEngine = !player;\n\n  /** @private {!shaka.util.Destroyer} */\n  this.destroyer_ = new shaka.util.Destroyer(async () => {\n    // Wait for all the open operations to end. Wrap each operations so that a\n    // single rejected promise won't cause |Promise.all| to return early or to\n    // return a rejected Promise.\n    const noop = () => {};\n    await Promise.all(this.openOperations_.map((op) => op.then(noop, noop)));\n\n    // Wait until after all the operations have finished before we destroy\n    // the networking engine to avoid any unexpected errors.\n    if (destroyNetworkingEngine) {\n      await this.networkingEngine_.destroy();\n    }\n\n    // Drop all references to internal objects to help with GC.\n    this.config_ = null;\n    this.networkingEngine_ = null;\n  });\n};\n\n\n/**\n * Gets whether offline storage is supported.  Returns true if offline storage\n * is supported for clear content.  Support for offline storage of encrypted\n * content will not be determined until storage is attempted.\n *\n * @return {boolean}\n * @export\n */\nshaka.offline.Storage.support = function() {\n  // Our Storage system is useless without MediaSource.  MediaSource allows us\n  // to pull data from anywhere (including our Storage system) and feed it to\n  // the video element.\n  if (!shaka.util.Platform.supportsMediaSource()) return false;\n\n  return shaka.offline.StorageMuxer.support();\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.offline.Storage.prototype.destroy = function() {\n  return this.destroyer_.destroy();\n};\n\n\n/**\n * Sets configuration values for Storage.  This is associated with\n * Player.configure and will change the player instance given at\n * initialization.\n *\n * @param {string|!Object} config This should either be a field name or an\n *   object following the form of {@link shaka.extern.PlayerConfiguration},\n *   where you may omit any field you do not wish to change.\n * @param {*=} value This should be provided if the previous parameter\n *   was a string field name.\n * @return {boolean}\n * @export\n */\nshaka.offline.Storage.prototype.configure = function(config, value) {\n  goog.asserts.assert(typeof(config) == 'object' || arguments.length == 2,\n                      'String configs should have values!');\n\n  // ('fieldName', value) format\n  if (arguments.length == 2 && typeof(config) == 'string') {\n    config = shaka.util.ConfigUtils.convertToConfigObject(config, value);\n  }\n\n  goog.asserts.assert(typeof(config) == 'object', 'Should be an object!');\n\n  shaka.offline.Storage.verifyConfig_(config);\n\n  goog.asserts.assert(\n      this.config_, 'Cannot reconfigure stroage after calling destroy.');\n  return shaka.util.PlayerConfiguration.mergeConfigObjects(\n      this.config_ /* destination */, config /* updates */);\n};\n\n\n/**\n * Return a copy of the current configuration.  Modifications of the returned\n * value will not affect the Storage instance's active configuration.  You must\n * call storage.configure() to make changes.\n *\n * @return {shaka.extern.PlayerConfiguration}\n * @export\n */\nshaka.offline.Storage.prototype.getConfiguration = function() {\n  goog.asserts.assert(this.config_, 'Config must not be null!');\n\n  let ret = shaka.util.PlayerConfiguration.createDefault();\n  shaka.util.PlayerConfiguration.mergeConfigObjects(\n      ret, this.config_, shaka.util.PlayerConfiguration.createDefault());\n  return ret;\n};\n\n\n/**\n * Return the networking engine that storage is using. If storage was\n * initialized with a player instance, then the networking engine returned\n * will be the same as |player.getNetworkingEngine()|.\n *\n * The returned value will only be null if |destroy| was called before\n * |getNetworkingEngine|.\n *\n * @return {shaka.net.NetworkingEngine}\n * @export\n */\nshaka.offline.Storage.prototype.getNetworkingEngine = function() {\n  return this.networkingEngine_;\n};\n\n\n/**\n * Stores the given manifest.  If the content is encrypted, and encrypted\n * content cannot be stored on this platform, the Promise will be rejected with\n * error code 6001, REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE.\n *\n * @param {string} uri The URI of the manifest to store.\n * @param {!Object=} appMetadata An arbitrary object from the application\n *   that will be stored along-side the offline content.  Use this for any\n *   application-specific metadata you need associated with the stored content.\n *   For details on the data types that can be stored here, please refer to\n *   {@link https://bit.ly/StructClone}\n * @param {string|shaka.extern.ManifestParser.Factory=} mimeType\n *   The mime type for the content |manifestUri| points to or a manifest parser\n *   factory to override auto-detection or use an unregistered parser. Passing\n *   a manifest parser factory is deprecated and will be removed.\n * @return {!Promise.<shaka.extern.StoredContent>}  A Promise to a structure\n *   representing what was stored.  The \"offlineUri\" member is the URI that\n *   should be given to Player.load() to play this piece of content offline.\n *   The \"appMetadata\" member is the appMetadata argument you passed to store().\n * @export\n */\nshaka.offline.Storage.prototype.store = function(uri, appMetadata, mimeType) {\n  const getParser = async () => {\n    if (mimeType && typeof mimeType != 'string') {\n        shaka.Deprecate.deprecateFeature(\n            2, 6,\n            'Storing with a manifest parser factory',\n            'Please register a manifest parser and for the mime-type.');\n\n      const Factory =\n          /** @type {shaka.extern.ManifestParser.Factory} */(mimeType);\n      return new Factory();\n    }\n\n    goog.asserts.assert(\n        this.networkingEngine_, 'Should not call |store| after |destroy|');\n\n    const parser = await shaka.media.ManifestParser.create(\n        uri,\n        this.networkingEngine_,\n        this.config_.manifest.retryParameters,\n        /** @type {?string} */ (mimeType));\n\n    return parser;\n  };\n\n  return this.startOperation_(this.store_(uri, appMetadata || {}, getParser));\n};\n\n\n/**\n * Returns true if an asset is currently downloading.\n *\n * @return {boolean}\n * @export\n */\nshaka.offline.Storage.prototype.getStoreInProgress = function() {\n  return this.storeInProgress_;\n};\n\n\n/**\n * See |shaka.offline.Storage.store| for details.\n *\n * @param {string} uri\n * @param {!Object} appMetadata\n * @param {function():!Promise.<shaka.extern.ManifestParser>} getParser\n * @return {!Promise.<shaka.extern.StoredContent>}\n * @private\n */\nshaka.offline.Storage.prototype.store_ = async function(\n    uri, appMetadata, getParser) {\n  // TODO: Create a way for a download to be canceled while being downloaded.\n  this.requireSupport_();\n\n  if (this.storeInProgress_) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.STORE_ALREADY_IN_PROGRESS));\n  }\n  this.storeInProgress_ = true;\n\n  const manifest = await this.parseManifest(uri, getParser);\n\n  // Check if we were asked to destroy ourselves while we were \"away\"\n  // downloading the manifest.\n  this.checkDestroyed_();\n\n  // Check if we can even download this type of manifest before trying to\n  // create the drm engine.\n  const canDownload = !manifest.presentationTimeline.isLive() &&\n                      !manifest.presentationTimeline.isInProgress();\n  if (!canDownload) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.CANNOT_STORE_LIVE_OFFLINE,\n        uri);\n  }\n\n\n  // Since we will need to use |drmEngine|, |activeHandle|, and |muxer| in the\n  // catch/finally blocks, we need to define them out here. Since they may not\n  // get initialized when we enter the catch/finally block, we need to assume\n  // that they may be null/undefined when we get there.\n  /** @type {?shaka.media.DrmEngine} */\n  let drmEngine = null;\n  /** @type {shaka.offline.StorageMuxer} */\n  let muxer = new shaka.offline.StorageMuxer();\n  /** @type {?shaka.offline.StorageCellHandle} */\n  let activeHandle = null;\n\n  // This will be used to store any errors from drm engine. Whenever drm engine\n  // is passed to another function to do work, we should check if this was\n  // set.\n  let drmError = null;\n\n  try {\n    drmEngine = await this.createDrmEngine(\n        manifest,\n        (e) => { drmError = drmError || e; });\n\n    // We could have been asked to destroy ourselves while we were \"away\"\n    // creating the drm engine.\n    this.checkDestroyed_();\n    if (drmError) { throw drmError; }\n\n    this.filterManifest_(manifest, drmEngine);\n\n    await muxer.init();\n    this.checkDestroyed_();\n\n    // Get the cell that we are saving the manifest to. Once we get a cell\n    // we will only reference the cell and not the muxer so that the manifest\n    // and segments will all be saved to the same cell.\n    activeHandle = await muxer.getActive();\n    this.checkDestroyed_();\n\n    goog.asserts.assert(drmEngine, 'drmEngine should be non-null here.');\n\n    const manifestDB = await this.downloadManifest_(\n        activeHandle.cell, drmEngine, manifest, uri, appMetadata);\n    this.checkDestroyed_();\n    if (drmError) { throw drmError; }\n\n    const ids = await activeHandle.cell.addManifests([manifestDB]);\n    this.checkDestroyed_();\n\n    const offlineUri = shaka.offline.OfflineUri.manifest(\n        activeHandle.path.mechanism, activeHandle.path.cell, ids[0]);\n\n    return shaka.offline.StoredContentUtils.fromManifestDB(\n        offlineUri, manifestDB);\n  } catch (e) {\n    // If we did start saving some data, we need to remove it all to avoid\n    // wasting storage. However if the muxer did not manage to initialize, then\n    // we won't have an active cell to remove the segments from.\n    if (activeHandle) {\n      await activeHandle.cell.removeSegments(this.segmentsFromStore_, () => {});\n    }\n\n    // If we already had an error, ignore this error to avoid hiding\n    // the original error.\n    throw drmError || e;\n  } finally {\n    this.storeInProgress_ = false;\n    this.segmentsFromStore_ = [];\n\n    await muxer.destroy();\n    if (drmEngine) {\n      await drmEngine.destroy();\n    }\n  }\n};\n\n\n/**\n * Filter |manifest| such that it will only contain the variants and text\n * streams that we want to store and can actually play.\n *\n * @param {shaka.extern.Manifest} manifest\n * @param {!shaka.media.DrmEngine} drmEngine\n * @private\n */\nshaka.offline.Storage.prototype.filterManifest_ = function(\n    manifest, drmEngine) {\n  // Filter the manifest based on the restrictions given in the player\n  // configuration.\n  const maxHwRes = {width: Infinity, height: Infinity};\n  shaka.util.ManifestFilter.filterByRestrictions(\n      manifest, this.config_.restrictions, maxHwRes);\n\n  // Filter the manifest based on what we know media source will be able to\n  // play later (no point storing something we can't play).\n  shaka.util.ManifestFilter.filterByMediaSourceSupport(manifest);\n\n  // Filter the manifest based on what we know our drm system will support\n  // playing later.\n  shaka.util.ManifestFilter.filterByDrmSupport(manifest, drmEngine);\n\n  // Filter the manifest so that it will only use codecs that are available in\n  // all periods.\n  shaka.util.ManifestFilter.filterByCommonCodecs(manifest);\n\n  // Filter each variant based on what the app says they want to store. The app\n  // will only be given variants that are compatible with all previous\n  // post-filtered periods.\n  shaka.util.ManifestFilter.rollingFilter(manifest, (period) => {\n    const StreamUtils = shaka.util.StreamUtils;\n    const allTracks = [];\n\n    for (const variant of period.variants) {\n      goog.asserts.assert(\n          StreamUtils.isPlayable(variant),\n          'We should have already filtered by \"is playable\"');\n\n      allTracks.push(StreamUtils.variantToTrack(variant));\n    }\n\n    for (const text of period.textStreams) {\n      allTracks.push(StreamUtils.textStreamToTrack(text));\n    }\n\n    const chosenTracks = this.config_.offline.trackSelectionCallback(allTracks);\n\n    /** @type {!Set.<number>} */\n    const variantIds = new Set();\n    /** @type {!Set.<number>} */\n    const textIds = new Set();\n\n    for (const track of chosenTracks) {\n      if (track.type == 'variant') { variantIds.add(track.id); }\n      if (track.type == 'text') { textIds.add(track.id); }\n    }\n\n    period.variants =\n        period.variants.filter((variant) => variantIds.has(variant.id));\n    period.textStreams =\n        period.textStreams.filter((stream) => textIds.has(stream.id));\n  });\n\n  // Check the post-filtered manifest for characteristics that may indicate\n  // issues with how the app selected tracks.\n  shaka.offline.Storage.validateManifest_(manifest);\n};\n\n\n/**\n * Create a download manager and download the manifest.\n *\n * @param {shaka.extern.StorageCell} storage\n * @param {!shaka.media.DrmEngine} drmEngine\n * @param {shaka.extern.Manifest} manifest\n * @param {string} uri\n * @param {!Object} metadata\n * @return {!Promise.<shaka.extern.ManifestDB>}\n * @private\n */\nshaka.offline.Storage.prototype.downloadManifest_ = async function(\n    storage, drmEngine, manifest, uri, metadata) {\n  goog.asserts.assert(\n      this.networkingEngine_,\n      'Cannot call |downloadManifest_| after calling |destroy|.');\n\n  const pendingContent = shaka.offline.StoredContentUtils.fromManifest(\n      uri, manifest, /* size */ 0, metadata);\n\n  /** @type {!shaka.offline.DownloadManager} */\n  const downloader = new shaka.offline.DownloadManager(\n      this.networkingEngine_,\n      (progress, size) => {\n        // Update the size of the stored content before issuing a progress\n        // update.\n        pendingContent.size = size;\n        this.config_.offline.progressCallback(pendingContent, progress);\n      });\n\n  try {\n    const manifestDB = this.createOfflineManifest_(\n        downloader, storage, drmEngine, manifest, uri, metadata);\n\n    manifestDB.size = await downloader.waitToFinish();\n\n    return manifestDB;\n  } finally {\n    await downloader.destroy();\n  }\n};\n\n\n/**\n * Removes the given stored content.  This will also attempt to release the\n * licenses, if any.\n *\n * @param {string} contentUri\n * @return {!Promise}\n * @export\n */\nshaka.offline.Storage.prototype.remove = function(contentUri) {\n  return this.startOperation_(this.remove_(contentUri));\n};\n\n\n/**\n * See |shaka.offline.Storage.remove| for details.\n *\n * @param {string} contentUri\n * @return {!Promise}\n * @private\n */\nshaka.offline.Storage.prototype.remove_ = async function(contentUri) {\n  this.requireSupport_();\n\n  const nullableUri = shaka.offline.OfflineUri.parse(contentUri);\n  if (nullableUri == null || !nullableUri.isManifest()) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.MALFORMED_OFFLINE_URI,\n        contentUri));\n  }\n\n  /** @type {!shaka.offline.OfflineUri} */\n  const uri = nullableUri;\n\n  /** @type {!shaka.offline.StorageMuxer} */\n  const muxer = new shaka.offline.StorageMuxer();\n\n  try {\n    await muxer.init();\n\n    const cell = await muxer.getCell(uri.mechanism(), uri.cell());\n    const manifests = await cell.getManifests([uri.key()]);\n    const manifest = manifests[0];\n\n    await Promise.all([\n      this.removeFromDRM_(uri, manifest, muxer),\n      this.removeFromStorage_(cell, uri, manifest),\n    ]);\n  } finally {\n    await muxer.destroy();\n  }\n};\n\n\n/**\n * @param {shaka.extern.ManifestDB} manifestDb\n * @param {boolean} isVideo\n * @return {!Array.<MediaKeySystemMediaCapability>}\n * @private\n */\nshaka.offline.Storage.getCapabilities_ = function(manifestDb, isVideo) {\n  const MimeUtils = shaka.util.MimeUtils;\n\n  const ret = [];\n  for (const period of manifestDb.periods) {\n    for (const stream of period.streams) {\n      if (isVideo && stream.contentType == 'video') {\n        ret.push({\n          contentType: MimeUtils.getFullType(stream.mimeType, stream.codecs),\n          robustness: manifestDb.drmInfo.videoRobustness,\n        });\n      } else if (!isVideo && stream.contentType == 'audio') {\n        ret.push({\n          contentType: MimeUtils.getFullType(stream.mimeType, stream.codecs),\n          robustness: manifestDb.drmInfo.audioRobustness,\n        });\n      }\n    }\n  }\n  return ret;\n};\n\n\n/**\n * @param {!shaka.offline.OfflineUri} uri\n * @param {shaka.extern.ManifestDB} manifestDb\n * @param {!shaka.offline.StorageMuxer} muxer\n * @return {!Promise}\n * @private\n */\nshaka.offline.Storage.prototype.removeFromDRM_ = async function(\n    uri, manifestDb, muxer) {\n  goog.asserts.assert(this.networkingEngine_, 'Cannot be destroyed');\n  await shaka.offline.Storage.deleteLicenseFor_(\n      this.networkingEngine_, this.config_.drm, muxer, manifestDb);\n};\n\n\n/**\n * @param {shaka.extern.StorageCell} storage\n * @param {!shaka.offline.OfflineUri} uri\n * @param {shaka.extern.ManifestDB} manifest\n * @return {!Promise}\n * @private\n */\nshaka.offline.Storage.prototype.removeFromStorage_ = function(\n    storage, uri, manifest) {\n  /** @type {!Array.<number>} */\n  let segmentIds = shaka.offline.Storage.getAllSegmentIds_(manifest);\n\n  // Count(segments) + Count(manifests)\n  let toRemove = segmentIds.length + 1;\n  let removed = 0;\n\n  let pendingContent = shaka.offline.StoredContentUtils.fromManifestDB(\n      uri, manifest);\n\n  let onRemove = (key) => {\n    removed += 1;\n    this.config_.offline.progressCallback(pendingContent, removed / toRemove);\n  };\n\n  return Promise.all([\n    storage.removeSegments(segmentIds, onRemove),\n    storage.removeManifests([uri.key()], onRemove),\n  ]);\n};\n\n\n/**\n * Removes any EME sessions that were not successfully removed before.  This\n * returns whether all the sessions were successfully removed.\n *\n * @return {!Promise.<boolean>}\n * @export\n */\nshaka.offline.Storage.prototype.removeEmeSessions = function() {\n  return this.startOperation_(this.removeEmeSessions_());\n};\n\n/**\n * @return {!Promise.<boolean>}\n * @private\n */\nshaka.offline.Storage.prototype.removeEmeSessions_ = async function() {\n  this.requireSupport_();\n\n  goog.asserts.assert(this.networkingEngine_, 'Cannot be destroyed');\n  const net = this.networkingEngine_;\n  const config = this.config_.drm;\n\n  /** @type {!shaka.offline.StorageMuxer} */\n  const muxer = new shaka.offline.StorageMuxer();\n  /** @type {!shaka.offline.SessionDeleter} */\n  const deleter = new shaka.offline.SessionDeleter();\n\n  let hasRemaining = false;\n\n  try {\n    await muxer.init();\n\n    /** @type {!Array.<shaka.extern.EmeSessionStorageCell>} */\n    const cells = [];\n    muxer.forEachEmeSessionCell((c) => cells.push(c));\n\n    // Run these sequentially to avoid creating too many DrmEngine instances\n    // and having multiple CDMs alive at once.  Some embedded platforms may\n    // not support that.\n    let p = Promise.resolve();\n\n    for (const sessionIdCell of cells) {\n      p = p.then(async () => {\n        const sessions = await sessionIdCell.getAll();\n        const deletedSessionIds = await deleter.delete(config, net, sessions);\n        await sessionIdCell.remove(deletedSessionIds);\n\n        if (deletedSessionIds.length != sessions.length) {\n          hasRemaining = true;\n        }\n      });\n    }\n\n    await p;\n  } finally {\n    await muxer.destroy();\n  }\n\n  return !hasRemaining;\n};\n\n\n/**\n * Lists all the stored content available.\n *\n * @return {!Promise.<!Array.<shaka.extern.StoredContent>>}  A Promise to an\n *   array of structures representing all stored content.  The \"offlineUri\"\n *   member of the structure is the URI that should be given to Player.load()\n *   to play this piece of content offline.  The \"appMetadata\" member is the\n *   appMetadata argument you passed to store().\n * @export\n */\nshaka.offline.Storage.prototype.list = function() {\n  return this.startOperation_(this.list_());\n};\n\n\n/**\n * See |shaka.offline.Storage.list| for details.\n *\n * @return {!Promise.<!Array.<shaka.extern.StoredContent>>}\n * @private\n */\nshaka.offline.Storage.prototype.list_ = async function() {\n  this.requireSupport_();\n\n  /** @type {!Array.<shaka.extern.StoredContent>} */\n  const result = [];\n\n  /** @type {!shaka.offline.StorageMuxer} */\n  const muxer = new shaka.offline.StorageMuxer();\n  try {\n    await muxer.init();\n\n    let p = Promise.resolve();\n    muxer.forEachCell((path, cell) => {\n      p = p.then(async () => {\n        const manifests = await cell.getAllManifests();\n\n        manifests.forEach((manifest, key) => {\n          const uri = shaka.offline.OfflineUri.manifest(\n              path.mechanism,\n              path.cell,\n              key);\n\n          const content = shaka.offline.StoredContentUtils.fromManifestDB(\n              uri,\n              manifest);\n\n          result.push(content);\n        });\n      });\n    });\n\n    await p;\n  } finally {\n    await muxer.destroy();\n  }\n\n  return result;\n};\n\n\n/**\n * This method is public so that it can be overridden in testing.\n *\n * @param {string} uri\n * @param {function():!Promise.<shaka.extern.ManifestParser>} getParser\n * @return {!Promise.<shaka.extern.Manifest>}\n */\nshaka.offline.Storage.prototype.parseManifest = async function(\n    uri, getParser) {\n  let error = null;\n\n  const networkingEngine = this.networkingEngine_;\n  goog.asserts.assert(networkingEngine, 'Should be initialized!');\n\n  /** @type {shaka.extern.ManifestParser.PlayerInterface} */\n  const playerInterface = {\n    networkingEngine: networkingEngine,\n\n    // Don't bother filtering now. We will do that later when we have all the\n    // information we need to filter.\n    filterAllPeriods: () => {},\n    filterNewPeriod: () => {},\n\n    onTimelineRegionAdded: () => {},\n    onEvent: () => {},\n\n    // Used to capture an error from the manifest parser. We will check the\n    // error before returning.\n    onError: (e) => {\n      error = e;\n    },\n  };\n\n  const parser = await getParser();\n  parser.configure(this.config_.manifest);\n\n  // We may have been destroyed while we were waiting on |getParser| to\n  // resolve.\n  this.checkDestroyed_();\n\n  try {\n    const manifest = await parser.start(uri, playerInterface);\n\n    // We may have been destroyed while we were waiting on |start| to\n    // resolve.\n    this.checkDestroyed_();\n\n    // Get all the streams that are used in the manifest.\n    const streams = shaka.offline.Storage.getStreamSet_(manifest);\n\n    // Wait for each stream to create their segment indexes.\n    await Promise.all(Array.from(streams).map((stream) => {\n      return stream.createSegmentIndex();\n    }));\n\n    // We may have been destroyed while we were waiting on |createSegmentIndex|\n    // to resolve for each stream.\n    this.checkDestroyed_();\n\n    // If we saw an error while parsing, surface the error.\n    if (error) {\n      throw error;\n    }\n\n    return manifest;\n  } finally {\n    await parser.stop();\n  }\n};\n\n\n/**\n * This method is public so that it can be override in testing.\n *\n * @param {shaka.extern.Manifest} manifest\n * @param {function(shaka.util.Error)} onError\n * @return {!Promise.<!shaka.media.DrmEngine>}\n */\nshaka.offline.Storage.prototype.createDrmEngine = async function(\n    manifest, onError) {\n  goog.asserts.assert(\n      this.networkingEngine_, 'Cannot call |createDrmEngine| after |destroy|');\n\n  /** @type {!shaka.media.DrmEngine} */\n  const drmEngine = new shaka.media.DrmEngine({\n    netEngine: this.networkingEngine_,\n    onError: onError,\n    onKeyStatus: () => {},\n    onExpirationUpdated: () => {},\n    onEvent: () => {},\n  });\n\n  const variants = shaka.util.Periods.getAllVariantsFrom(manifest.periods);\n\n  const config = this.config_;\n  drmEngine.configure(config.drm);\n  await drmEngine.initForStorage(variants, config.offline.usePersistentLicense);\n  await drmEngine.setServerCertificate();\n  await drmEngine.createOrLoad();\n\n  return drmEngine;\n};\n\n\n/**\n * Creates an offline 'manifest' for the real manifest.  This does not store the\n * segments yet, only adds them to the download manager through createPeriod_.\n *\n * @param {!shaka.offline.DownloadManager} downloader\n * @param {shaka.extern.StorageCell} storage\n * @param {!shaka.media.DrmEngine} drmEngine\n * @param {shaka.extern.Manifest} manifest\n * @param {string} originalManifestUri\n * @param {!Object} metadata\n * @return {shaka.extern.ManifestDB}\n * @private\n */\nshaka.offline.Storage.prototype.createOfflineManifest_ = function(\n    downloader, storage, drmEngine, manifest, originalManifestUri, metadata) {\n  let estimator = new shaka.offline.StreamBandwidthEstimator();\n\n  let periods = manifest.periods.map((period) => {\n    return this.createPeriod_(\n        downloader, storage, estimator, drmEngine, manifest, period);\n  });\n\n  let drmInfo = drmEngine.getDrmInfo();\n  let sessions = drmEngine.getSessionIds();\n\n  if (drmInfo && this.config_.offline.usePersistentLicense) {\n    if (!sessions.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL, shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.NO_INIT_DATA_FOR_OFFLINE, originalManifestUri);\n    }\n    // Don't store init data, since we have stored sessions.\n    drmInfo.initData = [];\n  }\n\n  return {\n    originalManifestUri: originalManifestUri,\n    duration: manifest.presentationTimeline.getDuration(),\n    size: 0,\n    expiration: drmEngine.getExpiration(),\n    periods: periods,\n    sessionIds: this.config_.offline.usePersistentLicense ? sessions : [],\n    drmInfo: drmInfo,\n    appMetadata: metadata,\n  };\n};\n\n\n/**\n * Converts a manifest Period to a database Period.  This will use the current\n * configuration to get the tracks to use, then it will search each segment\n * index and add all the segments to the download manager through createStream_.\n *\n * @param {!shaka.offline.DownloadManager} downloader\n * @param {shaka.extern.StorageCell} storage\n * @param {shaka.offline.StreamBandwidthEstimator} estimator\n * @param {!shaka.media.DrmEngine} drmEngine\n * @param {shaka.extern.Manifest} manifest\n * @param {shaka.extern.Period} period\n * @return {shaka.extern.PeriodDB}\n * @private\n */\nshaka.offline.Storage.prototype.createPeriod_ = function(\n    downloader, storage, estimator, drmEngine, manifest, period) {\n  // Pass all variants and text streams to the estimator so that we can\n  // get the best estimate for each stream later.\n  manifest.periods.forEach((period) => {\n    period.variants.forEach((variant) => { estimator.addVariant(variant); });\n    period.textStreams.forEach((text) => { estimator.addText(text); });\n  });\n\n  // Find the streams we want to download and create a stream db instance\n  // for each of them.\n  const streamSet = shaka.offline.Storage.getStreamSet_(manifest);\n  const streamDBs = new Map();\n\n  for (const stream of streamSet) {\n    const streamDB = this.createStream_(\n        downloader, storage, estimator, manifest, period, stream);\n    streamDBs.set(stream.id, streamDB);\n  }\n\n  // Connect streams and variants together.\n  period.variants.forEach((variant) => {\n    if (variant.audio) {\n      streamDBs.get(variant.audio.id).variantIds.push(variant.id);\n    }\n    if (variant.video) {\n      streamDBs.get(variant.video.id).variantIds.push(variant.id);\n    }\n  });\n\n  return {\n    startTime: period.startTime,\n    streams: Array.from(streamDBs.values()),\n  };\n};\n\n\n/**\n * Converts a manifest stream to a database stream.  This will search the\n * segment index and add all the segments to the download manager.\n *\n * @param {!shaka.offline.DownloadManager} downloader\n * @param {shaka.extern.StorageCell} storage\n * @param {shaka.offline.StreamBandwidthEstimator} estimator\n * @param {shaka.extern.Manifest} manifest\n * @param {shaka.extern.Period} period\n * @param {shaka.extern.Stream} stream\n * @return {shaka.extern.StreamDB}\n * @private\n */\nshaka.offline.Storage.prototype.createStream_ = function(\n    downloader, storage, estimator, manifest, period, stream) {\n  /** @type {shaka.extern.StreamDB} */\n  let streamDb = {\n    id: stream.id,\n    originalId: stream.originalId,\n    primary: stream.primary,\n    presentationTimeOffset: stream.presentationTimeOffset || 0,\n    contentType: stream.type,\n    mimeType: stream.mimeType,\n    codecs: stream.codecs,\n    frameRate: stream.frameRate,\n    kind: stream.kind,\n    language: stream.language,\n    label: stream.label,\n    width: stream.width || null,\n    height: stream.height || null,\n    initSegmentKey: null,\n    encrypted: stream.encrypted,\n    keyId: stream.keyId,\n    segments: [],\n    variantIds: [],\n  };\n\n  /** @type {number} */\n  let startTime =\n      manifest.presentationTimeline.getSegmentAvailabilityStart();\n\n  // Download each stream in parallel.\n  let downloadGroup = stream.id;\n\n  shaka.offline.Storage.forEachSegment_(stream, startTime, (segment) => {\n    const request = shaka.util.Networking.createSegmentRequest(\n        segment.getUris(),\n        segment.startByte,\n        segment.endByte,\n        this.config_.streaming.retryParameters);\n\n    downloader.queue(\n        downloadGroup,\n        request,\n        estimator.getSegmentEstimate(stream.id, segment),\n        (data) => {\n          return storage.addSegments([{data: data}]).then((ids) => {\n            this.segmentsFromStore_.push(ids[0]);\n\n            streamDb.segments.push({\n              startTime: segment.startTime,\n              endTime: segment.endTime,\n              dataKey: ids[0],\n            });\n          });\n        });\n  });\n\n  let initSegment = stream.initSegmentReference;\n  if (initSegment) {\n    const request = shaka.util.Networking.createSegmentRequest(\n        initSegment.getUris(),\n        initSegment.startByte,\n        initSegment.endByte,\n        this.config_.streaming.retryParameters);\n\n    downloader.queue(\n        downloadGroup,\n        request,\n        estimator.getInitSegmentEstimate(stream.id),\n        (data) => {\n          return storage.addSegments([{data: data}]).then((ids) => {\n            this.segmentsFromStore_.push(ids[0]);\n            streamDb.initSegmentKey = ids[0];\n          });\n        });\n  }\n\n  return streamDb;\n};\n\n\n/**\n * @param {shaka.extern.Stream} stream\n * @param {number} startTime\n * @param {function(!shaka.media.SegmentReference)} callback\n * @private\n */\nshaka.offline.Storage.forEachSegment_ = function(stream, startTime, callback) {\n  /** @type {?number} */\n  let i = stream.findSegmentPosition(startTime);\n  /** @type {?shaka.media.SegmentReference} */\n  let ref = i == null ? null : stream.getSegmentReference(i);\n\n  while (ref) {\n    callback(ref);\n    ref = stream.getSegmentReference(++i);\n  }\n};\n\n\n/**\n * Throws an error if the object is destroyed.\n * @private\n */\nshaka.offline.Storage.prototype.checkDestroyed_ = function() {\n  if (this.destroyer_.destroyed()) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.OPERATION_ABORTED);\n  }\n};\n\n\n/**\n * Used by functions that need storage support to ensure that the current\n * platform has storage support before continuing. This should only be\n * needed to be used at the start of public methods.\n *\n * @private\n */\nshaka.offline.Storage.prototype.requireSupport_ = function() {\n  if (!shaka.offline.Storage.support()) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.STORAGE_NOT_SUPPORTED);\n  }\n};\n\n\n/**\n * Perform an action. Track the action's progress so that when we destroy\n * we will wait until all the actions have completed before allowing destroy\n * to resolve.\n *\n * @param {!Promise<T>} action\n * @return {!Promise<T>}\n * @template T\n * @private\n */\nshaka.offline.Storage.prototype.startOperation_ = async function(action) {\n  this.openOperations_.push(action);\n\n  try {\n    // Await |action| so we can use the finally statement to remove |action|\n    // from |openOperations_| when we still have a reference to |action|.\n    return await action;\n  } finally {\n    shaka.util.ArrayUtils.remove(this.openOperations_, action);\n  }\n};\n\n\n/**\n * @param {shaka.extern.ManifestDB} manifest\n * @return {!Array.<number>}\n * @private\n */\nshaka.offline.Storage.getAllSegmentIds_ = function(manifest) {\n  /** @type {!Array.<number>} */\n  let ids = [];\n\n  // Get every segment for every stream in the manifest.\n  manifest.periods.forEach(function(period) {\n    period.streams.forEach(function(stream) {\n      if (stream.initSegmentKey != null) {\n        ids.push(stream.initSegmentKey);\n      }\n\n      stream.segments.forEach(function(segment) {\n        ids.push(segment.dataKey);\n      });\n    });\n  });\n\n  return ids;\n};\n\n\n/**\n * Delete the on-disk storage and all the content it contains. This should not\n * be done in normal circumstances. Only do it when storage is rendered\n * unusable, such as by a version mismatch. No business logic will be run, and\n * licenses will not be released.\n *\n * @return {!Promise}\n * @export\n */\nshaka.offline.Storage.deleteAll = async function() {\n  /** @type {!shaka.offline.StorageMuxer} */\n  const muxer = new shaka.offline.StorageMuxer();\n  try {\n    // Wipe all content from all storage mechanisms.\n    await muxer.erase();\n  } finally {\n    // Destroy the muxer, whether or not erase() succeeded.\n    await muxer.destroy();\n  }\n};\n\n\n/**\n * @param {!shaka.net.NetworkingEngine} net\n * @param {!shaka.extern.DrmConfiguration} drmConfig\n * @param {!shaka.offline.StorageMuxer} muxer\n * @param {shaka.extern.ManifestDB} manifestDb\n * @return {!Promise}\n * @private\n */\nshaka.offline.Storage.deleteLicenseFor_ = async function(\n    net, drmConfig, muxer, manifestDb) {\n  if (!manifestDb.drmInfo) {\n    return;\n  }\n\n  const sessionIdCell = muxer.getEmeSessionCell();\n\n  /** @type {!Array.<shaka.extern.EmeSessionDB>} */\n  const sessions = manifestDb.sessionIds.map((sessionId) => {\n    return {\n      sessionId: sessionId,\n      keySystem: manifestDb.drmInfo.keySystem,\n      licenseUri: manifestDb.drmInfo.licenseServerUri,\n      serverCertificate: manifestDb.drmInfo.serverCertificate,\n      audioCapabilities: shaka.offline.Storage.getCapabilities_(\n          manifestDb,\n          /* isVideo */ false),\n      videoCapabilities: shaka.offline.Storage.getCapabilities_(\n          manifestDb,\n          /* isVideo */ true),\n    };\n  });\n  // Try to delete the sessions; any sessions that weren't deleted get stored\n  // in the database so we can try to remove them again later.  This allows us\n  // to still delete the stored content but not \"forget\" about these sessions.\n  // Later, we can remove the sessions to free up space.\n  const deleter = new shaka.offline.SessionDeleter();\n  const deletedSessionIds = await deleter.delete(drmConfig, net, sessions);\n  await sessionIdCell.remove(deletedSessionIds);\n  await sessionIdCell.add(sessions.filter(\n      (session) => deletedSessionIds.indexOf(session.sessionId) == -1));\n};\n\n\n/**\n * Get the set of all streams in |manifest|.\n *\n * @param {shaka.extern.Manifest} manifest\n * @return {!Set.<shaka.extern.Stream>}\n * @private\n */\nshaka.offline.Storage.getStreamSet_ = function(manifest) {\n  /** @type {!Set.<shaka.extern.Stream>} */\n  const set = new Set();\n\n  for (const period of manifest.periods) {\n    for (const text of period.textStreams) {\n      set.add(text);\n    }\n\n    for (const variant of period.variants) {\n      if (variant.audio) { set.add(variant.audio); }\n      if (variant.video) { set.add(variant.video); }\n    }\n  }\n\n  return set;\n};\n\n\n/**\n * Make sure that the given configuration object follows the correct structure\n * expected by |configure|. This function should be removed in v2.6 when\n * backward-compatibility is no longer needed.\n *\n * @param {!Object} config\n *    The config fields that the app wants to update. This object will be\n *    change by this function.\n * @private\n */\nshaka.offline.Storage.verifyConfig_ = function(config) {\n  // To avoid printing a deprecated warning multiple times, track all\n  // infractions and then print it once at the end.\n  let usedLegacyConfig = false;\n\n  // For each field in the legacy config structure\n  // (shaka.extern.OfflineConfiguration), move any occurances to the correct\n  // location in the player configuration.\n  if (config.trackSelectionCallback != null) {\n    usedLegacyConfig = true;\n    config.offline = config.offline || {};\n    config.offline.trackSelectionCallback = config.trackSelectionCallback;\n    delete config.trackSelectionCallback;\n  }\n\n  if (config.progressCallback != null) {\n    usedLegacyConfig = true;\n    config.offline = config.offline || {};\n    config.offline.progressCallback = config.progressCallback;\n    delete config.progressCallback;\n  }\n\n  if (config.usePersistentLicense != null) {\n    usedLegacyConfig = true;\n    config.offline = config.offline || {};\n    config.offline.usePersistentLicense = config.usePersistentLicense;\n    delete config.usePersistentLicense;\n  }\n\n  if (usedLegacyConfig) {\n    shaka.Deprecate.deprecateFeature(\n        2, 6,\n        'Storage.configure with OfflineConfig',\n        'Please configure storage with a player configuration.');\n  }\n};\n\n\n/**\n * Go over a manifest and issue warnings for any suspicious properties.\n *\n * @param {shaka.extern.Manifest} manifest\n * @private\n */\nshaka.offline.Storage.validateManifest_ = function(manifest) {\n  // Make sure that the period has not been reduced to nothing.\n  if (manifest.periods.length == 0) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.NO_PERIODS);\n  }\n\n  for (const period of manifest.periods) {\n    shaka.offline.Storage.validatePeriod_(period);\n  }\n};\n\n\n/**\n * Go over a period and issue warnings for any suspicious properties.\n *\n * @param {shaka.extern.Period} period\n * @private\n */\nshaka.offline.Storage.validatePeriod_ = function(period) {\n  const videos = new Set(period.variants.map((v) => v.video));\n  const audios = new Set(period.variants.map((v) => v.audio));\n  const texts = period.textStreams;\n\n  if (videos.size > 1) {\n    shaka.log.warning('Multiple video tracks selected to be stored');\n  }\n\n  for (const audio1 of audios) {\n    for (const audio2 of audios) {\n      if (audio1 != audio2 && audio1.language == audio2.language) {\n        shaka.log.warning(\n            'Similar audio tracks were selected to be stored',\n            audio1.id,\n            audio2.id);\n      }\n    }\n  }\n\n  for (const text1 of texts) {\n    for (const text2 of texts) {\n      if (text1 != text2 && text1.language == text2.language) {\n        shaka.log.warning(\n            'Similar text tracks were selected to be stored',\n            text1.id,\n            text2.id);\n      }\n    }\n  }\n};\n\nshaka.Player.registerSupportPlugin('offline', shaka.offline.Storage.support);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.installAll');\ngoog.provide('shaka.polyfill.register');\n\n\n/**\n * @namespace shaka.polyfill\n * @summary A one-stop installer for all polyfills.\n * @see http://enwp.org/polyfill\n * @exportDoc\n */\n\n\n/**\n * Install all polyfills.\n * @export\n */\nshaka.polyfill.installAll = function() {\n  for (let i = 0; i < shaka.polyfill.polyfills_.length; ++i) {\n    shaka.polyfill.polyfills_[i].callback();\n  }\n};\n\n\n/**\n * Contains the polyfills that will be installed.\n * @private {!Array.<{priority: number, callback: function()}>}\n */\nshaka.polyfill.polyfills_ = [];\n\n\n/**\n * Registers a new polyfill to be installed.\n *\n * @param {function()} polyfill\n * @param {number=} priority An optional number priority.  Higher priorities\n *   will be executed before lower priority ones.  Default is 0.\n * @export\n */\nshaka.polyfill.register = function(polyfill, priority) {\n  priority = priority || 0;\n  const item = {priority: priority, callback: polyfill};\n  for (let i = 0; i < shaka.polyfill.polyfills_.length; i++) {\n    if (shaka.polyfill.polyfills_[i].priority < priority) {\n      shaka.polyfill.polyfills_.splice(i, 0, item);\n      return;\n    }\n  }\n  shaka.polyfill.polyfills_.push(item);\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.PatchedMediaKeysApple');\n\ngoog.require('goog.Uri');\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill.register');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @namespace shaka.polyfill.PatchedMediaKeysApple\n *\n * @summary A polyfill to implement modern, standardized EME on top of Apple's\n * prefixed EME in Safari.\n */\n\n\n/**\n * Installs the polyfill if needed.\n */\nshaka.polyfill.PatchedMediaKeysApple.install = function() {\n  if (!window.HTMLVideoElement || !window.WebKitMediaKeys) {\n    // No HTML5 video or no prefixed EME.\n    return;\n  }\n\n  // TODO: Prefer unprefixed EME once we know how to use it.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=197433\n  /*\n  if (navigator.requestMediaKeySystemAccess &&\n      MediaKeySystemAccess.prototype.getConfiguration) {\n    // Prefixed EME is preferable.\n    return;\n  }\n  */\n\n  shaka.log.info('Using Apple-prefixed EME');\n\n  // Alias\n  const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n  // Construct a fake key ID.  This is not done at load-time to avoid exceptions\n  // on unsupported browsers.  This particular fake key ID was suggested in\n  // w3c/encrypted-media#32.\n  PatchedMediaKeysApple.MediaKeyStatusMap.KEY_ID_ =\n      (new Uint8Array([0])).buffer;\n\n  // Delete mediaKeys to work around strict mode compatibility issues.\n  delete HTMLMediaElement.prototype['mediaKeys'];\n  // Work around read-only declaration for mediaKeys by using a string.\n  HTMLMediaElement.prototype['mediaKeys'] = null;\n  HTMLMediaElement.prototype.setMediaKeys = PatchedMediaKeysApple.setMediaKeys;\n\n  // Install patches\n  window.MediaKeys = PatchedMediaKeysApple.MediaKeys;\n  window.MediaKeySystemAccess = PatchedMediaKeysApple.MediaKeySystemAccess;\n  navigator.requestMediaKeySystemAccess =\n      PatchedMediaKeysApple.requestMediaKeySystemAccess;\n};\n\n\n/**\n * An implementation of navigator.requestMediaKeySystemAccess.\n * Retrieves a MediaKeySystemAccess object.\n *\n * @this {!Navigator}\n * @param {string} keySystem\n * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n * @return {!Promise.<!MediaKeySystemAccess>}\n */\nshaka.polyfill.PatchedMediaKeysApple.requestMediaKeySystemAccess =\n    function(keySystem, supportedConfigurations) {\n  shaka.log.debug('PatchedMediaKeysApple.requestMediaKeySystemAccess');\n  goog.asserts.assert(this == navigator,\n                      'bad \"this\" for requestMediaKeySystemAccess');\n\n  // Alias.\n  const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n  try {\n    const access = new PatchedMediaKeysApple.MediaKeySystemAccess(\n        keySystem, supportedConfigurations);\n    return Promise.resolve(/** @type {!MediaKeySystemAccess} */ (access));\n  } catch (exception) {\n    return Promise.reject(exception);\n  }\n};\n\n\n/**\n * An implementation of MediaKeySystemAccess.\n *\n * @constructor\n * @struct\n * @param {string} keySystem\n * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n * @implements {MediaKeySystemAccess}\n * @throws {Error} if the key system is not supported.\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySystemAccess =\n    function(keySystem, supportedConfigurations) {\n  shaka.log.debug('PatchedMediaKeysApple.MediaKeySystemAccess');\n\n  /** @type {string} */\n  this.keySystem = keySystem;\n\n  /** @private {!MediaKeySystemConfiguration} */\n  this.configuration_;\n\n  // Optimization: WebKitMediaKeys.isTypeSupported delays responses by a\n  // significant amount of time, possibly to discourage fingerprinting.\n  // Since we know only FairPlay is supported here, let's skip queries for\n  // anything else to speed up the process.\n  if (keySystem.startsWith('com.apple.fps')) {\n    for (const cfg of supportedConfigurations) {\n      const newCfg = this.checkConfig_(cfg);\n      if (newCfg) {\n        this.configuration_ = newCfg;\n        return;\n      }\n    }\n  }\n\n  // As per the spec, this should be a DOMException, but there is not a public\n  // constructor for DOMException.\n  const unsupportedKeySystemError = new Error('Unsupported keySystem');\n  unsupportedKeySystemError.name = 'NotSupportedError';\n  unsupportedKeySystemError.code = DOMException.NOT_SUPPORTED_ERR;\n  throw unsupportedKeySystemError;\n};\n\n\n/**\n * Check a single config for MediaKeySystemAccess.\n *\n * @param {MediaKeySystemConfiguration} cfg The requested config.\n * @return {?MediaKeySystemConfiguration} A matching config we can support, or\n *   null if the input is not supportable.\n * @private\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySystemAccess.prototype.\n    checkConfig_ = function(cfg) {\n  if (cfg.persistentState == 'required') {\n    // Not supported by the prefixed API.\n    return null;\n  }\n\n  // Create a new config object and start adding in the pieces which we find\n  // support for.  We will return this from getConfiguration() later if asked.\n\n  /** @type {!MediaKeySystemConfiguration} */\n  const newCfg = {\n    'audioCapabilities': [],\n    'videoCapabilities': [],\n    // It is technically against spec to return these as optional, but we\n    // don't truly know their values from the prefixed API:\n    'persistentState': 'optional',\n    'distinctiveIdentifier': 'optional',\n    // Pretend the requested init data types are supported, since we don't\n    // really know that either:\n    'initDataTypes': cfg.initDataTypes,\n    'sessionTypes': ['temporary'],\n    'label': cfg.label,\n  };\n\n  // PatchedMediaKeysApple tests for key system availability through\n  // WebKitMediaKeys.isTypeSupported.\n  let ranAnyTests = false;\n  let success = false;\n\n  if (cfg.audioCapabilities) {\n    for (const cap of cfg.audioCapabilities) {\n      if (cap.contentType) {\n        ranAnyTests = true;\n\n        const contentType = cap.contentType.split(';')[0];\n        if (WebKitMediaKeys.isTypeSupported(this.keySystem, contentType)) {\n          newCfg.audioCapabilities.push(cap);\n          success = true;\n        }\n      }\n    }\n  }\n\n  if (cfg.videoCapabilities) {\n    for (const cap of cfg.videoCapabilities) {\n      if (cap.contentType) {\n        ranAnyTests = true;\n\n        const contentType = cap.contentType.split(';')[0];\n        if (WebKitMediaKeys.isTypeSupported(this.keySystem, contentType)) {\n          newCfg.videoCapabilities.push(cap);\n          success = true;\n        }\n      }\n    }\n  }\n\n  if (!ranAnyTests) {\n    // If no specific types were requested, we check all common types to find\n    // out if the key system is present at all.\n    success = WebKitMediaKeys.isTypeSupported(this.keySystem, 'video/mp4');\n  }\n\n  if (success) {\n    return newCfg;\n  }\n  return null;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySystemAccess.prototype.\n    createMediaKeys = function() {\n  shaka.log.debug('PatchedMediaKeysApple.MediaKeySystemAccess.createMediaKeys');\n\n  // Alias\n  const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n  const mediaKeys = new PatchedMediaKeysApple.MediaKeys(this.keySystem);\n  return Promise.resolve(/** @type {!MediaKeys} */ (mediaKeys));\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySystemAccess.prototype.\n    getConfiguration = function() {\n  shaka.log.debug(\n      'PatchedMediaKeysApple.MediaKeySystemAccess.getConfiguration');\n  return this.configuration_;\n};\n\n\n/**\n * An implementation of HTMLMediaElement.prototype.setMediaKeys.\n * Attaches a MediaKeys object to the media element.\n *\n * @this {!HTMLMediaElement}\n * @param {MediaKeys} mediaKeys\n * @return {!Promise}\n */\nshaka.polyfill.PatchedMediaKeysApple.setMediaKeys = function(mediaKeys) {\n  shaka.log.debug('PatchedMediaKeysApple.setMediaKeys');\n  goog.asserts.assert(this instanceof HTMLMediaElement,\n                      'bad \"this\" for setMediaKeys');\n\n  // Alias\n  const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n  const newMediaKeys =\n      /** @type {shaka.polyfill.PatchedMediaKeysApple.MediaKeys} */ (\n      mediaKeys);\n  const oldMediaKeys =\n      /** @type {shaka.polyfill.PatchedMediaKeysApple.MediaKeys} */ (\n      this.mediaKeys);\n\n  if (oldMediaKeys && oldMediaKeys != newMediaKeys) {\n    goog.asserts.assert(oldMediaKeys instanceof PatchedMediaKeysApple.MediaKeys,\n                        'non-polyfill instance of oldMediaKeys');\n    // Have the old MediaKeys stop listening to events on the video tag.\n    oldMediaKeys.setMedia(null);\n  }\n\n  delete this['mediaKeys'];  // in case there is an existing getter\n  this['mediaKeys'] = mediaKeys;  // work around read-only declaration\n\n  if (newMediaKeys) {\n    goog.asserts.assert(newMediaKeys instanceof PatchedMediaKeysApple.MediaKeys,\n                        'non-polyfill instance of newMediaKeys');\n    return newMediaKeys.setMedia(this);\n  }\n\n  return Promise.resolve();\n};\n\n\n/**\n * An implementation of MediaKeys.\n *\n * @constructor\n * @struct\n * @param {string} keySystem\n * @implements {MediaKeys}\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeys = function(keySystem) {\n  shaka.log.debug('PatchedMediaKeysApple.MediaKeys');\n\n  /** @private {!WebKitMediaKeys} */\n  this.nativeMediaKeys_ = new WebKitMediaKeys(keySystem);\n\n  /** @private {!shaka.util.EventManager} */\n  this.eventManager_ = new shaka.util.EventManager();\n\n  /** @type {Uint8Array} */\n  this.certificate = null;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeys.prototype.\n    createSession = function(sessionType) {\n  shaka.log.debug('PatchedMediaKeysApple.MediaKeys.createSession');\n\n  sessionType = sessionType || 'temporary';\n  // For now, only the 'temporary' type is supported.\n  if (sessionType != 'temporary') {\n    throw new TypeError('Session type ' + sessionType +\n        ' is unsupported on this platform.');\n  }\n\n  // Alias\n  const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n  return new PatchedMediaKeysApple.MediaKeySession(\n      this.nativeMediaKeys_, sessionType);\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeys.prototype.\n    setServerCertificate = function(serverCertificate) {\n  shaka.log.debug('PatchedMediaKeysApple.MediaKeys.setServerCertificate');\n\n  this.certificate =\n      serverCertificate ? new Uint8Array(serverCertificate) : null;\n\n  return Promise.resolve(true);\n};\n\n\n/**\n * @param {HTMLMediaElement} media\n * @protected\n * @return {!Promise}\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeys.prototype.\n    setMedia = function(media) {\n  // Alias\n  const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n  // Remove any old listeners.\n  this.eventManager_.removeAll();\n\n  // It is valid for media to be null; null is used to flag that event handlers\n  // need to be cleaned up.\n  if (!media) {\n    return Promise.resolve();\n  }\n\n  // Intercept and translate these prefixed EME events.\n  this.eventManager_.listen(media, 'webkitneedkey',\n      /** @type {shaka.util.EventManager.ListenerType} */\n      (PatchedMediaKeysApple.onWebkitNeedKey_));\n\n  // Wrap native HTMLMediaElement.webkitSetMediaKeys with a Promise.\n  try {\n    // Some browsers require that readyState >=1 before mediaKeys can be set, so\n    // check this and wait for loadedmetadata if we are not in the correct state\n    if (media.readyState >= 1) {\n      media.webkitSetMediaKeys(this.nativeMediaKeys_);\n    } else {\n      this.eventManager_.listenOnce(media, 'loadedmetadata', () => {\n        media.webkitSetMediaKeys(this.nativeMediaKeys_);\n      });\n    }\n\n    return Promise.resolve();\n  } catch (exception) {\n    return Promise.reject(exception);\n  }\n};\n\n\n/**\n * An implementation of MediaKeySession.\n *\n * @constructor\n * @struct\n * @param {WebKitMediaKeys} nativeMediaKeys\n * @param {string} sessionType\n * @implements {MediaKeySession}\n * @extends {shaka.util.FakeEventTarget}\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySession =\n    function(nativeMediaKeys, sessionType) {\n  shaka.log.debug('PatchedMediaKeysApple.MediaKeySession');\n  shaka.util.FakeEventTarget.call(this);\n\n  /** The native MediaKeySession, which will be created in generateRequest.\n   * @private {WebKitMediaKeySession} */\n  this.nativeMediaKeySession_ = null;\n\n  /** @private {WebKitMediaKeys} */\n  this.nativeMediaKeys_ = nativeMediaKeys;\n\n  // Promises that are resolved later\n  /** @private {shaka.util.PublicPromise} */\n  this.generateRequestPromise_ = null;\n\n  /** @private {shaka.util.PublicPromise} */\n  this.updatePromise_ = null;\n\n  /** @private {!shaka.util.EventManager} */\n  this.eventManager_ = new shaka.util.EventManager();\n\n  /** @type {string} */\n  this.sessionId = '';\n\n  /** @type {number} */\n  this.expiration = NaN;\n\n  /** @type {!shaka.util.PublicPromise} */\n  this.closed = new shaka.util.PublicPromise();\n\n  /** @type {!shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap} */\n  this.keyStatuses =\n      new shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap();\n};\ngoog.inherits(shaka.polyfill.PatchedMediaKeysApple.MediaKeySession,\n    shaka.util.FakeEventTarget);\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype.\n    generateRequest = function(initDataType, initData) {\n  shaka.log.debug('PatchedMediaKeysApple.MediaKeySession.generateRequest');\n\n  this.generateRequestPromise_ = new shaka.util.PublicPromise();\n\n  try {\n    // This EME spec version requires a MIME content type as the 1st param\n    // to createSession, but doesn't seem to matter what the value is.\n    // It also only accepts Uint8Array, not ArrayBuffer, so explicitly make\n    // initData into a Uint8Array.\n    this.nativeMediaKeySession_ = this.nativeMediaKeys_.createSession(\n        'video/mp4', new Uint8Array(initData));\n\n    // Attach session event handlers here.\n    this.eventManager_.listen(this.nativeMediaKeySession_, 'webkitkeymessage',\n        /** @type {shaka.util.EventManager.ListenerType} */\n        (this.onWebkitKeyMessage_.bind(this)));\n    this.eventManager_.listen(this.nativeMediaKeySession_, 'webkitkeyadded',\n        /** @type {shaka.util.EventManager.ListenerType} */\n        (this.onWebkitKeyAdded_.bind(this)));\n    this.eventManager_.listen(this.nativeMediaKeySession_, 'webkitkeyerror',\n        /** @type {shaka.util.EventManager.ListenerType} */\n        (this.onWebkitKeyError_.bind(this)));\n\n    this.updateKeyStatus_('status-pending');\n  } catch (exception) {\n    this.generateRequestPromise_.reject(exception);\n  }\n\n  return this.generateRequestPromise_;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype.\n    load = function() {\n  shaka.log.debug('PatchedMediaKeysApple.MediaKeySession.load');\n\n  return Promise.reject(new Error('MediaKeySession.load not yet supported'));\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype.\n    update = function(response) {\n  shaka.log.debug('PatchedMediaKeysApple.MediaKeySession.update');\n\n  this.updatePromise_ = new shaka.util.PublicPromise();\n\n  try {\n    // Pass through to the native session.\n    this.nativeMediaKeySession_.update(new Uint8Array(response));\n  } catch (exception) {\n    this.updatePromise_.reject(exception);\n  }\n\n  return this.updatePromise_;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype.\n    close = function() {\n  shaka.log.debug('PatchedMediaKeysApple.MediaKeySession.close');\n\n  try {\n    // Pass through to the native session.\n    this.nativeMediaKeySession_.close();\n\n    this.closed.resolve();\n    this.eventManager_.removeAll();\n  } catch (exception) {\n    this.closed.reject(exception);\n  }\n\n  return this.closed;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype.\n    remove = function() {\n  shaka.log.debug('PatchedMediaKeysApple.MediaKeySession.remove');\n\n  return Promise.reject(new Error('MediaKeySession.remove is only ' +\n      'applicable for persistent licenses, which are not supported on ' +\n      'this platform'));\n};\n\n\n/**\n * Rebuild FairPlay init data according to Apple's docs.  It's unclear why this\n * is not done by the browser, or if the unprefixed version will do it for us.\n *\n * @param {BufferSource} initData\n * @param {BufferSource} certificate\n * @return {BufferSource}\n */\nshaka.polyfill.PatchedMediaKeysApple.rebuildInitData_ =\n    function(initData, certificate) {\n  // TODO: Move this into DrmEngine if it is still needed with unprefixed EME.\n  // FairPlay init data is in two parts and must be processed a bit.\n  // The first part is a 4 byte little-endian int, which is the length of the\n  // second part.\n  const initDataArray = new Uint8Array(initData);\n  const dataview = new DataView(initDataArray.buffer);\n  const length = dataview.getUint32(\n      /* position= */ 0, /* littleEndian= */ true);\n  if (length + 4 != initDataArray.byteLength) {\n    throw new Error('Malformed init data!');\n  }\n\n  // The second part is a UTF-16 LE URI from the manifest.\n  const uriString = shaka.util.StringUtils.fromUTF16(\n      initDataArray.slice(4), /* littleEndian= */ true);\n\n  // The domain of that URI is the content ID according to Apple's FPS sample.\n  const uri = new goog.Uri(uriString);\n  const contentId = uri.getDomain();\n\n  // From that, we build a new init data to use in the session.  This is\n  // composed of several parts.  First, the raw init data we already got.\n  // Second, a 4-byte LE length followed by the content ID in UTF-16-LE.\n  // Third, a 4-byte LE length followed by the certificate.\n  const contentIdArray = new Uint8Array(\n      shaka.util.StringUtils.toUTF16(contentId, /* littleEndian= */ true));\n\n  const rebuiltInitData = new Uint8Array(\n      initDataArray.byteLength +\n      4 + contentIdArray.byteLength +\n      4 + certificate.byteLength);\n\n  let offset = 0;\n  /** @param {!Uint8Array} array */\n  const append = (array) => {\n    rebuiltInitData.set(array, offset);\n    offset += array.byteLength;\n  };\n  /** @param {!Uint8Array} array */\n  const appendWithLength = (array) => {\n    const view = new DataView(rebuiltInitData.buffer);\n    const value = array.byteLength;\n    view.setUint32(offset, value, /* littleEndian= */ true);\n    offset += 4;\n    append(array);\n  };\n\n  append(initDataArray);\n  appendWithLength(contentIdArray);\n  appendWithLength(new Uint8Array(certificate));\n\n  return rebuiltInitData;\n};\n\n\n/**\n * Handler for the native media elements webkitneedkey event.\n *\n * @this {!HTMLMediaElement}\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysApple.onWebkitNeedKey_ = function(event) {\n  shaka.log.debug('PatchedMediaKeysApple.onWebkitNeedKey_', event);\n\n  const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n  const mediaKeys =\n      /** @type {shaka.polyfill.PatchedMediaKeysApple.MediaKeys} */(\n          this.mediaKeys);\n  goog.asserts.assert(mediaKeys instanceof PatchedMediaKeysApple.MediaKeys,\n                      'non-polyfill instance of newMediaKeys');\n\n  goog.asserts.assert(event.initData != null, 'missing init data!');\n\n  const certificate = mediaKeys.certificate;\n  goog.asserts.assert(certificate != null, 'missing certificate!');\n\n  // NOTE: Because \"this\" is a real EventTarget, the event we dispatch here must\n  // also be a real Event.\n  const event2 = new Event('encrypted');\n  // TODO: validate this initDataType against the unprefixed version\n  event2.initDataType = 'cenc';\n  event2.initData = PatchedMediaKeysApple.rebuildInitData_(\n      event.initData, certificate);\n\n  this.dispatchEvent(event2);\n};\n\n\n/**\n * Handler for the native keymessage event on WebKitMediaKeySession.\n *\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype.\n    onWebkitKeyMessage_ = function(event) {\n  shaka.log.debug('PatchedMediaKeysApple.onWebkitKeyMessage_', event);\n\n  // We can now resolve this.generateRequestPromise, which should be non-null.\n  goog.asserts.assert(this.generateRequestPromise_,\n                      'generateRequestPromise_ should be set before now!');\n  if (this.generateRequestPromise_) {\n    this.generateRequestPromise_.resolve();\n    this.generateRequestPromise_ = null;\n  }\n\n  const isNew = this.keyStatuses.getStatus() == undefined;\n\n  const event2 = new shaka.util.FakeEvent('message', {\n    messageType: isNew ? 'license-request' : 'license-renewal',\n    message: event.message.buffer,\n  });\n\n  this.dispatchEvent(event2);\n};\n\n\n/**\n * Handler for the native keyadded event on WebKitMediaKeySession.\n *\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype.\n    onWebkitKeyAdded_ = function(event) {\n  shaka.log.debug('PatchedMediaKeysApple.onWebkitKeyAdded_', event);\n\n  // This shouldn't fire while we're in the middle of generateRequest, but if it\n  // does, we will need to change the logic to account for it.\n  goog.asserts.assert(!this.generateRequestPromise_,\n      'Key added during generate!');\n\n  // We can now resolve this.updatePromise, which should be non-null.\n  goog.asserts.assert(this.updatePromise_,\n                      'updatePromise_ should be set before now!');\n  if (this.updatePromise_) {\n    this.updateKeyStatus_('usable');\n    this.updatePromise_.resolve();\n    this.updatePromise_ = null;\n  }\n};\n\n\n/**\n * Handler for the native keyerror event on WebKitMediaKeySession.\n *\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype.\n    onWebkitKeyError_ = function(event) {\n  shaka.log.debug('PatchedMediaKeysApple.onWebkitKeyError_', event);\n\n  const error = new Error('EME PatchedMediaKeysApple key error');\n  error.errorCode = this.nativeMediaKeySession_.error;\n\n  if (this.generateRequestPromise_ != null) {\n    this.generateRequestPromise_.reject(error);\n    this.generateRequestPromise_ = null;\n  } else if (this.updatePromise_ != null) {\n    this.updatePromise_.reject(error);\n    this.updatePromise_ = null;\n  } else {\n    // Unexpected error - map native codes to standardised key statuses.\n    // Possible values of this.nativeMediaKeySession_.error.code:\n    // MEDIA_KEYERR_UNKNOWN        = 1\n    // MEDIA_KEYERR_CLIENT         = 2\n    // MEDIA_KEYERR_SERVICE        = 3\n    // MEDIA_KEYERR_OUTPUT         = 4\n    // MEDIA_KEYERR_HARDWARECHANGE = 5\n    // MEDIA_KEYERR_DOMAIN         = 6\n\n    switch (this.nativeMediaKeySession_.error.code) {\n      case WebKitMediaKeyError.MEDIA_KEYERR_OUTPUT:\n      case WebKitMediaKeyError.MEDIA_KEYERR_HARDWARECHANGE:\n        this.updateKeyStatus_('output-not-allowed');\n        break;\n      default:\n        this.updateKeyStatus_('internal-error');\n        break;\n    }\n  }\n};\n\n\n/**\n * Updates key status and dispatch a 'keystatuseschange' event.\n *\n * @param {string} status\n * @private\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype.\n    updateKeyStatus_ = function(status) {\n  this.keyStatuses.setStatus(status);\n  const event = new shaka.util.FakeEvent('keystatuseschange');\n  this.dispatchEvent(event);\n};\n\n\n/**\n * An implementation of MediaKeyStatusMap.\n * This fakes a map with a single key ID.\n *\n * @constructor\n * @struct\n * @implements {MediaKeyStatusMap}\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap = function() {\n  /**\n   * @type {number}\n   */\n  this.size = 0;\n\n  /**\n   * @private {string|undefined}\n   */\n  this.status_ = undefined;\n};\n\n\n/**\n * @const {!ArrayBuffer}\n * @private\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.KEY_ID_;\n\n\n/**\n * An internal method used by the session to set key status.\n * @param {string|undefined} status\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.prototype.\n    setStatus = function(status) {\n  this.size = status == undefined ? 0 : 1;\n  this.status_ = status;\n};\n\n\n/**\n * An internal method used by the session to get key status.\n * @return {string|undefined}\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.prototype.\n    getStatus = function() {\n  return this.status_;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.prototype.\n    forEach = function(fn) {\n  if (this.status_) {\n    const fakeKeyId =\n        shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.KEY_ID_;\n    fn(this.status_, fakeKeyId);\n  }\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.prototype.\n    get = function(keyId) {\n  if (this.has(keyId)) {\n    return this.status_;\n  }\n  return undefined;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.prototype.\n    has = function(keyId) {\n  const fakeKeyId =\n      shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.KEY_ID_;\n  if (this.status_ &&\n      shaka.util.Uint8ArrayUtils.equal(\n          new Uint8Array(keyId), new Uint8Array(fakeKeyId))) {\n    return true;\n  }\n  return false;\n};\n\n\n/**\n * @suppress {missingReturn}\n * @override\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.prototype.\n    entries = function() {\n  goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n};\n\n\n/**\n * @suppress {missingReturn}\n * @override\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.prototype.\n    keys = function() {\n  goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n};\n\n\n/**\n * @suppress {missingReturn}\n * @override\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.prototype.\n    values = function() {\n  goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n};\n\n\nshaka.polyfill.register(shaka.polyfill.PatchedMediaKeysApple.install);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.PatchedMediaKeysMs');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill.register');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.Pssh');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @namespace shaka.polyfill.PatchedMediaKeysMs\n *\n * @summary A polyfill to implement\n * {@link https://bit.ly/EmeMar15 EME draft 12 March 2015}\n * on top of ms-prefixed\n * {@link https://www.w3.org/TR/2014/WD-encrypted-media-20140218/ EME v20140218}\n */\n\n\n/**\n * Installs the polyfill if needed.\n */\nshaka.polyfill.PatchedMediaKeysMs.install = function() {\n  if (!window.HTMLVideoElement || !window.MSMediaKeys ||\n      (navigator.requestMediaKeySystemAccess &&\n       MediaKeySystemAccess.prototype.getConfiguration)) {\n    return;\n  }\n  shaka.log.info('Using ms-prefixed EME v20140218');\n\n  // Alias\n  const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n  // Construct a fake key ID.  This is not done at load-time to avoid exceptions\n  // on unsupported browsers.  This particular fake key ID was suggested in\n  // w3c/encrypted-media#32.\n  PatchedMediaKeysMs.MediaKeyStatusMap.KEY_ID_ = (new Uint8Array([0])).buffer;\n\n  // Delete mediaKeys to work around strict mode compatibility issues.\n  delete HTMLMediaElement.prototype['mediaKeys'];\n  // Work around read-only declaration for mediaKeys by using a string.\n  HTMLMediaElement.prototype['mediaKeys'] = null;\n  HTMLMediaElement.prototype.setMediaKeys = PatchedMediaKeysMs.setMediaKeys;\n\n  // Install patches\n  window.MediaKeys = PatchedMediaKeysMs.MediaKeys;\n  window.MediaKeySystemAccess = PatchedMediaKeysMs.MediaKeySystemAccess;\n  navigator.requestMediaKeySystemAccess =\n      PatchedMediaKeysMs.requestMediaKeySystemAccess;\n};\n\n\n/**\n * An implementation of navigator.requestMediaKeySystemAccess.\n * Retrieves a MediaKeySystemAccess object.\n *\n * @this {!Navigator}\n * @param {string} keySystem\n * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n * @return {!Promise.<!MediaKeySystemAccess>}\n */\nshaka.polyfill.PatchedMediaKeysMs.requestMediaKeySystemAccess =\n    function(keySystem, supportedConfigurations) {\n  shaka.log.debug('PatchedMediaKeysMs.requestMediaKeySystemAccess');\n  goog.asserts.assert(this == navigator,\n                      'bad \"this\" for requestMediaKeySystemAccess');\n\n  // Alias.\n  const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n  try {\n    let access = new PatchedMediaKeysMs.MediaKeySystemAccess(\n        keySystem, supportedConfigurations);\n    return Promise.resolve(/** @type {!MediaKeySystemAccess} */ (access));\n  } catch (exception) {\n    return Promise.reject(exception);\n  }\n};\n\n\n/**\n * An implementation of MediaKeySystemAccess.\n *\n * @constructor\n * @struct\n * @param {string} keySystem\n * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n * @implements {MediaKeySystemAccess}\n * @throws {Error} if the key system is not supported.\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySystemAccess =\n    function(keySystem, supportedConfigurations) {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeySystemAccess');\n\n  /** @type {string} */\n  this.keySystem = keySystem;\n\n  /** @private {!MediaKeySystemConfiguration} */\n  this.configuration_;\n\n  let allowPersistentState = false;\n\n  let success = false;\n  for (let i = 0; i < supportedConfigurations.length; ++i) {\n    let cfg = supportedConfigurations[i];\n\n    // Create a new config object and start adding in the pieces which we\n    // find support for.  We will return this from getConfiguration() if asked.\n    /** @type {!MediaKeySystemConfiguration} */\n    let newCfg = {\n      'audioCapabilities': [],\n      'videoCapabilities': [],\n      // It is technically against spec to return these as optional, but we\n      // don't truly know their values from the prefixed API:\n      'persistentState': 'optional',\n      'distinctiveIdentifier': 'optional',\n      // Pretend the requested init data types are supported, since we don't\n      // really know that either:\n      'initDataTypes': cfg.initDataTypes,\n      'sessionTypes': ['temporary'],\n      'label': cfg.label,\n    };\n\n    // PatchedMediaKeysMs tests for key system availability through\n    // MSMediaKeys.isTypeSupported\n    let ranAnyTests = false;\n    if (cfg.audioCapabilities) {\n      for (let j = 0; j < cfg.audioCapabilities.length; ++j) {\n        let cap = cfg.audioCapabilities[j];\n        if (cap.contentType) {\n          ranAnyTests = true;\n          let contentType = cap.contentType.split(';')[0];\n          if (MSMediaKeys.isTypeSupported(this.keySystem, contentType)) {\n            newCfg.audioCapabilities.push(cap);\n            success = true;\n          }\n        }\n      }\n    }\n    if (cfg.videoCapabilities) {\n      for (let j = 0; j < cfg.videoCapabilities.length; ++j) {\n        let cap = cfg.videoCapabilities[j];\n        if (cap.contentType) {\n          ranAnyTests = true;\n          let contentType = cap.contentType.split(';')[0];\n          if (MSMediaKeys.isTypeSupported(this.keySystem, contentType)) {\n            newCfg.videoCapabilities.push(cap);\n            success = true;\n          }\n        }\n      }\n    }\n\n    if (!ranAnyTests) {\n      // If no specific types were requested, we check all common types to find\n      // out if the key system is present at all.\n      success = MSMediaKeys.isTypeSupported(this.keySystem, 'video/mp4');\n    }\n    if (cfg.persistentState == 'required') {\n      if (allowPersistentState) {\n        newCfg.persistentState = 'required';\n        newCfg.sessionTypes = ['persistent-license'];\n      } else {\n        success = false;\n      }\n    }\n\n    if (success) {\n      this.configuration_ = newCfg;\n      return;\n    }\n  }  // for each cfg in supportedConfigurations\n\n  // As per the spec, this should be a DOMException, but there is not a public\n  // constructor for this.\n  let unsupportedKeySystemError = new Error('Unsupported keySystem');\n  unsupportedKeySystemError.name = 'NotSupportedError';\n  unsupportedKeySystemError.code = DOMException.NOT_SUPPORTED_ERR;\n  throw unsupportedKeySystemError;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySystemAccess.prototype.\n    createMediaKeys = function() {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeySystemAccess.createMediaKeys');\n\n  // Alias\n  const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n  let mediaKeys = new PatchedMediaKeysMs.MediaKeys(this.keySystem);\n  return Promise.resolve(/** @type {!MediaKeys} */ (mediaKeys));\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySystemAccess.prototype.\n    getConfiguration = function() {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeySystemAccess.getConfiguration');\n  return this.configuration_;\n};\n\n\n/**\n * An implementation of HTMLMediaElement.prototype.setMediaKeys.\n * Attaches a MediaKeys object to the media element.\n *\n * @this {!HTMLMediaElement}\n * @param {MediaKeys} mediaKeys\n * @return {!Promise}\n */\nshaka.polyfill.PatchedMediaKeysMs.setMediaKeys = function(mediaKeys) {\n  shaka.log.debug('PatchedMediaKeysMs.setMediaKeys');\n  goog.asserts.assert(this instanceof HTMLMediaElement,\n                      'bad \"this\" for setMediaKeys');\n\n  // Alias\n  const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n  let newMediaKeys =\n      /** @type {shaka.polyfill.PatchedMediaKeysMs.MediaKeys} */ (\n      mediaKeys);\n  let oldMediaKeys =\n      /** @type {shaka.polyfill.PatchedMediaKeysMs.MediaKeys} */ (\n      this.mediaKeys);\n\n  if (oldMediaKeys && oldMediaKeys != newMediaKeys) {\n    goog.asserts.assert(oldMediaKeys instanceof PatchedMediaKeysMs.MediaKeys,\n                        'non-polyfill instance of oldMediaKeys');\n    // Have the old MediaKeys stop listening to events on the video tag.\n    oldMediaKeys.setMedia(null);\n  }\n\n  delete this['mediaKeys'];  // in case there is an existing getter\n  this['mediaKeys'] = mediaKeys;  // work around read-only declaration\n\n  if (newMediaKeys) {\n    goog.asserts.assert(newMediaKeys instanceof PatchedMediaKeysMs.MediaKeys,\n                        'non-polyfill instance of newMediaKeys');\n    return newMediaKeys.setMedia(this);\n  }\n\n  return Promise.resolve();\n};\n\n\n/**\n * An implementation of MediaKeys.\n *\n * @constructor\n * @struct\n * @param {string} keySystem\n * @implements {MediaKeys}\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeys = function(keySystem) {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeys');\n\n  /** @private {!MSMediaKeys} */\n  this.nativeMediaKeys_ = new MSMediaKeys(keySystem);\n\n  /** @private {!shaka.util.EventManager} */\n  this.eventManager_ = new shaka.util.EventManager();\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeys.prototype.\n    createSession = function(sessionType) {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeys.createSession');\n\n  sessionType = sessionType || 'temporary';\n  // For now, only the 'temporary' type is supported.\n  if (sessionType != 'temporary') {\n    throw new TypeError('Session type ' + sessionType +\n        ' is unsupported on this platform.');\n  }\n\n  // Alias\n  const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n  return new PatchedMediaKeysMs.MediaKeySession(\n      this.nativeMediaKeys_, sessionType);\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeys.prototype.\n    setServerCertificate = function(serverCertificate) {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeys.setServerCertificate');\n\n  // There is no equivalent in PatchedMediaKeysMs, so return failure.\n  return Promise.resolve(false);\n};\n\n\n/**\n * @param {HTMLMediaElement} media\n * @protected\n * @return {!Promise}\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeys.prototype.\n    setMedia = function(media) {\n  // Alias\n  const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n  // Remove any old listeners.\n  this.eventManager_.removeAll();\n\n  // It is valid for media to be null; null is used to flag that event handlers\n  // need to be cleaned up.\n  if (!media) {\n    return Promise.resolve();\n  }\n\n  // Intercept and translate these prefixed EME events.\n  this.eventManager_.listen(media, 'msneedkey',\n      /** @type {shaka.util.EventManager.ListenerType} */\n      (PatchedMediaKeysMs.onMsNeedKey_));\n\n  let self = this;\n  function setMediaKeysDeferred() {\n    media.msSetMediaKeys(self.nativeMediaKeys_);\n    media.removeEventListener('loadedmetadata', setMediaKeysDeferred);\n  }\n\n  // Wrap native HTMLMediaElement.msSetMediaKeys with a Promise.\n  try {\n    // IE11/Edge requires that readyState >=1 before mediaKeys can be set, so\n    // check this and wait for loadedmetadata if we are not in the correct state\n    if (media.readyState >= 1) {\n      media.msSetMediaKeys(this.nativeMediaKeys_);\n    } else {\n      media.addEventListener('loadedmetadata', setMediaKeysDeferred);\n    }\n\n    return Promise.resolve();\n  } catch (exception) {\n    return Promise.reject(exception);\n  }\n};\n\n\n/**\n * An implementation of MediaKeySession.\n *\n * @constructor\n * @struct\n * @param {MSMediaKeys} nativeMediaKeys\n * @param {string} sessionType\n * @implements {MediaKeySession}\n * @extends {shaka.util.FakeEventTarget}\n */\nshaka.polyfill.PatchedMediaKeysMs.\n    MediaKeySession = function(nativeMediaKeys, sessionType) {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeySession');\n  shaka.util.FakeEventTarget.call(this);\n\n  // The native MediaKeySession, which will be created in generateRequest.\n  /** @private {MSMediaKeySession} */\n  this.nativeMediaKeySession_ = null;\n\n  /** @private {MSMediaKeys} */\n  this.nativeMediaKeys_ = nativeMediaKeys;\n\n  // Promises that are resolved later\n  /** @private {shaka.util.PublicPromise} */\n  this.generateRequestPromise_ = null;\n\n  /** @private {shaka.util.PublicPromise} */\n  this.updatePromise_ = null;\n\n  /** @private {!shaka.util.EventManager} */\n  this.eventManager_ = new shaka.util.EventManager();\n\n  /** @type {string} */\n  this.sessionId = '';\n\n  /** @type {number} */\n  this.expiration = NaN;\n\n  /** @type {!shaka.util.PublicPromise} */\n  this.closed = new shaka.util.PublicPromise();\n\n  /** @type {!shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap} */\n  this.keyStatuses =\n      new shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap();\n};\ngoog.inherits(shaka.polyfill.PatchedMediaKeysMs.MediaKeySession,\n    shaka.util.FakeEventTarget);\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.\n    generateRequest = function(initDataType, initData) {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.generateRequest');\n\n  this.generateRequestPromise_ = new shaka.util.PublicPromise();\n\n  try {\n    // This EME spec version requires a MIME content type as the 1st param\n    // to createSession, but doesn't seem to matter what the value is.\n\n    // NOTE: IE11 takes either Uint8Array or ArrayBuffer, but Edge 12 only\n    // accepts Uint8Array.\n    this.nativeMediaKeySession_ = this.nativeMediaKeys_\n        .createSession('video/mp4', new Uint8Array(initData), null);\n\n    // Attach session event handlers here.\n    this.eventManager_.listen(this.nativeMediaKeySession_, 'mskeymessage',\n        /** @type {shaka.util.EventManager.ListenerType} */\n        (this.onMsKeyMessage_.bind(this)));\n    this.eventManager_.listen(this.nativeMediaKeySession_, 'mskeyadded',\n        /** @type {shaka.util.EventManager.ListenerType} */\n        (this.onMsKeyAdded_.bind(this)));\n    this.eventManager_.listen(this.nativeMediaKeySession_, 'mskeyerror',\n        /** @type {shaka.util.EventManager.ListenerType} */\n        (this.onMsKeyError_.bind(this)));\n\n    this.updateKeyStatus_('status-pending');\n  } catch (exception) {\n    this.generateRequestPromise_.reject(exception);\n  }\n\n  return this.generateRequestPromise_;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.\n    load = function() {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.load');\n\n  return Promise.reject(new Error('MediaKeySession.load not yet supported'));\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.\n    update = function(response) {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.update');\n\n  this.updatePromise_ = new shaka.util.PublicPromise();\n\n  try {\n    // Pass through to the native session.\n    // NOTE: IE11 takes either Uint8Array or ArrayBuffer, but Edge 12 only\n    // accepts Uint8Array.\n    this.nativeMediaKeySession_.update(new Uint8Array(response));\n  } catch (exception) {\n    this.updatePromise_.reject(exception);\n  }\n\n  return this.updatePromise_;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.\n    close = function() {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.close');\n\n  try {\n    // Pass through to the native session.\n    // NOTE: IE seems to have a spec discrepancy here - v2010218 should have\n    // MediaKeySession.release, but actually uses \"close\". The next version\n    // of the spec is the initial Promise based one, so it's not the target spec\n    // either.\n    this.nativeMediaKeySession_.close();\n\n    this.closed.resolve();\n    this.eventManager_.removeAll();\n  } catch (exception) {\n    this.closed.reject(exception);\n  }\n\n  return this.closed;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.\n    remove = function() {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.remove');\n\n  return Promise.reject(new Error('MediaKeySession.remove is only ' +\n      'applicable for persistent licenses, which are not supported on ' +\n      'this platform'));\n};\n\n\n/**\n * Handler for the native media elements msNeedKey event.\n *\n * @this {!HTMLMediaElement}\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysMs.onMsNeedKey_ = function(event) {\n  shaka.log.debug('PatchedMediaKeysMs.onMsNeedKey_', event);\n  if (!event.initData) {\n    return;\n  }\n\n  // Alias\n  const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n  // NOTE: Because \"this\" is a real EventTarget, on IE, the event we dispatch\n  // here must also be a real Event.\n  let event2 = /** @type {!CustomEvent} */(document.createEvent('CustomEvent'));\n  event2.initCustomEvent('encrypted', false, false, null);\n  event2.initDataType = 'cenc';\n  event2.initData = PatchedMediaKeysMs.normaliseInitData_(event.initData);\n\n  this.dispatchEvent(event2);\n};\n\n\n/**\n * Normalise the initData array. This is to apply browser specific work-arounds,\n * e.g. removing duplicates which appears to occur intermittently when the\n * native msneedkey event fires (i.e. event.initData contains dupes).\n *\n * @param {?Uint8Array} initData\n * @private\n * @return {?Uint8Array}\n */\nshaka.polyfill.PatchedMediaKeysMs.normaliseInitData_ = function(initData) {\n  if (!initData) {\n    return initData;\n  }\n\n  let pssh = new shaka.util.Pssh(initData);\n\n  // If there is only a single pssh, return the original array.\n  if (pssh.dataBoundaries.length <= 1) {\n    return initData;\n  }\n\n  let unfilteredInitDatas = [];\n  for (let i = 0; i < pssh.dataBoundaries.length; i++) {\n    let currPssh = initData.subarray(\n        pssh.dataBoundaries[i].start,\n        pssh.dataBoundaries[i].end + 1); // End is exclusive, hence the +1.\n\n    unfilteredInitDatas.push(currPssh);\n  }\n\n  // Dedupe psshData.\n  const dedupedInitDatas = [];\n  for (const initData of unfilteredInitDatas) {\n    const found = dedupedInitDatas.some((x) => {\n      return shaka.util.Uint8ArrayUtils.equal(x, initData);\n    });\n\n    if (!found) {\n      dedupedInitDatas.push(initData);\n    }\n  }\n\n  let targetLength = 0;\n  for (const initData of dedupedInitDatas) {\n    targetLength += initData.length;\n  }\n\n  // Flatten the array of Uint8Arrays back into a single Uint8Array.\n  const normalisedInitData = new Uint8Array(targetLength);\n  let offset = 0;\n  for (const initData of dedupedInitDatas) {\n    normalisedInitData.set(initData, offset);\n    offset += initData.length;\n  }\n\n  return normalisedInitData;\n};\n\n\n/**\n * Handler for the native keymessage event on MSMediaKeySession.\n *\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.\n    onMsKeyMessage_ = function(event) {\n  shaka.log.debug('PatchedMediaKeysMs.onMsKeyMessage_', event);\n\n  // We can now resolve this.generateRequestPromise, which should be non-null.\n  goog.asserts.assert(this.generateRequestPromise_,\n                      'generateRequestPromise_ not set in onMsKeyMessage_');\n  if (this.generateRequestPromise_) {\n    this.generateRequestPromise_.resolve();\n    this.generateRequestPromise_ = null;\n  }\n\n  let isNew = this.keyStatuses.getStatus() == undefined;\n\n  let event2 = new shaka.util.FakeEvent('message', {\n    messageType: isNew ? 'license-request' : 'license-renewal',\n    message: event.message.buffer,\n  });\n\n  this.dispatchEvent(event2);\n};\n\n\n/**\n * Handler for the native keyadded event on MSMediaKeySession.\n *\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.\n    onMsKeyAdded_ = function(event) {\n  shaka.log.debug('PatchedMediaKeysMs.onMsKeyAdded_', event);\n\n  // PlayReady's concept of persistent licenses makes emulation difficult here.\n  // A license policy can say that the license persists, which causes the CDM to\n  // store it for use in a later session.  The result is that in IE11, the CDM\n  // fires 'mskeyadded' without ever firing 'mskeymessage'.\n  if (this.generateRequestPromise_) {\n    shaka.log.debug('Simulating completion for a PR persistent license.');\n    goog.asserts.assert(!this.updatePromise_,\n        'updatePromise_ and generateRequestPromise_ set in onMsKeyAdded_');\n    this.updateKeyStatus_('usable');\n    this.generateRequestPromise_.resolve();\n    this.generateRequestPromise_ = null;\n    return;\n  }\n\n  // We can now resolve this.updatePromise, which should be non-null.\n  goog.asserts.assert(this.updatePromise_,\n                      'updatePromise_ not set in onMsKeyAdded_');\n  if (this.updatePromise_) {\n    this.updateKeyStatus_('usable');\n    this.updatePromise_.resolve();\n    this.updatePromise_ = null;\n  }\n};\n\n\n/**\n * Handler for the native keyerror event on MSMediaKeySession.\n *\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.\n    onMsKeyError_ = function(event) {\n  shaka.log.debug('PatchedMediaKeysMs.onMsKeyError_', event);\n\n  let error = new Error('EME PatchedMediaKeysMs key error');\n  error.errorCode = this.nativeMediaKeySession_.error;\n\n  if (this.generateRequestPromise_ != null) {\n    this.generateRequestPromise_.reject(error);\n    this.generateRequestPromise_ = null;\n  } else if (this.updatePromise_ != null) {\n    this.updatePromise_.reject(error);\n    this.updatePromise_ = null;\n  } else {\n    // Unexpected error - map native codes to standardised key statuses.\n    // Possible values of this.nativeMediaKeySession_.error.code:\n    // MS_MEDIA_KEYERR_UNKNOWN        = 1\n    // MS_MEDIA_KEYERR_CLIENT         = 2\n    // MS_MEDIA_KEYERR_SERVICE        = 3\n    // MS_MEDIA_KEYERR_OUTPUT         = 4\n    // MS_MEDIA_KEYERR_HARDWARECHANGE = 5\n    // MS_MEDIA_KEYERR_DOMAIN         = 6\n\n    switch (this.nativeMediaKeySession_.error.code) {\n      case MSMediaKeyError.MS_MEDIA_KEYERR_OUTPUT:\n      case MSMediaKeyError.MS_MEDIA_KEYERR_HARDWARECHANGE:\n        this.updateKeyStatus_('output-not-allowed');\n        break;\n      default:\n        this.updateKeyStatus_('internal-error');\n        break;\n    }\n  }\n};\n\n\n/**\n * Updates key status and dispatch a 'keystatuseschange' event.\n *\n * @param {string} status\n * @private\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.\n    updateKeyStatus_ = function(status) {\n  this.keyStatuses.setStatus(status);\n  let event = new shaka.util.FakeEvent('keystatuseschange');\n  this.dispatchEvent(event);\n};\n\n\n/**\n * An implementation of MediaKeyStatusMap.\n * This fakes a map with a single key ID.\n *\n * @constructor\n * @struct\n * @implements {MediaKeyStatusMap}\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap = function() {\n  /**\n   * @type {number}\n   */\n  this.size = 0;\n\n  /**\n   * @private {string|undefined}\n   */\n  this.status_ = undefined;\n};\n\n\n/**\n * @const {!ArrayBuffer}\n * @private\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.KEY_ID_;\n\n\n/**\n * An internal method used by the session to set key status.\n * @param {string|undefined} status\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.\n    setStatus = function(status) {\n  this.size = status == undefined ? 0 : 1;\n  this.status_ = status;\n};\n\n\n/**\n * An internal method used by the session to get key status.\n * @return {string|undefined}\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.\n    getStatus = function() {\n  return this.status_;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.\n    forEach = function(fn) {\n  if (this.status_) {\n    let fakeKeyId =\n        shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.KEY_ID_;\n    fn(this.status_, fakeKeyId);\n  }\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.\n    get = function(keyId) {\n  if (this.has(keyId)) {\n    return this.status_;\n  }\n  return undefined;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.\n    has = function(keyId) {\n  let fakeKeyId =\n      shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.KEY_ID_;\n  if (this.status_ &&\n      shaka.util.Uint8ArrayUtils.equal(\n          new Uint8Array(keyId), new Uint8Array(fakeKeyId))) {\n    return true;\n  }\n  return false;\n};\n\n\n/**\n * @suppress {missingReturn}\n * @override\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.\n    entries = function() {\n  goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n};\n\n\n/**\n * @suppress {missingReturn}\n * @override\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.\n    keys = function() {\n  goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n};\n\n\n/**\n * @suppress {missingReturn}\n * @override\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.\n    values = function() {\n  goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n};\n\n\nshaka.polyfill.register(shaka.polyfill.PatchedMediaKeysMs.install);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.Fullscreen');\n\ngoog.require('shaka.polyfill.register');\n\n\n/**\n * @namespace shaka.polyfill.Fullscreen\n *\n * @summary A polyfill to unify fullscreen APIs across browsers.\n * Many browsers have prefixed fullscreen methods on Element and document.\n * See {@link https://mzl.la/2K0xcHo Using fullscreen mode} on MDN for more\n * information.\n */\n\n\n/**\n * Install the polyfill if needed.\n */\nshaka.polyfill.Fullscreen.install = function() {\n  if (!window.Document) {\n    // Avoid errors on very old browsers.\n    return;\n  }\n\n  let proto = Element.prototype;\n  proto.requestFullscreen = proto.requestFullscreen ||\n                            proto.mozRequestFullScreen ||\n                            proto.msRequestFullscreen ||\n                            proto.webkitRequestFullscreen;\n\n  proto = Document.prototype;\n  proto.exitFullscreen = proto.exitFullscreen ||\n                         proto.mozCancelFullScreen ||\n                         proto.msExitFullscreen ||\n                         proto.webkitExitFullscreen;\n\n  if (!('fullscreenElement' in document)) {\n    Object.defineProperty(document, 'fullscreenElement', {\n      get: function() {\n        return document.mozFullScreenElement ||\n               document.msFullscreenElement ||\n               document.webkitFullscreenElement;\n      },\n    });\n    Object.defineProperty(document, 'fullscreenEnabled', {\n      get: function() {\n        return document.mozFullScreenEnabled ||\n               document.msFullscreenEnabled ||\n               document.webkitSupportsFullscreen ||\n               document.webkitFullscreenEnabled;\n      },\n    });\n  }\n\n  let proxy = shaka.polyfill.Fullscreen.proxyEvent_;\n  document.addEventListener('webkitfullscreenchange', proxy);\n  document.addEventListener('webkitfullscreenerror', proxy);\n  document.addEventListener('mozfullscreenchange', proxy);\n  document.addEventListener('mozfullscreenerror', proxy);\n  document.addEventListener('MSFullscreenChange', proxy);\n  document.addEventListener('MSFullscreenError', proxy);\n};\n\n\n/**\n * Proxy fullscreen events after changing their name.\n * @param {!Event} event\n * @private\n */\nshaka.polyfill.Fullscreen.proxyEvent_ = function(event) {\n  let eventType = event.type.replace(/^(webkit|moz|MS)/, '').toLowerCase();\n\n  let newEvent;\n  // IE 11 does not have an Event constructor\n  if (typeof(Event) === 'function') {\n    newEvent = new Event(eventType, /** @type {EventInit} */(event));\n  } else {\n    newEvent = document.createEvent('Event');\n    newEvent.initEvent(eventType, event.bubbles, event.cancelable);\n  }\n\n  event.target.dispatchEvent(newEvent);\n};\n\n\nshaka.polyfill.register(shaka.polyfill.Fullscreen.install);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.InputEvent');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill.register');\n\n\n/**\n * @namespace shaka.polyfill.InputEvent\n *\n * @summary A polyfill to patch 'input' event support in IE11.\n */\n\n\n/**\n * Install the polyfill if needed.\n */\nshaka.polyfill.InputEvent.install = function() {\n  shaka.log.debug('InputEvent.install');\n\n  // IE11 doesn't treat the 'input' event correctly.\n  // https://bit.ly/2loLsuX\n\n  if (!shaka.util.Platform.isIE()) {\n    // Not IE, so don't patch anything.\n    return;\n  }\n\n  // In our tests, we can end up with multiple independent \"shaka\" namespaces.\n  // So we can't compare addEventListener with the polyfill directly.\n  // Instead, store the original in a globally accessible place and check if\n  // that has been used yet.\n  if (HTMLInputElement.prototype['originalAddEventListener']) {\n    // The polyfill was already installed.\n    return;\n  }\n\n  shaka.log.info('Patching input event support on IE.');\n\n  HTMLInputElement.prototype['originalAddEventListener'] =\n      HTMLInputElement.prototype.addEventListener;\n\n  HTMLInputElement.prototype['addEventListener'] =\n      shaka.polyfill.InputEvent.addEventListener_;\n};\n\n\n/**\n * Add an event listener to this object and translate the event types to those\n * that work on IE11.\n *\n * @param {string} type\n * @param {EventListener|function(!Event):(boolean|undefined)} listener\n * @param {(!AddEventListenerOptions|boolean)=} options\n * @this {HTMLInputElement}\n * @private\n */\nshaka.polyfill.InputEvent.addEventListener_ =\n    function(type, listener, options) {\n  if (type == 'input') {\n    // Based on the type of input element, translate the HTML5 'input' event to\n    // one that IE11 will actually dispatch.\n\n    switch (this.type) {\n      // For range inputs, we use the 'change' event.\n      case 'range':\n        type = 'change';\n        break;\n    }\n  }\n\n  HTMLInputElement.prototype['originalAddEventListener'].call(\n      this, type, listener, options);\n};\n\n\nshaka.polyfill.register(shaka.polyfill.InputEvent.install);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.MediaSource');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill.register');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Platform');\n\n/**\n * @namespace shaka.polyfill.MediaSource\n *\n * @summary A polyfill to patch MSE bugs.\n */\n\n\n/**\n * Install the polyfill if needed.\n */\nshaka.polyfill.MediaSource.install = function() {\n  shaka.log.debug('MediaSource.install');\n\n  // MediaSource bugs are difficult to detect without checking for the affected\n  // platform.  SourceBuffer is not always exposed on window, for example, and\n  // instances are only accessible after setting up MediaSource on a video\n  // element.  Because of this, we use UA detection and other platform detection\n  // tricks to decide which patches to install.\n\n  if (!window.MediaSource) {\n    shaka.log.info('No MSE implementation available.');\n  } else if (window.cast && cast.__platform__ &&\n             cast.__platform__.canDisplayType) {\n    shaka.log.info('Patching Chromecast MSE bugs.');\n    // Chromecast cannot make accurate determinations via isTypeSupported.\n    shaka.polyfill.MediaSource.patchCastIsTypeSupported_();\n  } else if (shaka.util.Platform.isApple()) {\n    let version = navigator.appVersion;\n\n    // TS content is broken on Safari in general.\n    // See https://github.com/google/shaka-player/issues/743\n    // and https://bugs.webkit.org/show_bug.cgi?id=165342\n    shaka.polyfill.MediaSource.rejectTsContent_();\n\n    if (version.includes('Version/8')) {\n      // Safari 8 does not implement appendWindowEnd.  If we ignore the\n      // incomplete MSE implementation, some content (especially multi-period)\n      // will fail to play correctly.  The best we can do is blacklist Safari 8.\n      shaka.log.info('Blacklisting Safari 8 MSE.');\n      shaka.polyfill.MediaSource.blacklist_();\n    } else if (version.includes('Version/9')) {\n      shaka.log.info('Patching Safari 9 MSE bugs.');\n      // Safari 9 does not correctly implement abort() on SourceBuffer.\n      // Calling abort() causes a decoder failure, rather than resetting the\n      // decode timestamp as called for by the spec.\n      // Bug filed: https://bugs.webkit.org/show_bug.cgi?id=160316\n      shaka.polyfill.MediaSource.stubAbort_();\n    } else if (version.includes('Version/10')) {\n      shaka.log.info('Patching Safari 10 MSE bugs.');\n      // Safari 10 does not correctly implement abort() on SourceBuffer.\n      // Calling abort() before appending a segment causes that segment to be\n      // incomplete in buffer.\n      // Bug filed: https://bugs.webkit.org/show_bug.cgi?id=165342\n      shaka.polyfill.MediaSource.stubAbort_();\n      // Safari 10 fires spurious 'updateend' events after endOfStream().\n      // Bug filed: https://bugs.webkit.org/show_bug.cgi?id=165336\n      shaka.polyfill.MediaSource.patchEndOfStreamEvents_();\n    } else if (version.includes('Version/11') ||\n               version.includes('Version/12')) {\n      shaka.log.info('Patching Safari 11/12 MSE bugs.');\n      // Safari 11 does not correctly implement abort() on SourceBuffer.\n      // Calling abort() before appending a segment causes that segment to be\n      // incomplete in the buffer.\n      // Bug filed: https://bugs.webkit.org/show_bug.cgi?id=165342\n      shaka.polyfill.MediaSource.stubAbort_();\n      // If you remove up to a keyframe, Safari 11 incorrectly will also remove\n      // that keyframe and the content up to the next.\n      // Offsetting the end of the removal range seems to help.\n      // Bug filed: https://bugs.webkit.org/show_bug.cgi?id=177884\n      shaka.polyfill.MediaSource.patchRemovalRange_();\n    }\n  } else if (shaka.util.Platform.isTizen()) {\n    // Tizen's implementation of MSE does not work well with opus. To prevent\n    // the player from trying to play opus on Tizen, we will override media\n    // source to always reject opus content.\n\n    shaka.polyfill.MediaSource.rejectCodec_('opus');\n  } else {\n    shaka.log.info('Using native MSE as-is.');\n  }\n};\n\n\n/**\n * Blacklist the current browser by removing media source. A side-effect of this\n * will be to make |shaka.util.Platform.supportsMediaSource| return |false|.\n *\n * @private\n */\nshaka.polyfill.MediaSource.blacklist_ = function() {\n  window['MediaSource'] = null;\n};\n\n\n/**\n * Stub out abort().  On some buggy MSE implementations, calling abort() causes\n * various problems.\n *\n * @private\n */\nshaka.polyfill.MediaSource.stubAbort_ = function() {\n  const addSourceBuffer = MediaSource.prototype.addSourceBuffer;\n  MediaSource.prototype.addSourceBuffer = function(...varArgs) {\n    let sourceBuffer = addSourceBuffer.apply(this, varArgs);\n    sourceBuffer.abort = function() {};  // Stub out for buggy implementations.\n    return sourceBuffer;\n  };\n};\n\n\n/**\n * Patch remove().  On Safari 11, if you call remove() to remove the content up\n * to a keyframe, Safari will also remove the keyframe and all of the data up to\n * the next one. For example, if the keyframes are at 0s, 5s, and 10s, and you\n * tried to remove 0s-5s, it would instead remove 0s-10s.\n *\n * Offsetting the end of the range seems to be a usable workaround.\n *\n * @private\n */\nshaka.polyfill.MediaSource.patchRemovalRange_ = function() {\n  const originalRemove = SourceBuffer.prototype.remove;\n\n  SourceBuffer.prototype.remove = function(startTime, endTime) {\n    return originalRemove.call(this, startTime, endTime - 0.001);\n  };\n};\n\n\n/**\n * Patch endOfStream() to get rid of 'updateend' events that should not fire.\n * These extra events confuse MediaSourceEngine, which relies on correct events\n * to manage SourceBuffer state.\n *\n * @private\n */\nshaka.polyfill.MediaSource.patchEndOfStreamEvents_ = function() {\n  const endOfStream = MediaSource.prototype.endOfStream;\n  MediaSource.prototype.endOfStream = function(...varArgs) {\n    // This bug manifests only when endOfStream() results in the truncation\n    // of the MediaSource's duration.  So first we must calculate what the\n    // new duration will be.\n    let newDuration = 0;\n    for (let i = 0; i < this.sourceBuffers.length; ++i) {\n      let buffer = this.sourceBuffers[i];\n      let bufferEnd = buffer.buffered.end(buffer.buffered.length - 1);\n      newDuration = Math.max(newDuration, bufferEnd);\n    }\n\n    // If the duration is going to be reduced, suppress the next 'updateend'\n    // event on each SourceBuffer.\n    if (!isNaN(this.duration) &&\n        newDuration < this.duration) {\n      this.ignoreUpdateEnd_ = true;\n      for (let i = 0; i < this.sourceBuffers.length; ++i) {\n        let buffer = this.sourceBuffers[i];\n        buffer.eventSuppressed_ = false;\n      }\n    }\n\n    return endOfStream.apply(this, varArgs);\n  };\n\n  let cleanUpHandlerInstalled = false;\n  let addSourceBuffer = MediaSource.prototype.addSourceBuffer;\n  MediaSource.prototype.addSourceBuffer = function(...varArgs) {\n    // After adding a new source buffer, add an event listener to allow us to\n    // suppress events.\n    let sourceBuffer = addSourceBuffer.apply(this, varArgs);\n    sourceBuffer['mediaSource_'] = this;\n    sourceBuffer.addEventListener('updateend',\n        shaka.polyfill.MediaSource.ignoreUpdateEnd_, false);\n\n    if (!cleanUpHandlerInstalled) {\n      // If we haven't already, install an event listener to allow us to clean\n      // up listeners when MediaSource is torn down.\n      this.addEventListener('sourceclose',\n          shaka.polyfill.MediaSource.cleanUpListeners_, false);\n      cleanUpHandlerInstalled = true;\n    }\n    return sourceBuffer;\n  };\n};\n\n\n/**\n * An event listener for 'updateend' which selectively suppresses the events.\n *\n * @see shaka.polyfill.MediaSource.patchEndOfStreamEvents_\n *\n * @param {Event} event\n * @private\n */\nshaka.polyfill.MediaSource.ignoreUpdateEnd_ = function(event) {\n  let sourceBuffer = event.target;\n  let mediaSource = sourceBuffer['mediaSource_'];\n\n  if (mediaSource.ignoreUpdateEnd_) {\n    event.preventDefault();\n    event.stopPropagation();\n    event.stopImmediatePropagation();\n    sourceBuffer.eventSuppressed_ = true;\n\n    for (let i = 0; i < mediaSource.sourceBuffers.length; ++i) {\n      let buffer = mediaSource.sourceBuffers[i];\n      if (buffer.eventSuppressed_ == false) {\n        // More events need to be suppressed.\n        return;\n      }\n    }\n\n    // All events have been suppressed, all buffers are out of 'updating'\n    // mode.  Stop suppressing events.\n    mediaSource.ignoreUpdateEnd_ = false;\n  }\n};\n\n\n/**\n * An event listener for 'sourceclose' which cleans up listeners for 'updateend'\n * to avoid memory leaks.\n *\n * @see shaka.polyfill.MediaSource.patchEndOfStreamEvents_\n * @see shaka.polyfill.MediaSource.ignoreUpdateEnd_\n *\n * @param {Event} event\n * @private\n */\nshaka.polyfill.MediaSource.cleanUpListeners_ = function(event) {\n  let mediaSource = /** @type {!MediaSource} */ (event.target);\n  for (let i = 0; i < mediaSource.sourceBuffers.length; ++i) {\n    let buffer = mediaSource.sourceBuffers[i];\n    buffer.removeEventListener('updateend',\n        shaka.polyfill.MediaSource.ignoreUpdateEnd_, false);\n  }\n  mediaSource.removeEventListener('sourceclose',\n      shaka.polyfill.MediaSource.cleanUpListeners_, false);\n};\n\n\n/**\n * Patch isTypeSupported() to reject TS content.  Used to avoid TS-related MSE\n * bugs on Safari.\n *\n * @private\n */\nshaka.polyfill.MediaSource.rejectTsContent_ = function() {\n  const originalIsTypeSupported = MediaSource.isTypeSupported;\n\n  MediaSource.isTypeSupported = function(mimeType) {\n    // Parse the basic MIME type from its parameters.\n    let pieces = mimeType.split(/ *; */);\n    let basicMimeType = pieces[0];\n    let container = basicMimeType.split('/')[1];\n\n    if (container.toLowerCase() == 'mp2t') {\n      return false;\n    }\n\n    return originalIsTypeSupported(mimeType);\n  };\n};\n\n\n/**\n * Patch |MediaSource.isTypeSupported| to always reject |codec|. This is used\n * when we know that we are on a platform that does not work well with a given\n * codec.\n *\n * @param {string} codec\n * @private\n */\nshaka.polyfill.MediaSource.rejectCodec_ = function(codec) {\n  const isTypeSupported = MediaSource.isTypeSupported;\n\n  MediaSource.isTypeSupported = (mimeType) => {\n    const actualCodec = shaka.util.MimeUtils.getCodecBase(mimeType);\n    return actualCodec != codec && isTypeSupported(mimeType);\n  };\n};\n\n\n/**\n * Patch isTypeSupported() to parse for HDR-related clues and chain to a private\n * API on the Chromecast which can query for support.\n *\n * @private\n */\nshaka.polyfill.MediaSource.patchCastIsTypeSupported_ = function() {\n  const originalIsTypeSupported = MediaSource.isTypeSupported;\n\n  // Docs from Dolby detailing profile names: https://bit.ly/2T2wKbu\n  let dolbyVisionRegex = /^dv(?:h[e1]|a[v1])\\./;\n\n  MediaSource.isTypeSupported = function(mimeType) {\n    // Parse the basic MIME type from its parameters.\n    let pieces = mimeType.split(/ *; */);\n    let basicMimeType = pieces[0];\n\n    // Parse the parameters into key-value pairs.\n    /** @type {Object.<string, string>} */\n    let parameters = {};\n    for (let i = 1; i < pieces.length; ++i) {\n      let kv = pieces[i].split('=');\n      let k = kv[0];\n      let v = kv[1].replace(/\"(.*)\"/, '$1');\n      parameters[k] = v;\n    }\n\n    let codecs = parameters['codecs'];\n    if (!codecs) {\n      return originalIsTypeSupported(mimeType);\n    }\n\n    let isHDR = false;\n    let isDolbyVision = false;\n\n    let codecList = codecs.split(',').filter(function(codec) {\n      if (dolbyVisionRegex.test(codec)) {\n        isDolbyVision = true;\n      }\n\n      // We take this string as a signal for HDR, but don't remove it.\n      if (/^(hev|hvc)1\\.2/.test(codec)) {\n        isHDR = true;\n      }\n\n      // Keep all other strings in the list.\n      return true;\n    });\n\n    // If the content uses Dolby Vision, we take this as a sign that the content\n    // is not HDR after all.\n    if (isDolbyVision) isHDR = false;\n\n    // Reconstruct the \"codecs\" parameter from the results of the filter.\n    parameters['codecs'] = codecList.join(',');\n\n    // If the content is HDR, we add this additional parameter so that the Cast\n    // platform will check for HDR support.\n    if (isHDR) {\n      parameters['eotf'] = 'smpte2084';\n    }\n\n    // Reconstruct the MIME type, possibly with additional parameters.\n    let extendedMimeType = basicMimeType;\n    for (let k in parameters) {\n      let v = parameters[k];\n      extendedMimeType += '; ' + k + '=\"' + v + '\"';\n    }\n    return cast.__platform__.canDisplayType(extendedMimeType);\n  };\n};\n\n\nshaka.polyfill.register(shaka.polyfill.MediaSource.install);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.Pssh');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * Parse a PSSH box and extract the system IDs.\n *\n * @param {!Uint8Array} psshBox\n * @constructor\n * @struct\n * @throws {shaka.util.Error} if a PSSH box is truncated or contains a size\n *   field over 53 bits.\n */\nshaka.util.Pssh = function(psshBox) {\n  /**\n   * In hex.\n   * @type {!Array.<string>}\n   */\n  this.systemIds = [];\n\n  /**\n   * In hex.\n   * @type {!Array.<string>}\n   */\n  this.cencKeyIds = [];\n\n  /*\n  * Array of tuples that define the startIndex + size for each\n  * discrete pssh within |psshBox|\n  * */\n  this.dataBoundaries = [];\n\n  new shaka.util.Mp4Parser()\n      .fullBox('pssh', this.parseBox_.bind(this)).parse(psshBox.buffer);\n\n  if (this.dataBoundaries.length == 0) {\n    shaka.log.warning('No pssh box found!');\n  }\n};\n\n\n/**\n * @param {!shaka.extern.ParsedBox} box\n * @private\n */\nshaka.util.Pssh.prototype.parseBox_ = function(box) {\n  goog.asserts.assert(\n      box.version != null,\n      'PSSH boxes are full boxes and must have a valid version');\n\n  goog.asserts.assert(\n      box.flags != null,\n      'PSSH boxes are full boxes and must have a valid flag');\n\n  if (box.version > 1) {\n    shaka.log.warning('Unrecognized PSSH version found!');\n    return;\n  }\n\n  let systemId = shaka.util.Uint8ArrayUtils.toHex(box.reader.readBytes(16));\n  let keyIds = [];\n  if (box.version > 0) {\n    let numKeyIds = box.reader.readUint32();\n    for (let i = 0; i < numKeyIds; ++i) {\n      let keyId = shaka.util.Uint8ArrayUtils.toHex(box.reader.readBytes(16));\n      keyIds.push(keyId);\n    }\n  }\n\n  let dataSize = box.reader.readUint32();\n  box.reader.skip(dataSize);  // Ignore the data section.\n\n  // Now that everything has been succesfully parsed from this box,\n  // update member variables.\n  this.cencKeyIds.push.apply(this.cencKeyIds, keyIds);\n  this.systemIds.push(systemId);\n  this.dataBoundaries.push({\n    start: box.start,\n    end: box.start + box.size - 1,\n  });\n\n  if (box.reader.getPosition() != box.reader.getLength()) {\n    shaka.log.warning('Mismatch between box size and data size!');\n  }\n};\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.PatchedMediaKeysNop');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill.register');\n\n\n/**\n * @namespace shaka.polyfill.PatchedMediaKeysNop\n *\n * @summary A polyfill to stub out\n * {@link https://bit.ly/EmeMar15 EME draft 12 March 2015} on browsers without\n * EME.\n * All methods will fail.\n */\n\n\n/**\n * Installs the polyfill if needed.\n */\nshaka.polyfill.PatchedMediaKeysNop.install = function() {\n  if (!window.HTMLVideoElement ||\n      (navigator.requestMediaKeySystemAccess &&\n       MediaKeySystemAccess.prototype.getConfiguration)) {\n    return;\n  }\n  shaka.log.info('EME not available.');\n\n  // Alias.\n  const PatchedMediaKeysNop = shaka.polyfill.PatchedMediaKeysNop;\n\n  // Install patches.\n  navigator.requestMediaKeySystemAccess =\n      PatchedMediaKeysNop.requestMediaKeySystemAccess;\n  // Delete mediaKeys to work around strict mode compatibility issues.\n  delete HTMLMediaElement.prototype['mediaKeys'];\n  // Work around read-only declaration for mediaKeys by using a string.\n  HTMLMediaElement.prototype['mediaKeys'] = null;\n  HTMLMediaElement.prototype.setMediaKeys = PatchedMediaKeysNop.setMediaKeys;\n  // These are not usable, but allow Player.isBrowserSupported to pass.\n  window.MediaKeys = PatchedMediaKeysNop.MediaKeys;\n  window.MediaKeySystemAccess = PatchedMediaKeysNop.MediaKeySystemAccess;\n};\n\n\n/**\n * An implementation of navigator.requestMediaKeySystemAccess.\n * Retrieves a MediaKeySystemAccess object.\n *\n * @this {!Navigator}\n * @param {string} keySystem\n * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n * @return {!Promise.<!MediaKeySystemAccess>}\n */\nshaka.polyfill.PatchedMediaKeysNop.requestMediaKeySystemAccess =\n    function(keySystem, supportedConfigurations) {\n  shaka.log.debug('PatchedMediaKeysNop.requestMediaKeySystemAccess');\n  goog.asserts.assert(this == navigator,\n                      'bad \"this\" for requestMediaKeySystemAccess');\n\n\n  return Promise.reject(new Error(\n      'The key system specified is not supported.'));\n};\n\n\n/**\n * An implementation of HTMLMediaElement.prototype.setMediaKeys.\n * Attaches a MediaKeys object to the media element.\n *\n * @this {!HTMLMediaElement}\n * @param {MediaKeys} mediaKeys\n * @return {!Promise}\n */\nshaka.polyfill.PatchedMediaKeysNop.setMediaKeys = function(mediaKeys) {\n  shaka.log.debug('PatchedMediaKeysNop.setMediaKeys');\n  goog.asserts.assert(this instanceof HTMLMediaElement,\n                      'bad \"this\" for setMediaKeys');\n\n  if (mediaKeys == null) {\n    return Promise.resolve();\n  }\n\n  return Promise.reject(new Error('MediaKeys not supported.'));\n};\n\n\n/**\n * An unusable constructor for MediaKeys.\n * @constructor\n * @struct\n * @implements {MediaKeys}\n */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeys = function() {\n  throw new TypeError('Illegal constructor.');\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeys.prototype.createSession =\n    function() {};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeys.prototype.setServerCertificate =\n    function() {};\n\n\n/**\n * An unusable constructor for MediaKeySystemAccess.\n * @constructor\n * @struct\n * @implements {MediaKeySystemAccess}\n */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeySystemAccess = function() {\n  throw new TypeError('Illegal constructor.');\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeySystemAccess.prototype.\n    getConfiguration = function() {};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeySystemAccess.prototype.\n    createMediaKeys = function() {};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeySystemAccess.prototype.\n    keySystem;\n\n\n// A low priority ensures this is the last and acts as a fallback.\nshaka.polyfill.register(shaka.polyfill.PatchedMediaKeysNop.install, -10);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.IndexedDB');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill.register');\n\n\n/**\n * @namespace shaka.polyfill.IndexedDB\n *\n * @summary A polyfill to patch IndexedDB bugs.\n */\n\n\n/**\n * Install the polyfill if needed.\n */\nshaka.polyfill.IndexedDB.install = function() {\n  shaka.log.debug('IndexedDB.install');\n\n  if (shaka.util.Platform.isChromecast()) {\n    shaka.log.debug('Removing IndexedDB from ChromeCast');\n    delete window.indexedDB;\n    goog.asserts.assert(\n        !window.indexedDB, 'Failed to override window.indexedDB');\n  }\n};\n\nshaka.polyfill.register(shaka.polyfill.IndexedDB.install);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.Languages');\n\ngoog.require('shaka.polyfill.register');\n\n\n/**\n * @namespace shaka.polyfill.Languages\n *\n * @summary A polyfill to provide navigator.languages on all browsers.\n * This is necessary for IE and possibly others we have yet to discover.\n */\n\n/**\n * Install the polyfill if needed.\n */\nshaka.polyfill.Languages.install = function() {\n  if (navigator.languages) {\n    // No need.\n    return;\n  }\n\n  Object.defineProperty(navigator, 'languages', {\n    get: () => {\n      // If the browser provides a single language (all that we've seen), then\n      // make an array out of that.  Otherwise, return English.\n      if (navigator.language) {\n        return [navigator.language];\n      }\n      return ['en'];\n    },\n  });\n};\n\nshaka.polyfill.register(shaka.polyfill.Languages.install);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\ngoog.provide('shaka.polyfill.MathRound');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill.register');\n\n/**\n * @namespace shaka.polyfill.MathRound\n *\n * @summary A polyfill to patch math round bug on some browsers.\n * @see https://stackoverflow.com/q/12830742\n */\n\n\n/**\n @const {number}\n @private\n */\nshaka.polyfill.MathRound.MAX_ACCURATE_INPUT_ = 0x10000000000000;\n\n\n/**\n * Install the polyfill if needed.\n */\nshaka.polyfill.MathRound.install = function() {\n  shaka.log.debug('mathRound.install');\n\n  let testNumber = shaka.polyfill.MathRound.MAX_ACCURATE_INPUT_ + 1;\n  if (Math.round(testNumber) != testNumber) {\n    shaka.log.debug('polyfill Math.round');\n    let originalMathRound = Math.round;\n    Math.round = function(number) {\n      let result = number;\n      // Due to the precision of JavaScript numbers, the number must be integer.\n      if (number <= shaka.polyfill.MathRound.MAX_ACCURATE_INPUT_) {\n        result = originalMathRound(number);\n      }\n      return result;\n    };\n  }\n};\n\nshaka.polyfill.register(shaka.polyfill.MathRound.install);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.PatchedMediaKeysWebkit');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill.register');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Timer');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @namespace shaka.polyfill.PatchedMediaKeysWebkit\n *\n * @summary A polyfill to implement\n * {@link https://bit.ly/EmeMar15 EME draft 12 March 2015} on top of\n * webkit-prefixed {@link https://bit.ly/Eme01b EME v0.1b}.\n */\n\n\n/**\n * Store api prefix.\n *\n * @private {string}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.prefix_ = '';\n\n\n/**\n * Installs the polyfill if needed.\n */\nshaka.polyfill.PatchedMediaKeysWebkit.install = function() {\n  // Alias.\n  const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n  const prefixApi = PatchedMediaKeysWebkit.prefixApi_;\n\n  if (!window.HTMLVideoElement ||\n      (navigator.requestMediaKeySystemAccess &&\n       MediaKeySystemAccess.prototype.getConfiguration)) {\n    return;\n  }\n  if (HTMLMediaElement.prototype.webkitGenerateKeyRequest) {\n    shaka.log.info('Using webkit-prefixed EME v0.1b');\n    PatchedMediaKeysWebkit.prefix_ = 'webkit';\n  } else if (HTMLMediaElement.prototype.generateKeyRequest) {\n    shaka.log.info('Using nonprefixed EME v0.1b');\n  } else {\n    return;\n  }\n\n  goog.asserts.assert(\n      HTMLMediaElement.prototype[prefixApi('generateKeyRequest')],\n                      'PatchedMediaKeysWebkit APIs not available!');\n\n  // Construct a fake key ID.  This is not done at load-time to avoid exceptions\n  // on unsupported browsers.  This particular fake key ID was suggested in\n  // w3c/encrypted-media#32.\n  PatchedMediaKeysWebkit.MediaKeyStatusMap.KEY_ID_ =\n      (new Uint8Array([0])).buffer;\n\n  // Install patches.\n  navigator.requestMediaKeySystemAccess =\n      PatchedMediaKeysWebkit.requestMediaKeySystemAccess;\n  // Delete mediaKeys to work around strict mode compatibility issues.\n  delete HTMLMediaElement.prototype['mediaKeys'];\n  // Work around read-only declaration for mediaKeys by using a string.\n  HTMLMediaElement.prototype['mediaKeys'] = null;\n  HTMLMediaElement.prototype.setMediaKeys = PatchedMediaKeysWebkit.setMediaKeys;\n  window.MediaKeys = PatchedMediaKeysWebkit.MediaKeys;\n  window.MediaKeySystemAccess = PatchedMediaKeysWebkit.MediaKeySystemAccess;\n};\n\n\n/**\n * Prefix the api with the stored prefix.\n *\n * @param {string} api\n * @return {string}\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.prefixApi_ = function(api) {\n  let prefix = shaka.polyfill.PatchedMediaKeysWebkit.prefix_;\n  if (prefix) {\n    return prefix + api.charAt(0).toUpperCase() + api.slice(1);\n  }\n  return api;\n};\n\n\n/**\n * An implementation of navigator.requestMediaKeySystemAccess.\n * Retrieves a MediaKeySystemAccess object.\n *\n * @this {!Navigator}\n * @param {string} keySystem\n * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n * @return {!Promise.<!MediaKeySystemAccess>}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.requestMediaKeySystemAccess =\n    function(keySystem, supportedConfigurations) {\n  shaka.log.debug('PatchedMediaKeysWebkit.requestMediaKeySystemAccess');\n  goog.asserts.assert(this == navigator,\n                      'bad \"this\" for requestMediaKeySystemAccess');\n\n  // Alias.\n  const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n  try {\n    let access = new PatchedMediaKeysWebkit.MediaKeySystemAccess(\n        keySystem, supportedConfigurations);\n    return Promise.resolve(/** @type {!MediaKeySystemAccess} */ (access));\n  } catch (exception) {\n    return Promise.reject(exception);\n  }\n};\n\n\n/**\n * An implementation of HTMLMediaElement.prototype.setMediaKeys.\n * Attaches a MediaKeys object to the media element.\n *\n * @this {!HTMLMediaElement}\n * @param {MediaKeys} mediaKeys\n * @return {!Promise}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.setMediaKeys = function(mediaKeys) {\n  shaka.log.debug('PatchedMediaKeysWebkit.setMediaKeys');\n  goog.asserts.assert(this instanceof HTMLMediaElement,\n                      'bad \"this\" for setMediaKeys');\n\n  // Alias.\n  const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n  let newMediaKeys =\n      /** @type {shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys} */ (\n          mediaKeys);\n  let oldMediaKeys =\n      /** @type {shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys} */ (\n          this.mediaKeys);\n\n  if (oldMediaKeys && oldMediaKeys != newMediaKeys) {\n    goog.asserts.assert(\n        oldMediaKeys instanceof PatchedMediaKeysWebkit.MediaKeys,\n        'non-polyfill instance of oldMediaKeys');\n    // Have the old MediaKeys stop listening to events on the video tag.\n    oldMediaKeys.setMedia(null);\n  }\n\n  delete this['mediaKeys'];  // In case there is an existing getter.\n  this['mediaKeys'] = mediaKeys;  // Work around the read-only declaration.\n\n  if (newMediaKeys) {\n    goog.asserts.assert(\n        newMediaKeys instanceof PatchedMediaKeysWebkit.MediaKeys,\n        'non-polyfill instance of newMediaKeys');\n    newMediaKeys.setMedia(this);\n  }\n\n  return Promise.resolve();\n};\n\n\n/**\n * For some of this polyfill's implementation, we need to query a video element.\n * But for some embedded systems, it is memory-expensive to create multiple\n * video elements.  Therefore, we check the document to see if we can borrow one\n * to query before we fall back to creating one temporarily.\n *\n * @return {!HTMLVideoElement}\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.getVideoElement_ = function() {\n  let videos = document.getElementsByTagName('video');\n  let tmpVideo = videos.length ? videos[0] : document.createElement('video');\n  return /** @type {!HTMLVideoElement} */(tmpVideo);\n};\n\n\n/**\n * An implementation of MediaKeySystemAccess.\n *\n * @constructor\n * @struct\n * @param {string} keySystem\n * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n * @implements {MediaKeySystemAccess}\n * @throws {Error} if the key system is not supported.\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySystemAccess =\n    function(keySystem, supportedConfigurations) {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySystemAccess');\n\n  /** @type {string} */\n  this.keySystem = keySystem;\n\n  /** @private {string} */\n  this.internalKeySystem_ = keySystem;\n\n  /** @private {!MediaKeySystemConfiguration} */\n  this.configuration_;\n\n  // This is only a guess, since we don't really know from the prefixed API.\n  let allowPersistentState = false;\n\n  if (keySystem == 'org.w3.clearkey') {\n    // ClearKey's string must be prefixed in v0.1b.\n    this.internalKeySystem_ = 'webkit-org.w3.clearkey';\n    // ClearKey doesn't support persistence.\n    allowPersistentState = false;\n  }\n\n  let success = false;\n  let tmpVideo = shaka.polyfill.PatchedMediaKeysWebkit.getVideoElement_();\n  for (let i = 0; i < supportedConfigurations.length; ++i) {\n    let cfg = supportedConfigurations[i];\n\n    // Create a new config object and start adding in the pieces which we\n    // find support for.  We will return this from getConfiguration() if asked.\n    /** @type {!MediaKeySystemConfiguration} */\n    let newCfg = {\n      'audioCapabilities': [],\n      'videoCapabilities': [],\n      // It is technically against spec to return these as optional, but we\n      // don't truly know their values from the prefixed API:\n      'persistentState': 'optional',\n      'distinctiveIdentifier': 'optional',\n      // Pretend the requested init data types are supported, since we don't\n      // really know that either:\n      'initDataTypes': cfg.initDataTypes,\n      'sessionTypes': ['temporary'],\n      'label': cfg.label,\n    };\n\n    // v0.1b tests for key system availability with an extra argument on\n    // canPlayType.\n    let ranAnyTests = false;\n    if (cfg.audioCapabilities) {\n      for (let j = 0; j < cfg.audioCapabilities.length; ++j) {\n        let cap = cfg.audioCapabilities[j];\n        if (cap.contentType) {\n          ranAnyTests = true;\n          // In Chrome <= 40, if you ask about Widevine-encrypted audio support,\n          // you get a false-negative when you specify codec information.\n          // Work around this by stripping codec info for audio types.\n          let contentType = cap.contentType.split(';')[0];\n          if (tmpVideo.canPlayType(contentType, this.internalKeySystem_)) {\n            newCfg.audioCapabilities.push(cap);\n            success = true;\n          }\n        }\n      }\n    }\n    if (cfg.videoCapabilities) {\n      for (let j = 0; j < cfg.videoCapabilities.length; ++j) {\n        let cap = cfg.videoCapabilities[j];\n        if (cap.contentType) {\n          ranAnyTests = true;\n          if (tmpVideo.canPlayType(cap.contentType, this.internalKeySystem_)) {\n            newCfg.videoCapabilities.push(cap);\n            success = true;\n          }\n        }\n      }\n    }\n\n    if (!ranAnyTests) {\n      // If no specific types were requested, we check all common types to find\n      // out if the key system is present at all.\n      success = tmpVideo.canPlayType('video/mp4', this.internalKeySystem_) ||\n                tmpVideo.canPlayType('video/webm', this.internalKeySystem_);\n    }\n    if (cfg.persistentState == 'required') {\n      if (allowPersistentState) {\n        newCfg.persistentState = 'required';\n        newCfg.sessionTypes = ['persistent-license'];\n      } else {\n        success = false;\n      }\n    }\n\n    if (success) {\n      this.configuration_ = newCfg;\n      return;\n    }\n  }  // for each cfg in supportedConfigurations\n\n  let message = 'Unsupported keySystem';\n  if (keySystem == 'org.w3.clearkey' || keySystem == 'com.widevine.alpha') {\n    message = 'None of the requested configurations were supported.';\n  }\n  let unsupportedError = new Error(message);\n  unsupportedError.name = 'NotSupportedError';\n  unsupportedError.code = DOMException.NOT_SUPPORTED_ERR;\n  throw unsupportedError;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySystemAccess.prototype.\n    createMediaKeys = function() {\n  shaka.log.debug(\n      'PatchedMediaKeysWebkit.MediaKeySystemAccess.createMediaKeys');\n\n  // Alias.\n  const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n  let mediaKeys = new PatchedMediaKeysWebkit.MediaKeys(this.internalKeySystem_);\n  return Promise.resolve(/** @type {!MediaKeys} */ (mediaKeys));\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySystemAccess.prototype.\n    getConfiguration = function() {\n  shaka.log.debug(\n      'PatchedMediaKeysWebkit.MediaKeySystemAccess.getConfiguration');\n  return this.configuration_;\n};\n\n\n/**\n * An implementation of MediaKeys.\n *\n * @constructor\n * @struct\n * @param {string} keySystem\n * @implements {MediaKeys}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys = function(keySystem) {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys');\n\n  /** @private {string} */\n  this.keySystem_ = keySystem;\n\n  /** @private {HTMLMediaElement} */\n  this.media_ = null;\n\n  /** @private {!shaka.util.EventManager} */\n  this.eventManager_ = new shaka.util.EventManager();\n\n  /**\n   * @private {!Array.<!shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession>}\n   */\n  this.newSessions_ = [];\n\n  /**\n   * @private {!Object.<string,\n   *                    !shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession>}\n   */\n  this.sessionMap_ = {};\n};\n\n\n/**\n * @param {HTMLMediaElement} media\n * @protected\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.setMedia =\n    function(media) {\n  this.media_ = media;\n\n  // Remove any old listeners.\n  this.eventManager_.removeAll();\n\n  let prefix = shaka.polyfill.PatchedMediaKeysWebkit.prefix_;\n  if (media) {\n    // Intercept and translate these prefixed EME events.\n    this.eventManager_.listen(media, prefix + 'needkey',\n        /** @type {shaka.util.EventManager.ListenerType} */ (\n            this.onWebkitNeedKey_.bind(this)));\n\n    this.eventManager_.listen(media, prefix + 'keymessage',\n        /** @type {shaka.util.EventManager.ListenerType} */ (\n            this.onWebkitKeyMessage_.bind(this)));\n\n    this.eventManager_.listen(media, prefix + 'keyadded',\n        /** @type {shaka.util.EventManager.ListenerType} */ (\n            this.onWebkitKeyAdded_.bind(this)));\n\n    this.eventManager_.listen(media, prefix + 'keyerror',\n        /** @type {shaka.util.EventManager.ListenerType} */ (\n            this.onWebkitKeyError_.bind(this)));\n  }\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.createSession =\n    function(sessionType) {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys.createSession');\n\n  sessionType = sessionType || 'temporary';\n  if (sessionType != 'temporary' && sessionType != 'persistent-license') {\n    throw new TypeError('Session type ' + sessionType +\n                        ' is unsupported on this platform.');\n  }\n\n  // Alias.\n  const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n  // Unprefixed EME allows for session creation without a video tag or src.\n  // Prefixed EME requires both a valid HTMLMediaElement and a src.\n  let media = this.media_ || /** @type {!HTMLMediaElement} */(\n      document.createElement('video'));\n  if (!media.src) media.src = 'about:blank';\n\n  let session = new PatchedMediaKeysWebkit.MediaKeySession(\n      media, this.keySystem_, sessionType);\n  this.newSessions_.push(session);\n  return session;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.setServerCertificate =\n    function(serverCertificate) {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys.setServerCertificate');\n\n  // There is no equivalent in v0.1b, so return failure.\n  return Promise.resolve(false);\n};\n\n\n/**\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.onWebkitNeedKey_ =\n    function(event) {\n  shaka.log.debug('PatchedMediaKeysWebkit.onWebkitNeedKey_', event);\n  goog.asserts.assert(this.media_, 'media_ not set in onWebkitNeedKey_');\n\n  let event2 =\n      /** @type {!CustomEvent} */ (document.createEvent('CustomEvent'));\n  event2.initCustomEvent('encrypted', false, false, null);\n\n  // not used by v0.1b EME, but given a valid value\n  event2.initDataType = 'webm';\n  event2.initData = event.initData;\n\n  this.media_.dispatchEvent(event2);\n};\n\n\n/**\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.onWebkitKeyMessage_ =\n    function(event) {\n  shaka.log.debug('PatchedMediaKeysWebkit.onWebkitKeyMessage_', event);\n\n  let session = this.findSession_(event.sessionId);\n  if (!session) {\n    shaka.log.error('Session not found', event.sessionId);\n    return;\n  }\n\n  let isNew = session.keyStatuses.getStatus() == undefined;\n\n  let event2 = new shaka.util.FakeEvent('message', {\n    messageType: isNew ? 'licenserequest' : 'licenserenewal',\n    message: event.message,\n  });\n\n  session.generated();\n  session.dispatchEvent(event2);\n};\n\n\n/**\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.onWebkitKeyAdded_ =\n    function(event) {\n  shaka.log.debug('PatchedMediaKeysWebkit.onWebkitKeyAdded_', event);\n\n  let session = this.findSession_(event.sessionId);\n  goog.asserts.assert(session, 'unable to find session in onWebkitKeyAdded_');\n  if (session) {\n    session.ready();\n  }\n};\n\n\n/**\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.onWebkitKeyError_ =\n    function(event) {\n  shaka.log.debug('PatchedMediaKeysWebkit.onWebkitKeyError_', event);\n\n  let session = this.findSession_(event.sessionId);\n  goog.asserts.assert(session, 'unable to find session in onWebkitKeyError_');\n  if (session) {\n    session.handleError(event);\n  }\n};\n\n\n/**\n * @param {string} sessionId\n * @return {shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession}\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.findSession_ =\n    function(sessionId) {\n  let session = this.sessionMap_[sessionId];\n  if (session) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys.findSession_', session);\n    return session;\n  }\n\n  session = this.newSessions_.shift();\n  if (session) {\n    session.sessionId = sessionId;\n    this.sessionMap_[sessionId] = session;\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys.findSession_', session);\n    return session;\n  }\n\n  return null;\n};\n\n\n/**\n * An implementation of MediaKeySession.\n *\n * @param {!HTMLMediaElement} media\n * @param {string} keySystem\n * @param {string} sessionType\n *\n * @constructor\n * @struct\n * @implements {MediaKeySession}\n * @extends {shaka.util.FakeEventTarget}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession =\n    function(media, keySystem, sessionType) {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession');\n  shaka.util.FakeEventTarget.call(this);\n\n  /** @private {!HTMLMediaElement} */\n  this.media_ = media;\n\n  /** @private {boolean} */\n  this.initialized_ = false;\n\n  /** @private {shaka.util.PublicPromise} */\n  this.generatePromise_ = null;\n\n  /** @private {shaka.util.PublicPromise} */\n  this.updatePromise_ = null;\n\n  /** @private {string} */\n  this.keySystem_ = keySystem;\n\n  /** @private {string} */\n  this.type_ = sessionType;\n\n  /** @type {string} */\n  this.sessionId = '';\n\n  /** @type {number} */\n  this.expiration = NaN;\n\n  /** @type {!shaka.util.PublicPromise} */\n  this.closed = new shaka.util.PublicPromise();\n\n  /** @type {!shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap} */\n  this.keyStatuses =\n      new shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap();\n};\ngoog.inherits(shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession,\n              shaka.util.FakeEventTarget);\n\n\n/**\n * Signals that the license request has been generated.  This resolves the\n * 'generateRequest' promise.\n *\n * @protected\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.generated =\n    function() {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.generated');\n\n  if (this.generatePromise_) {\n    this.generatePromise_.resolve();\n    this.generatePromise_ = null;\n  }\n};\n\n\n/**\n * Signals that the session is 'ready', which is the terminology used in older\n * versions of EME.  The new signal is to resolve the 'update' promise.  This\n * translates between the two.\n *\n * @protected\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.ready =\n    function() {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.ready');\n\n  this.updateKeyStatus_('usable');\n\n  if (this.updatePromise_) {\n    this.updatePromise_.resolve();\n  }\n  this.updatePromise_ = null;\n};\n\n\n/**\n * Either rejects a promise, or dispatches an error event, as appropriate.\n *\n * @param {!MediaKeyEvent} event\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.handleError =\n    function(event) {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.handleError', event);\n\n  // This does not match the DOMException we get in current WD EME, but it will\n  // at least provide some information which can be used to look into the\n  // problem.\n  let error = new Error('EME v0.1b key error');\n  error.errorCode = event.errorCode;\n  error.errorCode.systemCode = event.systemCode;\n\n  // The presence or absence of sessionId indicates whether this corresponds to\n  // generateRequest() or update().\n  if (!event.sessionId && this.generatePromise_) {\n    error.method = 'generateRequest';\n    if (event.systemCode == 45) {\n      error.message = 'Unsupported session type.';\n    }\n    this.generatePromise_.reject(error);\n    this.generatePromise_ = null;\n  } else if (event.sessionId && this.updatePromise_) {\n    error.method = 'update';\n    this.updatePromise_.reject(error);\n    this.updatePromise_ = null;\n  } else {\n    // This mapping of key statuses is imperfect at best.\n    let code = event.errorCode.code;\n    let systemCode = event.systemCode;\n    if (code == MediaKeyError['MEDIA_KEYERR_OUTPUT']) {\n      this.updateKeyStatus_('output-restricted');\n    } else if (systemCode == 1) {\n      this.updateKeyStatus_('expired');\n    } else {\n      this.updateKeyStatus_('internal-error');\n    }\n  }\n};\n\n\n/**\n * Logic which is shared between generateRequest() and load(), both of which\n * are ultimately implemented with webkitGenerateKeyRequest in prefixed EME.\n *\n * @param {?BufferSource} initData\n * @param {?string} offlineSessionId\n * @return {!Promise}\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.generate_ =\n    function(initData, offlineSessionId) {\n  if (this.initialized_) {\n    return Promise.reject(new Error('The session is already initialized.'));\n  }\n\n  this.initialized_ = true;\n\n  /** @type {!Uint8Array} */\n  let mangledInitData;\n\n  try {\n    if (this.type_ == 'persistent-license') {\n      const StringUtils = shaka.util.StringUtils;\n      if (!offlineSessionId) {\n        // Persisting the initial license.\n        // Prefix the init data with a tag to indicate persistence.\n        let prefix = StringUtils.toUTF8('PERSISTENT|');\n        let result = new Uint8Array(prefix.byteLength + initData.byteLength);\n        result.set(new Uint8Array(prefix), 0);\n        result.set(new Uint8Array(initData), prefix.byteLength);\n        mangledInitData = result;\n      } else {\n        // Loading a stored license.\n        // Prefix the init data (which is really a session ID) with a tag to\n        // indicate that we are loading a persisted session.\n        mangledInitData = new Uint8Array(\n            StringUtils.toUTF8('LOAD_SESSION|' + offlineSessionId));\n      }\n    } else {\n      // Streaming.\n      goog.asserts.assert(this.type_ == 'temporary',\n                          'expected temporary session');\n      goog.asserts.assert(!offlineSessionId,\n                          'unexpected offline session ID');\n      mangledInitData = new Uint8Array(initData);\n    }\n\n    goog.asserts.assert(mangledInitData,\n                        'init data not set!');\n  } catch (exception) {\n    return Promise.reject(exception);\n  }\n\n  goog.asserts.assert(this.generatePromise_ == null,\n                      'generatePromise_ should be null');\n  this.generatePromise_ = new shaka.util.PublicPromise();\n\n  // Because we are hacking media.src in createSession to better emulate\n  // unprefixed EME's ability to create sessions and license requests without a\n  // video tag, we can get ourselves into trouble.  It seems that sometimes,\n  // the setting of media.src hasn't been processed by some other thread, and\n  // GKR can throw an exception.  If this occurs, wait 10 ms and try again at\n  // most once.  This situation should only occur when init data is available\n  // ahead of the 'needkey' event.\n\n  let prefixApi = shaka.polyfill.PatchedMediaKeysWebkit.prefixApi_;\n  let generateKeyRequestName = prefixApi('generateKeyRequest');\n  try {\n    this.media_[generateKeyRequestName](this.keySystem_, mangledInitData);\n  } catch (exception) {\n    if (exception.name != 'InvalidStateError') {\n      this.generatePromise_ = null;\n      return Promise.reject(exception);\n    }\n\n    const timer = new shaka.util.Timer(() => {\n      try {\n        this.media_[generateKeyRequestName](this.keySystem_, mangledInitData);\n      } catch (exception2) {\n        this.generatePromise_.reject(exception2);\n        this.generatePromise_ = null;\n      }\n    });\n\n    timer.tickAfter(/* seconds= */ 0.01);\n  }\n\n  return this.generatePromise_;\n};\n\n\n/**\n * An internal version of update which defers new calls while old ones are in\n * progress.\n *\n * @param {!shaka.util.PublicPromise} promise  The promise associated with this\n *   call.\n * @param {?BufferSource} response\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.update_ =\n    function(promise, response) {\n  if (this.updatePromise_) {\n    // We already have an update in-progress, so defer this one until after the\n    // old one is resolved.  Execute this whether the original one succeeds or\n    // fails.\n    this.updatePromise_.then(\n        this.update_.bind(this, promise, response)\n    ).catch(\n        this.update_.bind(this, promise, response)\n    );\n    return;\n  }\n\n  this.updatePromise_ = promise;\n\n  let key;\n  let keyId;\n\n  if (this.keySystem_ == 'webkit-org.w3.clearkey') {\n    // The current EME version of clearkey wants a structured JSON response.\n    // The v0.1b version wants just a raw key.  Parse the JSON response and\n    // extract the key and key ID.\n    const StringUtils = shaka.util.StringUtils;\n    const Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n    let licenseString = StringUtils.fromUTF8(response);\n    let jwkSet = /** @type {JWKSet} */ (JSON.parse(licenseString));\n    let kty = jwkSet.keys[0].kty;\n    if (kty != 'oct') {\n      // Reject the promise.\n      let error = new Error('Response is not a valid JSON Web Key Set.');\n      this.updatePromise_.reject(error);\n      this.updatePromise_ = null;\n    }\n    key = Uint8ArrayUtils.fromBase64(jwkSet.keys[0].k);\n    keyId = Uint8ArrayUtils.fromBase64(jwkSet.keys[0].kid);\n  } else {\n    // The key ID is not required.\n    key = new Uint8Array(response);\n    keyId = null;\n  }\n\n  let prefixApi = shaka.polyfill.PatchedMediaKeysWebkit.prefixApi_;\n  let addKeyName = prefixApi('addKey');\n  try {\n    this.media_[addKeyName](this.keySystem_, key, keyId, this.sessionId);\n  } catch (exception) {\n    // Reject the promise.\n    this.updatePromise_.reject(exception);\n    this.updatePromise_ = null;\n  }\n};\n\n\n/**\n * Update key status and dispatch a 'keystatuseschange' event.\n *\n * @param {string} status\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.\n    updateKeyStatus_ = function(status) {\n  this.keyStatuses.setStatus(status);\n  let event = new shaka.util.FakeEvent('keystatuseschange');\n  this.dispatchEvent(event);\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.\n    generateRequest = function(initDataType, initData) {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.generateRequest');\n  return this.generate_(initData, null);\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.load =\n    function(sessionId) {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.load');\n  if (this.type_ == 'persistent-license') {\n    return this.generate_(null, sessionId);\n  } else {\n    return Promise.reject(new Error('Not a persistent session.'));\n  }\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.update =\n    function(response) {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.update', response);\n  goog.asserts.assert(this.sessionId, 'update without session ID');\n\n  let nextUpdatePromise = new shaka.util.PublicPromise();\n  this.update_(nextUpdatePromise, response);\n  return nextUpdatePromise;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.close =\n    function() {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.close');\n\n  // This will remove a persistent session, but it's also the only way to\n  // free CDM resources on v0.1b.\n  if (this.type_ != 'persistent-license') {\n    // sessionId may reasonably be null if no key request has been generated\n    // yet.  Unprefixed EME will return a rejected promise in this case.\n    // We will use the same error message that Chrome 41 uses in its EME\n    // implementation.\n    if (!this.sessionId) {\n      this.closed.reject(new Error('The session is not callable.'));\n      return this.closed;\n    }\n\n    // This may throw an exception, but we ignore it because we are only using\n    // it to clean up resources in v0.1b.  We still consider the session closed.\n    // We can't let the exception propagate because MediaKeySession.close()\n    // should not throw.\n    let prefixApi = shaka.polyfill.PatchedMediaKeysWebkit.prefixApi_;\n    let cancelKeyRequestName = prefixApi('cancelKeyRequest');\n    try {\n      this.media_[cancelKeyRequestName](this.keySystem_, this.sessionId);\n    } catch (exception) {}\n  }\n\n  // Resolve the 'closed' promise and return it.\n  this.closed.resolve();\n  return this.closed;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.remove =\n    function() {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.remove');\n\n  if (this.type_ != 'persistent-license') {\n    return Promise.reject(new Error('Not a persistent session.'));\n  }\n\n  return this.close();\n};\n\n\n/**\n * An implementation of MediaKeyStatusMap.\n * This fakes a map with a single key ID.\n *\n * @constructor\n * @struct\n * @implements {MediaKeyStatusMap}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap = function() {\n  /**\n   * @type {number}\n   */\n  this.size = 0;\n\n  /**\n   * @private {string|undefined}\n   */\n  this.status_ = undefined;\n};\n\n\n/**\n * @const {!ArrayBuffer}\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.KEY_ID_;\n\n\n/**\n * An internal method used by the session to set key status.\n * @param {string|undefined} status\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.setStatus =\n    function(status) {\n  this.size = status == undefined ? 0 : 1;\n  this.status_ = status;\n};\n\n\n/**\n * An internal method used by the session to get key status.\n * @return {string|undefined}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.getStatus =\n    function() {\n  return this.status_;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.forEach =\n    function(fn) {\n  if (this.status_) {\n    let fakeKeyId =\n        shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.KEY_ID_;\n    fn(this.status_, fakeKeyId);\n  }\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.get =\n    function(keyId) {\n  if (this.has(keyId)) {\n    return this.status_;\n  }\n  return undefined;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.has =\n    function(keyId) {\n  let fakeKeyId =\n      shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.KEY_ID_;\n  if (this.status_ &&\n      shaka.util.Uint8ArrayUtils.equal(\n          new Uint8Array(keyId), new Uint8Array(fakeKeyId))) {\n    return true;\n  }\n  return false;\n};\n\n\n/**\n * @suppress {missingReturn}\n * @override\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.\n    entries = function() {\n  goog.asserts.assert(false, 'Not used!  Provided only for compiler.');\n};\n\n\n/**\n * @suppress {missingReturn}\n * @override\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.\n    keys = function() {\n  goog.asserts.assert(false, 'Not used!  Provided only for compiler.');\n};\n\n\n/**\n * @suppress {missingReturn}\n * @override\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.\n    values = function() {\n  goog.asserts.assert(false, 'Not used!  Provided only for compiler.');\n};\n\n\nshaka.polyfill.register(shaka.polyfill.PatchedMediaKeysWebkit.install);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.PiPWebkit');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill.register');\n\n/**\n * @namespace shaka.polyfill.PiPWebkit\n *\n * @summary A polyfill to provide PiP support in Safari.\n * Note that Safari only supports PiP on video elements, not audio.\n */\n\n/**\n * Install the polyfill if needed.\n */\nshaka.polyfill.PiPWebkit.install = function() {\n  if (!window.HTMLVideoElement) {\n    // Avoid errors on very old browsers.\n    return;\n  }\n\n  const proto = HTMLVideoElement.prototype;\n  if (proto.requestPictureInPicture &&\n    document.exitPictureInPicture) {\n    // No polyfill needed.\n    return;\n  }\n\n  if (!proto.webkitSupportsPresentationMode) {\n    // No Webkit PiP API available.\n    return;\n  }\n\n  const PiPWebkit = shaka.polyfill.PiPWebkit;\n  shaka.log.debug('PiPWebkit.install');\n\n  // Polyfill document.pictureInPictureEnabled.\n  // It's definitely enabled now.  :-)\n  document.pictureInPictureEnabled = true;\n\n  // Polyfill document.pictureInPictureElement.\n  // This is initially empty.  We don't need getter or setter because we don't\n  // need any special handling when this is set.  We assume in good faith that\n  // applications won't try to set this directly.\n  document.pictureInPictureElement = null;\n\n  // Polyfill HTMLVideoElement.requestPictureInPicture.\n  proto.requestPictureInPicture = PiPWebkit.requestPictureInPicture_;\n\n  // Polyfill document.exitPictureInPicture.\n  document.exitPictureInPicture = PiPWebkit.exitPictureInPicture_;\n\n  // Use the \"capturing\" event phase to get the webkit presentation mode event\n  // from the document.  This way, we get the event on its way from document to\n  // the target element without having to intercept events in every possible\n  // video element.\n  document.addEventListener(\n      'webkitpresentationmodechanged', PiPWebkit.proxyEvent_,\n      /* useCapture= */ true);\n};\n\n/**\n * @param {!Event} event\n * @private\n */\nshaka.polyfill.PiPWebkit.proxyEvent_ = function(event) {\n  const PiPWebkit = shaka.polyfill.PiPWebkit;\n  const element = /** @type {!HTMLVideoElement} */(event.target);\n\n  if (element.webkitPresentationMode == PiPWebkit.PIP_MODE_) {\n    // Keep track of the PiP element.  This element just entered PiP mode.\n    document.pictureInPictureElement = element;\n\n    // Dispatch a standard event to match.\n    const event2 = new Event('enterpictureinpicture');\n    element.dispatchEvent(event2);\n  } else {\n    // Keep track of the PiP element.  This element just left PiP mode.\n    // If something else hasn't already take its place, clear it.\n    if (document.pictureInPictureElement == element) {\n      document.pictureInPictureElement = null;\n    }\n\n    // Dispatch a standard event to match.\n    const event2 = new Event('leavepictureinpicture');\n    element.dispatchEvent(event2);\n  }\n};\n\n/**\n * @this {HTMLVideoElement}\n * @return {!Promise}\n * @private\n */\nshaka.polyfill.PiPWebkit.requestPictureInPicture_ = function() {\n  const PiPWebkit = shaka.polyfill.PiPWebkit;\n  // NOTE: \"this\" here is the video element.\n\n  // Check if PiP is enabled for this element.\n  if (!this.webkitSupportsPresentationMode(PiPWebkit.PIP_MODE_)) {\n    const error = new Error('PiP not allowed by video element');\n    return Promise.reject(error);\n  } else {\n    // Enter PiP mode.\n    this.webkitSetPresentationMode(PiPWebkit.PIP_MODE_);\n    document.pictureInPictureElement = this;\n    return Promise.resolve();\n  }\n};\n\n/**\n * @this {Document}\n * @return {!Promise}\n * @private\n */\nshaka.polyfill.PiPWebkit.exitPictureInPicture_ = function() {\n  const PiPWebkit = shaka.polyfill.PiPWebkit;\n\n  const pipElement =\n      /** @type {HTMLVideoElement} */(document.pictureInPictureElement);\n  if (pipElement) {\n    // Exit PiP mode.\n    pipElement.webkitSetPresentationMode(PiPWebkit.INLINE_MODE_);\n    document.pictureInPictureElement = null;\n    return Promise.resolve();\n  } else {\n    const error = new Error('No picture in picture element found');\n    return Promise.reject(error);\n  }\n};\n\n/**\n * The presentation mode string used to indicate PiP mode in Safari.\n *\n * @const {string}\n * @private\n */\nshaka.polyfill.PiPWebkit.PIP_MODE_ = 'picture-in-picture';\n\n/**\n * The presentation mode string used to indicate inline mode in Safari.\n *\n * @const {string}\n * @private\n */\nshaka.polyfill.PiPWebkit.INLINE_MODE_ = 'inline';\n\nshaka.polyfill.register(shaka.polyfill.PiPWebkit.install);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.VideoPlaybackQuality');\n\ngoog.require('shaka.polyfill.register');\n\n\n/**\n * @namespace shaka.polyfill.VideoPlaybackQuality\n *\n * @summary A polyfill to provide MSE VideoPlaybackQuality metrics.\n * Many browsers do not yet provide this API, and Chrome currently provides\n * similar data through individual prefixed attributes on HTMLVideoElement.\n */\n\n\n/**\n * Install the polyfill if needed.\n */\nshaka.polyfill.VideoPlaybackQuality.install = function() {\n  if (!window.HTMLVideoElement) {\n    // Avoid errors on very old browsers.\n    return;\n  }\n\n  let proto = HTMLVideoElement.prototype;\n  if (proto.getVideoPlaybackQuality) {\n    // No polyfill needed.\n    return;\n  }\n\n  if ('webkitDroppedFrameCount' in proto) {\n    proto.getVideoPlaybackQuality =\n        shaka.polyfill.VideoPlaybackQuality.webkit_;\n  }\n};\n\n\n/**\n * @this {HTMLVideoElement}\n * @return {!VideoPlaybackQuality}\n * @private\n */\nshaka.polyfill.VideoPlaybackQuality.webkit_ = function() {\n  return {\n    'droppedVideoFrames': this.webkitDroppedFrameCount,\n    'totalVideoFrames': this.webkitDecodedFrameCount,\n    // Not provided by this polyfill:\n    'corruptedVideoFrames': 0,\n    'creationTime': NaN,\n    'totalFrameDelay': 0,\n  };\n};\n\n\nshaka.polyfill.register(shaka.polyfill.VideoPlaybackQuality.install);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.VTTCue');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill.register');\n\n\n/**\n * @namespace shaka.polyfill.VTTCue\n *\n * @summary A polyfill to provide VTTCue.\n */\n\n\n/**\n * Install the polyfill if needed.\n */\nshaka.polyfill.VTTCue.install = function() {\n  if (window.VTTCue) {\n    shaka.log.info('Using native VTTCue.');\n    return;\n  }\n\n  if (!window.TextTrackCue) {\n    shaka.log.error('VTTCue not available.');\n    return;\n  }\n\n  let constructorLength = TextTrackCue.length;\n  if (constructorLength == 3) {\n    shaka.log.info('Using VTTCue polyfill from 3 argument TextTrackCue.');\n    window.VTTCue = shaka.polyfill.VTTCue.from3ArgsTextTrackCue_;\n  } else if (constructorLength == 6) {\n    shaka.log.info('Using VTTCue polyfill from 6 argument TextTrackCue.');\n    window.VTTCue = shaka.polyfill.VTTCue.from6ArgsTextTrackCue_;\n  } else if (shaka.polyfill.VTTCue.canUse3ArgsTextTrackCue_()) {\n    shaka.log.info('Using VTTCue polyfill from 3 argument TextTrackCue.');\n    window.VTTCue = shaka.polyfill.VTTCue.from3ArgsTextTrackCue_;\n  }\n};\n\n\n/**\n * Draft spec TextTrackCue with 3 constructor arguments.\n * @see {@link https://bit.ly/2IdyKbA W3C Working Draft 25 October 2012}.\n *\n * @param {number} startTime\n * @param {number} endTime\n * @param {string} text\n * @return {TextTrackCue}\n * @private\n */\nshaka.polyfill.VTTCue.from3ArgsTextTrackCue_ = function(startTime, endTime,\n    text) {\n  return new window.TextTrackCue(startTime, endTime, text);\n};\n\n\n/**\n * Draft spec TextTrackCue with 6 constructor arguments (5th & 6th are\n * optional).\n * @see {@link https://bit.ly/2KaGSP2 W3C Working Draft 29 March 2012}.\n *\n * @param {number} startTime\n * @param {number} endTime\n * @param {string} text\n * @return {TextTrackCue}\n * @private\n */\nshaka.polyfill.VTTCue.from6ArgsTextTrackCue_ = function(startTime, endTime,\n    text) {\n  let id = startTime + '-' + endTime + '-' + text;\n  // Quoting the access to the TextTrackCue object to satisfy the compiler.\n  return new window['TextTrackCue'](id, startTime, endTime, text);\n};\n\n\n/**\n * IE10, IE11 and Edge return TextTrackCue.length = 0, although they accept 3\n * constructor arguments.\n *\n * @return {boolean}\n * @private\n */\nshaka.polyfill.VTTCue.canUse3ArgsTextTrackCue_ = function() {\n  try {\n    return !!shaka.polyfill.VTTCue.from3ArgsTextTrackCue_(1, 2, '');\n  } catch (error) {\n    return false;\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.VTTCue.install);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.text.TtmlTextParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.CueRegion');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * @constructor\n * @implements {shaka.extern.TextParser}\n */\nshaka.text.TtmlTextParser = function() {};\n\n\n/**\n * @const {string}\n * @private\n */\nshaka.text.TtmlTextParser.parameterNs_ = 'http://www.w3.org/ns/ttml#parameter';\n\n\n/**\n * @const {string}\n * @private\n */\nshaka.text.TtmlTextParser.styleNs_ = 'http://www.w3.org/ns/ttml#styling';\n\n\n/** @override */\nshaka.text.TtmlTextParser.prototype.parseInit = function(data) {\n  goog.asserts.assert(false, 'TTML does not have init segments');\n};\n\n\n/** @override */\nshaka.text.TtmlTextParser.prototype.parseMedia = function(data, time) {\n  const TtmlTextParser = shaka.text.TtmlTextParser;\n  const XmlUtils = shaka.util.XmlUtils;\n  const ttpNs = TtmlTextParser.parameterNs_;\n  let str = shaka.util.StringUtils.fromUTF8(data);\n  let ret = [];\n  let parser = new DOMParser();\n  let xml = null;\n\n  try {\n    xml = parser.parseFromString(str, 'text/xml');\n  } catch (exception) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.INVALID_XML);\n  }\n\n  if (xml) {\n    // Try to get the framerate, subFrameRate and frameRateMultiplier\n    // if applicable\n    let frameRate = null;\n    let subFrameRate = null;\n    let frameRateMultiplier = null;\n    let tickRate = null;\n    let spaceStyle = null;\n    let extent = null;\n    let tts = xml.getElementsByTagName('tt');\n    let tt = tts[0];\n    // TTML should always have tt element.\n    if (!tt) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_XML);\n    } else {\n      frameRate = XmlUtils.getAttributeNS(tt, ttpNs, 'frameRate');\n      subFrameRate = XmlUtils.getAttributeNS(tt, ttpNs, 'subFrameRate');\n      frameRateMultiplier =\n          XmlUtils.getAttributeNS(tt, ttpNs, 'frameRateMultiplier');\n      tickRate = XmlUtils.getAttributeNS(tt, ttpNs, 'tickRate');\n      spaceStyle = tt.getAttribute('xml:space') || 'default';\n      extent = tt.getAttribute('tts:extent');\n    }\n\n    if (spaceStyle != 'default' && spaceStyle != 'preserve') {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_XML);\n    }\n    let whitespaceTrim = spaceStyle == 'default';\n\n    let rateInfo = new TtmlTextParser.RateInfo_(\n        frameRate, subFrameRate, frameRateMultiplier, tickRate);\n\n    const metadataElements = TtmlTextParser.getLeafNodes_(\n        tt.getElementsByTagName('metadata')[0]);\n    let styles = TtmlTextParser.getLeafNodes_(\n        tt.getElementsByTagName('styling')[0]);\n    let regionElements = TtmlTextParser.getLeafNodes_(\n        tt.getElementsByTagName('layout')[0]);\n    let cueRegions = [];\n    for (let i = 0; i < regionElements.length; i++) {\n      let cueRegion = TtmlTextParser.parseCueRegion_(\n          regionElements[i], styles, extent);\n      if (cueRegion) {\n        cueRegions.push(cueRegion);\n      }\n    }\n\n    let textNodes = TtmlTextParser.getLeafNodes_(\n        tt.getElementsByTagName('body')[0]);\n\n    for (let i = 0; i < textNodes.length; i++) {\n      let cue = TtmlTextParser.parseCue_(textNodes[i],\n                                         time.periodStart,\n                                         rateInfo,\n                                         metadataElements,\n                                         styles,\n                                         regionElements,\n                                         cueRegions,\n                                         whitespaceTrim);\n      if (cue) {\n        ret.push(cue);\n      }\n    }\n  }\n\n  return ret;\n};\n\n\n/**\n * @const\n * @private {!RegExp}\n * @example 50% 10%\n */\nshaka.text.TtmlTextParser.percentValues_ = /^(\\d{1,2}|100)% (\\d{1,2}|100)%$/;\n\n\n/**\n * @const\n * @private {!RegExp}\n * @example 100px\n */\nshaka.text.TtmlTextParser.unitValues_ = /^(\\d+px|\\d+em)$/;\n\n\n/**\n * @const\n * @private {!RegExp}\n * @example 100px\n */\nshaka.text.TtmlTextParser.pixelValues_ = /^(\\d+)px (\\d+)px$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)\n */\nshaka.text.TtmlTextParser.timeColonFormatFrames_ =\n    /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/;\n\n\n/**\n * @const\n * @private {!RegExp}\n * @example 00:00:40 or 00:40\n */\nshaka.text.TtmlTextParser.timeColonFormat_ = /^(?:(\\d{2,}):)?(\\d{2}):(\\d{2})$/;\n\n\n/**\n * @const\n * @private {!RegExp}\n * @example 01:02:43.0345555 or 02:43.03\n */\nshaka.text.TtmlTextParser.timeColonFormatMilliseconds_ =\n    /^(?:(\\d{2,}):)?(\\d{2}):(\\d{2}\\.\\d{2,})$/;\n\n\n/**\n * @const\n * @private {!RegExp}\n * @example 75f or 75.5f\n */\nshaka.text.TtmlTextParser.timeFramesFormat_ = /^(\\d*(?:\\.\\d*)?)f$/;\n\n\n/**\n * @const\n * @private {!RegExp}\n * @example 50t or 50.5t\n */\nshaka.text.TtmlTextParser.timeTickFormat_ = /^(\\d*(?:\\.\\d*)?)t$/;\n\n\n/**\n * @const\n * @private {!RegExp}\n * @example 3.45h, 3m or 4.20s\n */\nshaka.text.TtmlTextParser.timeHMSFormat_ =\n    new RegExp(['^(?:(\\\\d*(?:\\\\.\\\\d*)?)h)?',\n                '(?:(\\\\d*(?:\\\\.\\\\d*)?)m)?',\n                '(?:(\\\\d*(?:\\\\.\\\\d*)?)s)?',\n                '(?:(\\\\d*(?:\\\\.\\\\d*)?)ms)?$'].join(''));\n\n\n/**\n * @const\n * @private {!Object.<string, shaka.text.Cue.lineAlign>}\n */\nshaka.text.TtmlTextParser.textAlignToLineAlign_ = {\n  'left': shaka.text.Cue.lineAlign.START,\n  'center': shaka.text.Cue.lineAlign.CENTER,\n  'right': shaka.text.Cue.lineAlign.END,\n  'start': shaka.text.Cue.lineAlign.START,\n  'end': shaka.text.Cue.lineAlign.END,\n};\n\n\n/**\n * @const\n * @private {!Object.<string, shaka.text.Cue.positionAlign>}\n */\nshaka.text.TtmlTextParser.textAlignToPositionAlign_ = {\n  'left': shaka.text.Cue.positionAlign.LEFT,\n  'center': shaka.text.Cue.positionAlign.CENTER,\n  'right': shaka.text.Cue.positionAlign.RIGHT,\n};\n\n\n/**\n * Gets the leaf nodes of the xml node tree. Ignores the text, br elements\n * and the spans positioned inside paragraphs\n *\n * @param {Element} element\n * @return {!Array.<!Element>}\n * @private\n */\nshaka.text.TtmlTextParser.getLeafNodes_ = function(element) {\n  let result = [];\n  if (!element) {\n    return result;\n  }\n\n  let childNodes = element.childNodes;\n  for (let i = 0; i < childNodes.length; i++) {\n    // Currently we don't support styles applicable to span\n    // elements, so they are ignored.\n    let isSpanChildOfP = childNodes[i].nodeName == 'span' &&\n        element.nodeName == 'p';\n    if (childNodes[i].nodeType == Node.ELEMENT_NODE &&\n        childNodes[i].nodeName != 'br' && !isSpanChildOfP) {\n      // Get the leaves the child might contain.\n      goog.asserts.assert(childNodes[i] instanceof Element,\n                          'Node should be Element!');\n      let leafChildren = shaka.text.TtmlTextParser.getLeafNodes_(\n          /** @type {Element} */(childNodes[i]));\n      goog.asserts.assert(leafChildren.length > 0,\n                          'Only a null Element should return no leaves!');\n      result = result.concat(leafChildren);\n    }\n  }\n\n  // if no result at this point, the element itself must be a leaf.\n  if (!result.length) {\n    result.push(element);\n  }\n  return result;\n};\n\n\n/**\n * Inserts \\n where <br> tags are found.\n *\n * @param {!Node} element\n * @param {boolean} whitespaceTrim\n * @private\n */\nshaka.text.TtmlTextParser.addNewLines_ = function(element, whitespaceTrim) {\n  let childNodes = element.childNodes;\n\n  for (let i = 0; i < childNodes.length; i++) {\n    if (childNodes[i].nodeName == 'br' && i > 0) {\n      childNodes[i - 1].textContent += '\\n';\n    } else if (childNodes[i].childNodes.length > 0) {\n      shaka.text.TtmlTextParser.addNewLines_(childNodes[i], whitespaceTrim);\n    } else if (whitespaceTrim) {\n      // Trim leading and trailing whitespace.\n      let trimmed = childNodes[i].textContent.trim();\n      // Collapse multiple spaces into one.\n      trimmed = trimmed.replace(/\\s+/g, ' ');\n\n      childNodes[i].textContent = trimmed;\n    }\n  }\n};\n\n\n/**\n * Parses an Element into a TextTrackCue or VTTCue.\n *\n * @param {!Element} cueElement\n * @param {number} offset\n * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n * @param {!Array.<!Element>} metadataElements\n * @param {!Array.<!Element>} styles\n * @param {!Array.<!Element>} regionElements\n * @param {!Array.<!shaka.text.CueRegion>} cueRegions\n * @param {boolean} whitespaceTrim\n * @return {shaka.text.Cue}\n * @private\n */\nshaka.text.TtmlTextParser.parseCue_ = function(\n    cueElement, offset, rateInfo, metadataElements, styles,\n    regionElements, cueRegions, whitespaceTrim) {\n  // Disregard empty elements:\n  // TTML allows for empty elements like <div></div>.\n  // If cueElement has neither time attributes, nor\n  // non-whitespace text, don't try to make a cue out of it.\n  if (!cueElement.hasAttribute('begin') &&\n      !cueElement.hasAttribute('end') &&\n      /^\\s*$/.test(cueElement.textContent)) {\n    return null;\n  }\n\n  shaka.text.TtmlTextParser.addNewLines_(cueElement, whitespaceTrim);\n\n  // Get time.\n  let start = shaka.text.TtmlTextParser.parseTime_(\n      cueElement.getAttribute('begin'), rateInfo);\n  let end = shaka.text.TtmlTextParser.parseTime_(\n      cueElement.getAttribute('end'), rateInfo);\n  let duration = shaka.text.TtmlTextParser.parseTime_(\n      cueElement.getAttribute('dur'), rateInfo);\n  let payload = cueElement.textContent;\n\n  if (end == null && duration != null) {\n    end = start + duration;\n  }\n\n  if (start == null || end == null) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.INVALID_TEXT_CUE);\n  }\n\n  start += offset;\n  end += offset;\n\n  let cue = new shaka.text.Cue(start, end, payload);\n\n  // Get other properties if available.\n  let regionElement = shaka.text.TtmlTextParser.getElementFromCollection_(\n      cueElement, 'region', regionElements, /* prefix= */ '');\n  if (regionElement && regionElement.getAttribute('xml:id')) {\n    let regionId = regionElement.getAttribute('xml:id');\n    let regionsWithId = cueRegions.filter(function(region) {\n      return region.id == regionId;\n    });\n    cue.region = regionsWithId[0];\n  }\n  const imageElement = shaka.text.TtmlTextParser.getElementFromCollection_(\n      cueElement, 'smpte:backgroundImage', metadataElements, '#');\n  shaka.text.TtmlTextParser.addStyle_(\n      cue,\n      cueElement,\n      regionElement,\n      imageElement,\n      styles);\n\n  return cue;\n};\n\n\n/**\n * Parses an Element into a TextTrackCue or VTTCue.\n *\n * @param {!Element} regionElement\n * @param {!Array.<!Element>} styles Defined in the top of tt  element and\n * used principally for images.\n * @param {string} globalExtent\n * @return {shaka.text.CueRegion}\n * @private\n */\nshaka.text.TtmlTextParser.parseCueRegion_ = function(regionElement, styles,\n  globalExtent) {\n  const TtmlTextParser = shaka.text.TtmlTextParser;\n  let region = new shaka.text.CueRegion();\n  let id = regionElement.getAttribute('xml:id');\n  if (!id) {\n    shaka.log.warning('TtmlTextParser parser encountered a region with ' +\n                      'no id. Region will be ignored.');\n    return null;\n  }\n  region.id = id;\n\n  let globalResults = null;\n  if (globalExtent) {\n    globalResults = TtmlTextParser.percentValues_.exec(globalExtent) ||\n      TtmlTextParser.pixelValues_.exec(globalExtent);\n  }\n  const globalWidth = globalResults ? Number(globalResults[1]) : null;\n  const globalHeight = globalResults ? Number(globalResults[2]) : null;\n\n  let results = null;\n  let percentage = null;\n  let extent = TtmlTextParser.getStyleAttributeFromRegion_(\n      regionElement, styles, 'extent');\n  if (extent) {\n    percentage = TtmlTextParser.percentValues_.exec(extent);\n    results = percentage || TtmlTextParser.pixelValues_.exec(extent);\n    if (results != null) {\n      if (globalWidth != null) {\n        region.width = Number(results[1]) * 100 / globalWidth;\n      } else {\n        region.width = Number(results[1]);\n      }\n      if (globalHeight != null) {\n        region.height = Number(results[2]) * 100 / globalHeight;\n      } else {\n        region.height = Number(results[2]);\n      }\n      region.widthUnits = percentage || globalWidth != null ?\n                         shaka.text.CueRegion.units.PERCENTAGE :\n                         shaka.text.CueRegion.units.PX;\n\n      region.heightUnits = percentage || globalHeight != null ?\n                         shaka.text.CueRegion.units.PERCENTAGE :\n                         shaka.text.CueRegion.units.PX;\n    }\n  }\n\n  let origin = TtmlTextParser.getStyleAttributeFromRegion_(\n      regionElement, styles, 'origin');\n  if (origin) {\n    percentage = TtmlTextParser.percentValues_.exec(origin);\n    results = percentage || TtmlTextParser.pixelValues_.exec(origin);\n    if (results != null) {\n      if (globalHeight != null) {\n        region.viewportAnchorX = Number(results[1]) * 100 / globalHeight;\n      } else {\n        region.viewportAnchorX = Number(results[1]);\n      }\n      if (globalWidth != null) {\n        region.viewportAnchorY = Number(results[2]) * 100 / globalWidth;\n      } else {\n        region.viewportAnchorY = Number(results[2]);\n      }\n      region.viewportAnchorUnits = percentage || globalWidth != null ?\n                shaka.text.CueRegion.units.PERCENTAGE :\n                shaka.text.CueRegion.units.PX;\n    }\n  }\n\n  return region;\n};\n\n/**\n * Adds applicable style properties to a cue.\n *\n * @param {!shaka.text.Cue} cue\n * @param {!Element} cueElement\n * @param {Element} region\n * @param {Element} imageElement\n * @param {!Array.<!Element>} styles\n * @private\n */\nshaka.text.TtmlTextParser.addStyle_ = function(\n    cue, cueElement, region, imageElement, styles) {\n  const TtmlTextParser = shaka.text.TtmlTextParser;\n  const Cue = shaka.text.Cue;\n\n  let direction = TtmlTextParser.getStyleAttribute_(\n      cueElement, region, styles, 'direction');\n  if (direction == 'rtl') {\n    cue.direction = Cue.direction.HORIZONTAL_RIGHT_TO_LEFT;\n  }\n\n  // Direction attribute specifies one-dimentional writing direction\n  // (left to right or right to left). Writing mode specifies that\n  // plus whether text is vertical or horizontal.\n  // They should not contradict each other. If they do, we give\n  // preference to writing mode.\n  let writingMode = TtmlTextParser.getStyleAttribute_(\n      cueElement, region, styles, 'writingMode');\n  // Set cue's direction if the text is horizontal, and cue's writingMode if\n  // it's vertical.\n  if (writingMode == 'tb' || writingMode == 'tblr') {\n    cue.writingMode = Cue.writingMode.VERTICAL_LEFT_TO_RIGHT;\n  } else if (writingMode == 'tbrl') {\n    cue.writingMode = Cue.writingMode.VERTICAL_RIGHT_TO_LEFT;\n  } else if (writingMode == 'rltb' || writingMode == 'rl') {\n    cue.direction = Cue.direction.HORIZONTAL_RIGHT_TO_LEFT;\n  } else if (writingMode) {\n    cue.direction = Cue.direction.HORIZONTAL_LEFT_TO_RIGHT;\n  }\n\n  let align = TtmlTextParser.getStyleAttribute_(\n      cueElement, region, styles, 'textAlign');\n  if (align) {\n    cue.positionAlign = TtmlTextParser.textAlignToPositionAlign_[align];\n    cue.lineAlign = TtmlTextParser.textAlignToLineAlign_[align];\n\n    goog.asserts.assert(align.toUpperCase() in Cue.textAlign,\n                        align.toUpperCase() +\n                        ' Should be in Cue.textAlign values!');\n\n    cue.textAlign = Cue.textAlign[align.toUpperCase()];\n  }\n\n  let displayAlign = TtmlTextParser.getStyleAttribute_(\n      cueElement, region, styles, 'displayAlign');\n  if (displayAlign) {\n    goog.asserts.assert(displayAlign.toUpperCase() in Cue.displayAlign,\n                        displayAlign.toUpperCase() +\n                        ' Should be in Cue.displayAlign values!');\n    cue.displayAlign = Cue.displayAlign[displayAlign.toUpperCase()];\n  }\n\n  let color = TtmlTextParser.getStyleAttribute_(\n      cueElement, region, styles, 'color');\n  if (color) {\n    cue.color = color;\n  }\n\n  let backgroundColor = TtmlTextParser.getStyleAttribute_(\n      cueElement, region, styles, 'backgroundColor');\n  if (backgroundColor) {\n    cue.backgroundColor = backgroundColor;\n  }\n\n  let fontFamily = TtmlTextParser.getStyleAttribute_(\n      cueElement, region, styles, 'fontFamily');\n  if (fontFamily) {\n    cue.fontFamily = fontFamily;\n  }\n\n  let fontWeight = TtmlTextParser.getStyleAttribute_(\n      cueElement, region, styles, 'fontWeight');\n  if (fontWeight && fontWeight == 'bold') {\n    cue.fontWeight = Cue.fontWeight.BOLD;\n  }\n\n  let wrapOption = TtmlTextParser.getStyleAttribute_(\n      cueElement, region, styles, 'wrapOption');\n  if (wrapOption && wrapOption == 'noWrap') {\n    cue.wrapLine = false;\n  }\n\n  let lineHeight = TtmlTextParser.getStyleAttribute_(\n      cueElement, region, styles, 'lineHeight');\n  if (lineHeight && lineHeight.match(TtmlTextParser.unitValues_)) {\n    cue.lineHeight = lineHeight;\n  }\n\n  let fontSize = TtmlTextParser.getStyleAttribute_(\n      cueElement, region, styles, 'fontSize');\n  if (fontSize && fontSize.match(TtmlTextParser.unitValues_)) {\n    cue.fontSize = fontSize;\n  }\n\n  let fontStyle = TtmlTextParser.getStyleAttribute_(\n      cueElement, region, styles, 'fontStyle');\n  if (fontStyle) {\n    goog.asserts.assert(fontStyle.toUpperCase() in Cue.fontStyle,\n                        fontStyle.toUpperCase() +\n                        ' Should be in Cue.fontStyle values!');\n    cue.fontStyle = Cue.fontStyle[fontStyle.toUpperCase()];\n  }\n\n  if (imageElement) {\n    const backgroundImageType = imageElement.getAttribute('imagetype');\n    const backgroundImageEncoding = imageElement.getAttribute('encoding');\n    const backgroundImageData = imageElement.textContent.trim();\n    if (backgroundImageType == 'PNG' &&\n        backgroundImageEncoding == 'Base64' &&\n        backgroundImageData) {\n      cue.backgroundImage = 'data:image/png;base64,' + backgroundImageData;\n    }\n  }\n\n  // Text decoration is an array of values which can come both from the\n  // element's style or be inherited from elements' parent nodes. All of those\n  // values should be applied as long as they don't contradict each other. If\n  // they do, elements' own style gets preference.\n  let textDecorationRegion = TtmlTextParser.getStyleAttributeFromRegion_(\n      region, styles, 'textDecoration');\n  if (textDecorationRegion) {\n    TtmlTextParser.addTextDecoration_(cue, textDecorationRegion);\n  }\n\n  let textDecorationElement = TtmlTextParser.getStyleAttributeFromElement_(\n      cueElement, styles, 'textDecoration');\n  if (textDecorationElement) {\n    TtmlTextParser.addTextDecoration_(cue, textDecorationElement);\n  }\n};\n\n\n/**\n * Parses text decoration values and adds/removes them to/from the cue.\n *\n * @param {!shaka.text.Cue} cue\n * @param {string} decoration\n * @private\n */\nshaka.text.TtmlTextParser.addTextDecoration_ = function(cue, decoration) {\n  const Cue = shaka.text.Cue;\n  let values = decoration.split(' ');\n  for (let i = 0; i < values.length; i++) {\n    switch (values[i]) {\n      case 'underline':\n        if (!cue.textDecoration.includes(Cue.textDecoration.UNDERLINE)) {\n          cue.textDecoration.push(Cue.textDecoration.UNDERLINE);\n        }\n        break;\n      case 'noUnderline':\n        if (cue.textDecoration.includes(Cue.textDecoration.UNDERLINE)) {\n          shaka.util.ArrayUtils.remove(cue.textDecoration,\n                                       Cue.textDecoration.UNDERLINE);\n        }\n        break;\n      case 'lineThrough':\n        if (!cue.textDecoration.includes(Cue.textDecoration.LINE_THROUGH)) {\n          cue.textDecoration.push(Cue.textDecoration.LINE_THROUGH);\n        }\n        break;\n      case 'noLineThrough':\n        if (cue.textDecoration.includes(Cue.textDecoration.LINE_THROUGH)) {\n          shaka.util.ArrayUtils.remove(cue.textDecoration,\n                                       Cue.textDecoration.LINE_THROUGH);\n        }\n        break;\n      case 'overline':\n        if (!cue.textDecoration.includes(Cue.textDecoration.OVERLINE)) {\n          cue.textDecoration.push(Cue.textDecoration.OVERLINE);\n        }\n        break;\n      case 'noOverline':\n        if (cue.textDecoration.includes(Cue.textDecoration.OVERLINE)) {\n          shaka.util.ArrayUtils.remove(cue.textDecoration,\n                                       Cue.textDecoration.OVERLINE);\n        }\n        break;\n    }\n  }\n};\n\n\n/**\n * Finds a specified attribute on either the original cue element or its\n * associated region and returns the value if the attribute was found.\n *\n * @param {!Element} cueElement\n * @param {Element} region\n * @param {!Array.<!Element>} styles\n * @param {string} attribute\n * @return {?string}\n * @private\n */\nshaka.text.TtmlTextParser.getStyleAttribute_ = function(\n    cueElement, region, styles, attribute) {\n  // An attribute can be specified on region level or in a styling block\n  // associated with the region or original element.\n  const TtmlTextParser = shaka.text.TtmlTextParser;\n  let attr = TtmlTextParser.getStyleAttributeFromElement_(\n      cueElement, styles, attribute);\n  if (attr) {\n    return attr;\n  }\n\n  return TtmlTextParser.getStyleAttributeFromRegion_(\n      region, styles, attribute);\n};\n\n\n/**\n * Finds a specified attribute on the element's associated region\n * and returns the value if the attribute was found.\n *\n * @param {Element} region\n * @param {!Array.<!Element>} styles\n * @param {string} attribute\n * @return {?string}\n * @private\n */\nshaka.text.TtmlTextParser.getStyleAttributeFromRegion_ = function(\n    region, styles, attribute) {\n  const XmlUtils = shaka.util.XmlUtils;\n  const ttsNs = shaka.text.TtmlTextParser.styleNs_;\n\n  let regionChildren = shaka.text.TtmlTextParser.getLeafNodes_(region);\n  for (let i = 0; i < regionChildren.length; i++) {\n    let attr = XmlUtils.getAttributeNS(regionChildren[i], ttsNs, attribute);\n    if (attr) {\n      return attr;\n    }\n  }\n\n  let style = shaka.text.TtmlTextParser.getElementFromCollection_(\n      region, 'style', styles, /* prefix= */ '');\n  if (style) {\n    return XmlUtils.getAttributeNS(style, ttsNs, attribute);\n  }\n  return null;\n};\n\n\n/**\n * Finds a specified attribute on the cue element and returns the value\n * if the attribute was found.\n *\n * @param {!Element} cueElement\n * @param {!Array.<!Element>} styles\n * @param {string} attribute\n * @return {?string}\n * @private\n */\nshaka.text.TtmlTextParser.getStyleAttributeFromElement_ = function(\n    cueElement, styles, attribute) {\n  const XmlUtils = shaka.util.XmlUtils;\n  const ttsNs = shaka.text.TtmlTextParser.styleNs_;\n\n  let getElementFromCollection_ =\n      shaka.text.TtmlTextParser.getElementFromCollection_;\n  let style = getElementFromCollection_(\n      cueElement, 'style', styles, /* prefix= */ '');\n  if (style) {\n    return XmlUtils.getAttributeNS(style, ttsNs, attribute);\n  }\n  return null;\n};\n\n\n/**\n * Selects an item from |collection| whose id matches |attributeName|\n * from |element|.\n *\n * @param {Element} element\n * @param {string} attributeName\n * @param {!Array.<Element>} collection\n * @param {string} prefixName\n * @return {Element}\n * @private\n */\nshaka.text.TtmlTextParser.getElementFromCollection_ = function(\n    element, attributeName, collection, prefixName) {\n  if (!element || collection.length < 1) {\n    return null;\n  }\n  let item = null;\n  let itemName = shaka.text.TtmlTextParser.getInheritedAttribute_(\n      element, attributeName);\n  if (itemName) {\n    for (let i = 0; i < collection.length; i++) {\n      if ((prefixName + collection[i].getAttribute('xml:id')) == itemName) {\n        item = collection[i];\n        break;\n      }\n    }\n  }\n\n  return item;\n};\n\n\n/**\n * Traverses upwards from a given node until a given attribute is found.\n *\n * @param {!Element} element\n * @param {string} attributeName\n * @return {?string}\n * @private\n */\nshaka.text.TtmlTextParser.getInheritedAttribute_ = function(\n    element, attributeName) {\n  let ret = null;\n  while (element) {\n    ret = element.getAttribute(attributeName);\n    if (ret) {\n      break;\n    }\n\n    // Element.parentNode can lead to XMLDocument, which is not an Element and\n    // has no getAttribute().\n    let parentNode = element.parentNode;\n    if (parentNode instanceof Element) {\n      element = parentNode;\n    } else {\n      break;\n    }\n  }\n  return ret;\n};\n\n\n/**\n * Parses a TTML time from the given word.\n *\n * @param {string} text\n * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n * @return {?number}\n * @private\n */\nshaka.text.TtmlTextParser.parseTime_ = function(text, rateInfo) {\n  let ret = null;\n  const TtmlTextParser = shaka.text.TtmlTextParser;\n\n  if (TtmlTextParser.timeColonFormatFrames_.test(text)) {\n    ret = TtmlTextParser.parseColonTimeWithFrames_(rateInfo, text);\n  } else if (TtmlTextParser.timeColonFormat_.test(text)) {\n    ret = TtmlTextParser.parseTimeFromRegex_(\n        TtmlTextParser.timeColonFormat_, text);\n  } else if (TtmlTextParser.timeColonFormatMilliseconds_.test(text)) {\n    ret = TtmlTextParser.parseTimeFromRegex_(\n        TtmlTextParser.timeColonFormatMilliseconds_, text);\n  } else if (TtmlTextParser.timeFramesFormat_.test(text)) {\n    ret = TtmlTextParser.parseFramesTime_(rateInfo, text);\n  } else if (TtmlTextParser.timeTickFormat_.test(text)) {\n    ret = TtmlTextParser.parseTickTime_(rateInfo, text);\n  } else if (TtmlTextParser.timeHMSFormat_.test(text)) {\n    ret = TtmlTextParser.parseTimeFromRegex_(\n        TtmlTextParser.timeHMSFormat_, text);\n  }\n\n  return ret;\n};\n\n\n/**\n * Parses a TTML time in frame format.\n *\n * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n * @param {string} text\n * @return {?number}\n * @private\n */\nshaka.text.TtmlTextParser.parseFramesTime_ = function(rateInfo, text) {\n  // 75f or 75.5f\n  let results = shaka.text.TtmlTextParser.timeFramesFormat_.exec(text);\n  let frames = Number(results[1]);\n\n  return frames / rateInfo.frameRate;\n};\n\n\n/**\n * Parses a TTML time in tick format.\n *\n * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n * @param {string} text\n * @return {?number}\n * @private\n */\nshaka.text.TtmlTextParser.parseTickTime_ = function(rateInfo, text) {\n  // 50t or 50.5t\n  let results = shaka.text.TtmlTextParser.timeTickFormat_.exec(text);\n  let ticks = Number(results[1]);\n\n  return ticks / rateInfo.tickRate;\n};\n\n\n/**\n * Parses a TTML colon formatted time containing frames.\n *\n * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n * @param {string} text\n * @return {?number}\n * @private\n */\nshaka.text.TtmlTextParser.parseColonTimeWithFrames_ = function(\n    rateInfo, text) {\n  // 01:02:43:07 ('07' is frames) or 01:02:43:07.1 (subframes)\n  let results = shaka.text.TtmlTextParser.timeColonFormatFrames_.exec(text);\n\n  let hours = Number(results[1]);\n  let minutes = Number(results[2]);\n  let seconds = Number(results[3]);\n  let frames = Number(results[4]);\n  let subframes = Number(results[5]) || 0;\n\n  frames += subframes / rateInfo.subFrameRate;\n  seconds += frames / rateInfo.frameRate;\n\n  return seconds + (minutes * 60) + (hours * 3600);\n};\n\n\n/**\n * Parses a TTML time with a given regex. Expects regex to be some\n * sort of a time-matcher to match hours, minutes, seconds and milliseconds\n *\n * @param {!RegExp} regex\n * @param {string} text\n * @return {?number}\n * @private\n */\nshaka.text.TtmlTextParser.parseTimeFromRegex_ = function(regex, text) {\n  let results = regex.exec(text);\n  if (results == null || results[0] == '') {\n    return null;\n  }\n  // This capture is optional, but will still be in the array as undefined,\n  // in which case it is 0.\n  let hours = Number(results[1]) || 0;\n  let minutes = Number(results[2]) || 0;\n  let seconds = Number(results[3]) || 0;\n  let miliseconds = Number(results[4]) || 0;\n\n  return (miliseconds / 1000) + seconds + (minutes * 60) + (hours * 3600);\n};\n\n\n/**\n * Contains information about frame/subframe rate\n * and frame rate multiplier for time in frame format.\n *\n * @example 01:02:03:04(4 frames) or 01:02:03:04.1(4 frames, 1 subframe)\n * @param {?string} frameRate\n * @param {?string} subFrameRate\n * @param {?string} frameRateMultiplier\n * @param {?string} tickRate\n * @constructor\n * @struct\n * @private\n */\nshaka.text.TtmlTextParser.RateInfo_ = function(\n    frameRate, subFrameRate, frameRateMultiplier, tickRate) {\n  /**\n   * @type {number}\n   */\n  this.frameRate = Number(frameRate) || 30;\n\n  /**\n   * @type {number}\n   */\n  this.subFrameRate = Number(subFrameRate) || 1;\n\n  /**\n   * @type {number}\n   */\n  this.tickRate = Number(tickRate);\n  if (this.tickRate == 0) {\n    if (frameRate) {\n      this.tickRate = this.frameRate * this.subFrameRate;\n    } else {\n      this.tickRate = 1;\n    }\n  }\n\n  if (frameRateMultiplier) {\n    const multiplierResults = /^(\\d+) (\\d+)$/g.exec(frameRateMultiplier);\n    if (multiplierResults) {\n      const numerator = Number(multiplierResults[1]);\n      const denominator = Number(multiplierResults[2]);\n      const multiplierNum = numerator / denominator;\n      this.frameRate *= multiplierNum;\n    }\n  }\n};\n\n\nshaka.text.TextEngine.registerParser(\n    'application/ttml+xml',\n    shaka.text.TtmlTextParser);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.VideoPlayPromise');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill.register');\n\n\n/**\n * @namespace shaka.polyfill.VideoPlayPromise\n *\n * @summary A polyfill to silence the play() Promise in HTML5 video.\n */\n\n\n/**\n * Install the polyfill if needed.\n */\nshaka.polyfill.VideoPlayPromise.install = function() {\n  shaka.log.debug('VideoPlayPromise.install');\n\n  if (window.HTMLMediaElement) {\n    const originalPlay = HTMLMediaElement.prototype.play;\n    HTMLMediaElement.prototype.play = function() {\n      let p = originalPlay.apply(this);\n      if (p) {\n        // This browser is returning a Promise from play().\n        // If the play() call fails or is interrupted, the Promise will be\n        // rejected.  Some apps, however, don't listen to this Promise,\n        // especially since it is not available cross-browser.  If the Promise\n        // is rejected without anyone listening for the failure, an error will\n        // appear in the JS console.\n        // To avoid confusion over this innocuous \"error\", we will install a\n        // catch handler on the Promise.  This does not prevent the app from\n        // also catching failures and handling them.  It only prevents the\n        // console message.\n        p.catch(function() {});\n      }\n      return p;\n    };\n  }\n};\n\nshaka.polyfill.register(shaka.polyfill.VideoPlayPromise.install);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.text.Mp4TtmlParser');\n\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.text.TtmlTextParser');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Mp4Parser');\n\n\n/**\n * @struct\n * @constructor\n * @implements {shaka.extern.TextParser}\n */\nshaka.text.Mp4TtmlParser = function() {\n  /**\n   * @type {!shaka.extern.TextParser}\n   * @private\n   */\n  this.parser_ = new shaka.text.TtmlTextParser();\n};\n\n\n/** @override **/\nshaka.text.Mp4TtmlParser.prototype.parseInit = function(data) {\n  const Mp4Parser = shaka.util.Mp4Parser;\n\n  let sawSTPP = false;\n\n  new Mp4Parser()\n      .box('moov', Mp4Parser.children)\n      .box('trak', Mp4Parser.children)\n      .box('mdia', Mp4Parser.children)\n      .box('minf', Mp4Parser.children)\n      .box('stbl', Mp4Parser.children)\n      .fullBox('stsd', Mp4Parser.sampleDescription)\n      .box('stpp', function(box) {\n        sawSTPP = true;\n        box.parser.stop();\n      }).parse(data);\n\n  if (!sawSTPP) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.INVALID_MP4_TTML);\n  }\n};\n\n\n/** @override **/\nshaka.text.Mp4TtmlParser.prototype.parseMedia = function(data, time) {\n  const Mp4Parser = shaka.util.Mp4Parser;\n\n  let sawMDAT = false;\n  let payload = [];\n\n  new Mp4Parser()\n      .box('mdat', Mp4Parser.allData(function(data) {\n        sawMDAT = true;\n        // Join this to any previous payload, in case the mp4 has multiple\n        // mdats.\n        payload = payload.concat(this.parser_.parseMedia(data, time));\n      }.bind(this))).parse(data);\n\n  if (!sawMDAT) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.INVALID_MP4_TTML);\n  }\n\n  return payload;\n};\n\n\nshaka.text.TextEngine.registerParser(\n    'application/mp4; codecs=\"stpp\"',\n    shaka.text.Mp4TtmlParser);\nshaka.text.TextEngine.registerParser(\n    'application/mp4; codecs=\"stpp.TTML.im1t\"',\n    shaka.text.Mp4TtmlParser);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.text.VttTextParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.CueRegion');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.TextParser');\n\n\n/**\n * @constructor\n * @implements {shaka.extern.TextParser}\n */\nshaka.text.VttTextParser = function() {};\n\n\n/** @override */\nshaka.text.VttTextParser.prototype.parseInit = function(data) {\n  goog.asserts.assert(false, 'VTT does not have init segments');\n};\n\n\n/**\n * @override\n * @throws {shaka.util.Error}\n */\nshaka.text.VttTextParser.prototype.parseMedia = function(data, time) {\n  const VttTextParser = shaka.text.VttTextParser;\n  // Get the input as a string.  Normalize newlines to \\n.\n  let str = shaka.util.StringUtils.fromUTF8(data);\n  str = str.replace(/\\r\\n|\\r(?=[^\\n]|$)/gm, '\\n');\n  let blocks = str.split(/\\n{2,}/m);\n\n  if (!/^WEBVTT($|[ \\t\\n])/m.test(blocks[0])) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.INVALID_TEXT_HEADER);\n  }\n\n  let offset = time.segmentStart;\n  if (offset == null) {\n    // This is a probe, such as the HLS parser makes.  We don't know the segment\n    // start time, so we will use the X-TIMESTAMP-MAP header, if present, to get\n    // the segment start time.  By only doing this when segmentStart == null, we\n    // protect against rollover in the MPEGTS field.\n\n    // In case the attempt below doesn't work out, assume an offset of 0.\n    offset = 0;\n\n    if (blocks[0].includes('X-TIMESTAMP-MAP')) {\n      // https://bit.ly/2K92l7y\n      // The 'X-TIMESTAMP-MAP' header is used in HLS to align text with\n      // the rest of the media.\n      // The header format is 'X-TIMESTAMP-MAP=MPEGTS:n,LOCAL:m'\n      // (the attributes can go in any order)\n      // where n is MPEG-2 time and m is cue time it maps to.\n      // For example 'X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:900000'\n      // means an offset of 10 seconds\n      // 900000/MPEG_TIMESCALE - cue time.\n      const cueTimeMatch =\n          blocks[0].match(/LOCAL:((?:(\\d{1,}):)?(\\d{2}):(\\d{2})\\.(\\d{3}))/m);\n\n      const mpegTimeMatch = blocks[0].match(/MPEGTS:(\\d+)/m);\n      if (cueTimeMatch && mpegTimeMatch) {\n        const parser = new shaka.util.TextParser(cueTimeMatch[1]);\n        const cueTime = shaka.text.VttTextParser.parseTime_(parser);\n        if (cueTime == null) {\n          throw new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.TEXT,\n              shaka.util.Error.Code.INVALID_TEXT_HEADER);\n        }\n\n        const mpegTime = Number(mpegTimeMatch[1]);\n        const mpegTimescale = shaka.text.VttTextParser.MPEG_TIMESCALE_;\n        // Apple-encoded HLS content uses absolute timestamps, so assume the\n        // presence of the map tag means the content uses absolute timestamps.\n        offset = time.periodStart + (mpegTime / mpegTimescale - cueTime);\n      }\n    }\n  }\n\n  // Parse VTT regions.\n  /* !Array.<!shaka.extern.CueRegion> */\n  let regions = [];\n  let lines = blocks[0].split('\\n');\n  for (let i = 1; i < lines.length; i++) {\n    if (/^Region:/.test(lines[i])) {\n      let region = VttTextParser.parseRegion_(lines[i]);\n      regions.push(region);\n    }\n  }\n\n  // Parse cues.\n  let ret = [];\n  for (let i = 1; i < blocks.length; i++) {\n    lines = blocks[i].split('\\n');\n    let cue = VttTextParser.parseCue_(lines, offset, regions);\n    if (cue) {\n      ret.push(cue);\n    }\n    }\n\n  return ret;\n};\n\n\n/**\n * Parses a string into a Region object.\n *\n * @param {string} text\n * @return {!shaka.extern.CueRegion}\n * @private\n */\nshaka.text.VttTextParser.parseRegion_ = function(text) {\n  const VttTextParser = shaka.text.VttTextParser;\n  let parser = new shaka.util.TextParser(text);\n  // The region string looks like this:\n  // Region: id=fred width=50% lines=3 regionanchor=0%,100%\n  //         viewportanchor=10%,90% scroll=up\n  let region = new shaka.text.CueRegion();\n\n  // Skip 'Region:'\n  parser.readWord();\n  parser.skipWhitespace();\n\n  let word = parser.readWord();\n  while (word) {\n    if (!VttTextParser.parseRegionSetting_(region, word)) {\n      shaka.log.warning('VTT parser encountered an invalid VTTRegion setting: ',\n                        word,\n                        ' The setting will be ignored.');\n    }\n    parser.skipWhitespace();\n    word = parser.readWord();\n  }\n\n  return region;\n};\n\n\n/**\n * Parses a text block into a Cue object.\n *\n * @param {!Array.<string>} text\n * @param {number} timeOffset\n * @param {!Array.<!shaka.extern.CueRegion>} regions\n * @return {shaka.text.Cue}\n * @private\n */\nshaka.text.VttTextParser.parseCue_ = function(text, timeOffset, regions) {\n  const VttTextParser = shaka.text.VttTextParser;\n\n  // Skip empty blocks.\n  if (text.length == 1 && !text[0]) {\n    return null;\n  }\n\n  // Skip comment blocks.\n  if (/^NOTE($|[ \\t])/.test(text[0])) {\n    return null;\n  }\n\n  // Skip style blocks.\n  if (text[0] == 'STYLE') {\n    return null;\n  }\n\n  let id = null;\n  if (!text[0].includes('-->')) {\n    id = text[0];\n    text.splice(0, 1);\n  }\n\n  // Parse the times.\n  let parser = new shaka.util.TextParser(text[0]);\n  let start = VttTextParser.parseTime_(parser);\n  let expect = parser.readRegex(/[ \\t]+-->[ \\t]+/g);\n  let end = VttTextParser.parseTime_(parser);\n\n  if (start == null || expect == null || end == null) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.INVALID_TEXT_CUE);\n  }\n\n  start += timeOffset;\n  end += timeOffset;\n\n  // Get the payload.\n  let payload = text.slice(1).join('\\n').trim();\n\n  let cue = new shaka.text.Cue(start, end, payload);\n\n  // Parse optional settings.\n  parser.skipWhitespace();\n  let word = parser.readWord();\n  while (word) {\n    if (!VttTextParser.parseCueSetting(cue, word, regions)) {\n      shaka.log.warning('VTT parser encountered an invalid VTT setting: ',\n                        word,\n                        ' The setting will be ignored.');\n    }\n    parser.skipWhitespace();\n    word = parser.readWord();\n  }\n\n  if (id != null) {\n    cue.id = id;\n  }\n  return cue;\n};\n\n\n/**\n * Parses a WebVTT setting from the given word.\n *\n * @param {!shaka.text.Cue} cue\n * @param {string} word\n * @param {!Array.<!shaka.text.CueRegion>} regions\n * @return {boolean} True on success.\n */\nshaka.text.VttTextParser.parseCueSetting = function(cue, word, regions) {\n  const VttTextParser = shaka.text.VttTextParser;\n  let results = null;\n  if ((results = /^align:(start|middle|center|end|left|right)$/.exec(word))) {\n    VttTextParser.setTextAlign_(cue, results[1]);\n  } else if ((results = /^vertical:(lr|rl)$/.exec(word))) {\n    VttTextParser.setVerticalWritingMode_(cue, results[1]);\n  } else if ((results = /^size:([\\d.]+)%$/.exec(word))) {\n    cue.size = Number(results[1]);\n  } else if ((results =\n      /^position:([\\d.]+)%(?:,(line-left|line-right|center|start|end))?$/\n      .exec(word))) {\n    cue.position = Number(results[1]);\n    if (results[2]) {\n      VttTextParser.setPositionAlign_(cue, results[2]);\n    }\n  } else if ((results = /^region:(.*)$/.exec(word))) {\n    let region = VttTextParser.getRegionById_(regions, results[1]);\n    if (region) {\n      cue.region = region;\n    }\n  } else {\n    return VttTextParser.parsedLineValueAndInterpretation_(cue, word);\n  }\n\n  return true;\n};\n\n\n/**\n *\n * @param {!Array.<!shaka.text.CueRegion>} regions\n * @param {string} id\n * @return {?shaka.text.CueRegion}\n * @private\n */\nshaka.text.VttTextParser.getRegionById_ = function(regions, id) {\n  let regionsWithId = regions.filter(function(region) {\n    return region.id == id;\n  });\n  if (!regionsWithId.length) {\n    shaka.log.warning('VTT parser could not find a region with id: ',\n                  id,\n                  ' The region will be ignored.');\n    return null;\n  }\n  goog.asserts.assert(regionsWithId.length == 1,\n                      'VTTRegion ids should be unique!');\n\n  return regionsWithId[0];\n};\n\n\n/**\n * Parses a WebVTTRegion setting from the given word.\n *\n * @param {!shaka.text.CueRegion} region\n * @param {string} word\n * @return {boolean} True on success.\n * @private\n */\nshaka.text.VttTextParser.parseRegionSetting_ = function(region, word) {\n  let results = null;\n  if ((results = /^id=(.*)$/.exec(word))) {\n    region.id = results[1];\n  } else if ((results = /^width=(\\d{1,2}|100)%$/.exec(word))) {\n    region.width = Number(results[1]);\n  } else if ((results = /^lines=(\\d+)$/.exec(word))) {\n    region.height = Number(results[1]);\n    region.heightUnits = shaka.text.CueRegion.units.LINES;\n  } else if ((results = /^regionanchor=(\\d{1,2}|100)%,(\\d{1,2}|100)%$/\n            .exec(word))) {\n    region.regionAnchorX = Number(results[1]);\n    region.regionAnchorY = Number(results[2]);\n  } else if ((results = /^viewportanchor=(\\d{1,2}|100)%,(\\d{1,2}|100)%$/\n            .exec(word))) {\n    region.viewportAnchorX = Number(results[1]);\n    region.viewportAnchorY = Number(results[2]);\n  } else if ((results = /^scroll=up$/.exec(word))) {\n    region.scroll = shaka.text.CueRegion.scrollMode.UP;\n  } else {\n    return false;\n  }\n\n  return true;\n};\n\n\n/**\n * @param {!shaka.text.Cue} cue\n * @param {string} align\n * @private\n */\nshaka.text.VttTextParser.setTextAlign_ = function(cue, align) {\n  const Cue = shaka.text.Cue;\n  if (align == 'middle') {\n    cue.textAlign = Cue.textAlign.CENTER;\n  } else {\n    goog.asserts.assert(align.toUpperCase() in Cue.textAlign,\n                        align.toUpperCase() +\n                        ' Should be in Cue.textAlign values!');\n\n    cue.textAlign = Cue.textAlign[align.toUpperCase()];\n  }\n};\n\n\n/**\n * @param {!shaka.text.Cue} cue\n * @param {string} align\n * @private\n */\nshaka.text.VttTextParser.setPositionAlign_ = function(cue, align) {\n  const Cue = shaka.text.Cue;\n  if (align == 'line-left' || align == 'start') {\n    cue.positionAlign = Cue.positionAlign.LEFT;\n  } else if (align == 'line-right' || align == 'end') {\n    cue.positionAlign = Cue.positionAlign.RIGHT;\n  } else {\n    cue.positionAlign = Cue.positionAlign.CENTER;\n  }\n};\n\n\n/**\n * @param {!shaka.text.Cue} cue\n * @param {string} value\n * @private\n */\nshaka.text.VttTextParser.setVerticalWritingMode_ = function(cue, value) {\n  const Cue = shaka.text.Cue;\n  if (value == 'lr') {\n    cue.writingMode = Cue.writingMode.VERTICAL_LEFT_TO_RIGHT;\n  } else {\n    cue.writingMode = Cue.writingMode.VERTICAL_RIGHT_TO_LEFT;\n  }\n};\n\n\n/**\n * @param {!shaka.text.Cue} cue\n * @param {string} word\n * @return {boolean}\n * @private\n */\nshaka.text.VttTextParser.parsedLineValueAndInterpretation_ =\n    function(cue, word) {\n  const Cue = shaka.text.Cue;\n  let results = null;\n  if ((results = /^line:([\\d.]+)%(?:,(start|end|center))?$/.exec(word))) {\n    cue.lineInterpretation = Cue.lineInterpretation.PERCENTAGE;\n    cue.line = Number(results[1]);\n    if (results[2]) {\n      goog.asserts.assert(results[2].toUpperCase() in Cue.lineAlign,\n                          results[2].toUpperCase() +\n                          ' Should be in Cue.lineAlign values!');\n      cue.lineAlign = Cue.lineAlign[results[2].toUpperCase()];\n    }\n  } else if ((results = /^line:(-?\\d+)(?:,(start|end|center))?$/.exec(word))) {\n    cue.lineInterpretation = Cue.lineInterpretation.LINE_NUMBER;\n    cue.line = Number(results[1]);\n    if (results[2]) {\n      goog.asserts.assert(results[2].toUpperCase() in Cue.lineAlign,\n                          results[2].toUpperCase() +\n                          ' Should be in Cue.lineAlign values!');\n      cue.lineAlign = Cue.lineAlign[results[2].toUpperCase()];\n    }\n  } else {\n    return false;\n  }\n\n  return true;\n};\n\n\n/**\n * Parses a WebVTT time from the given parser.\n *\n * @param {!shaka.util.TextParser} parser\n * @return {?number}\n * @private\n */\nshaka.text.VttTextParser.parseTime_ = function(parser) {\n  // 00:00.000 or 00:00:00.000 or 0:00:00.000\n  let results = parser.readRegex(/(?:(\\d{1,}):)?(\\d{2}):(\\d{2})\\.(\\d{3})/g);\n  if (results == null) {\n    return null;\n  }\n  // This capture is optional, but will still be in the array as undefined,\n  // in which case it is 0.\n  let hours = Number(results[1]) || 0;\n  let minutes = Number(results[2]);\n  let seconds = Number(results[3]);\n  let miliseconds = Number(results[4]);\n  if (minutes > 59 || seconds > 59) {\n    return null;\n  }\n\n  return (miliseconds / 1000) + seconds + (minutes * 60) + (hours * 3600);\n};\n\n\n/**\n * @const {number}\n * @private\n */\nshaka.text.VttTextParser.MPEG_TIMESCALE_ = 90000;\n\nshaka.text.TextEngine.registerParser(\n    'text/vtt',\n    shaka.text.VttTextParser);\n\nshaka.text.TextEngine.registerParser(\n    'text/vtt; codecs=\"vtt\"',\n    shaka.text.VttTextParser);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.text.Mp4VttParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.text.VttTextParser');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.TextParser');\n\n\n/**\n * @struct\n * @constructor\n * @implements {shaka.extern.TextParser}\n */\nshaka.text.Mp4VttParser = function() {\n  /**\n   * The current time scale used by the VTT parser.\n   *\n   * @type {?number}\n   * @private\n   */\n  this.timescale_ = null;\n};\n\n\n/** @override */\nshaka.text.Mp4VttParser.prototype.parseInit = function(data) {\n  const Mp4Parser = shaka.util.Mp4Parser;\n\n  let sawWVTT = false;\n\n  new Mp4Parser()\n      .box('moov', Mp4Parser.children)\n      .box('trak', Mp4Parser.children)\n      .box('mdia', Mp4Parser.children)\n      .fullBox('mdhd', function(box) {\n        goog.asserts.assert(\n            box.version == 0 || box.version == 1,\n            'MDHD version can only be 0 or 1');\n        if (box.version == 0) {\n          box.reader.skip(4); // Skip \"creation_time\".\n          box.reader.skip(4); // Skip \"modification_time\".\n          this.timescale_ = box.reader.readUint32();\n          box.reader.skip(4); // Skip \"duration\".\n        } else {\n          box.reader.skip(8); // Skip \"creation_time\".\n          box.reader.skip(8); // Skip \"modification_time\".\n          this.timescale_ = box.reader.readUint32();\n          box.reader.skip(8); // Skip \"duration\".\n        }\n        box.reader.skip(4); // Skip \"pad\", \"language\", and \"pre-defined\".\n      }.bind(this))\n      .box('minf', Mp4Parser.children)\n      .box('stbl', Mp4Parser.children)\n      .fullBox('stsd', Mp4Parser.sampleDescription)\n      .box('wvtt', function(box) {\n        // A valid vtt init segment, though we have no actual subtitles yet.\n        sawWVTT = true;\n      }).parse(data);\n\n  if (!this.timescale_) {\n    // Missing timescale for VTT content. It should be located in the MDHD.\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.INVALID_MP4_VTT);\n  }\n\n  if (!sawWVTT) {\n    // A WVTT box should have been seen (a valid vtt init segment with no\n    // actual subtitles).\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.INVALID_MP4_VTT);\n  }\n};\n\n\n/** @override */\nshaka.text.Mp4VttParser.prototype.parseMedia = function(data, time) {\n  if (!this.timescale_) {\n    // Missing timescale for VTT content. We should have seen the init segment.\n    shaka.log.error('No init segment for MP4+VTT!');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.INVALID_MP4_VTT);\n  }\n\n  const Mp4VttParser = shaka.text.Mp4VttParser;\n  const Mp4Parser = shaka.util.Mp4Parser;\n\n  let baseTime = 0;\n  /** @type {!Array.<shaka.text.Mp4VttParser.TimeSegment>} */\n  let presentations = [];\n  /** @type {Uint8Array} */\n  let rawPayload;\n  /** @type {!Array.<shaka.text.Cue>} */\n  let cues = [];\n\n  let sawTFDT = false;\n  let sawTRUN = false;\n  let sawMDAT = false;\n  let defaultDuration = null;\n\n  new Mp4Parser()\n      .box('moof', Mp4Parser.children)\n      .box('traf', Mp4Parser.children)\n      .fullBox('tfdt', function(box) {\n        sawTFDT = true;\n        goog.asserts.assert(\n            box.version == 0 || box.version == 1,\n            'TFDT version can only be 0 or 1');\n        baseTime = (box.version == 0) ?\n            box.reader.readUint32() :\n            box.reader.readUint64();\n      })\n      .fullBox('tfhd', function(box) {\n        goog.asserts.assert(\n            box.flags != null,\n            'A TFHD box should have a valid flags value');\n        defaultDuration = Mp4VttParser.parseTFHD_(\n            box.flags, box.reader);\n      })\n      .fullBox('trun', function(box) {\n        sawTRUN = true;\n        goog.asserts.assert(\n            box.version != null,\n            'A TRUN box should have a valid version value');\n        goog.asserts.assert(\n            box.flags != null,\n            'A TRUN box should have a valid flags value');\n        presentations = Mp4VttParser.parseTRUN_(\n            box.version, box.flags, box.reader);\n      })\n      .box('mdat', Mp4Parser.allData(function(data) {\n        goog.asserts.assert(!sawMDAT,\n            'VTT cues in mp4 with multiple MDAT are not currently supported!');\n        sawMDAT = true;\n        rawPayload = data;\n      })).parse(data);\n\n  if (!sawMDAT && !sawTFDT && !sawTRUN) {\n    // A required box is missing.\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.INVALID_MP4_VTT);\n  }\n\n  let currentTime = baseTime;\n\n  let dataView = new DataView(\n      rawPayload.buffer, rawPayload.byteOffset, rawPayload.byteLength);\n  /** @type {!shaka.util.DataViewReader} */\n  let reader = new shaka.util.DataViewReader(\n      dataView, shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n  presentations.forEach((presentation) => {\n    // If one presentation corresponds to multiple payloads, it is assumed\n    // that all of those payloads have the same start time and duration.\n    let duration = presentation.duration || defaultDuration;\n    let startTime = presentation.timeOffset ?\n                    baseTime + presentation.timeOffset :\n                    currentTime;\n    currentTime = startTime + (duration || 0);\n\n    // Read samples until it adds up to the given size.\n    let totalSize = 0;\n    do {\n      // Read the payload size.\n      let payloadSize = reader.readUint32();\n      totalSize += payloadSize;\n\n      // Skip the type.\n      let payloadType = reader.readUint32();\n      let payloadName = shaka.util.Mp4Parser.typeToString(payloadType);\n\n      // Read the data payload.\n      /** @type {Uint8Array} */\n      let payload = null;\n      if (payloadName == 'vttc') {\n        if (payloadSize > 8) {\n          payload = reader.readBytes(payloadSize - 8);\n        }\n      } else if (payloadName == 'vtte') {\n        // It's a vtte, which is a vtt cue that is empty. Ignore any data that\n        // does exist.\n        reader.skip(payloadSize - 8);\n      } else {\n        shaka.log.error('Unknown box ' + payloadName + '! Skipping!');\n        reader.skip(payloadSize - 8);\n      }\n\n      if (duration) {\n        if (payload) {\n          goog.asserts.assert(\n              this.timescale_ != null, 'Timescale should not be null!');\n          cues.push(shaka.text.Mp4VttParser.parseVTTC_(\n              payload,\n              time.periodStart + startTime / this.timescale_,\n              time.periodStart + currentTime / this.timescale_));\n        }\n      } else {\n        shaka.log.error('WVTT sample duration unknown, and no default found!');\n      }\n\n      goog.asserts.assert(\n          !presentation.sampleSize || totalSize <= presentation.sampleSize,\n          'The samples do not fit evenly into the sample sizes given in the ' +\n          'TRUN box!');\n\n      // If no sampleSize was specified, it's assumed that this presentation\n      // corresponds to only a single cue.\n    } while (presentation.sampleSize && (totalSize < presentation.sampleSize));\n  });\n\n  goog.asserts.assert(\n      !reader.hasMoreData(),\n      'MDAT which contain VTT cues and non-VTT data are not currently ' +\n      'supported!');\n\n  return /** @type {!Array.<!shaka.extern.Cue>} */ (\n      cues.filter(shaka.util.Functional.isNotNull));\n};\n\n\n/**\n * @typedef {{\n *    duration: ?number,\n *    sampleSize: ?number,\n *    timeOffset: ?number\n *  }}\n *\n * @property {?number} duration\n *    The length of the segment in timescale units.\n * @property {?number} sampleSize\n *    The size of the segment in bytes.\n * @property {?number} timeOffset\n *    The time since the start of the segment in timescale units. Time\n *    offset is based of the start of the segment. If this value is\n *    missing, the accumated durations preceeding this time segment will\n *    be used to create the start time.\n */\nshaka.text.Mp4VttParser.TimeSegment;\n\n\n/**\n * @param {number} flags\n * @param {!shaka.util.DataViewReader} reader\n * @return {?number} The default_sample_duration field, if present.\n * @private\n */\nshaka.text.Mp4VttParser.parseTFHD_ = function(flags, reader) {\n  // Skip \"track_ID\".\n  reader.skip(4);\n\n  // Skip \"base_data_offset\" if present.\n  if (flags & 0x000001) { reader.skip(8); }\n\n  // Skip \"sample_description_index\" if present.\n  if (flags & 0x000002) { reader.skip(4); }\n\n  // Read and return \"default_sample_duration\" if present.\n  if (flags & 0x000008) { return reader.readUint32(); }\n\n  // There is no \"default_sample_duration\".\n  return null;\n};\n\n\n/**\n * @param {number} version\n * @param {number} flags\n * @param {!shaka.util.DataViewReader} reader\n * @return {!Array.<shaka.text.Mp4VttParser.TimeSegment>}\n * @private\n */\nshaka.text.Mp4VttParser.parseTRUN_ = function(version, flags, reader) {\n  let sampleCount = reader.readUint32();\n\n  // Skip \"data_offset\" if present.\n  if (flags & 0x000001) { reader.skip(4); }\n\n  // Skip \"first_sample_flags\" if present.\n  if (flags & 0x000004) { reader.skip(4); }\n\n  let samples = [];\n\n  for (let sampleIndex = 0; sampleIndex < sampleCount; sampleIndex++) {\n    /** @type {shaka.text.Mp4VttParser.TimeSegment} */\n    let sample = {\n      duration: null,\n      sampleSize: null,\n      timeOffset: null,\n    };\n\n    // Read \"sample duration\" if present.\n    if (flags & 0x000100) { sample.duration = reader.readUint32(); }\n\n    // Read \"sample_size\" if present.\n    if (flags & 0x000200) { sample.sampleSize = reader.readUint32(); }\n\n    // Skip \"sample_flags\" if present.\n    if (flags & 0x000400) { reader.skip(4); }\n\n    // Read \"sample_time_offset\" if present.\n    if (flags & 0x000800) {\n      sample.timeOffset = version == 0 ?\n          reader.readUint32() :\n          reader.readInt32();\n    }\n\n    samples.push(sample);\n  }\n\n  return samples;\n};\n\n\n/**\n * Parses a vttc box into a cue.\n *\n * @param {!Uint8Array} data\n * @param {number} startTime\n * @param {number} endTime\n * @return {shaka.text.Cue}\n * @private\n */\nshaka.text.Mp4VttParser.parseVTTC_ = function(data, startTime, endTime) {\n  let payload;\n  let id;\n  let settings;\n\n  new shaka.util.Mp4Parser()\n      .box('payl', shaka.util.Mp4Parser.allData(function(data) {\n        payload = shaka.util.StringUtils.fromUTF8(data);\n      }))\n      .box('iden', shaka.util.Mp4Parser.allData(function(data) {\n        id = shaka.util.StringUtils.fromUTF8(data);\n      }))\n      .box('sttg', shaka.util.Mp4Parser.allData(function(data) {\n        settings = shaka.util.StringUtils.fromUTF8(data);\n      }))\n      .parse(data);\n\n  if (payload) {\n    return shaka.text.Mp4VttParser.assembleCue_(payload,\n                                                id,\n                                                settings,\n                                                startTime,\n                                                endTime);\n  } else {\n    return null;\n  }\n};\n\n\n/**\n * Take the individual components that make a cue and create a vttc cue.\n *\n * @param {string} payload\n * @param {?string} id\n * @param {?string} settings\n * @param {number} startTime\n * @param {number} endTime\n * @return {!shaka.text.Cue}\n * @private\n */\nshaka.text.Mp4VttParser.assembleCue_ = function(payload,\n                                                id,\n                                                settings,\n                                                startTime,\n                                                endTime) {\n  let cue = new shaka.text.Cue(\n      startTime,\n      endTime,\n      payload);\n\n  if (id) {\n    cue.id = id;\n  }\n\n  if (settings) {\n    let parser = new shaka.util.TextParser(settings);\n\n    let word = parser.readWord();\n\n    while (word) {\n      // TODO: Check WebVTTConfigurationBox for region info.\n      if (!shaka.text.VttTextParser.parseCueSetting(cue, word,\n                                                    /* VTTRegions */ [])) {\n        shaka.log.warning('VTT parser encountered an invalid VTT setting: ',\n                          word,\n                          ' The setting will be ignored.');\n      }\n\n      parser.skipWhitespace();\n      word = parser.readWord();\n    }\n  }\n\n  return cue;\n};\n\n\nshaka.text.TextEngine.registerParser(\n    'application/mp4; codecs=\"wvtt\"',\n    shaka.text.Mp4VttParser);\n","import * as muxjs from 'mux.js';\nimport shaka from 'shaka-player';\n\nif(!window.muxjs){\n    window.muxjs = muxjs;\n}\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    const playerElement = document.getElementById('playerElement');\n    const errorElement = document.getElementById('errorElement');\n    const playerElement2 = document.getElementById('playerElement2');\n    const errorElement2 = document.getElementById('errorElement2');\n\n    // Start the first player at 0\n    new ShakaPlayer(playerElement, errorElement, 0);\n\n    // Start the second player at 20\n    new ShakaPlayer(playerElement2, errorElement2,20);\n});\n\nclass ShakaPlayer {\n    constructor(playerElement, errorElement, startTime){\n        this.playerElement = playerElement;\n        this.hlsManifestUrl = this.playerElement.dataset['hlsManifest'];\n        this.errorElement = errorElement;\n        this.startTime = startTime;\n        let shakaPlayer;\n\n        shaka.polyfill.installAll();\n\n        if (shaka.Player.isBrowserSupported()) {\n            shakaPlayer = new shaka.Player();\n\n            shakaPlayer.addEventListener('error', (error) => {\n                console.error(error);\n                this.appendErrors(error.detail.data);\n            });\n\n            shakaPlayer.attach(playerElement)\n                .then(() => {\n                    shakaPlayer.configure({\n                        abr: {\n                            restrictions: {\n                                maxHeight: window.screen.height,\n                            },\n                        },\n                        streaming: {\n                            bufferingGoal: 150,\n                            ignoreTextStreamFailures: true,\n                        },\n                    });\n\n                    shakaPlayer.load(\n                        this.hlsManifestUrl,\n                        this.startTime,\n                        'application/x-mpegURL',\n                    )\n                        .catch((error) => {\n                            console.error(error);\n                            this.appendErrors(error.detail.data);\n                        });\n                })\n                .catch((error) => {\n                    console.error(error);\n                    this.appendErrors(error.detail.data);\n                });\n        }\n    }\n\n    appendErrors(errors){\n        errors.forEach((error) => {\n            const element = document.createElement('li');\n            element.innerHTML = error;\n\n            console.log(error);\n\n            this.errorElement.appendChild(element);\n        });\n    }\n}\n"]}